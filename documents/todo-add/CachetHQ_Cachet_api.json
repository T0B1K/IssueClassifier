[{"labels":["api",null],"text":"Hi, the API isn't working as expected.\r\n\r\nI'm assuming the status query should be int as that's what is being returned.\r\n\r\nPlease help!\r\n\r\n```\r\n$ http -v https://demo.cachethq.io/api/v1/incidents component_Id==1 X-Cachet-Token:\"9yMHsdioQosnyVK4iCVR\" status==1\r\nGET /api/v1/incidents?component_Id=1&status=1 HTTP/1.1\r\nAccept: */*\r\nAccept-Encoding: gzip, deflate\r\nConnection: keep-alive\r\nHost: demo.cachethq.io\r\nUser-Agent: HTTPie/0.9.9\r\nX-Cachet-Token: 9yMHsdioQosnyVK4iCVR\r\n\r\n\r\n\r\nHTTP/1.1 500 Internal Server Error\r\nCF-RAY: 4fd020501d23a9d0-SIN\r\nCache-Control: no-cache, private\r\nConnection: keep-alive\r\nContent-Type: application/json\r\nDate: Sat, 27 Jul 2019 16:52:52 GMT\r\nExpect-CT: max-age=604800, report-uri=\"https://report-uri.cloudflare.com/cdn-cgi/beacon/expect-ct\"\r\nServer: cloudflare\r\nSet-Cookie: __cfduid=d09ee393ca2c4ea7448ced3192077c2fc1564246371; expires=Sun, 26-Jul-20 16:52:51 GMT; path=/; domain=.cachethq.io; HttpOnly\r\nTransfer-Encoding: chunked\r\n\r\n{\r\n    \"errors\": [\r\n        {\r\n            \"detail\": \"An error has occurred and this resource cannot be displayed.\",\r\n            \"id\": \"7d810996-8320-457b-844e-554d5e80e799\",\r\n            \"status\": 500,\r\n            \"title\": \"Internal Server Error\"\r\n        }\r\n    ]\r\n}\r\n```"},{"labels":["api",null,null],"text":"Developing a POC for my office to make use of cachet and we're testing the API functionality.\r\n\r\nI'm getting a 404 response when trying to create an update:\r\n\r\nGET incident snippet:\r\n```        \r\n{\r\n            \"id\": 5,\r\n            \"component_id\": 0,\r\n            \"name\": \"API Test Incident 3\",\r\n            \"status\": 2,\r\n            \"message\": \"API Test Incident 3\",\r\n            \"created_at\": \"2019-01-22 14:00:00\",\r\n            \"updated_at\": \"2019-01-22 14:00:00\",\r\n            \"deleted_at\": null,\r\n            \"scheduled_at\": \"2019-01-22 13:41:50\",\r\n            \"visible\": 1,\r\n            \"human_status\": \"Identified\"\r\n        } \r\n```\r\n\r\nPOST Incident update creation\r\n``` \r\nhttp://localhost/api/v1/incidents/5/updates\r\n```\r\n``` \r\nContent-Type:application/json\r\nX-Cachet-Token:<REMOVED> \r\n```\r\n``` \r\n{\r\n    \"status\": 2,\r\n    \"message\": \"update test\"\r\n} \r\n```\r\n\r\nAnd the response:\r\n``` \r\n{\r\n    \"errors\": [\r\n        {\r\n            \"id\": \"c352ccfe-a7e7-4a1f-b7bd-05fb8ca5106e\",\r\n            \"status\": 404,\r\n            \"title\": \"Not Found\",\r\n            \"detail\": \"The requested resource could not be found but may be available again in the future.\"\r\n        }\r\n    ]\r\n} \r\n```"},{"labels":["api",null],"text":"I am trying to utilise the still undocumented Maintenances API. I tried to infer the correct parameters, but I nearly always get the bad HTTP request error with a description of trailing data.\r\n\r\nCan someone provide me with the needed parameters and their format in order to make a successful API call?"},{"labels":["api",null,null],"text":"We should make use of the built in [Eloquent Resources](https://laravel.com/docs/5.7/eloquent-resources) over our custom `AbstractApiController`. Eloquent resources give us more flexibility of what is returned in the results + meta and require far less code to maintain.\r\n\r\nAs an added side effect, we should be able to switch with little effort because both solutions wrap the results in `meta` and `data`, so the output should remain the same."},{"labels":["api",null],"text":"I just had an issue where my server got a huge number of hits to the `/api/v1/status` endpoint, which basically killed my PHP-FPM server (it hit the maximum number of workers, preventing people from connecting to any other sites in the same pool).\r\n\r\nDoes Cachet cache the response to this API call? It would be good to cache its response (even if only for a short period of time, like 30 seconds), so that a large number of hits don't cause any perf issues. If a lot of hits come in at the same time, they could all receive the cached response rather than having to recompute it + hit the DB."},{"labels":["api",null],"text":"Hi.\r\nIs there Swagger / OpenAPI json file available? Or endpoint with it? I found discussion about generating docs only but no json file with API description. \r\n\r\nThanks "},{"labels":["api",null],"text":"I have to create a new issue for this problem since issue #2947 is being automatically closed without the author input. For me this seems pretty simple to reproduce: Call OPTIONS https://demo.cachethq.io//api/v1/components from Postman with Access-Control-Request-Method set to GET and Origin set to a web site url. Observe that there is no Access-Control-Allow-Origin header, thereby effectively making it impossible to use from an external web site.\r\n\r\n_Originally posted by @palktonderAtpowelno in https://github.com/CachetHQ/Cachet/issues/2947#issuecomment-452217255_"},{"labels":["api",null,null],"text":"Hi,\r\n\r\nWhen using the API to create an incident I'm getting an error 500 and the following error message in the log:\r\n\r\nNext Illuminate\\Database\\QueryException: SQLSTATE[42S22]: Column not found: 1054 Unknown column 'notify' in 'where clause' (SQL: select count(*) as aggregate from `incidents` where `visible` >= 1 and (`name` = test incident and `message` = This is a test incident created via API calls and `status` = 1 and `visible` = 1 and `notify` = 1) and `incidents`.`deleted_at` is null)\r\n\r\nI'm running 2.4.0-dev\r\nany suggestions?\r\n\r\nJay"},{"labels":["api"],"text":"When I make an API call to a component the updated_at field only updates to the current time if the status actually changes - i.e. If I send a request to update a component from Operational to Operational the update_at timestamp does not change.\r\n\r\nI have automated monitoring setup to update the components status regularly, and I want the timestamp to reflect the most recent time the component was checked.\r\n\r\nThe other option would be to send a PUT request to manually change the updated_at field with the current time, however when I do this it causes the status to be set to 'cachet.components.status.0' and doesn't even update the time field.\r\n\r\nExample:\r\nCall: `[2018-12-13 13:22.54] curl -X PUT http://status.domain.com/api/v1/components/4 -H \"Content-type: application/json\" -H \"X-Cachet-Token: <token omitted>\" -d \"{\\\"updated_at\\\":date +%s}\"`\r\nResult:\r\n`{\"data\":{\"id\":4,\"name\":\"Component Four\",\"description\":\"\",\"link\":\"https:\\/\\/www.component-four.com\",\"status\":0,\"order\":0,\"group_id\":1,\"created_at\":\"2018-12-12 15:13:15\",\"updated_at\":\"2018-12-13 13:22:42\",\"deleted_at\":null,\"enabled\":true,\"status_name\":\"cachet.components.status.0\",\"tags\":[]}} `\r\n\r\nEDIT: Already reached out on slack and was told to raise an issue, also I see there was a similar issue raised on here but it was closed with no resolution"},{"labels":["api",null,null],"text":"When i try to call getAllSubscribers method, i have this result :  \r\n\r\n> PHP Fatal error:  Uncaught exception 'GuzzleHttp\\Exception\\ConnectException' with message 'cURL error 28: Operation timed out after 3002 milliseconds with 0 out of -1 bytes received (see http://curl.haxx.se/libcurl/c/libcurl-errors.html)' in /vendor/guzzlehttp/guzzle/src/Handler/CurlFactory.php:186\r\n\r\nAny ideas? \r\n\r\nPS. another methods for example (getAllIncidents & getAllComponents) works fine "},{"labels":["api",null,null,null,null],"text":"Before we can work on https://github.com/CachetHQ/Cachet/issues/1375 we need to ensure that the API is both adequately and accurately tested. We should **always** be able to rely on the API to work as expected, returning the desired results.\r\n\r\nWe should be testing for:\r\n\r\n- Events firing\r\n- Data being created, deleted and updated\r\n- Result format to be correct\r\n- Expected cases of errors\r\n\r\n## Tests to check\r\n\r\n- [x] `ComponentGroupTest`\r\n- [x] `ComponentTest`\r\n- [x] `IncidentTest`\r\n- [ ] `IncidentUpdateTest`\r\n- [ ] `MetricPointTest`\r\n- [ ] `MetricTest`\r\n- [ ] `ScheduleTest`\r\n- [ ] `SubscriberTest`"},{"labels":["api",null,null,null,null],"text":"I've searched existing issues, and couldn't find an answer.\r\nIs it possible to do API sorting on status for component first, then component groups?\r\n\r\nCondition:\r\nAssume you have one component in a group that is currently having major outage. All other components in other groups is OK. When I query the API, I wanted the one that is having problem is shown first.\r\n\r\nCode used:\r\n `http://localhost:8000/api/v1/components/groups?sort=status&order=desc` \r\n\r\nPlease let me know whether this can't be done.\r\n\r\nThanks!"}]