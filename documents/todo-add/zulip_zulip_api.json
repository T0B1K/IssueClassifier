[{"labels":["api",null,null],"text":"The following POST-only routes return an empty body when requested with GET. Instead they should return an error message:\r\n\r\n* https://chat.zulip.org/accounts/logout/\r\n* https://chat.zulip.org/accounts/register/\r\n* https://chat.zulip.org/json/subscriptions/exists\r\n* https://zulip.com/json/remotes/server/register\r\n* https://chat.zulip.org/api/v1/dev_fetch_api_key\r\n\r\nAll of these seem to be caused by using the `@require_post` decorator, without restricting the route to `POST` in `zerver/urls.py`.\r\n\r\nAn example of where a body is returned as expected is:\r\n\r\n* https://chat.zulip.org/json/fetch_api_key"},{"labels":["api"],"text":"Currently, the creation of a user via the REST API returns either \"success\" or \"error\". Adding the Zulip ID of the new user in the response would be an improvement that would facilitate integrations."},{"labels":["api",null,null],"text":"In `do_update_embedded_data`, we generate a variant `update_message` event, which has not been properly maintained and doesn't actually match the normal format.  I fixed one issue in 00fd9afad5147beb373caf3410ddc34b0c68a83f; but we should figure out how to make this event actually match the format of a normal `update_message` event, and then update the `GET /events` documentation with clear advice on handling it.  \r\n\r\nI'd like us to move that event to be more clearly match the format of normal `update_message` events, with perhaps some clear marker for these variant events.\r\n\r\n@amanagr @showell I'd be interested in your thoughts on this."},{"labels":["api",null,null],"text":"All events related to `update_message_flags` use `operation` instead of `op`, the latter being the key used in ALL other events.So modify the `update_message_flags` events so that they also use `op`. Backward compatibility should be taken care of."},{"labels":["api",null,null],"text":"While working on #15899, we discovered that a few internal fields in the message event handling system are incorrectly being leaked to clients.  The details on the fields are here: dbde901684ae67eeed67de14ac699fb430082479.\r\n\r\nWhat's going on is that we're somewhat sloppily attaching values to event objects in order to pass data around internal to `zerver/tornado/event_queue.py` logic -- but then not removing those values before\r\n\r\nThere's no security issue here, because the values are mostly data the client could know.  And arguably for the `push_notified` bundle of fields, it'd arguably be reasonable to expose them to clients as a useful hint -- except for the fact that we have no guarantee of a value of False correct since push notifications could be triggered later on via `missedmessage_hook`.  For that reason, we should just remove them from the API.\r\n\r\nSpecifically, the fields are:\r\n* `handler_id`: An internal tracking value for an open HTTP connection.\r\n* push_notified`: Internal booleans used to keep track of whether a push notification has been sent for the purposes of sending additional ones.  \r\n\r\nI'm not sure what the best way to handle these is; @showell might have ideas.  One option would be to make `contents()` return a copied data structure with these fields explicitly excluded (or a whitelist of included fields).\r\n"},{"labels":["api",null,null],"text":"We can't handle this event type in the most natural way, because what it means is that the data we've fetched thus far should be discarded.  We've seen this error twice ever, so it's pretty unimportant, but it's annoying to have any 500s in the codebase, so I'm opening an issue.\r\n\r\n```\r\n  File \"./zerver/views/home.py\", line 196, in home_real\r\n    narrow=narrow)\r\n  File \"./zerver/lib/events.py\", line 875, in do_events_register\r\n    fetch_event_types=fetch_event_types)\r\n  File \"./zerver/lib/events.py\", line 350, in apply_events\r\n    client_gravatar, slim_presence, include_subscribers)\r\n  File \"./zerver/lib/events.py\", line 823, in apply_event\r\n    raise AssertionError(\"Unexpected event type {}\".format(event['type']))\r\nAssertionError: Unexpected event type restart\r\n```\r\n\r\nTo fix this, I believe what we want to do is just restart the `do_events_register` call.  We don't have a great standard mechanism for doing this; in theory we could just do a recursive call, but I'm a little worried about that creating a potential for some very unpleasant self-DoS corner case."},{"labels":["api",null,null],"text":"This is a pretty advanced bug, unless you have knowledge of our REQ/validator framework.\r\n\r\nBasically, it appears that we skip over validators if the function argument was provided via Django using `urls.py` to pull a parameter out of the URL path with a regex check.\r\n\r\nMore details here: https://chat.zulip.org/#narrow/stream/3-backend/topic/types/near/907156"},{"labels":["api",null,null,null],"text":"We should include the creation date for streams in the bundle of data we send down to clients, since I can easily see it as being something that clients would find useful to display.\r\n\r\n(We should also look at finding a home for displaying this in \"Stream settings\")."},{"labels":["api",null,null],"text":"User should be able to refer exact argument via a #reference link like https://chat.zulip.org/api/register-queue#arguments even for all the arguments to an endpoint. \r\n\r\nFor example, a link like https://chat.zulip.org/api/register-queue#client_capabilities  should go directly to `client_capabilities` argument within https://chat.zulip.org/api/register-queue#argument."},{"labels":["api",null,null],"text":"Tim Abbott: In our API endpoint for editing a stream's properties: https://chat.zulip.org/api/update-subscription-properties\r\n\r\nWe appear to have an unusual return value scheme, where we return basically what the client sent rather than an empty HTTP response.  While there's potentially some mild utility for communicating what changes were confirmed by the server, it feels to me like this is probably just a bug; none of our other POST/PATCH endpoints for doing a write have this pattern of returning what you just sent (which was a pattern used in the early days of Zulip, before we had the real-time events system).\r\n\r\nThe fix is to just have this endpoint `return json_success()` rather than gathering a response.  I believe no known clients actually look at the response from this endpoint, so we can just make the change (bumping `API_FEATURE_LEVEL` appropriately).\r\n\r\nSee https://chat.zulip.org/#narrow/stream/3-backend/topic/update-subscription-properties/near/900984 for discussion.\r\n\r\nTagging as a priority since this sort of API cleanup is valuable to do sooner rather than later."},{"labels":["api",null,null],"text":"The links (for streams, topics and messages) we obtain by clicking \"Copy link\"/\"Copy link to conversation\" in the interface, or automatically generated by \"Quote & reply\" are relative to the names of the stream/topic (while the id of the message stays correct), and they break when streams are renamed, when topics are moved or renamed and when messages are moved to other streams/topics. In particular, topics are moved or renamed quite frequently, by design, and when they are, all links to messages are suddenly lost, in external and internal communications, which is really problematic, ...\r\n\r\nAFAIU,\r\n- For messages, message ids are contained in message links, and I guess it would be trivial to make sure they work as permalinks, by simply ignoring the stream/topic information of the URL and finding messages by id directly.\r\n- For streams, it seems that the stream id is not included in the URL, which makes it unusable as a permalink... In my experience, links to streams are not used so often, but they are in integrated apps e.g. github notifications. This caused trouble for me before, when slightly renaming streams, because bots started sending messages to inexistant streams (and by the way the private messages of the bot owner gets flooded). EDIT: after all, I reckon this problem is in fact independent from the interface provided links, but it's still related to how to reference streams.\r\n- For topics, I guess there is no such thing as a topic id. When a topic moves from one stream to another, there is an automatic notification post, so that users may follow the flow, but not when a topic is renamed. There could be an automated redirection for every topic renaming for which the original name has not been reused (yet), but I fear the ratio importance/workload is too low... and I do not care that much, I just mentioned it for completeness sake."},{"labels":["api",null,null,null,null],"text":"Now that we're doing things that from a user perspective are bulk-deletions of messages, we need to update the interface for how Zulip's real-time events API notifies clients of message deletions to support bulk updates.  We'll use this in a few places:\r\n* The existing `do_delete_messages`, even in cases where all messages are in the same stream/topic, ends up doing individual events for each message in a giant loop.\r\n* This is a blocker for https://github.com/zulip/zulip/pull/15277.\r\n\r\nWhat's super tricky about this is that the `delete_message` event format wasn't designed with bulk messages in mind.  So we need to detect which clients support the newer format, using our handy `client_capabilities` feature.  Here's the plan:\r\n* Add a new supported `bulk_message_deletion` client capability to `events_register_backend` and the API documentation, in a first commit.\r\n* pass that property through `do_events_register`.  We may want to do a preparatory refactoring commit to pass the whole `client_capabilities` structure through to `do_events_register` as future-proofing, (replacing the `notification_settings_null` parameter).  We'll ultimate need that to end up in `request_event_queue` and finally being stored on the `ClientDescriptor` object generated created in our events system.\r\n* Then, we migrate the format for `delete_message` events to use a `message_ids` list rather than a `message_id` singleton integer.  For backwards-compatibility, clients without the feature would have a list of events generated for them.\r\n\r\n```\r\n    elif event['type'] == \"delete_message\" and len(users) > 0 and isinstance(users[0], dict):        \r\n        # do_delete_messages used to send events with users in dict format {\"id\": <int>}             \r\n        # This block is here for compatibility with events in that format still in the queue         \r\n        # at the time of upgrade.                                                                    \r\n        # TODO: Remove this block in release >= 2.3.                                                 \r\n        user_ids = [user['id'] for user in cast(Iterable[Mapping[str, int]], users)]                 \r\n-        process_event(event, user_ids)                                                               \r\n+        process_deletion_event(event, user_ids)                                                               \r\n\r\n\r\ndef process_deletion_event(event: Mapping[str, Any], users: Iterable[int]) -> None:                           \r\n    for user_profile_id in users:                                                                    \r\n        for client in get_client_descriptors_for_user(user_profile_id):                              \r\n            if not client.accepts_event(event):\r\n                continue\r\n            if client.has_capability(\"bulk_message_deletion\"):\r\n                client.add_event(event)                                                              \r\n                continue\r\n            for message_id in event['message_ids']:\r\n                compatibility_event = event.copy()\r\n                compatibility_event['message_id'] = message_id\r\n                del compatibility_event['message_ids']\r\n                client.add_event(event)\r\n```\r\n\r\nWe'll want to push hard on releasing updated apps that support the new `client_capability`, to minimize how often the backwards-compatibility code ever runs.\r\n\r\n(And we might want to default all non-ZulipMobile app clients to assume the new capability to avoid accidental use of the old format in the future)."},{"labels":["api",null,null,null,null,null],"text":"Unless I'm mistaken, the is_old_stream property on Stream objects in our API is an unnecessary; it's a boolean that is equivalent to `stream_weekly_traffic != null`.\r\n\r\nNoticed while reviewing #15178.\r\n\r\nLike all API cleanups, this is a priority issue, but should be pretty accessible.  We only use `is_old_stream` is a couple places in the frontend codebase, and I think they could be replaced by just computing it in `stream_data.update_calculated_fields`."},{"labels":["api",null,null],"text":"If the response from an outgoing webhook (which can be used to trigger a message in Zulip) returns empty or no content, we currently raise an exception as follows: \r\n\r\n```\r\nTraceback (most recent call last):\r\n  File \"/home/zulip/deployments/2020-05-27-05-59-05/zerver/worker/queue_processors.py\", line 171, in do_consume\r\n    consume_func(events)\r\n  File \"/home/zulip/deployments/2020-05-27-05-59-05/zerver/worker/queue_processors.py\", line 200, in <lambda>\r\n    consume_func = lambda events: self.consume(events[0])\r\n  File \"/home/zulip/deployments/2020-05-27-05-59-05/zerver/worker/queue_processors.py\", line 589, in consume\r\n    service_handler)\r\n  File \"/home/zulip/deployments/2020-05-27-05-59-05/zerver/lib/outgoing_webhook.py\", line 289, in do_rest_call\r\n    process_success_response(event, service_handler, response)\r\n  File \"/home/zulip/deployments/2020-05-27-05-59-05/zerver/lib/outgoing_webhook.py\", line 277, in process_success_response\r\n    send_response_message(bot_id=bot_id, message_info=message_info, response_data=response_data)\r\n  File \"/home/zulip/deployments/2020-05-27-05-59-05/zerver/lib/outgoing_webhook.py\", line 166, in send_response_message\r\n    raise JsonableError(_(\"Missing content\"))\r\nzerver.lib.exceptions.JsonableError: Missing content\r\n```\r\n\r\nWe should change the error handling to either silently succeed, or perhaps better, send a PM to the bot owner letting them know the bot is buggy (I think we have a general mechanism for this).\r\n\r\n@Hypro999 this could be a good intro issue for you, if you're interested in getting involved in outgoing webhooks too :)"},{"labels":["api",null,null,null],"text":"Zulip's API endpoint for fetching a realm's configured custom emoji, has a legacy structure for the `author` object that contains a user_id/email/name for the uploader.  Clients that display this type of settings information should have data on users by ID, so we should migrate this to an integer `author_id` field for a cleaner API.\r\n\r\nI think this just requires changes to `get_realm_emoji_dicts` plus to tests, assuming that current mobile clients won't be sad if we change this detail.\r\n\r\nTagging as a priority since this sort of API cleanup is best done sooner rather than later."},{"labels":["api",null,null],"text":"This endpoint will be convenient for clients (like zulip-mobile) instead of fetching the complete list of subscribers to a stream (which can be very large).\r\n\r\nThe endpoint can be of the form `/users/{user_id}/subscription/{stream_id}`, returning data in a JSON format: `{\"subscribed\": true}`, so that it can be extended in the future to include other fields like `stream_admin: true` or `role` etc.\r\n\r\nSee also:\r\n[Discussion on CZO](https://chat.zulip.org/#narrow/stream/243-mobile-team/topic/.23M3373.20Warn.20on.20.40-mention.20when.20not.20subscribed)\r\n[zulip-mobile issue](https://github.com/zulip/zulip-mobile/issues/3373)\r\n"},{"labels":["api",null,null,null],"text":"We want to add a \"feature level\", which is a monotonically-increasing integer which the server advertises in the API. The purpose is to provide a way for (non-webapp) clients, like the mobile and terminal apps, to tell whether the server it's talking to is new enough to support a given API feature -- in particular a way that\r\n* is finer-grained than release numbers, so that for features developed after e.g. 2.1.0 we can use them immediately on servers deployed from master (like chat.zulip.org and zulipchat.com) without waiting the months until a 2.2 release;\r\n* is reliable, unlike e.g. looking at the number of commits since a release;\r\n* doesn't lead to a growing bag of named feature flags which the server has to go on sending forever.\r\n\r\nDiscussion in chat starting [here](https://chat.zulip.org/#narrow/stream/243-mobile-team/topic/Server.20version.20number/near/814964).\r\n\r\nSpecifically:\r\n* This would appear in the `server_settings` and `register` responses, just like `zulip_version` does. It might look like (name open for discussion):\r\n```\r\n  \"zulip_feature_level\": 1,\r\n```\r\n\r\n* The value will live in `version.py` -- e.g.\r\n```python\r\nFEATURE_LEVEL = 1\r\n```\r\n\r\n* The [protocol will be](https://chat.zulip.org/#narrow/stream/243-mobile-team/topic/Server.20version.20number/near/815008):\r\n  * When we add a feature to the API, such that clients might want to know it's available before trying to use it, we bump the feature level.\r\n  * It's OK if we forget, or don't notice a given change qualifies for it before merging the change -- we can just go back and bump it later.\r\n    * The consequence is just that clients looking for the feature will only find it on servers with versions after the feature-level bump. Effectively, from a client's perspective, it just means the new feature wasn't actually complete until the feature level was bumped.\r\n\r\n* A client can then look for the feature level, in the same way the mobile app looks for `zulip_version` since zulip/zulip-mobile#3839.\r\n  * A missing feature level should be treated as zero, corresponding to all versions before we introduce feature levels. For distinguishing different pre-feature-level versions, we'll resort to comparing version numbers. (This is pretty OK, because the finer-grained distinctions mainly matter for servers that follow master ahead of the latest release.)\r\n  * Feature level >= 1 means the server has all API features introduced before feature levels, [notably `stream_post_policy`](https://chat.zulip.org/#narrow/stream/243-mobile-team/topic/Add.20functionality.20to.20create.20announcement.20streams/near/855688).\r\n  * Future clients will look for feature levels >= other thresholds, for future features.\r\n\r\n* What about stable releases?\r\n  * Stable releases will never bump the feature level -- all 2.1.x releases will have a missing/zero feature level, all 2.2.x releases will have the feature level of 2.2.0, etc.\r\n  * Usually we [don't backport new features to stable releases](https://chat.zulip.org/#narrow/stream/243-mobile-team/topic/Server.20version.20number/near/814979) at all, so this is perfect.\r\n  * Occasionally we might. If so, we can introduce a named feature flag which the stable release with the backport can send. Then the client's condition for \"is this API feature supported\" might look like \"anything with feature level >= $threshold, *or* with feature flag `foo`\". Importantly, newer releases from master don't send the flag -- the feature level subsumes all older flags -- so flags don't accumulate.\r\n"},{"labels":["api",null,null,null,null,null],"text":"Similar to https://github.com/zulip/zulip/issues/14481, when a user clicks the \"mark stream as read\" option in the left sidebar, we don't presently provide any feedback that we're working on it.  As a result, if there are many thousands of matching messages, the user is likely to think it didn't work, retry, and then that second HTTP request will probably fail after a deadlock with the first, spamming our server-side error logs.\r\n\r\nWe can prevent this through showing a loading indicator over the unread count for the stream until the HTTP request finishes (Well, that might be super ugly, but we should do something visible).\r\n\r\nAnd then there's probably a backend change to make such a fast duplicate request not deadlock/500 as well, though I'm not sure what that needs to be.\r\n\r\nThe exception we get is this mess: \r\n\r\n```\r\n  File \"./zerver/decorator.py\", line 589, in _wrapped_func_arguments\r\n    raise err\r\n  File \"./zerver/decorator.py\", line 574, in _wrapped_func_arguments\r\n    return target_view_func(request, profile, *args, **kwargs)\r\n  File \"./zerver/decorator.py\", line 789, in wrapped_func\r\n    return func(request, *args, **kwargs)\r\n  File \"./zerver/lib/request.py\", line 368, in _wrapped_view_func\r\n    return view_func(request, *args, **kwargs)\r\n  File \"./zerver/views/messages.py\", line 1156, in mark_stream_as_read\r\n    count = do_mark_stream_messages_as_read(user_profile, request.client, stream)\r\n  File \"./zerver/lib/actions.py\", line 4251, in do_mark_stream_messages_as_read\r\n    flags=F('flags').bitor(UserMessage.flags.read)\r\n  File \"/srv/zulip-venv-cache/5f67b9220527f4792938295885923757cc6301b9/zulip-py3-venv/lib/python3.6/site-packages/django/db/models/query.py\", line 741, in update\r\n    rows = query.get_compiler(self.db).execute_sql(CURSOR)\r\n  File \"/srv/zulip-venv-cache/5f67b9220527f4792938295885923757cc6301b9/zulip-py3-venv/lib/python3.6/site-packages/django/db/models/sql/compiler.py\", line 1462, in execute_sql\r\n    cursor = super().execute_sql(result_type)\r\n  File \"/srv/zulip-venv-cache/5f67b9220527f4792938295885923757cc6301b9/zulip-py3-venv/lib/python3.6/site-packages/django/db/models/sql/compiler.py\", line 1133, in execute_sql\r\n    cursor.execute(sql, params)\r\n  File \"/srv/zulip-venv-cache/5f67b9220527f4792938295885923757cc6301b9/zulip-py3-venv/lib/python3.6/site-packages/django/db/backends/utils.py\", line 67, in execute\r\n    return self._execute_with_wrappers(sql, params, many=False, executor=self._execute)\r\n  File \"/srv/zulip-venv-cache/5f67b9220527f4792938295885923757cc6301b9/zulip-py3-venv/lib/python3.6/site-packages/django/db/backends/utils.py\", line 76, in _execute_with_wrappers\r\n    return executor(sql, params, many, context)\r\n  File \"/srv/zulip-venv-cache/5f67b9220527f4792938295885923757cc6301b9/zulip-py3-venv/lib/python3.6/site-packages/django/db/backends/utils.py\", line 84, in _execute\r\n    return self.cursor.execute(sql, params)\r\n  File \"/srv/zulip-venv-cache/5f67b9220527f4792938295885923757cc6301b9/zulip-py3-venv/lib/python3.6/site-packages/django/db/utils.py\", line 89, in __exit__\r\n    raise dj_exc_value.with_traceback(traceback) from exc_value\r\n  File \"/srv/zulip-venv-cache/5f67b9220527f4792938295885923757cc6301b9/zulip-py3-venv/lib/python3.6/site-packages/django/db/backends/utils.py\", line 84, in _execute\r\n    return self.cursor.execute(sql, params)\r\n  File \"./zerver/lib/db.py\", line 31, in execute\r\n    return wrapper_execute(self, super().execute, query, vars)\r\n  File \"./zerver/lib/db.py\", line 18, in wrapper_execute\r\n    return action(sql, params)\r\ndjango.db.utils.OperationalError: deadlock detected\r\nDETAIL:  Process 19245 waits for ShareLock on transaction 1337553386; blocked by process 19483.\r\nProcess 19483 waits for ShareLock on transaction 1337553388; blocked by process 19245.\r\nHINT:  See server log for query details.\r\nCONTEXT:  while updating tuple (5452156,93) in relation \"zerver_usermessage\"\r\n```"},{"labels":["api",null],"text":"Currently the get user presence endpoint (https://zulipchat.com/api/get-presence) is the only endpoint on zulip which takes an email address. This is pretty inconsistent with the rest of the API, which only takes user_ids. Get user presence should be updated to only take the user id.\r\n\r\nRelates to #14302 , which would allow looking up a user via email address (to get the user ID)"},{"labels":["api"],"text":"Currently the only way to lookup a user is via their internal zulip ID. In order to fetch a Zulip user by email, you'd have to fetch all Zulip users then search the payloads for the email, backtracking and then saving the zulip ID for future reference.\r\n\r\nIt'd be nice to have an endpoint which allowed searching a zulip instance for a user with a specific email, and getting the payload for that user."},{"labels":["api",null,null,null,null],"text":"This is a planned follow-up to #13912; I'm opening it now so we don't lose track of it.  We should add a case to `test_stream_send_message_events` (or similar to the message editing piece of it) that moving a message between streams using the `propagate` feature, and verifies that our `zerver/lib/events.py` code does the right thing.\r\n\r\nI'm pretty sure it doesn't today and might be fairly tricky to fix, and it's a very small race, so I'm OK with merging #13912 without a proper fix for it.  "},{"labels":["api",null,null],"text":"This is a new issue replacing #10044, which has become cluttered with time.  Zulip has done a lot of big investments over the last few years in making our API documentation use the OpenAPI format and have automated tests, which makes it possible for it to be maintained reasonably.  This issue documents the important work that needs to happen for our API documentation to be complete for common use cases.  This bundle of work could probably end up being 1-2 GSoC projects this summer.\r\n\r\n* [ ] Improve the documentation for the system to cover the automated testing system and how it works (see https://github.com/zulip/zulip/issues/12571).\r\n* [x] Change every endpoint to use the `description: |` syntax (with a paragraph afterwards), which is much nicer for writing paragraph text and allows use of markdown.\r\n* [x] Change the way the heading sections at the top of the `templates/zerver/api/` pages are written to use the OpenAPI endpoint description field instead (currently, that field in `zulip.yaml` is completely ignored and usually has junk in it).  So we'd want to migrate the text and then use the same sort of machinery we use to render arguments to render the top-of-page descriptions.  \r\n* [x] Deduplicate various common constructs, like `event_types`, to live in `components` and be shared between the documentation for multiple endpoints.  This will make it a lot easier to improve the quality of the descriptions of our parameters.\r\n* [ ] Many minor updates to the docs for specific endpoints are recorded [in the issue label](https://github.com/zulip/zulip/issues?q=is%3Aopen+is%3Aissue+label%3A%22area%3A+documentation+%28api+and+integrations%29%22); a lot of these could be good warm-up projects.\r\n* [x] Move any useful content from `zulip-2.0.yaml` to `zulip.yaml` and delete it.\r\n* [x] Make `zerver/openapi/zulip.yaml` work with the [Swagger online editor](https://editor.swagger.io/), which largely requires migrating any ways we've extended the OpenAPI syntax for our own purpose to something that's more standard.  Probably the first step is to upgrade to OpenAPI 3, which I think explicitly allows adding random extra keys.\r\n* [x] Figure out how to migrate the remaining bit of content in the legacy `templates/zerver/api/fixtures.json` to live in `zerver/openapi/zulip.yaml` so that we can stop maintaining two duplicate formats for fixtures.  \r\n* [x] And if we can, similarly for `templates/zerver/api/arguments.json`.\r\n* [x] Create a system similar to `generate_api_arguments_table` for displaying nicer details about the formats of the various keys in the responses, ideally reusing rather than duplicating as much code as possible.  Ideally, this would do nesting correctly (where we'd visually display sub-keys indented 30px).\r\n* ~~[ ] Integrate the `/events` introspection logic in https://github.com/zulip/zulip/pull/13499 https://github.com/zulip/zulip/pull/13204~~\r\n* [ ] Extending our documentation to cover important endpoints.  A prioritized list is documented extensively in `pending_endpoints` in `test_openapi.py`; it seems best to maintain the details there.\r\n* [x] Add tags matching the organization in the `/api` sidebar (e.g. `users` for the user-related endpoints).  https://swagger.io/docs/specification/grouping-operations-with-tags/\r\n* [x] Add `operationId` values for every endpoint.  Ideally, these would match the name we'd want for a function for the API, e.g. `get_messages`.  Probably we can use the names from `python-zulip-api` for all the endpoints have have a name there.  This would fix https://github.com/zulip/zulip/issues/14629\r\n* [x] Make sure all of our example responses are currently schemas from the current REST API and validate that with automated tooling.\r\n* [x] Mark \"Deprecated Parameters\" appropriately in our documentation, and adjust our display logic to display them appropriately (Sorted to end, and with a \"Deprecated\" marker on them, similar to the Optional marker).  \r\n* [ ] Look at doing fancier styling for how our responses are rendered in the API docs\r\n* [ ] If supported, do the same deprecated handling for our response objects.\r\n\r\nDon't claim this issue via zulipbot; as it's a multi-part item; folks can coordinate with comments on what they're working on."},{"labels":["api",null,null,null],"text":"In https://chat.zulip.org/#narrow/stream/9-issues/topic/strange.20linkifiers.20behaviour/near/824977, a user reported an issue that I believe can be traced to our not flushing the per-request caches (aka clearing a couple dictionaries) in the `message_sender` workers.  While those queue workers have been removed, I believe there's a very similar issue with the `email_mirror`, `outgoing_webhook`, `embedded_bots`, and  `embed_links` queues.\r\n\r\n```\r\ndiff --git a/zerver/worker/queue_processors.py b/zerver/worker/queue_processors.py\r\nindex 89c8073681..e8bd32036a 100644\r\n--- a/zerver/worker/queue_processors.py\r\n+++ b/zerver/worker/queue_processors.py\r\n@@ -131,6 +131,7 @@ class QueueProcessingWorker(ABC):\r\n         except Exception:\r\n             self._handle_consume_exception([data])\r\n         finally:\r\n+            flush_per_request_caches()\r\n             reset_queries()\r\n \r\n     def _handle_consume_exception(self, events: List[Dict[str, Any]]) -> None:\r\n@@ -171,6 +172,7 @@ class LoopQueueProcessingWorker(QueueProcessingWorker):\r\n             except Exception:\r\n                 self._handle_consume_exception(events)\r\n             finally:\r\n+                flush_per_request_caches()\r\n                 reset_queries()\r\n \r\n             # To avoid spinning the CPU, we go to sleep if there's\r\n```\r\n\r\nI think most of the work would be in writing an appropriate test for this, which I think will actually be really tricky.  A test for this would:\r\n\r\n* Create a realm_filter\r\n* Trigger a queue worker that will eventually render markdown (`embed_links` might be the simplest) and inspect the resulting message to confirm it used the linkifier config (and critically, cached it).\r\n* Edit the realm_filter, and save it, but in a way that avoids (1) making an HTTP request within out process, which will clear the cache or (2) saving the RealmFilter object, which will also flush the cache for our process (just not other processes).\r\n\r\nBased on the challenges in writing a robust test for the failure caused by not flushing this, I'm thinking I'll just merge the fix without a specific test for it.\r\n\r\nTagging as a priority as all cache consistency issues are important to resolve since they produce confusing results.  \r\n\r\n"},{"labels":["api",null,null],"text":"Currently, all of our API requests go through decorators that call `process_client`.  This does 3 things:\r\n* Parse the User-Agent and determine whether the client (claims to be) an official Zulip client or not\r\n* Call `get_client` and store `request.client` with a `Client` object, which is needed for\r\n* Call `process_user_activity` to trigger UserActivity logging.  For `get_events`, #13917 has some ideas for further work we'll want to do there that one should be mindful of.\r\n\r\nThere are a few problems:\r\n* `write_log_line` only can specify which client was used in requests that fail authentication or rate limiting, since `process_client` is never called.  This could be fixed by calling `get_client_name` in the except clause, but that's duplicating work.\r\n* `write_log_line` doesn't have access to the client version, which would be a nice touch to include in `write_log_line` where we display the client (e.g. `ZulipMobile/2.1.3`), since that's not stored in Client objects.  It just does `?` inside an `except` block instead.  \r\n\r\nWhat I'd like to do instead is to split `process_client`:\r\n* `process_user_agent`: Does `get_client_name`, attaches it as `request.client_name` and if it's an official client, store the version in `request.client_version` (otherwise set that to None).  Called early, potentially it could be in the LogRequests `process_request` middleware since it'd be really cheap and there'd be a lot of duplication involved in calling it everywhere via decorators.\r\n* `process_client`: Calls `get_client` and `update_user_activity`, using `request.client_name` as an input.  We'd still store `request.client`.\r\n\r\nWe may want to do the version piece as commits at the end as it may involve some refactoring of the User-Agent code to plumb the data through properly.\r\n\r\nAs a sidenote, `process_user_activity` should probably transmit the client by ID, not name, since we don't need the name in the queue worker.  We'll definitely need backwards-compatibility code for old events here; @mateuszmandera maybe you should take this bundle of work since you're planning to work on some related Tornado-adjacent things anyway?"},{"labels":["api",null,null],"text":"When a client attempts to send a message to a stream, `extract_recipients` is still invoked on the `to` field, and still attempts to interpret it as a list.\r\n\r\nThis means that a stream name which contains commas, or (less plausibly) which appears to be valid JSON, cannot be sent directly; it must be encoded as a JSON list containing a string containing the stream name. Otherwise, the stream name is parsed as CSV/JSON. (This is the cause of a bug in the mobile app. See zulip/zulip-mobile#3734.)"},{"labels":["api",null,null],"text":"So, I'm not sure the approach in #13709 is the right path forward for improving our presence system's handling of users inactive for more than 2 weeks in large realms.\r\n\r\nTo explain what's going on, the current model is that the \"last active\" data is maintained via the presence system.  Presence is something that requires careful optimization, see https://zulip.readthedocs.io/en/latest/subsystems/presence.html for details.\r\n\r\nOur original presence algorithm sent data for every user in the organization to clients, which is very expensive, both to compute and to send.  For smallish realms (say, <500 users), we probably would be better off just using that algorithm (and we should look at changing the behavior).\r\n\r\nZulip's current presence algorithm has some optimizations for realms with many (e.g. 10K+) inactive users (like chat.zulip.org).  The way it works is that we only send presence data to clients in regular updates for users whose last activity is recent (in the last 2 weeks).  Which then for those users whose last activity is older means we don't have any data.\r\n\r\nI think the right path forward here is as follows:\r\n* Architecturally, we're going to send more complete presence data on first page load (i.e. in `page_params`) and potentially less complete presence data on future page loads (i.e. when sending presence data to the server).  \r\n* [ ] Change `get_status_dict` to support an optional second argument, the time window as a `datetime.timedelta` object.  If the option isn't provided, it doesn't do any time restriction (which we'll potentially use for `page_params`).  This refactor may require a bit of care to avoid \r\n* [x] Optimize the performance of `get_status_dict`.  My testing on `chat.zulip.org` suggests it takes about 150ms there, but list(UserPresence.objects.filter(timestamp__gte=timezone_now() - datetime.timedelta(weeks=2), user_profile__realm_id=2, user_profile__is_active=True, user_profile__is_bot=False).values_list(\"id\", \"timestamp\", \"client__name\")))` (an approximation of the core database query) only about 25ms.  So I think there's significant room for improvement by having the database do some of the join work internally.\r\n* [ ] Look at changing the format of how we send presence records to clients to use a much more efficient compressed format.  E.g. we should be able to remove `user_profile_email` from the structure entirely (replacing it with IDs), skip `status` when the timestamp is more than a day old (since the state is unconditionally going to be offline in that case), skip sending non-aggregated data, etc.  This could significantly reduce the Python processing and bandwidth work involved in presence as well.\r\n* [ ] Switch the model to have the presence data include `page_params` include the historical timestamps for every user (or maybe, do a separate 1-time query for this data and remove presence from `page_params` entirely?).  We can potentially do special storage or caching of the presence timestamps for users last active weeks ago to make this inexpensive (e.g. a memcached cache line that's updated daily and where entries are discarded if something newer is available).\r\n* [ ] Allow clients fetching presence data to specify a shorter time window than 2 weeks for presence updates; if clients are smart about how they update existing data and managing their clock around network interruptions, it should be possible for this to be like 5 minutes.\r\n\r\n"},{"labels":["api",null,null,null],"text":"We have a useful API for fetching historical data on topics, `/users/me/{stream_id}/topics`.  This API is intended to be fast (it's used whenever one clicks \"more topics\"), and on chat.zulip.org, it is (50ms-200ms runtime).  But on zulipchat.com, where we have history from a great many organizations, it can end up quiet slow, e.g. this:\r\n\r\n```\r\nzulip=> EXPLAIN ANALYZE                 SELECT\r\n                    \"zerver_message\".\"subject\" as topic,\r\n                    max(\"zerver_message\".id) as max_message_id\r\n                FROM \"zerver_message\"\r\n                WHERE (\r\n                    \"zerver_message\".\"recipient_id\" = 103098\r\n                )\r\n                GROUP BY (\r\n                    \"zerver_message\".\"subject\"\r\n                )\r\n                ORDER BY max(\"zerver_message\".id) DESC\r\n;\r\n                                                                      QUERY PLAN                                                                       \r\n-------------------------------------------------------------------------------------------------------------------------------------------------------\r\n Sort  (cost=344541.59..344541.63 rows=14 width=14) (actual time=1327.835..1329.169 rows=2250 loops=1)\r\n   Sort Key: (max(id)) DESC\r\n   Sort Method: quicksort  Memory: 225kB\r\n   ->  HashAggregate  (cost=344541.18..344541.32 rows=14 width=14) (actual time=1324.231..1325.936 rows=2250 loops=1)\r\n         Group Key: subject\r\n         ->  Bitmap Heap Scan on zerver_message  (cost=4195.50..343615.42 rows=185152 width=14) (actual time=62.340..1152.213 rows=157280 loops=1)\r\n               Recheck Cond: (recipient_id = 103098)\r\n               Heap Blocks: exact=121738\r\n               ->  Bitmap Index Scan on recipient_id_groups  (cost=0.00..4149.21 rows=185152 width=0) (actual time=32.107..32.107 rows=159735 loops=1)\r\n                     Index Cond: (recipient_id = 103098)\r\n Planning time: 0.134 ms\r\n Execution time: 1331.549 ms\r\n```\r\n\r\nI think what's happening here is that postgres is using a query plan that, for a stream with 160K messages of history, is doing a \"Bitmap Heap Scan\" across a large portion of the `zerver_message` table.  The structural problem, I think, is that while we have an index on `subject/topic` and an index on `zerver_recipient`, we don't have a joint index on the two, so there's no way for the database to look through the range of `subject/topic` values within a given `zerver_recipient` value (aka stream).\r\n\r\nSo my guess is the fix for this will be to create a new index, `zerver_recipient_topic`, that makes it possible for the database to do this sort of query efficiently.\r\n"},{"labels":["api",null],"text":"- Zulip version: 2.1.0-5-g49ff894d6a\r\n- OS version: Ubuntu 18.04.3 LTS (bionic)\r\n\r\nWe currently have some seemingly strange problems by using Zulip API with message IDs (e.g. with message deletion).\r\n\r\nInitially we created a new (generic) bot in Zulip and enabled message deletion as described (https://zulipchat.com/help/configure-message-editing-and-deletion). On this way we are able to successfully send messages (which also then are shown up correctly in Zulip web/desktop/mobile client):\r\n\r\n```\r\ncurl -X POST https://zulip.domain.com/api/v1/messages \\\r\n    -u alert-bot@zulip.domain.com:APIKEY \\\r\n    -d \"type=stream\" \\\r\n    -d \"to=Alert\" \\\r\n    -d \"subject=Test\" \\\r\n    -d $\"content=TEST - Event ID #5000\"\r\n\r\n{\"result\":\"success\",\"msg\":\"\",\"id\":78539}\r\n```\r\n\r\nBut strangely it is not possible to get the message or to delete it via API by using the (correct) message ID:\r\n\r\n```\r\ncurl -sSX GET -G https://zulip.domain.com/api/v1/messages/78539 \\\r\n    -u alert-bot@zulip.domain.com:APIKEY\r\n\r\n{\"result\":\"error\",\"msg\":\"Invalid message(s)\",\"code\":\"BAD_REQUEST\"}\r\n```\r\n```\r\ncurl -sSX DELETE https://zulip.domain.com/api/v1/messages/78539 \\\r\n    -u alert-bot@zulip.domain.com:APIKEY\r\n\r\n{\"result\":\"error\",\"msg\":\"Invalid message(s)\",\"code\":\"BAD_REQUEST\"}\r\n```\r\n\r\nWe get then a BAD_REQUEST (400) error - which seem to related to a user indicated \"invalid/unknown\" message id (https://zulipchat.com/api/rest-error-handling).\r\n\r\nSo it seems that the message ID does not exist - but it is possible to query for the correct message (with narrow: https://zulipchat.com/api/construct-narrow) and this shows that the message ID actually exists indeed:\r\n\r\n```\r\ncurl -sSX GET -G https://zulip.domain.com/api/v1/messages \\\r\n    -u alert-bot@zulip.domain.com:APIKEY \\\r\n    -d 'use_first_unread_anchor=true' \\\r\n    -d 'num_before=1000' \\\r\n    -d 'num_after=1000' \\\r\n    --data-urlencode narrow='[{\"operator\": \"stream\", \"operand\": \"Alert\"}, {\"operator\": \"sender\", \"operand\": \"alert-bot@zulip.domain.com\", \"negated\": false}, {\"operator\": \"search\", \"operand\": \"#5000\"}]'\r\n\r\n{\"result\":\"success\",\"msg\":\"\",\"messages\":[{\"id\":78539,\"sender_id\":49,\"content\":\"<p>TEST - Event ID #5000<\\/p>\",\"recipient_id\":152,\"timestamp\":1578002626,\"client\":\"curl\",\"subject\":\"Test\",\"subject_links\":[],\"is_me_message\":false,\"reactions\":[],\"submessages\":[],\"flags\":[\"read\",\"historical\"],\"match_content\":\"<p>TEST - Event ID #<span class=\\\"highlight\\\">5000<\\/span><\\/p>\",\"match_subject\":\"Test\",\"sender_full_name\":\"Alert\",\"sender_short_name\":\"alert-bot\",\"sender_email\":\"alert-bot@zulip.domain.com\",\"sender_realm_str\":\"\",\"display_recipient\":\"Test\",\"type\":\"stream\",\"stream_id\":105,\"avatar_url\":\"https:\\/\\/secure.gravatar.com\\/avatar\\/0ebefs3b5d3581f24cf8d3fad67ac760?d=identicon&version=1\",\"content_type\":\"text\\/html\"}],\"found_anchor\":false,\"found_oldest\":true,\"found_newest\":true,\"history_limited\":false,\"anchor\":10000000000000000}\r\n```\r\n\r\nIn the Zulip logs we didn't found any helpful information in this context. For us it is currently not understandable where exactly the problem source lies - and we would be grateful for every hint..."},{"labels":["api",null,null],"text":"as we are using the zulip api a lot, we realized that creating a new stream via the post subscription api is very slow.\r\nits always more then 1 second, especially if the user already have a lot of streams. \r\n\r\nseeing that the get subscriptions  endpoint have a parameter to ignore subscribers, would this also be an option for the post endpoint ? "},{"labels":["api",null,null,null,null],"text":"We've had some issues with inconsistencies between in the dictionary format for `get_raw_user_data` and `get_cross_realm_dicts`, including in 630aadb7e077a857bb3940a404dacc8b1740f6a5.  \r\n\r\nWe should make that category of error impossible.  I see a few paths forward:\r\n* Deduplicating the code by having `get_cross_realm_dicts` call a part of `get_raw_user_data` as a subroutine.  (Maybe via extracting its `user_data` helper method as a public method, `format_user_row`)\r\n* Using a `TypedDict` to define the type for what they're returning\r\n* Extending one of our `zerver/views/home.py` tests to check the formats.\r\n\r\nI'd probably start with trying the first approach and see how it goes.\r\n\r\n@Hypro999 FYI."},{"labels":["api",null,null,null],"text":"This is an element of the broader `subject` -> `topic` migration (see #1192) that should be straightforward to change, because I believe the mobile apps don't access `subject_links` yet, so there's no compatibility work required.  (What the data is used for in the webapp is the little in-topic-field links we show when there is a link or linkifier matching the topic line of the message).\r\n\r\n@gnprice to confirm I'm reading the mobile codebase correctly that it's indeed not accessed.\r\n\r\nNoticed in #13587; tagging as a priority since this sort of API migration gets more complex when delayed.  We should be sure to look again at updating the docs as discussed in #13587 once this is complete."},{"labels":["api",null],"text":"Zulip should have features to set API endpoints, which would work as custom authentication endpoints for services. \r\nLike for auth, \r\nif the custom API endpoint is https://IP:PORT/login, params as userid, password -> \r\nThen authentication backend should have ability for making call to the same and verifying if the user is logged in, and can also fetch required information. "},{"labels":["api",null],"text":"Following #12502, we're now accessing the history of which users a given user has had private message conversations with as part of loading the Zulip webapp.\r\n\r\nThe database query we use there is well optimized, but in the end it's fairly expensive (about as 100ms for my account on chat.zulip.org).  There's two reasonable paths to improve that:\r\n* Denormalize into `zerver_userprofile` the value of `zerver_recipient.id` for personal PMs to that user.  This would let us simplify the query to no longer join on `zerver_recipient` at all -- it can just compare effectively `userprofile.personal_recipient_id==message.recipient_id`.  This might be a useful optimization in any case; the cost is a small increase in the size of the `UserProfile` table, and the benefit is a lot of logic involving PMs gets to avoid a join on Recipient.  We could potentially do the same change to `zerver_stream` as well.\r\n* Create a `PrivateMessageConversation` table structure containing (`user_profile`, `recipient`, `count`, `max_message_id`) tuples caching the data about which users the current user has had private message conversations with, how many messages, etc.  The cost would be that we'd need to write/update K rows to that table every time we send (or delete) a private message with K recipients, adding a tiny bit of latency, but the database part of sending a PM is already so fast it likely wouldn't matter much, especially if we do the database interaction in an optimized fashion.  But this would eliminate this expensive query entirely.  The main downside of this approach is that it might be awkward to adapt it if we add support for topics in private message conversations (#1555), which I imagine we'll eventually do.\r\n\r\nMy temptation would be to write a quick migration to do the denormalization thing for `UserProfile` and test it out (maybe on chat.zulip.org for a production load) to see to what extent that makes a big difference (my read of the query plan is >75% of the time is in the half that joins with Recipient)\r\n, and decide how to proceed from there.\r\n"},{"labels":["api",null,null,null],"text":"The response that would be generated when someone try to remove a user that is not subscribed to a stream is this.\r\n\r\n```\r\n{\r\n    \"msg\": \"\",\r\n    \"not_subscribed\": [\r\n        \"new stream\"\r\n    ],\r\n    \"removed\": []\r\n    \"result\": \"success\"\r\n}\r\n```\r\n\r\n`not_subscribed` should be renamed to `not_removed` since that makes more sense.\r\n\r\nhttp://zulip.zulipdev.com:9991/api/remove-subscriptions\r\n\r\nThis should be an easy easy issue to work."},{"labels":["api",null,null],"text":"Currently, Zulip's \"declare bankruptcy\" UI will remove all unread messages.  We likely want to provide a less aggressive version that preserves messages the user is likely to want to read given that they are coming back to Zulip:\r\n\r\n* Private messages\r\n* Mentions (just the `mentioned` flag, not `wildcard_mentioned`)\r\n* The most recent `BANKRUPTCY_KEEP_RECENT_COUNT=100` messages in the user's history.  \r\n\r\nWe have a `mark_all_as_read function`/API, which probably should do what it says (mark everything as read); I'm thinking we add a few API options, e.g. keep_mentions, keep_private, and keep_recent, and have the bankruptcy JavaScript code pass all 3 as True to produce the desired user-facing behavior.\r\n\r\nImplementation-wise, in addition to changing the backend, we'll need to change the frontend as well; this function currently just marks everything as read:\r\n```\r\nexports.declare_bankruptcy = function () {                                                           \r\n    exports.unread_pm_counter.clear();                                                               \r\n    exports.unread_topic_counter.clear();                                                            \r\n    exports.unread_mentions_counter.clear();                                                         \r\n    unread_messages.clear();                                                                         \r\n};                                                                                                   \r\n```\r\n\r\nThere's two good options for how to make that happen:\r\n* Probably the right option is to have the bankruptcy UI send your browser to a special /bankruptcy page that is effectively a loading indicator for the bankruptcy process, that when finished reloads them back to the Zulip webapp.  We might need to build a UI like this for soft-deactivated users anyway, which may save some work.\r\n* Or just have a highly visible loading indicator.\r\n* If we want to avoid that, we'll need to do something complicated involving determining which unread messages to keep on the frontend.\r\n\r\n(Split out of #6512)."},{"labels":["api",null],"text":"Hi,\r\n\r\nI'm trying to find an efficient way to group together private messages into private conversations.\r\nafaict this is not doable via something like a single `conversation_id` as of now.\r\n\r\nthe only way that seemed feasible was to compare (all of) the `display_recipients`.\r\n\r\nIs there a better way to find out which message is part of which (private) conversation?\r\n\r\nIf not, how about not omitting the `stream_id` for private conversations? \r\nArguably the naming is not ideal, but the existence of that property would allow for easy and efficient sorting and grouping of private messages... \r\n"},{"labels":["api",null],"text":"#### Background for anyone new to this issue/system:\r\n- Issue https://github.com/zulip/zulip/issues/12521\r\n- Pull Request https://github.com/zulip/zulip/pull/12681\r\n- Pull Request https://github.com/zulip/zulip/pull/12751 [where type checking was initially added]\r\n- Pull Request https://github.com/zulip/zulip/pull/12934 [system extended to lists]\r\n\r\n#### Issue:\r\nThe OpenAPIArgumentsTest, as far as type checking is concerned, currently compares the type hints in the python code with the type listed in the `zulip.yaml` file (static code analysis). But this isn't enough. We need to also check the type against the \"REQ converter\" element (see the REQ class in `zerver/lib/requests.py` and almost any view function in`zerver/views`) and resolve the TODO in OpenAPIArgumentsTest about converter elements:\r\n~~~\r\n# TODO: The below inference logic in cases where\r\n# there's a converter function declared is incorrect.\r\n# Theoretically, we could restructure the converter\r\n# function model so that we can check what type it\r\n# excepts to be passed to make validation here\r\n# possible.\r\n~~~"},{"labels":["api",null,null],"text":"Now that the OpenAPI test suite has been sufficiently developed. We should begin work on eliminating all of the endpoints in the `buggy_documentation_endpoints` list under `OpenAPIArgumentsTest`. The ideal way to approach this is by adding 1 commit per endpoint resolved and then 1 commit at the end to remove the variable `buggy_documentation_endpoints` and code for it from the test itself.\r\nRelated: https://github.com/zulip/zulip/issues/12521"},{"labels":["api",null,null,null],"text":"We removed all use of the legacy API endpoint for adding/removing reactions a long time ago (add_reaction_legacy, remove_reaction_legacy); I verified that no clients use this endpoint using server logs.  We should remove the implementation.\r\n\r\nThe main effort here will be migrating existing unit tests that use this endpoint to use the newer reactions endpoint.\r\n"},{"labels":["api",null],"text":"as I'm diving a bit deeper in using the API, I realised when testing against `chat.zulip.org`, that the request to get my stream subscriptions is ~10x slower than getting all streams.\r\n\r\nfor comparison: \r\n`https://chat.zulip.org/api/v1/streams`    **0.28s**\r\n`https://chat.zulip.org/api/v1/users/me/subscriptions`    **2.18s**\r\n\r\nis such a large performance difference expected?\r\n"},{"labels":["api",null],"text":"the REST API is not usable from within a browser without CORS allowed...\r\n\r\nare there reasons to not allow it ?"},{"labels":["api",null,null],"text":"This is really important because we've had a series of incidents of the `curl` examples in our docs being wrong.\r\n\r\nHere's a proposal for how to do this without losing any functionality (e.g. the ability to hand-decide which values to use in the examples):\r\n\r\n* We plan to use the `example` values we already have in the OpenAPI parameter data structures for this.  If we needed to, we could add support for reading a new `curl_example` value, adjacent to `example`, to the OpenAPI data in `zulip.yaml`, that has the example value to be used in the curl example for that parameter; but I don't think that should be required; it should be fine to have the `curl` example use the same example strings we use in the code.  \r\n* We add a function construct_curl_example(auth_email, auth_api_key), with code this:\r\n```\r\ncurl_first_line = [\"curl\"] + curl_method_arguments(http_method)\r\nif authentication_required:\r\n    curl_auth_line = [\"-u\", \"%s:%s\" % (auth_email, auth_api_key)]\r\nfor param, example_value in openapi_example_params:\r\n    curl_arguments += format_curl_argument(param_name, example_value)\r\nreturn curl_first_line, curl_auth_line, curl_arguments\r\n```\r\n* We add another function, e.g. `render_curl_example(endpoint)` that calls `construct_curl_example(\"BOT_EMAIL_ADDRESS\", ...)` and renders the nicely line-wrapped curl examples into the markdown file.\r\n* And we extend `tools/test-api` to have a loop that actually calls the curl example from the `construct_curl_example` (using `subprocess`) against the test server and checks it gets a 200 response.\r\n* We then convert the endpoints to use this new `render_curl_example` system; we'll probably want to do this as one commit per endpoint because we may be fixing things in those individual endpoints, and the endpoints should be independent of each other (so it'll be easy to merge the easy ones fast and then revisit the rest).\r\n"},{"labels":["api",null,null],"text":"Browsers increasingly do experimental, potentially buggy things with caching (especially in situations like trying to reload a tab after returning from suspend without going over the network).  Zulip attempts to prevent this on the webapp's main endpoint (/) via `patch_cache_control(response, no_cache=True, no_store=True, must_revalidate=True)`, which should disable all browser caching.  We've verified that the HTTP headers indeed make it through to the browser, so that's not the problem.\r\n\r\nHowever, empirically, Chrome at least sometimes will on a flaky network (re)load one to a state on e.g. chat.zulip.org where messages you read in the last few hours are shown as unread.  Reloading the webapp fixes the problem, so it's clear the server-side state is correct.  Because of how Zulip's unread messages system works:\r\n* Initial data on unread messages is sent to the client via `page_params`, which is encoded in the HTML for the main Zulip webapp page (`/`).\r\n* Zulip has no mechanism for read messages becoming unread\r\n\r\n, it's clear that the browser is using the HTML from a previous load of the webapp in restoring the page (and thus using a stale version of all the data in `page_params`, most visibly, the unread counts).  \r\n\r\nSince we don't have a reliable reproducer for this, it's unlikely we can get the browser vendors to fix it.  What we can do is make Zulip's webapp robust to this sort of incorrect browser caching behavior.  \r\n\r\nAfter an extended discussion with @andersk, one way we could fix it without making too many assumptions about browser behavior is this:\r\n* Because of the expected structure of the cached reloaded webapp, we should expect the client to have a stale state of everything in `page_params`.  In particular, it will be initialized with a very old value of the `last_event_id` parameter -- probably `0`, even though the actual event queue will likely have been in use for much longer.  \r\n* This means we can patch `fetch_events` in `zerver/tornado/event_queue.py` to look at requests that have a `last_event_id` older than the newest garbage-collected event, and return a special error for them.  \r\n* This should have no impact on properly functioning clients, since they have a monotonically increasing `last_event_id`.\r\n* This should have no impact on properly functioning clients experiencing network retries and races, since if the client resends a `get_events` request, it is expected to cancel and/or ignore the response if a previous `get_events` request is returned by the server, so it should never process the new error.\r\n* We can extend the browser client to check for this new error, and if it sees it, destroy its event queue, show a user-facing error, and try to reload itself properly.\r\n\r\n"},{"labels":["api",null,null,null],"text":"As described in detail in https://chat.zulip.org/#narrow/stream/3-backend/topic/hidden.20emails/near/768801, the current structure of the way we cache the `display_recipient` field in `message_dict` structures is \r\n\r\nThe work here is primarily going to be in the `messages_for_ids` code path, in particular not fetching `display_recipients` in the `generic_bulk_cached_fetch` code path, and instead converting the existing `hydrate_recipient_info` to work more like `bulk_hydrate_sender_info`.  \r\n\r\nWhile we are thinking about this, we may want to consider also adding support for an option in `get_messages_backend` to only include IDs in the `display_recipient` structure (or maybe just not include ` display_recipient`, and instead send just the IDs in some other structure?  Unclear.).  But that piece is lower priority."},{"labels":["api",null,null,null],"text":"Something that's incredibly valuable in maintaining API documentation is making sure that we keep it up to date as the API changes.  Our API documentation isn't complete yet (see https://github.com/zulip/zulip/issues/10044), but in 1de4b94fbe04e57c5959001ec8e881f36718cb15 I added an automated test that does a comparison between our API documentation and the actual arguments declared in our view functions.  There's a bunch of TODOs remaining to make this system really nice and have it add more coverage of possible bugs (I've marked the ones with an explicit TODO comment in the test, below):\r\n\r\n* [x] Not all arguments are intended to be documented (e.g. there's backwards compatibility, etc.).  We should add an option to `REQ` with a name like `intentionally_undocumented=True` that causes it to not add the argument to the `arguments_map` data structure. (and thus not to considered for whether we've documented all arguments that should be documented in our test).  This should let us remove a bunch of things from `BUGGY_DOCUMENTATION_ENDPOINTS` that aren't actually buggy, they just have arguments we don't want to document (e.g. because they're old legacy things).\r\n* [ ] Remove other things from `BUGGY_DOCUMENTATION_ENDPOINTS` that are there just because we added an argument and didn't update the documentation when we did so.  E.g. https://github.com/zulip/zulip/issues/11136.\r\n* [x] TODO: Figure out a way to handle this matching between the OpenAPI format for parameters and the `urls.py` format: `/messages/{message_id} <-> r'^messages/(?P<message_id>[0-9]+)$'`.  We might want to handle this by having a loop over all OpenAPI endpoints in addition to our existing loop over all `urls.py` endpoints, because doing so would allow us to also verify that every endpoint in the OpenAPI codebase is being successfully matched to the corresponding actual code.\r\n* [x] TODO: Add support for using this syntax supported by `rest_dispatch`: `{'POST': ('zerver.views.report.report_error', {'intentionally_undocumented'})}),` to mark in the `urls.py` which endpoints we expect to never have public API documentation (e.g. because they're used only internally by the webapp codebase).\r\n* [x] TODO: This is lower priority than the main issue, but it'd be really cool to cross-validate the types declared in OpenAPI against the types declared in `REQ` (via the `validator` parameter).  We may not be able to do this always, but 95% of the time it's `check_int` or `check_str` or `check_dict`, and we can certainly map those to the expected type.\r\n\r\nOur \"writing views\" developer tutorial is good reading prior to working on this, as are https://zulip.readthedocs.io/en/latest/documentation/api.html and https://zulip.readthedocs.io/en/latest/documentation/openapi.html."},{"labels":["api",null,null],"text":"Currently, only the /register API returns deactivated streams; the `GET /streams` endpoint only returns active streams.  While this is what one wants in most cases, there are use cases where one's explicitly looking for deactivated streams.\r\n\r\nWe need to add an argument, e.g. `include_all_deactivated`, which when passed `do_get_streams`, causes it to return deactivated streams as well.\r\n\r\nSee https://chat.zulip.org/#narrow/stream/9-issues/topic/api/near/740596 for the original report."},{"labels":["api",null,null,null],"text":"At the moment there doesn't seem to be an endpoint for getting individual users through the API. This is kinda important when wanted to edit, deactivate or reactivate individuals on a server.\r\n\r\n[related topic at chat.zulip.org](https://chat.zulip.org/#narrow/stream/170-ZulipAPI.2ENET/topic/endpoint.20questions)\r\n[and here](https://chat.zulip.org/#narrow/stream/127-integrations/topic/api.20endpoint.20for.20single.20user/near/739431)"},{"labels":["api"],"text":"This issue is appropriate for your only if you have experience researching Zulip code and writing basic docs. \r\n\r\nWe have docs for updating message flags:\r\n\r\nhttps://chat.zulip.org/api/update-message-flags\r\n\r\nThis lists all the flags that a user should update, but it doesn't explain what the flags mean.  Some flags are sort of self-explanatory to folks who use Zulip a lot--starred, read, mentioned, etc.--while others are a bit more obscure--summarize_in_stream, force_expand, etc.\r\n\r\nThe doc piece here would be pretty simple--just a table of flag and description.  Descriptions can be as short as \"true if user has starred message in an app.\"\r\n\r\nThe tricky part here is that for the more obscure flags, you'll want to research them to find out their precise meaning and what we expect API users to do with them."},{"labels":["api",null,null,null],"text":"While developing zulip-terminal, we noticed two different forms of reactions data being sent:\r\n* events have a `user` dict with a `user_id` entry (and others)\r\n* messages have a `user` dict with an `id` entry\r\n\r\nThis was reported as issue zulip/zulip-terminal#334.\r\n\r\nI initially suggested simply migrating to add `id` in the event. However, to satisfy a long-term goal of reducing user info and bandwidth @showell suggested we could move to a `user_id` entry in both places, instead of a fuller `user` dict.\r\n\r\nThe relevant discussion is below:\r\nhttps://chat.zulip.org/#narrow/stream/49-development-help/topic/reactions.3A.20id.20.26.20user_id.20keys/near/662711\r\n\r\nNo decision was made in the discussion, but as it stands it's a bit of an unexpected issue for those using the messages and reaction-event APIs, where the keys don't match."},{"labels":["api"],"text":"This is a somewhat advanced issue, so it should be taken by somebody who know both the backend and has familiarity with our three major clients.  We currently limit our presence queries to two weeks, going back to a performance fix that we id in 2017:\r\n\r\n3a332aee0b23786f15101876d97821e09d19497c\r\n\r\nWe'll need to get final signoff from Tim on how to re-introduce data for dormant users, in a way that doesn't impact bandwidth or performance of the apps (and which is also backward compatible).\r\n\r\nMore discussion here:\r\n\r\nhttps://chat.zulip.org/#narrow/stream/9-issues/topic/Last.20Online.3A.202.20Weeks.20Ago/near/727428"},{"labels":["api",null,null],"text":"The mobile app's PMs screen shows the PM conversations we've been in recently, but \"recently\" may be as few as the last 100 PM messages. For a user that heavily uses PMs, this can leave out conversations even from a day or two ago.  One user reported an example as a typical experience: they're looking for a specific conversation, and the last message in it was 3pm yesterday. It's 3:30pm at the time they look, just over 24hr later. It doesn't show up on the PMs screen, though 6 other conversations do.\r\n\r\nThis is a data issue -- the mobile app doesn't have a convenient way to query these data.\r\n\r\nWith in part this issue in mind, the Zulip backend as of Zulip 1.9 added a nice database index for PMs that a given user has received; so we can very quickly do queries on that data.\r\n\r\nThe really dumb version that could be done with the API today would be to do a GET /messages is:private narrow query, but that would be a lot of data over the network. Probably what we should actually do is write a function similar to the \"more topics\" function that takes advantage of this index to get you e.g. the (PM recipient User ID list, last_message_id) tuples covering e.g. the last 1K PMs you've had, which probably is a <10ms query on the database end, and either include the data in /register or a separate endpoint (depending what's better for mobile's architecture); I expect it'd be <1hr work for me to add backend support for this if we had confirmation of what format the mobile app wanted. And the app should be able to maintain that data set after /register as new messages come in, since it's basically just \"look up the user_id_list, and bump the last_message_id\".\r\n\r\n(Until the database index work in 1.9, this would have been prohibitively expensive, since we'd need to scan all messages to find enough PMs, which for low-PM users in an organization with a lot of streams traffic could have easily involved the database needing to look at 50K+ messages of history and thus adding 100sms of latency).\r\n\r\nI don't think this data set would need unreads data, since the client should have that and be able to splice it in directly and it's probably cleaner to have one source of truth there, but it wouldn't be hard to include.\r\n\r\nDiscussion in https://github.com/zulip/zulip-mobile/issues/3133 suggests we should use a dict data structure, not a tuple, e.g.\r\n```\r\n[{\r\n    user_ids: [1, 2, 3],\r\n    last_message_id: 23451,\r\n    ...\r\n}]\r\n```\r\n\r\nI think the query we'll want is roughly UserMessage.objects.filter(user_profile=user_profile, flags=UserMessage.flags.is_private).order_by(\"-id\")[0:1000] will get the conversations we want, and then we just need to format the data.\r\n\r\nWe also need a name for the data structure; maybe `recent_conversations` is good enough.\r\n\r\nThe super optimized version of the key database query is this:\r\n```\r\nzulip=> select sub.recipient_id, max(sub.message_id) from (select um.message_id as message_id, m.recipient_id as recipient_id from zerver_usermessage um join zerver_message m on um.message_id = m.id where um.user_profile_id=8683 and um.flags & 2048 <> 0 order by message_id desc limit 1000) as sub group by sub.recipient_id;\r\n\r\n-----------\r\nor spelled in Python:\r\n\r\nquery = '''\r\nSELECT                                             \r\n    subquery.recipient_id, max(subquery.message_id)\r\nFROM (                                             \r\n    SELECT                                         \r\n        um.message_id as message.id                \r\n        m.recipient_id as recipient_id             \r\n    FROM                                           \r\n        zerver_usermessage um                      \r\n    JOIN                                           \r\n        zerver_message m                           \r\n    ON                                             \r\n        um.message_id = m.id                       \r\n    WHERE                                          \r\n        um.user_profile_id=%d AND                  \r\n        um.flags & 2048 <> 0                       \r\n    ORDER BY message_id DESC                       \r\n    LIMIT %d                                       \r\n) AS subquery                                      \r\nGROUP BY subquery.recipient_id                     \r\n''' % (user_profile.id, RECENT_CONVERSATIONS_COUNT)\r\n```\r\n\r\nhowever, that has a bug, namely that it misses 1:1 PMs sent directly to the current user."},{"labels":["api",null],"text":"## Description\r\n As a developer I want to be able to reuse existing files a bot has uploaded in order to save resources on the installation. \r\nI wrote a bot that provides data in the form of images to the user and at the moment I have to re-upload the same data if a user asks for it, because the bot cannot access the list of uploaded files in order to check, if this data was already provided.\r\n\r\n## Possible Solutions\r\nAdd `https://ZULIPSERVER/json/attachments` to the list of api calls, e.g. allow me to access the same data by calling `GET https://ZULIPSERVER/api/v1/attachements`.\r\nFor my purpose it would be enough to have the list of attachements, but it would make sense to also support the deletion of such, the functionality for everything like this already exists in the UI and for me it would be ok if it works the same way."},{"labels":["api",null,null,null],"text":"We should add proper validation that \"stream color\" inputs are valid HTML colors in the format of `#abcd12` where the 6 colors after the hash are valid hex characters.  I think doing this basically involves just changing `update_subscription_properties_backend` to replace `check_string` with a a new validation function `check_color`, and adding some tests."},{"labels":["api",null,null,null],"text":"From our server logs, we occasionally see this sequence for users using the webapp, where the the `DELETE` requests are being apparently retransmitted several times to the server in the same second:\r\n\r\n```\r\n2019-01-07 23:45:18.583 INFO [zr] IP DELETE  200 155ms (db: 127ms/17q) /json/messages/ID\r\n2019-01-07 23:45:19.069 INFO [zr] IP DELETE  500 640ms (db: 81ms/5q) /json/messages/ID\r\n2019-01-07 23:45:19.069 INFO [zr] IP DELETE  500 641ms (db: 139ms/5q) /json/messages/ID\r\n2019-01-07 23:45:19.072 INFO [zr] IP DELETE  500 643ms (db: 94ms/5q) /json/messages/ID\r\n```\r\n\r\nBased on those logs, I'm pretty sure all 4 requests were received by the server essentially simultaneously (i.e. at 18.583 - 155ms ~= 19.069 - 640ms).  I think there's two possibilities for the problem here:\r\n\r\n* The click handler logic here is broken, and ends up somehow creating multiple click handlers if you do the right sequence of things.  It seems a bit hard to believe, though, given the chained placement of the `.off()` here:\r\n```\r\nexports.delete_message = function (msg_id) {                                                                        \r\n    $(\"#delete-message-error\").html('');                                                                            \r\n    $('#delete_message_modal').modal(\"show\");                                                                       \r\n    $('#do_delete_message_button').off().on('click', function (e) {                                                 \r\n        e.stopPropagation();                                                                                        \r\n        e.preventDefault();                                                                                         \r\n        channel.del({                                                                                               \r\n            url: \"/json/messages/\" + msg_id,                                                                        \r\n            success: function () {                                                                                  \r\n                $('#delete_message_modal').modal(\"hide\");                                                           \r\n            },                                                                                                      \r\n            error: function (xhr) {                                                                                 \r\n                ui_report.error(i18n.t(\"Error deleting message\"), xhr,                                              \r\n                                $(\"#delete-message-error\"));                                                        \r\n            },                                                                                                      \r\n        });                                                                                                         \r\n                                                                                                                    \r\n    });                                                                                                             \r\n};                                                                                                                  \r\n```\r\n\r\n* The other possible problem here is just that `DELETE` (hard-delete a message) HTTP requests are allowed to be arbitrarily repeated by browsers, caches, etc., and that's what's happening.  This seems a little suspicious, though, because sending 4 requests in the same ~5ms period is pretty aggressive for this feature.\r\n\r\nI believe mobile doesn't yet use this API, so we can get away with changing the endpoint at this stage if we think that's use of HTTP DELETE (as opposed to a POST to /delete) is the root cause of the problem here.\r\n\r\n"},{"labels":["api",null],"text":"Currently, most API users will have to do that manually to ensure that they don't have to download extra payload, which means, people have to be aware of such in the first place. If the default is `True`, then the \"error\" encountered by GUI-based API users will be explicit and can be mitigated early on.\r\n\r\nThe only complication with the migration is that legacy clients are not aware of `client_gravatar` in the first place.\r\n\r\nSpawned from https://github.com/zulip/zulip-terminal/issues/219."},{"labels":["api",null,null],"text":"Currently, the `subscribe` APIs tend to access streams by name, which is great for quick API tools, but we should also support interacting with a stream by ID, so that one can be specific in a way that's resilient to streams being renamed.\r\n\r\nI believe fixing this on the backend requires tweaking `list_to_streams`, and then we should follow up with frontend work to send stream IDs rather than names in the main `subscribe` code paths.  \r\n\r\n(We also had an issue where due to HipChat import violating the \"unique stream names\" invariant, and this combined with how `list_to_streams` works currently to subscribe users to both the new and old streams with a given name.\r\nSee https://chat.zulip.org/#narrow/stream/127-integrations/subject/hipchat/near/656572 for context.)"},{"labels":["api",null,null],"text":"Hi,I config a bot with type outgoing,when I custom a http server to handle the hook,there is no Content-Type field in headers,here are all header fields:\r\n\r\n```\r\n[ 'Host',\r\n  '127.0.0.1:7001',\r\n  'Connection',\r\n  'close',\r\n  'Content-Length',\r\n  '966',\r\n  'User-Agent',\r\n  'python-requests/2.18.4',\r\n  'Accept',\r\n  '*/*',\r\n  'Accept-Encoding',\r\n  'gzip, deflate' ]\r\n```\r\n\r\nso,many framwork can't handle body without Content-Type field,so can you add this field in outgoing webhook?\r\n\r\nthanks."},{"labels":["api",null,null,null],"text":"We ban bot users from accessing the main `POST presence` endpoint, because bot users don't have presence data, but we should have a corresponding `GET` endpoint that bot users can use to access the full presence data for an organization.  \r\n\r\nIt should be able to mostly reuse the code from the `POST` endpoint, just skipping the \"update\" part.\r\n\r\n"},{"labels":["api",null,null],"text":"I think something no larger than 5000 as the sum of `num_before` and `num_after` would be reasonable.\r\n\r\n(Anything larger than that might not work just due to request size issues, and if you need more than that, you should be paginating)"},{"labels":["api"],"text":"There is no way for fetching the user groups in a realm, besides reading them from the initial response given when registering a new event queue.\r\n\r\nWe could make use of the (currently orphan) `user_groups_in_realm` view in `zerver/views/user_groups.py`, and make it available by GETting the `user_groups/` endpoint.\r\n\r\nI can take this real soon if nobody is up for it first.\r\n\r\n---\r\n\r\n@zulipbot label \"area: api\" \"enhancement\""},{"labels":["api",null],"text":"On `/register` when the `realm_user` event type is included, we return the data for certain users in `cross_realm_bots`.\r\n\r\nThis is fine and dandy, but they're missing certain information. Most notably, `avatar_url`:\r\n```\r\n$ curl -s https://TESTORG.zulipchat.com/api/v1/register -u [...] \\\r\n  -d 'event_types=[\"realm_user\"]' | jq .cross_realm_bots\r\n[\r\n[...]\r\n  {\r\n    \"full_name\": \"Welcome Bot\",\r\n    \"is_admin\": false,\r\n    \"is_bot\": true,\r\n    \"email\": \"welcome-bot@zulip.com\",\r\n    \"user_id\": 100007\r\n  },\r\n[...]\r\n]\r\n```\r\n\r\nIn fact, these bots do have avatars set, at least on my test org on zulipchat.com which I used above (on chat.zulip.org, they seem to just have gravatars):\r\n![image](https://user-images.githubusercontent.com/28173/43509328-3f4784a8-9527-11e8-8f1c-72395c9c82c9.png)\r\n\r\nThis actually fools the mobile app into not showing these bots' avatars in certain places, though we do in the message list:\r\n![image](https://user-images.githubusercontent.com/28173/43509403-71b634ca-9527-11e8-9e0f-2ab1fdaafb15.png)\r\n\r\nWe should just start including the avatar_url.\r\n\r\n(More broadly, perhaps the cross-realm bots should just be folded into the `realm_users` field of the response; I'm not sure any client benefits from getting them separately. In the mobile app, the separation has been a source of confusion in the code and small bugs; @roberthoenig 's https://github.com/zulip/zulip-mobile/pull/2830 is cleaning some of that up, and will probably end up just folding the `cross_realm_bots` data into the same place we store what we get from `realm_users`. See also #5414.)\r\n"},{"labels":["api",null,null],"text":"This is a large multi-part issue.  The use case for this is to support custom fields like \"employee ID\" that (A) one might want to sync from another database like LDAP and (B) one might want to not allow users to change manually.\r\n\r\nThe stack of work for this would be:\r\n* [x] Add support for admins editing other users' profile fields via the API (currently not supported).  While we're at it, I imagine we'd add UI in the admin user-editing feature to modify these as well.\r\n* [ ] Document that API, maybe providing nice example code for doing this from LDAP or another data store, perhaps supporting using either the Zulip API or a `manage.py` command (the latter for LDAP is #10976, where we already have a pretty direct integration).\r\n* [ ] Add a flag for custom profile fields, allowing you to configure a field as not-user-editable."},{"labels":["api",null,null,null],"text":"Zulip has a pretty well-designed API, with a lot of good properties, but it's documentation is incomplete. \r\n The overall goal is to fully document the Zulip API on https://zulipchat.com/api, so that it's easy both for Zulip app developers (mobile, terminal, etc.) and people building custom integrations to understand how to use Zulip's API.  We have documented a few dozen endpoints, but there are many missing.  https://zulip.readthedocs.io/en/latest/documentation/api.html is our documentation on how that documentation works (thought it is somewhat out of date, in that we are migrating to using the OpenAPI format file `zerver/openapi/zulip.yaml` for some of the things like argument definitions that used to have a separate `fixtures` file).  Our general philosophy is to build a system that can be extensively unit-tested, so that we can ensure the documentation stays up-to-date as we expand and adjust the Zulip API .  Some good tasks in this area include:\r\n* [ ] Document a few endpoints.  Read 69da22d998c6f5f56931c8449f441b3fc114d59f as a recently added endpoint to refer to.  I've noted a few that seem like good starter items here.\r\n   * [ ] Document messages/${messageId}/reactions, the endpoint for adding emoji reactions\r\n   * [x] Work through the \"user groups\" endpoints mentioned below\r\n* [ ] Contribute to https://github.com/zulip/zulip/issues/12521, which has a bunch of coding tasks\r\n* [ ] Once one has done a few, update `docs/documentation/api.md` to correct the parts that are out of date.  (This is https://github.com/zulip/zulip/issues/12571)\r\n\r\nI'm very happy to provide help and support to folks working on this area.\r\n\r\n------------------------------------------------\r\n\r\nA good priority for doing this is to make sure we document all the endpoints that we need to use in the mobile (and terminal) apps, just because that's API documentation that will be readily and frequently consumed.  \r\n\r\nHere's the current list of endpoints the mobile apps interact with that don't have API docs, organized somewhat by priority.\r\n\r\nBelow are things that are not documented, and should be:\r\n* [ ] /messages/${messageId}/reactions\r\n* [x] /typing\r\n* [ ] /users \r\n\r\nAccessing uploaded files:\r\n* [ ] user_uploads\r\n\r\nUser settings for notifications:\r\n* [x] settings/notifications (https://github.com/zulip/zulip/pull/10342)\r\n\r\nPresence:\r\n* [x] users/me/presence (core presence endpoint)\r\n\r\nStarring and unread counts endpoints:\r\n* [x] mark_all_as_read\r\n* [x] mark_stream_as_read\r\n* [x] mark_topic_as_read\r\n* [x] messages/flags\r\n\r\n------------------------------\r\n\r\nI believe the app doesn't support editing these organization settings.  Further, it should be just getting these data from `/register` with the right `event_types` value, so it's probably a mobile bug if we're accessing these:\r\n* [x] realm/emoji\r\n* [x] realm/filters\r\n(Unless I'm wrong and the app supports managing user groups somewhere secret?)\r\n* [x] user_groups/create\r\n* [x] user_groups/${id}\r\n* [ ] user_groups/${id}/members\r\n* [x] users/me/user_groups\r\n\r\nSame story with these stream settings/deactivation (though I could imagine changing these):\r\n* [x] streams/${id} -- does the app actually support administering streams this way? \r\nUser stream settings (color, notification settings, muted topics; does the app support administering these?): \r\n* [ ] users/me/subscriptions/muted_topics\r\n* [x] users/me/subscriptions/properties\r\n\r\nAnd these user-level settings:\r\n* [ ] users/me/alert_words\r\n\r\n\r\n-------------------------------------------\r\n\r\nThis endpoint is mostly just for mobile/desktop to get organization icon, but has some use beyond mobile/desktop:\r\n* [x] server_settings\r\n\r\nThese are used only by mobile, so potentially lower priority for main API docs:\r\n* [x] dev_fetch_api_key\r\n* [ ] dev_list_users\r\n* [ ] fetch_api_key\r\n* [ ] users/me/android_gcm_reg_id\r\n* [ ] users/me/apns_device_token\r\n\r\nAlready documented, I think (unless it's a different method):\r\n* [x] events\r\n* [x] register (Ignoring documentation of the full data format, which is its own issue)\r\n* [x] messages\r\n* [x] messages/${id}\r\n* [x] messages/${messageId}\r\n* [x] users/me/${streamId}/topics\r\n* [x] users/me/subscriptions\r\n* [x] streams\r\n\r\n--------------------------\r\n\r\n"},{"labels":["api",null],"text":"This issue is not fully specified yet, so before you work on it, discuss it on chat.\r\n\r\nThe way our presence system currently works is that we essentially determine somebody's idleness by the lack of activity, which is pretty reasonable for lots of use cases.  It works through a combination of the server sending occasional updates of all recent activity and clients running timers.\r\n\r\nThe situation is still imperfect if I'm running off to a meeting **now**, and the person who wants to talk to me, particularly over PMs, will see my circle green for the next five minutes or so.  (We encourage async conversations in Zulip, but maybe the person who wants to talk to me can just get the answer from another person knowing I'm unavailable.)\r\n\r\nIt would be good to have a server endpoint that explicitly says a user has gone into DND mode or similar actions on the client side.  We may want this to include a time limit, too.\r\n\r\nMore discussion here:\r\n\r\nhttps://chat.zulip.org/#narrow/stream/137-feedback/subject/DND.20Button/near/586001\r\n\r\nOnce this is implemented, we will want to coordinate with mobile/desktop/webapp contributors to build out DND-like features."},{"labels":["api",null],"text":"As an example: searching for `stream:foo` (\"messages in stream 'foo'\") returns all messages in public stream `foo`. Searching for `stream:foo -is:starred` (\"messages in stream 'foo' that I haven't starred\") only returns messages in public stream `foo` that are in the user's history.\r\n\r\nNoticed while looking into #8859 . I don't think this is particularly urgent, but I also don't think it matches user expectations."},{"labels":["api",null,null,null,null],"text":"These show a super-ancient version of the UI:\r\n\r\n![image](https://user-images.githubusercontent.com/2746074/38837624-7bfda3e4-4187-11e8-8cec-38089e69a166.png)\r\n\r\n(There's probably other cleanup that would be valuable on this page)\r\n\r\nWe should make sure the screenshots show sensible examples (e.g. a \"GitHub Bot\" with the GitHub logo as its avatar)"},{"labels":["api",null,null],"text":"@borisyankov helped me discover a subtle bug where `use_first_unread_anchor` and `include_history` don't interact correctly in a situation where the only messages on a topic were before the current user subscribed to that stream.  Basically if you set things up like this:\r\n* Send a single message to a new topic \"test\" to a public stream Hamlet is not subscribed to (\"Denmark\" in this example).\r\n* Subscribe hamlet to that stream\r\n* Do the API query the mobile app does to try to view topic \"test\". (e.g. stream Denmark, topic \"test\", use_first_unread_anchor=True, anchor=0, num_before=25, num_after=25).  Then the API query will return 0 messages (!).  So effectively one sees messages in the webapp, but none appear on mobile.\r\n\r\nHere's how this happens:\r\n* Because `use_first_unread_anchor` is True, we end up going down the non-`include_history` code path in `get_messages_backend` and thus joining with UserMessage.  The user has 0 rows for that topic in UserMessage (since they weren't subscribed when the message was sent), so everything from there on returns no messages.\r\n\r\nWhat we should actually be doing is in `get_messages_backend`:\r\n* The main query should just be on `Message` (i.e. we should get rid of the `and not use_first_unread_anchor` part of the `include_history` line)\r\n* In the `use_first_unread_anchor` code block, we should check `include_history`, and if True, we do the join against UserMessage in constructing `first_unread_query`, since we do need that join for getting the first unread message ID (just not for fetching the messages themselves, i.e. no changes to the main query).  This should require a moderately sized refactor.\r\n* The rest of the code path correctly splits the logic based on whether `include_history` is True (i.e. does a UserMessage query to splice in the `flags` data as needed).\r\n\r\n@showell since you were just in this code, would you be up for tackling this in the next day or so?  Ideally we'd have a fix in before the 1.8 release (aka Monday).\r\n"},{"labels":["api",null,null,null],"text":"Currently, we can't really maintain the data for the PM/mention unread count badges on mobile home screens correct.  While this sounds like a mobile, it's actually a backend issue.\r\n\r\nFor iOS, it's pretty simple: Whenever you send a push notification to the device, you're supposed to include the current count.  This includes sending a push to set the count back to 0 if e.g. the user reads the messages on the web.  We don't have any such \"message read\" trigger, nor do we currently store in the database which message IDs are being treated as home screen unread counts.  \r\n\r\nI think a correct backend implementation would look like this:\r\n* Add a new flag on UserMessage to track push notification counts (warning: the next bit was reclaimed after having been previously used, and so we'll need to have the migration that adds an index for the new flag also 0 the bit).\r\n* When marking messages as read to any of the code paths that do this, check if any of those messages had a push notification unread; if so, trigger a push notification to change the count on the device to the new total as computed by the backend.  This may get a bit complicated; I'd prototype with just doing this in the main `update_message_flags` code path and then we can figure out the structure to ensure we do this everywhere.  \r\n* Hopefully one of the mobile folks can help us figure out what exactly we need to put in `zerver/lib/push_notifications.py` to just update the counts (it might be a super simple event); without that, we can't really do this correctly.\r\n\r\nAndroid may require more complexity (in that they seem to support more incremental behavior).  We should do more research on how apps do this before trying to fix this for Android, in case we need to do something different from the iOS approach.\r\n\r\nTagging this as a priority, since the fact that these counts don't work well is one of the more visible problems with mobile right now.\r\n\r\nWe can divide this project into stages:\r\n* [x] First, add the new flag, called `active_push_notification` on UserMessage, initialized to always 0 (so no expensive migration required)\r\n* [x] Then, add a database index for that new flag so queries against it perform well, similar to `zerver/migrations/0083_index_mentioned_user_messages.py`.  `git grep zerver_usermessage_mentioned_message_id` is instructive.\r\n* [x] Then, add a function to query what messages with the new `active_push_notification` flag are now marked as read after we mark a set of messages as read.  (these are the messages we'd want to notify devices to rescind the push notification for).  We'll need to call this function in the ~4 code paths that set the \"read\" flag on messages.  We should add a pretty good set of unit tests for this.\r\n* [x] Then, add code to set the new flag on UserMessage objects when we send the user a push notification for a given message.  We should add a good set of unit tests for this.\r\n* [x] Then, add code to send the actual updated push notification clearing the unread count, for each of Android and iOS.  For this, we'll need to coordinate with the mobile team on format.  It probably is a good idea to have an initial discuss about formatting of the event, so we can make sure the released mobile app at the time the backend is finished at least ignores the new push notification events.\r\n\r\n"},{"labels":["api",null,null,null],"text":"We just moved our documentation for writing bots into /api in #7392; this lists some CSS bugs \r\n\r\n* [ ] The multi-line bold section here is oddly not wrapped automatically:\r\n![image](https://user-images.githubusercontent.com/2746074/32851853-0b1664fe-c9eb-11e7-8a4d-b7f47eaa2270.png)\r\n* [ ] The pagedown key on /api/writing-bots moves much less than one would expect.\r\n* [ ] This multi-line code block looks wrong:\r\n![image](https://user-images.githubusercontent.com/2746074/32851837-fc989118-c9ea-11e7-889b-6790e5700c8d.png)\r\n* [x] Including a code block in the heading looks wrongs: \r\n![image](https://user-images.githubusercontent.com/2746074/32851917-446dc10c-c9eb-11e7-95e3-9e63ceb8e520.png)\r\n(This one we might want to just fix by changing the text to \"Zulip bots package\".\r\n\r\n"},{"labels":["api",null,null],"text":"The \"Usage\" section of the recently merged new /api site should be expanded to be 1 article per common things users want to do.\r\n\r\nYou can see how to interact with the API correctly in our Python bindings in https://github.com/zulip/python-zulip-api/, specifically under `zulip/zulip/examples/`.  And what you need to generate `curl` examples is in `zproject/urls.py` and the relevant view files; see http://zulip.readthedocs.io/en/latest/writing-views.html for notes on how those work.\r\n\r\nI think the goal should be to add sections for a few really popular things next, maybe using:\r\n* [ ] Split out `call_on_each_event` from the existing \"send message\" docs\r\n* [ ] Subscribe (`subscribe`)\r\n* [ ] Unsubscribe (`unsubscribe`)\r\n* [ ] List users in a Zulip organization (`list-members`)\r\n* [ ] List your subscriptions (`list-subscriptions`)\r\n* [ ] Fetch historical messages (`recent-messages`)\r\n\r\nWhile we work on this, I imagine we'll find we need to add features to the framework.  And possibly reorganze things a bit.\r\n\r\nAlso, I think we'll want to add something linked from `docs/README.md` on how to add documentation for an endpoint.  We can use the examples for the \"zulip-send\" category, which probably should be eventually renamed to something more broad.\r\n\r\nI should also mention the resource we have of Swagger data in `static/swagger/zulip.yaml`.\r\n\r\nAnyone working on this should start with bite-size pieces: Migrate one or two and then get feedback, since I think there will be a lot of little decisions to make on standards."},{"labels":["api",null,null],"text":"This is split out from #6837.  I fixed the first piece of that PR, which was to add sender_ids to the unreads structure.\r\n\r\nWe need this in order to support this future design for the mobile app's unread messages display:\r\n![image](https://user-images.githubusercontent.com/2746074/31213201-3596c8a6-a95a-11e7-8604-e76f48e24499.png)\r\n"},{"labels":["api",null,null],"text":"The \"private messages\" narrow is one of the more common things one clicks on in the Zulip UI.  Right now, it fetches the most recent few hundred private messages from the server, which is often fast, but can be very slow for a user who has been around for a year and has only ever been a participate in 4 private messages (since we effectively end up scanning every message they've received to find these).\r\n\r\nIdeally, we'd just have an index on UserMessage for this, but I'm not sure there's an easy way to get at whether the message.recipient.type is 1 or 3 directly from postgres.  So, probably what we want is to allocate a flag on UserMessage to the purpose, and then make an index on that.\r\n\r\nWhile fixing this requires a migration to update all existing UserMessage rows, it's probably not super expensive to do, and once done, it should be pretty cheap to maintain, since a message never changes between private and not.  \r\n\r\nFixing this would also be quite helpful in supporting #6875, since it would make it quite cheap to produce summary information on the user's last 1000 private messages (for example)."},{"labels":["api",null],"text":"This is related to #6837 but should be a separate issue.\r\n\r\nWhat we need is a new API endpoint, that on 'GET' returns a list that is:\r\n* chronological\r\n* includes all unique PMs and Huddles for the last N months (would 3 months be a good value? we don't need it configurable but it can be)\r\n* includes the last message in each PM and huddle (for preview purposes)\r\n* includes the unread message count (can be 0 as this is not a list of unreads)\r\n"},{"labels":["api",null,null,null],"text":"Currently, our 500 errors for all URLs is sorta a 500 webpage.  For API endpoints, we should try to return something in JSON format (though still with status code 500).  I think this should be possible in most cases by doing something in our middleware.  "},{"labels":["api",null],"text":"There are a few pieces of data that we need for the next version of the mobile app's home screen (some design docs here):\r\n\r\nhttps://paper.dropbox.com/doc/New-Home-Screen-TRkSsVPy6pAOfOlZ0GZOj\r\n\r\n* We need the list of user IDs of senders in the unread messages.  I think this should be an easy extension to the queries we're already doing to fetch messages, so mostly a plumbing project.\r\n* We need the message body details in the `get_messages` format.  I think basically this means implementing the backend for https://github.com/zulip/zulip/issues/4220 and calling it.\r\n\r\nProbably we can put these both behind a flag we pass to `register`, since we don't need that stuff on web."},{"labels":["api",null],"text":"Since the default avatars are gravatar, and the URLs can be simply be computed by the app give the realm and user IDs, we should be able to stop sending the gravatar URLs over the wire.  \r\n\r\nSince the gravatar URLs are based on a hash, they compress poorly, making this particularly valuable from a network performance perspective.  Thus, this could provide significant performance benefits for the mobile app.\r\n\r\nI think we can just make this a quick flag similar to `apply_markdown`.  `/register` is most important, but ideally we'd support both.\r\n\r\nA part 2 to this project would be to convert the webapp to do the same, which would probably shrink the size of what needs to be fetched when reloading Zulip."},{"labels":["api",null,null,null],"text":"Right now, if the server 500s on a JSON request from a client in a way that doesn't return valid JSON, we get this sort of JS exception sent back to the server.  \r\n\r\n```\r\nMessage:\r\nUnexpected token < in JSON at position 0\r\n\r\nStacktrace:\r\nSyntaxError: Unexpected token < in JSON at position 0\r\n    at JSON.parse (<anonymous>)\r\n\r\n    at Object.a.xhr_error_message (static/min/app.f993cb5274ab.js:1331:372)\r\n       = static/js/channel.js line 110 column 27\r\n\r\n    at error (static/min/app.f993cb5274ab.js:2062:742)\r\n       = static/js/reactions.js line 25 column 28\r\n```\r\n\r\nI think we should fix this in 2 ways;\r\n* Make it ~impossible for an invalid-JSON response to come back from `channel.js` (e.g. have a set of 500 error pages for API URLs that are in JSON format), and mostly not change this code.  This probably involves changes to both our `nginx` configuration (for \"unexpected errors\" where Django isn't even running).  And then there's a probably simpler piece of changing `zerver/middleware.py` to handle unexpected exceptions in JSON style API routes at the Django level.\r\n* Make `channel.js` catch this exception and provide a more clear error message for what's happening (perhaps including the invalid JSON it received) in the report, via `blueslip.error` or something.\r\n\r\n\r\n"},{"labels":["api",null,null],"text":"If you call the `get_messages` API with the `use_first_unread_anchor` argument, the server ends up picking the anchor (center) of the batch of messages for you.  Here's the logic:\r\n\r\n```\r\n    if use_first_unread_anchor:                                                                      \r\n        condition = column(\"flags\").op(\"&\")(UserMessage.flags.read.mask) == 0                        \r\n                                                                                                     \r\n        # We exclude messages on muted topics when finding the first unread                          \r\n        # message in this narrow                                                                     \r\n        muting_conditions = exclude_muting_conditions(user_profile, narrow)                          \r\n        if muting_conditions:                                                                        \r\n            condition = and_(condition, *muting_conditions)                                          \r\n                                                                                                     \r\n        # The mobile app uses narrow=[] and use_first_unread_anchor=True to                          \r\n        # determine what messages to show when you first load the app.                               \r\n        # Unfortunately, this means that if you have a years-old unread                              \r\n        # message, the mobile app could get stuck in the past.                                       \r\n        #                                                                                            \r\n        # To fix this, we enforce that the \"first unread anchor\" must be on or                       \r\n        # after the user's current pointer location. Since the pointer                               \r\n        # location refers to the latest the user has read in the home view,                          \r\n        # we'll only apply this logic in the home view (ie, when narrow is                           \r\n        # empty).                                                                                    \r\n        if not narrow:                                                                               \r\n            pointer_condition = inner_msg_id_col >= user_profile.pointer                             \r\n            condition = and_(condition, pointer_condition)                                           \r\n                                                                                                     \r\n        first_unread_query = query.where(condition)                                                  \r\n        first_unread_query = first_unread_query.order_by(inner_msg_id_col.asc()).limit(1)            \r\n        first_unread_result = list(sa_conn.execute(first_unread_query).fetchall())                   \r\n        if len(first_unread_result) > 0:                                                             \r\n            anchor = first_unread_result[0][0]                                                       \r\n        else:                                                                                        \r\n            anchor = LARGER_THAN_MAX_MESSAGE_ID                                                      \r\n```\r\n\r\nIt'd be nice to actually have the server report what anchor it used (rather than needing to compute it on the client side), since that's going to be important for the client.\r\n\r\nI think mostly this involves putting `ret['anchor'] = anchor` in an `if` statement near the end of `get_messages_backend`, and adding tests.\r\n\r\n\r\n"},{"labels":["api",null,null,null],"text":"I think we try to suppress these in `do_rest_call`, but the exception list is clearly not complete.\r\n\r\n```\r\nTraceback (most recent call last):\r\n  File \"/home/zulip/deployments/2017-08-14-16-02-48/zerver/lib/outgoing_webhook.py\", line 192, in do_rest_call\r\n    response = requests.request(http_method, final_url, data=request_data, **request_kwargs)\r\n  File \"/home/zulip/deployments/2017-08-14-16-02-48/zulip-venv/lib/python2.7/site-packages/requests/api.py\", line 58, in request\r\n    return session.request(method=method, url=url, **kwargs)\r\n  File \"/home/zulip/deployments/2017-08-14-16-02-48/zulip-venv/lib/python2.7/site-packages/requests/sessions.py\", line 502, in request\r\n    resp = self.send(prep, **send_kwargs)\r\n  File \"/home/zulip/deployments/2017-08-14-16-02-48/zulip-venv/lib/python2.7/site-packages/requests/sessions.py\", line 612, in send\r\n    r = adapter.send(request, **kwargs)\r\n  File \"/home/zulip/deployments/2017-08-14-16-02-48/zulip-venv/lib/python2.7/site-packages/requests/adapters.py\", line 504, in send\r\n    raise ConnectionError(e, request=request)\r\nConnectionError: HTTPSConnectionPool(host='zulipbotserver.herokuapp.com', port=33507): Max retries exceeded with url: /bots/converter (Caused by NewConnectionError('<urllib3.connection.VerifiedHTTPSConnection object at 0x7fc5ebd84490>: Failed to establish a new connection: [Errno 111] Connection refused',))\r\n```\r\n\r\nThis is a fairly high-priority issue, since it will result in a lot of error email spam to administrators of servers using outgoing webhooks (at least if their users configure them wrong...).\r\n\r\nA secondary issue we should think about after resolving the initial problem is how to send feedback to the user about the fact that their webhook isn't working.  I think it might make sense to have them get a PM from the bot or something notifying them."},{"labels":["api",null,null],"text":"I just got this exception on chat.zulip.org, which I don't think I've seen before:\r\n\r\n```\r\nTraceback (most recent call last):\r\n  File \"/home/zulip/deployments/2017-08-14-16-02-48/zulip-venv/lib/python2.7/site-packages/django/core/handlers/base.py\", line 185, in _get_response\r\n    response = wrapped_callback(request, *callback_args, **callback_kwargs)\r\n  File \"/home/zulip/deployments/2017-08-14-16-02-48/zulip-venv/lib/python2.7/site-packages/django/views/decorators/csrf.py\", line 58, in wrapped_view\r\n    return view_func(*args, **kwargs)\r\n  File \"./zerver/lib/rest.py\", line 123, in rest_dispatch\r\n    return target_function(request, **kwargs)\r\n  File \"/home/zulip/deployments/2017-08-14-16-02-48/zulip-venv/lib/python2.7/site-packages/django/utils/decorators.py\", line 149, in _wrapped_view\r\n    response = view_func(request, *args, **kwargs)\r\n  File \"./zerver/decorator.py\", line 553, in _wrapped_view_func\r\n    return authenticate_log_and_execute_json(request, view_func, *args, **kwargs)\r\n  File \"./zerver/decorator.py\", line 531, in authenticate_log_and_execute_json\r\n    return rate_limit()(view_func)(request, user_profile, *args, **kwargs)\r\n  File \"./zerver/decorator.py\", line 711, in wrapped_func\r\n    return func(request, *args, **kwargs)\r\n  File \"./zerver/lib/request.py\", line 175, in _wrapped_view_func\r\n    return view_func(request, *args, **kwargs)\r\n  File \"./zerver/views/messages.py\", line 1194, in messages_in_narrow_backend\r\n    (message_id, subject, rendered_content, content_matches, subject_matches) = row\r\nValueError: need more than 3 values to unpack\r\n```\r\n\r\nThis happened with a user using the webapp on chat.zulip.org today, the bug is actually triggereable by normal use.\r\n\r\n@showell FYI; reading the code, it's not obvious to me why we're expecting 5 items in each row in the first place.  Note that this is the code path for receiving a new message while narrowing to full-text search."},{"labels":["api",null,null,null],"text":"In the mobile app, we are currently requesting the last 100 PMs to use as 'last conversations you've had'. Since using the `unread_msgs` call, we can have a much lighter (in terms of traffic used) and robust call to get that data.\r\n\r\nWe need:\r\n* a combined list of PMs and Huddles\r\n* include the last message sent to narrow (no html formatting?)\r\n* sorted by timestamp of the last message\r\n* gives us at least all unread PMs and Huddles\r\n* possibly the duration is configurable and possible to go to minimum few months, possibly a year (maybe with 'from' 'to' parameters to get them later, if the data turns to be a lot, or too heavy on the backend)"},{"labels":["api",null,null],"text":"Currently, a user can have a bunch of unread messages that stay that way forever, because thy're on a stream the user isn't subscribed to anymore.  This is probably just wrong, since the user can't really benefit from keeping that state.\r\n\r\nOne question is whether we want this to be limited to the case that the user doesn't immediately unsubscribe (one could do it accidentally), e.g. by using an hourly cron job (maybe using `RealmAuditLog` to figure out which unsubscribes are more than 10 minutes old and need processing).  "},{"labels":["api"],"text":"Some users may have as many as 1M unread messages but still be caught up, because these other unread messages are in muted or even unsubscribed streams/topics.\r\n\r\nWe'll want to probably eliminate the situation of unread messages on muted streams, but for the case of muting, as well as users who just are really far behind, we should limit the `unread_msgs` API's number of messages to look at to something sane like 25K.  Anyone with more unread messages than that probably is in a weird state, and also probably doesn't care about the really old ones.\r\n\r\nSee https://chat.zulip.org/#narrow/stream/backend/subject/unread.20data/near/259338 for some details on a specific case of this issue."},{"labels":["api"],"text":"We are about to have a partial index for unread user messages, and it would be nice to have the expensive bankruptcy codepath use it.\r\n\r\nThis would be a simple, low risk change if there were a dedicated code path for marking messages as read, but right now the backend code (as well as the API) is conflated with starring and mentioning messages.\r\n\r\nThe bankruptcy API is low level and probably over-generalized.  The endpoint is called `/messages/flags`, and it takes a special parameter called `all` that only sensibly applies to unread messages.  You would never want a user to star all of their messages or mark them all as mentioned.  The API also allows you to set flags that are truly internal, like `is_me_message`.\r\n\r\nThe goal of this issue is not to fix every possible flaw in the `/messages/flags` API, but I think it does make sense to break out a special API for marking messages as read, and then only that API would take arguments like \"stream\" and \"all,\" and then we could also grow new features like leaving the last N hours of messages still unread.\r\n\r\nOnce we have a dedicated API for bankruptcy, it should be a fairly simple matter to take advantage of the partial indexes.  In order to use our partial index on unread messages, we do something like this:\r\n\r\n~~~\r\n    user_msgs = UserMessage.objects.filter(\r\n        user_profile=user_profile\r\n    ).extra(\r\n        where=[UserMessage.where_unread()]\r\n    )"},{"labels":["api",null,null,null,null],"text":"We have a few places where we're using a `PUT` HTTP method where the endpoint isn't actually idempotent.  This causes exceptions when things are automatically retransmitted by the browser incorrectly.   The main ones are:\r\n\r\n```\r\n    url(r'^realm/icon$', rest_dispatch,                                                              \r\n        {'PUT': 'zerver.views.realm_icon.upload_icon',                                               \r\n```\r\n\r\n```\r\n    url(r'^realm/emoji/(?P<emoji_name>.*)$', rest_dispatch,                                          \r\n        {'PUT': 'zerver.views.realm_emoji.upload_emoji',                                             \r\n```\r\n\r\n```\r\n    url(r'^users/me/avatar$', rest_dispatch,                                                         \r\n        {'PUT': 'zerver.views.user_settings.set_avatar_backend',                                     \r\n```\r\n\r\n```\r\n    url(r'^users/me/alert_words$', rest_dispatch,                                                    \r\n        {'GET': 'zerver.views.alert_words.list_alert_words',                                         \r\n         'POST': 'zerver.views.alert_words.set_alert_words',                                         \r\n         'PUT': 'zerver.views.alert_words.add_alert_words',                                          \r\n```\r\n\r\n3/4 of these are because we're uploading a file and we should just change to `POST`; the alert_words one is more interesting (but also hasn't been a source of problems yet).  Ideally we'd change them all. \r\n\r\nThe uploads part of this, at least, we should fix soon, since it's easy to do and I don't believe those APIs are in use in any apps (and we'd like to fix this before that changes)."},{"labels":["api",null,null],"text":"In at least a couple of places in the web frontend, we inspect the message text in an error returned by the server. This is a bug, because error message text gets translated -- many error messages may be shown to the user -- so if the user is using Zulip in a language other than English, the condition will fail.\r\n\r\nTwo known examples:\r\n```\r\n$ rg -C2 responseText.*indexOf\r\nstatic/js/server_events.js\r\n189-                // garbage collected, immediately reload.\r\n190-                if ((xhr.status === 400) &&\r\n191:                    (JSON.parse(xhr.responseText).msg.indexOf(\"Bad event queue id\") !== -1)) {\r\n192-                    page_params.event_queue_expired = true;\r\n193-                    reload.initiate({immediate: true,\r\n\r\nstatic/js/channel.js\r\n31-        if (xhr.status === 403) {\r\n32-            try {\r\n33:                if (JSON.parse(xhr.responseText).msg.indexOf(\"CSRF Error:\") !== -1) {\r\n34-                    reload.initiate({immediate: true,\r\n35-                                     save_pointer: true,\r\n```\r\n\r\nThe impact of the first example (\"Bad event queue id\") is that when using Zulip in a language for which we have a translation for the string \"Bad event queue ide: %s\" (e.g., German), if you come back to a tab after being idle for a while, your client persists indefinitely in a half-broken state: you can browse, and even send messages, but you don't get new messages and you have the red \"Unable to connect to Zulip\" (except translated) message at the top of the window.\r\n\r\nThere's nothing correct the frontend can do here; it needs better information from the server. And the server is right to translate the message text. What we should do is also send a numeric error code.\r\n\r\nI think the way I would do this first is\r\n* add an optional field with a name like `error_code` to `JsonableError`;\r\n* start an enum somewhere for values of the error code -- for now this can be duplicated between some code in the backend and the frontend;\r\n* add just a couple of values to that enum, the two we know we need;\r\n* use the new field for these two errors.\r\n\r\nAn ideal solution should have the list of code values and identifier names for them in one place, to be consumed by the backend, the web frontend, and other clients like the mobile and desktop apps. (Probably also the user-facing text for each error, like \"Bad event queue id\".) We should sort that out before rolling this out on a wide scale with tons of different error codes. But given that we have at least one live bug here (probably two), we shouldn't block on that solution before fixing these bugs.\r\n"},{"labels":["api",null],"text":"# Description\r\n\r\nUsing the `/bots` endpoint in the REST API, it's possible to create a bot with an empty username, which results in it having `-bot@<domain>` as the email address.\r\n\r\n# Steps to reproduce\r\n\r\n1. Start the development server.\r\n2. Get an API key for Iago, using the `/dev_fetch_api_key` endpoint:\r\n\r\n        curl -X POST -F 'username=iago@zulip.com' \\\r\n            http://localhost:9991/api/v1/dev_fetch_api_key\r\n\r\n3. Send an HTTP POST request to the `/bots` endpoint, using Basic auth (`iago@zulip.com:<api_key>`), and the following form-data content in the body:\r\n\r\n       full_name: \"Foo\"\r\n       short_name: \"\"\r\n\r\n    For instance, using cURL:\r\n\r\n       curl -X POST -u 'iago@zulip.com:<api_key>' \\\r\n           -F 'full_name=Foo' -F 'short_name=' \\\r\n           http://localhost:9991/api/v1/bots\r\n\r\n4. The server will reply with an HTTP 200 status code (success).\r\n5. The result is a bot with an empty `short_name`, that looks like this in the bot settings UI:\r\n\r\n    ![Bot with empty username](https://user-images.githubusercontent.com/7356565/27352532-59a34794-5601-11e7-8427-b35e4fddfc06.png)\r\n\r\nMeanwhile, the server should reply with an HTTP 400 (bad request), and an error message indicating that the format is invalid:\r\n\r\n    {\"result\":\"error\", \"msg\":\"Bad name or username\"}\r\n\r\n\r\n---\r\n\r\n@zulipbot label \"area: api\" \"bug\"\r\n"},{"labels":["api"],"text":"# Description\r\n\r\nDepending on what endpoint you're querying, the REST API may produce different objects to represent a user.\r\n\r\nHere are a few examples:\r\n\r\n- HTTP POST `api/v1/register`:\r\n\r\n    In the `realm_users` field:\r\n    ```json\r\n    {\r\n      \"user_id\": 3,\r\n      \"is_bot\": false,\r\n      \"avatar_url\": \"https://secure.gravatar.com/avatar/77c3871a68c8d70356156029fd0a4999?d=identicon&version=1\",\r\n      \"is_admin\": false,\r\n      \"full_name\": \"Cordelia Lear\",\r\n      \"timezone\": \"\",\r\n      \"email\": \"cordelia@zulip.com\"\r\n    }\r\n    ```\r\n\r\n    In the `cross_realm_bots` field:\r\n    ```json\r\n    {\r\n      \"is_admin\": false,\r\n      \"user_id\": 24,\r\n      \"email\": \"feedback@zulip.com\",\r\n      \"full_name\": \"Zulip Feedback Bot\",\r\n      \"is_bot\": true\r\n    }\r\n    ```\r\n\r\n- HTTP GET `/api/v1/users`:\r\n\r\n    ```json\r\n    {\r\n      \"user_id\": 24,\r\n      \"is_bot\": true,\r\n      \"is_active\": true,\r\n      \"avatar_url\": \"https://secure.gravatar.com/avatar/78eecc367eedd27e6ac9292dc966beb6?d=identicon&version=1\",\r\n      \"is_admin\": false,\r\n      \"full_name\": \"Zulip Feedback Bot\",\r\n      \"email\": \"feedback@zulip.com\"\r\n    }\r\n    ```\r\n\r\nThis makes it slightly unconsistent and difficult to document, since it makes it hard to use inheritance in these objects.\r\n\r\n# Additional information\r\n\r\nThere are also some bot-specific objects, that may be worth keeping in mind while tackling down this issue. This one is returned by `/register`:\r\n\r\n```json\r\n{\r\n      \"default_all_public_streams\": false,\r\n      \"avatar_url\": \"https://secure.gravatar.com/avatar/78eecc367eedd27e6ac9292dc966beb6?d=identicon&version=1\",\r\n      \"user_id\": 24,\r\n      \"full_name\": \"Zulip Feedback Bot\",\r\n      \"owner\": null,\r\n      \"default_events_register_stream\": null,\r\n      \"api_key\": \"M6Gk2R8LIIuYiXnNIk0z584wU6z78zkr\",\r\n      \"is_active\": true,\r\n      \"email\": \"feedback@zulip.com\",\r\n      \"default_sending_stream\": null\r\n}\r\n```\r\n\r\n---\r\n\r\n@zulipbot label \"area: api\""},{"labels":["api",null],"text":"When a user uses the keyboard navigation keys rapidly (such as the `n` hotkey), the user will receive the following error concerning their excess usage of the API:\r\n```json\r\n{\"msg\":\"API usage exceeded rate limit\",\"retry-after\":0.2033631802,\"result\":\"error\"}\r\n```\r\n\r\nThe default rate limit of the API should be thus increased, or separate API limits for the browser and the API where the browser would have a higher limit.\r\n\r\nSee discussion [here](https://chat.zulip.org/#narrow/stream/backend/topic/error.20connecting.20to.20Zulip) for more context."},{"labels":["api",null],"text":"# Description\r\nThe `dev_fetch_api_key` API endpoint is designed to provide an API key with access to accounts in a development server.\r\n\r\nWhen an invalid user account is provided, the server returns a 500 error and throws the following exception:\r\n\r\n```\r\nFile \"/srv/zulip-venv/local/lib/python2.7/site-packages/django/core/handlers/base.py\", line 185, in _get_response\r\n    response = wrapped_callback(request, *callback_args, **callback_kwargs)\r\n  File \"/srv/zulip-venv/local/lib/python2.7/site-packages/django/views/decorators/csrf.py\", line 58, in wrapped_view\r\n    return view_func(*args, **kwargs)\r\n  File \"/srv/zulip/zerver/decorator.py\", line 118, in wrapper\r\n    return func(request, *args, **kwargs)\r\n  File \"/srv/zulip/zerver/lib/request.py\", line 166, in _wrapped_view_func\r\n    return view_func(request, *args, **kwargs)\r\n  File \"/srv/zulip/zerver/views/auth.py\", line 504, in api_dev_fetch_api_key\r\n    login(request, user_profile)\r\n  File \"/srv/zulip-venv/local/lib/python2.7/site-packages/django/contrib/auth/__init__.py\", line 119, in login\r\n    'You have multiple authentication backends configured and '\r\nValueError: You have multiple authentication backends configured and therefore must provide the `backend` argument or set the `backend` attribute on the user.\r\n```\r\n\r\n# Steps to reproduce\r\n1. Start a development server.\r\n2. Send a POST HTTP request to `localhost:9991/api/v1/dev_fetch_api_key`, with a form-data encoded body containing a key \"username\", which value is \"foo@bar.com\".\r\n3. The result is an HTTP 500 response, with an internal server error. The abovementioned traceback appears in the server's log.\r\n\r\nThe expected result would be a different HTTP code (403, probably), and a descriptive error message, with no exceptions."},{"labels":["api",null,null],"text":"I'm looking at [the python sdk](https://github.com/zulip/zulip/blob/master/api/zulip/__init__.py), and it doesn't look like it [reuses the session](http://docs.python-requests.org/en/master/user/advanced/). I think this means it has to redo the TLS handshake and create a new TCP connection for every request.\r\n\r\n"},{"labels":["api",null,null],"text":"When doing a GET to `/messages` allow optionally to specify which fields the client is interested in, in addition to receiving all by default (the current behavior).\r\n\r\nThis functionality allows the API client some flexibility and enables cases like asking only for most basic information upfront (but for lots of messages) and later request the full message content."},{"labels":["api",null,null],"text":"Currently, a messages 'GET' operation works by specifying `anchor` and `num_before` and `num_after`.\r\n\r\nAllow, in addition to that, to get messages by passing a list of message IDs to the same call (but omitting the anchor, num_before, num_after fields)\r\n\r\nThis enables various scenarios, some not yet conceived."},{"labels":["api",null,null,null],"text":"We recently added `tools/test-api`, which performs basic tests of our API against a local development copy of our server.  It gets run as part of our continuous integration.\r\n\r\nA good project is to find any endpoints that aren't covered and add tests for them.  Also, for the mostly heavily used endpoints (stuff related to sending messages), we may want deeper tests."},{"labels":["api",null,null,null],"text":"Weird one: when I hit the new presence API, I'm getting active users showing as active, idle users showing as idle, and offline users showing as active.\r\n\r\nI cherry-picked three patches onto 1.5.1, so this could be my fault.  I've got 71af0f7e2ebb6162ed507439d2376481b44d0b97, ac8b661a8f45a49b0e4b2173cfd4f6cd05f19d65, and ffc24e9f6622035a4cc70e8062a443453ef042c1 on top."},{"labels":["api",null,null],"text":"These will be helpful for apps that may want to check if the server supports a given feature.\r\n\r\nI think it's already in page_params so that the webapp has it available; we just need to move it down a layer."},{"labels":["api",null],"text":"The API endpoint would return a list of the members of each of the user's `N` most recent private conversations, but not the actual conversations or messages themselves.\r\n\r\nThis would be useful for the mobile apps which aren't able to load a large chunk of messages upfront due to poor network connections."},{"labels":["api",null,null],"text":"(Maybe this exists already and if so, feel free to change this ticket to \"document where this lives better\" :) )\r\n\r\nFor my use case, I want to show the status of a specific member (online, online but away, offline, etc). I want to make a RESTful call to get that status so I can show it elsewhere outside of zulip. \r\n\r\nIt seems like there's a get_members call in the python bindings ( per https://github.com/zulip/zulip/blob/master/api/examples/list-members ), but I want get_member( user@domain.com ) and get a message back like:\r\n\r\n{\r\n 'full_name': 'John Doe',\r\n 'email': 'user@domain.com',\r\n 'presence': 'Online',\r\n 'status': 'Idle',\r\n}"},{"labels":["api",null],"text":"Swagger UI is a front end for REST API documentation. It generates an API reference with live examples using a specification file following the Swagger/OpenAPI format. (A longer description can be found at the linked PR.)\r\n\r\nThere is already a PR, https://github.com/zulip/zulip/pull/3397, this issue is so it is easier to find for folks looking for this in the future, and also to discuss next steps after the initial implementation. The work done in that PR creates a new endpoint where this documentation is visible (`/apidocs/`) and document the /messages endpoint as a first example. \r\n\r\nAfter the initial work is finished, we should talk about how these docs will be accessible within Zulip. Swagger UI not a complete a replacement for the existing `/api/` page, as that also includes information about the python bindings. (It may sufficiently replace the `/api/endpoints/` page however.)\r\n\r\nAdditional endpoint coverage is probably better as individual PRs, or as part of any work that creates new REST endpoints. Separate from this issue/PR, I'll add coverage for an additional endpoint that can be used as an example.\r\n\r\nQuestions to answer:\r\nShould Swagger UI replace an existing doc endpoint? (Like `/api/`)\r\nShould there be a new menu item (or other way of access)?\r\n\r\nLet me know if there are other things that should be addressed."},{"labels":["api",null],"text":"The Python API examples use `generate_option_group` and `init_from_options` to support a common set of options, but (mostly?) hardcode their usage messages. They should ideally display a more complete usage message as well (or instead) that reflects the other options, especially `--config-file` (though others are also occasionally useful, certainly)."},{"labels":["api",null,null],"text":"Right now the Client() constructor accepts parameters (API key, email, site, etc.) through constructor arguments, falling back to values in the config file. It would be convenient to also support getting those parameters (at least API key) through environment variables as well: argument->environment->config or so.\r\n\r\nMy sense is that it's reasonably common for people to stick secrets in environment variables (I know [CircleCI supports this](https://circleci.com/docs/environment-variables/#setting-environment-variables-for-all-commands-without-adding-them-to-git)), and it would be mildly convenient if the API bindings (and thus all the sample code) supported this directly, rather than implementing it in each API consumer.\r\n\r\nThis was [briefly discussed on Zulip](https://zulip.tabbott.net/#narrow/near/130754/stream/bots/topic/.24ZULIP_API_KEY)."},{"labels":["api"],"text":"We can now download zuliprc files for our bots, but often you don't want to create a bot to run the API and prefer to just use your primary account (particularly if you are not sending messages to Zulip).  We should add a download-zuliprc feature for our own user.\r\n\r\npinging @tommyip "},{"labels":["api",null,null],"text":"Currently, Zulip bots are created with an invalid domain of `foo-bot@domain.tld`.  The problem is, we don't own the customer's domain namespace, and so these aren't really valid domains to use.\r\n\r\nIn the REALMS_HAVE_SUBDOMAINS case, there's a great answer, which is that we should use `foo-bot@subdomain.zulip.example.com` as the email addresses, since that's within the domain namespace of the particular realm.  \r\n\r\nWithout subdomains, it's less clear what the best option is, but probably reasonable is to use the same scheme anyway (`@shortname.zulip.example.com`).  \r\n\r\nThe only thing that's tricky here is that if we were support changing subdomains, we'll need to deal with these.  I would probably just open a GitHub issue for supporting subdomain changes, and include dealing with this as one of the things that need to happen (it's a bit messy, because someone else getting the old subdomain may want the bot email addresses, but on the other hand changing the email address will break the existing bots.  Definitely a corner case issue...).\r\n\r\n@rishig this is kinda part of the domains removal project; what do you think of this plan?"},{"labels":["api",null],"text":"When I run `client.call_on_each_message` using our API client, the message dictionary that comes back to me should indicate whether my user (or bot) running the API has been at-mentioned in the message.\r\n\r\nSomewhat relatedly, the client API should make it easy for a client to determine the full name of the user running the API, so that we can avoid code like this:\r\n\r\n```\r\n+        for member in client.get_members()['members']:\r\n +            if member['email'] == client.email:\r\n +                self.bot_name = member['full_name']\r\n +                logging.info('found the bot account name')\r\n +                break\r\n```"},{"labels":["api",null],"text":"```python\r\nclient = zulip.Client(verbose=True)\r\n\r\ndef print_message(msg):\r\n      print(msg)     \r\n\r\n client.call_on_each_message(print_message)\r\n... Hangs forever without printing\r\n```\r\n\r\nThe problem happens in Python 2.7 and Python 3.\r\n\r\nThe credentials are present in `~/.zuliprc` like\r\n\r\n```\r\n[api]\r\nkey=no_secret_found\r\nemail=oh-my-bot@students.hackerschool.com\r\nsite=recurse.zulipchat.com\r\n```\r\nwhereas `call_on_each_event` receives the event message. The Chrome receives all the message but the code never receives any message.\r\n\r\nAm I missing something?"},{"labels":["api"],"text":"`pip intall zulip` for Python 3 fails.\r\n\r\n```python\r\nuser@user-ThinkPad-T400 ~/c/zulip> pip install zulip\r\nCollecting zulip\r\n  Using cached zulip-0.2.4.tar.gz\r\n    Complete output from command python setup.py egg_info:\r\n    Traceback (most recent call last):\r\n      File \"<string>\", line 1, in <module>\r\n      File \"/tmp/pip-build-9bng7ux4/zulip/setup.py\", line 26, in <module>\r\n        version=version(),\r\n      File \"/tmp/pip-build-9bng7ux4/zulip/setup.py\", line 13, in version\r\n        in_handle).next()\r\n    AttributeError: 'itertools.dropwhile' object has no attribute 'next'\r\n    \r\n    ----------------------------------------\r\nCommand \"python setup.py egg_info\" failed with error code 1 in /tmp/pip-build-9bng7ux4/zulip/\r\n```\r\nInstallation candidate in `api` directory works.\r\n\r\n```python\r\nuser@user-ThinkPad-T400 ~/c/z/api> python setup.py develop\r\nrunning develop\r\nrunning egg_info\r\nwriting requirements to zulip.egg-info/requires.txt\r\nwriting dependency_links to zulip.egg-info/dependency_links.txt\r\nwriting zulip.egg-info/PKG-INFO\r\n...\r\nInstalled /home/user/.virtualenvs/zulip-sand-3/lib/python3.5/site-packages/requests-2.12.1-py3.5.egg\r\nFinished processing dependencies for zulip==0.2.5\r\n\r\n```\r\n\r\nAlso PyPI package version is `0.2.4`."},{"labels":["api",null,null],"text":"If you're connected to the server, the server knows your host, your email, and your API key, so it can produce this for you:\r\n\r\n```\r\n[api]\r\nemail=cordelia@zulip.com\r\nkey=wlueAg7cQXqKpUgIaPP3dmF4vibZXal7\r\nsite=http://localhost:9991\r\n```\r\n\r\nThis would cut down a little bit of friction for people setting up their bots/integrations."},{"labels":["api"],"text":"Right now, our only blessed API client bindings/libraries/wrappers are the Python bindings we ship with Zulip core and our [JavaScript library](https://github.com/zulip/zulip-js). The Zulip community has written wrappers and bindings in many different languages. I did a bit of searching and found:\n- [Ruby library - updated 2013](https://github.com/verg/zulip-rb)\n- [Ruby library - also updated 2013](https://github.com/anna2/dude_bot)\n- [EventMachine bindings (Ruby) - updated Nov 2013](https://github.com/cqfd/zulip_machine)\n- [bot library in Go - updated July 2016](https://github.com/ifo/gozulipbot)\n- [Clojure bindings using core.async -updated 2013](https://github.com/thieman/clojure-zulip)\n- [Chicken Scheme wrapper - updated 2014](https://github.com/yamadapc/zulip-scheme)\n- [Node JS bindings - updated February 2015](https://github.com/CodeFridge/node-zulip)\n- [Node client - updated Nov 2013](https://github.com/cqfd/node-zulip)\n- [Angular client - updated January 2016](https://github.com/goodwin332/Zulip-angular)\n- [Zulip Client written in AngularJS using PhoneGap - updated March 2016](https://github.com/web-mi/Zulip-Messenger)\n- [Rust bindings - updated October 2015](https://github.com/mkasprzyk/rust-zulip)\n- [Lua bindings - updated April 2015](https://github.com/deckycoss/zulua)\n- [Perl wrapper - updated October 2014](https://github.com/Stantheman/WebService-Zulip)\n- [Elixir/Erlang client - updated June 2015](https://github.com/my-flow/zulex)\n- [Erlang wrapper - updated Sept 2016](https://github.com/femnad/tuplre)\n- [PHP library - updated October 2015](https://packagist.org/packages/mrferos/zulip-php),\n- [Haskell library - updated January 2016](https://hackage.haskell.org/package/hzulip)\n\nAnd I'm sure I'm missing some.\n\nTo do:\n- [ ] Look through these to see which ones are full-featured and robust as they are, so we can officially recommend them\n- [ ] Bring some of these libraries under the github.com/zulip umbrella\n- [ ] Search for Zulip libraries in other major languages\n- [ ] Invite authors of libraries to zulip.tabbott.net, [the zulip-devel mailing list](https://groups.google.com/forum/#!forum/zulip-devel), and the PyCon sprints, and tell them about http://zulip.readthedocs.io/en/latest/custom-apps.html and Steve's effort to make bots work on the Zulip server\n- [ ] Add documentation to our README encouraging contributors to work on these API client libraries and on new libraries in other languages\n"},{"labels":["api",null],"text":"One the ugliest warts in the Zulip API right now is that fetching the last N messages requires passing a super large integer as the anchor.  @arpith suggested the reasonable solution of making anchor optional, and if it is not specified, having `get_old_messages_backend` just do this for you.  It'd certainly be a lot cleaner API.\n\n@showell do you see any problems with making that API change?  We already effectively support not passing `anchor` in the event that the user passed the `use_first_unread` option (in that we ignore the `anchor` value passed in in that case).\n\nA few notes on executing this:\n- We'd want a check that `num_after` must not be set to a nonzero value in that case\n- We should write fairly careful tests for the relevant validation code in `test_narrow` (there are already a few similar ones related to `user_first_unread`).\n"},{"labels":["api",null,null,null],"text":"It is possible to upload files via the API, and we'd like to document it. There's a test, `test_rest_endpoint` in `zerver/tests/test_upload.py`, that tests this functionality and gives you some guidelines for how it ought to work. It would be great if someone got this working and added example code to `api/examples` for doing this.\n\n(This was added a few weeks ago as part of a project of being able to do end-to-end testing of upload functionality in CI, so the focus wasn't on documenting the feature).\n\nAs you can see in `test_rest_endpoint`:\n\n`result = self.client.post('/api/v1/user_uploads', {'file': fp}, **auth_headers)`\n\nThat `post` method is a feature of the Django `TestCase` class which just does an HTTP post with appropriate authentication headers (via `**auth_headers`) and the file object passed as part of the request. You'll need to replace it with something similar, perhaps using the `requests` library.\n\nFor the API bindings, you'll probably want to do a `Client._register` to add a new function like `Client.upload` that does a `POST` to that URL and has a `make_request` method that does the right thing for `python-requests`.\n\nYour endpoint might be something like `/api/v1/user_uploads`.\n\nPart of #672.\n"},{"labels":["api",null,null],"text":"We should document how to add new bindings to the Zulip Python API bindings, since it's not totally obvious how to do it.  Some notes:\n- Code is under api/zulip/**init**.py\n- You basically just need to write a little `make_request` function (if needed) and call `Client._register` with the right fields, so mostly we just need to document how that works.\n- As part of your contribution, you should write something under `api/examples` that exercises the code to document in the form of code how to use it.\n- (Ideally, if we had #713 done), you'd add a test that runs the script from `api/examples`.\n"},{"labels":["api",null,null,null],"text":"I've been working on an OAuth2 extension to allow Zulip to generate access tokens, allowing clients to call with the Bearer token in the Authorization header. Currently using the django-oauth-toolkit (https://django-oauth-toolkit.readthedocs.org/en/latest/index.html).\n\nThat library provides various ways to hook in the token authorization - hooks into djangorestframework; \"@protected_resource()\" decorator for functional views; and a middleware: \"oauth2_provider.middleware.OAuth2TokenMiddleware\".\n\nNone of these authenticators seem all that compatible with the \"rest_dispatch\" method in zerver/lib/rest.py, particularly due to the Basic auth requirement:\n\n``` python\n...\n        if not request.path.startswith(\"/api\") and request.user.is_authenticated():\n            # Authenticated via sessions framework, only CSRF check needed\n            target_function = csrf_protect(authenticated_json_view(target_function))\n        elif request.META.get('HTTP_AUTHORIZATION', None):\n            # Wrap function with decorator to authenticate the user before\n            # proceeding\n            target_function = authenticated_rest_api_view(target_function)\n        else:\n...\n```\n\nWould you recommend any approach to supporting Oauth or potentially other auths? The best thing I can think of is to add a \"request.user.is_authenticated()\" check to bypass the API authorization, and let the user auth take place in the middleware - Oauth2TokenMiddleware. Any other suggestions?\n"}]