[{"labels":["documentation",null],"text":"Hello there. Sorry for not using the issue template, but I think it is not suitable in this situation.\r\n\r\nI want to ask if there exists detailed documentation about the `@action` decorator. It wasn't easy to find out which arguments I can pass in it. For example, I needed to pass a `serializer_class` inside but found out that I can do it only after searching for issues on Github."},{"labels":["documentation"],"text":"Was fixing a broken link and noticed that the referenced section no longer exists in the schemas docs. \r\n\r\nhttps://github.com/encode/django-rest-framework/blob/9850441e6f58d67f4d533ee144aeef54724ac661/docs/topics/documenting-your-api.md#L224-L225"},{"labels":["documentation"],"text":"https://www.django-rest-framework.org/api-guide/schemas/\r\n\r\nSpecifically the block that describes how to override `AutoSchema` references an undefined method `get_link()`:\r\n\r\n```\r\n    from rest_framework.views import APIView\r\n    from rest_framework.schemas.openapi import AutoSchema\r\n\r\n    class CustomSchema(AutoSchema):\r\n        def get_link(...):\r\n            # Implement custom introspection here (or in other sub-methods)\r\n\r\n    class CustomView(APIView):\r\n        \"\"\"APIView subclass with custom schema introspection.\"\"\"\r\n        schema = CustomSchema()\r\n```"},{"labels":["documentation"],"text":"https://www.django-rest-framework.org/api-guide/versioning/#urlpathversioning \r\n\r\n`URLPathVersioning` and `NamespaceVersioning` examples use [`django.conf.urls`](https://docs.djangoproject.com/en/2.2/ref/urls/#url) implicitly and this function is likely to be deprecated (based on the description in the docs).\r\n\r\nI'm opening this issue because I tried copy pasting the code and got an error and spend a couple minutes googling where to import the old style `url` function from. If we can't replace it with `path` we can at least replace it with `re_path`. Let me know which one should I use and I'll open a PR. "},{"labels":["documentation"],"text":"Without using the X-CSRFToken HTTP header, swagger-ui will trigger CSRF error when sending post requests if Django session auth is being used.\r\nSomething like this worked for me, using `requestInterceptor`:\r\n\r\n```\r\n<body>\r\n\t<div id=\"swagger-ui\"></div>\r\n\t<script src=\"//unpkg.com/swagger-ui-dist@3/swagger-ui-bundle.js\"></script>\r\n\t<script>\r\n\t\tconst ui = SwaggerUIBundle({\r\n\t\t\turl: \"{% url 'schema_url' %}\",\r\n\t\t\tdom_id: '#swagger-ui',\r\n\t\t\tpresets: [\r\n\t\t\t\tSwaggerUIBundle.presets.apis,\r\n\t\t\t\tSwaggerUIBundle.SwaggerUIStandalonePreset\r\n\t\t\t],\r\n\t\t\tlayout: \"BaseLayout\",\r\n\t\t\trequestInterceptor: (req) => {\r\n\t\t\t\treq.headers['X-CSRFToken'] = \"{{csrf_token}}\"\r\n\t\t\t\treturn req;\r\n\t\t\t}\r\n\t\t});\r\n\t</script>\r\n</body>\r\n```"},{"labels":["documentation"],"text":"Jumping to a subsection via the sidenav will sometimes cause the page header to overlap the anchor point. When navigation is working correctly, there's a perceptible flicker/jump, so I'm guessing javascript is being used to calculate the offsets. Looking at mkdocs's docs, this isn't an issue. I'm wondering if this is something that will be fixed by upgrading mkdocs (#6623), or if it's a theme issue.\r\n\r\n![foo](https://user-images.githubusercontent.com/2370209/59729209-39d6c380-91f2-11e9-8871-bcb8d1584dc3.gif)"},{"labels":["documentation"],"text":"Cleaning up our third party packages/docs is something that has been on my mind for a while, and I'd be happy to take a stab at it. First, there are some simple issues that could be addressed:\r\n\r\n- Packages can be found in multiple places - the \"Third Party Packages\" doc (TPP doc), and a similarly named section for most of the API guides. Some packages are listed in both places, some only in one or the other. This is inconsistent and a little confusing - users may not think to check the other location for more potential packages. I'd propose moving all packages into the TPP doc. One doc is easier to maintain than ~15. The API guides could then link to their corresponding sections in the main TPP doc.\r\n- Inconsistent descriptions. The TPP doc itself is pretty consistent - most packages have a brief one to two line description. However, the descriptions in the individual API topics are not. Some are a line or two, some a paragraph, and some even contain basic (and unnecessary) installation/setup instructions. Aside from the inconsistency, descriptions that are significantly larger may come across as carrying an implicit recommendation when this may not be the case. We should cap descriptions at a couple of lines or a single, terse paragraph.\r\n\r\nBeyond that, I'd like to introduce a checklist/process that we can use to both approve new third party packages, as well as to (very occasionally) cull the list of recommended packages. I don't want to be too restrictive, but there are several packages that are no longer compatible, and I don't think it's helpful to point users to them. e.g., packages that haven't been updated in 5+ years<sup>[[1]](https://github.com/juanriaza/django-rest-framework-digestauth)</sup>, packages that have been archived<sup>[[2]](https://github.com/kevin-brown/drf-any-permissions)</sup>, and packages that don't have tests or CI <sup>[[3]](https://github.com/fredkingham/django_rest_model_hyperlink_serializers_project)</sup>. At a minimum, I think we should require that packages meet the following:\r\n- Must have tests & CI.\r\n- Maybe a baseline coverage metric (70-80%)?\r\n- Must be tested against at least one officially supported version of Django.\r\n- Must be tested against a relatively modern version of DRF (released within the last 2-3 years?). This might be implicitly covered by testing against modern Django versions.\r\n\r\nLastly, the [\"How to create a Third Party Package\"](https://www.django-rest-framework.org/community/third-party-packages/#how-to-create-a-third-party-package) section could use some love. The guide is somewhat outdated, but overall, I'd like to cut down on the amount of information present here. Most users are going to be more concerned with what packages are available rather than the process of creating a package. This information could be moved to a separate resource, and I'm thinking we could maintain our own cookiecutter that maintains this kind of tutorial information. "},{"labels":["documentation"],"text":"See https://github.com/encode/django-rest-framework/pull/5886#issuecomment-478789115\r\n\r\nJust opening this to make sure we don't lose track of it.\r\n\r\n\r\n> The docs recommend\r\n>\r\n> \"If you want the date field to be visible, but not editable by the user, then set read_only=True and additionally set a default=... argument.\"\r\n>\r\n> It then says:\r\n>\r\n> \"The field will not be writable to the user, but the default value **will still be passed through to the validated_data**.\"\r\n>\r\n> This is not true. It will **not** be passed through to the validated_data.\r\n\r\n"},{"labels":["documentation"],"text":"## Checklist\r\n\r\n- [x] I have verified that that issue exists against the `master` branch of Django REST framework.\r\n- [x] I have searched for similar issues in both open and closed tickets and cannot find a duplicate.\r\n- [x] This is not a usage question. (Those should be directed to the [discussion group](https://groups.google.com/forum/#!forum/django-rest-framework) instead.)\r\n- [x] This cannot be dealt with as a third party library. (We prefer new functionality to be [in the form of third party libraries](https://www.django-rest-framework.org/community/third-party-packages/#about-third-party-packages) where possible.)\r\n- [x] I have reduced the issue to the simplest possible case.\r\n- [ ] I have included a failing test as a pull request. (If you are unable to do so we can still accept the issue.)\r\n\r\nWhat do you think about documenting internals of the DRF? I've spent quite a lot of time digging in the implementations of different fields/serializers classes to understand what's the information flow between different methods (this is barely covered in the current API documentation). At the end I was satisfied because I got better understanding how thing works under the hood, but it was really time-consuming. What would you think if started working on documenting the internals of DRF?"},{"labels":["documentation"],"text":"## Checklist\r\n\r\n- [x] I have verified that that issue exists against the `master` branch of Django REST framework.\r\n- [x] I have searched for similar issues in both open and closed tickets and cannot find a duplicate.\r\n- [x] This is not a usage question. (Those should be directed to the [discussion group](https://groups.google.com/forum/#!forum/django-rest-framework) instead.)\r\n- [x] This cannot be dealt with as a third party library. (We prefer new functionality to be [in the form of third party libraries](https://www.django-rest-framework.org/topics/third-party-resources/#about-third-party-packages) where possible.)\r\n- [x] I have reduced the issue to the simplest possible case.\r\n- [ ] I have included a failing test as a pull request. (If you are unable to do so we can still accept the issue.)\r\n\r\n## Steps to reproduce\r\n1. Open https://www.django-rest-framework.org/api-guide/filtering/\r\n2. Search for `filter_fields`.\r\n\r\n## Expected behavior\r\nNothing found.\r\n\r\n## Actual behavior\r\nNo nothing found :)\r\n\r\n## More info\r\n[`filter_fields`][1] is deprecated in favor of [`filterset_fields`][2]. At least the following [file][3] is to be updated. It probably makes sense to change `get_filter_fields` method name as well.\r\n\r\n[1]: https://github.com/carltongibson/django-filter/blob/2.0.0/django_filters/views.py#L13-L17\r\n[2]: https://github.com/carltongibson/django-filter/blob/2.0.0/django_filters/rest_framework/backends.py#L52-L57\r\n[3]: https://github.com/encode/django-rest-framework/blob/3.9.1/docs/api-guide/filtering.md"},{"labels":["documentation"],"text":"It would be nice to have some minimal docs linting. e.g., ensure that we enforce tabs/spacing consistency. "},{"labels":["documentation",null,null],"text":"Hi, I just finished the Quickstart & Tutorial of this framework.  I would like to point out that I think the following phrase in Tutorial part 7 is incorrect:\r\n\r\n> If you visit the API root endpoint in a browser you should now see corejson representation become available as an option.\r\n\r\nWith the code you built up just before, corejson is not available on the [root endpoint](https://restframework.herokuapp.com/), but on the [/schema endpoint](https://restframework.herokuapp.com/schema/).\r\n\r\nI also find it unclear that in the Quickstart, the recommendation is to have an app in a subfolder of a Django root app - to avoid name conflicts, as you state - while in the Tutorial you start off with the app folder just being a subfolder of the Django project folder, as though the recommendation wasn't that important at all. I'm still confused, but suppose it then doesn't matter that much how we structure our folders. See also my [Stack Overflow question](https://stackoverflow.com/questions/48624307/must-a-django-rest-framework-app-really-be-a-subfolder-of-the-projects-root-app) about this for more info if this explanation was not very clear.\r\n\r\nCould you fix these issues in the Quickstart & Tutorial? People will have a better learning experience if you do, in my opinion.\r\n\r\nThanks! Kind regards."},{"labels":["documentation"],"text":"## Checklist\r\n\r\n- [X] I have verified that that issue exists against the `master` branch of Django REST framework.\r\n- [X] I have searched for similar issues in both open and closed tickets and cannot find a duplicate.\r\n- [X] This is not a usage question. (Those should be directed to the [discussion group](https://groups.google.com/forum/#!forum/django-rest-framework) instead.)\r\n- [X] This cannot be dealt with as a third party library. (We prefer new functionality to be [in the form of third party libraries](http://www.django-rest-framework.org/topics/third-party-resources/#about-third-party-packages) where possible.)\r\n- [X] I have reduced the issue to the simplest possible case.\r\n- [ ] I have included a failing test as a pull request. (If you are unable to do so we can still accept the issue.)\r\n\r\n## Steps to reproduce\r\n\r\nHere is a very minimal, vanilla app, `test_simple`.\r\n\r\n```\r\n# models.py\r\nimport uuid\r\nfrom django.db import models\r\nclass Entity(models.Model):\r\n    id = models.UUIDField(primary_key=True, default=uuid.uuid4)\r\n\r\n# serializers.py\r\nfrom rest_framework import serializers\r\nfrom test_simple import models\r\nclass EntitySerializer(serializers.ModelSerializer):\r\n    class Meta:\r\n        model = models.Entity\r\n        fields = ('id',)\r\n        extra_kwargs = {'id': {'read_only': True}}\r\n\r\n# views.py\r\nfrom rest_framework import viewsets\r\nfrom test_simple import models, serializers\r\nclass EntityViewSet(viewsets.ModelViewSet):\r\n    serializer_class = serializers.EntitySerializer\r\n    queryset = models.Entity.objects.all()\r\n    def perform_create(self, serializer):\r\n        # When it fails, it fails here\r\n        # With Postgres, it fails with `django.db.utils.InterfaceError: connection already closed`\r\n        # With MySQL, it fails with `django.db.transaction.TransactionManagementError: An error occurred in the current transaction. You can't execute queries until the end of the 'atomic' block.`\r\n        # With SQLite, it succeeds\r\n        return super().perform_create(serializer)\r\n```\r\n\r\nHere are some very simple, vanilla tests on the app.\r\n```\r\nfrom rest_framework.test import APITestCase, APIClient, RequestsClient\r\nclass Test(APITestCase):\r\n    def test_api_client(self):\r\n        client = APIClient()\r\n        response = client.post('/entities/')\r\n        self.assertEqual(response.status_code, 201)\r\n    def test_requests_client(self):\r\n        client = RequestsClient()\r\n        response = client.post('http://testserver/entities/')\r\n        self.assertEqual(response.status_code, 201)\r\n```\r\n\r\nAside from using different databases as explained below, no settings have been modified -- no authentication, permissioning, etc.\r\n\r\n## Expected behavior\r\n\r\nI would expect both tests to pass regardless of the database being used.\r\n\r\n## Actual behavior\r\n\r\nWhen I use SQLite, as per below, both tests pass:\r\n```\r\nDATABASES = {\r\n    'default': {\r\n        'ENGINE': 'django.db.backends.sqlite3',\r\n        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),\r\n    }\r\n}\r\n```\r\n\r\nHowever, when I use Postgres or MySQL as per below, the `APIClient` test passes but the test using `RequestClient` fails as noted in the inline comment under `perform_create` above:\r\n```\r\nDATABASES = {\r\n    'default': {\r\n        'ENGINE': 'django.db.backends.mysql',\r\n        'NAME': 'test',\r\n        'USER': 'test_user',\r\n        'PASSWORD': 'XXXXX',\r\n        'HOST': '',\r\n        'PORT': '',\r\n        'OPTIONS': {\r\n           'init_command': 'SET default_storage_engine=INNODB',\r\n        }\r\n    }\r\n}\r\n\r\nDATABASES = {\r\n    'default': {\r\n        'ENGINE': 'django.db.backends.postgresql_psycopg2',\r\n        'NAME': 'test',\r\n        'USER': 'test_user',\r\n        'PASSWORD': 'XXXXX', \r\n        'HOST': '',\r\n        'PORT': '',\r\n    }\r\n}\r\n```\r\nIn the failing cases, it does successfully connect to the database and build the tables -- and the `APIClient` test passes -- so it does not appear to be a connection problem.\r\n\r\nI don't believe it's user error, because both tests pass with SQLite.\r\n\r\n## Version Info\r\n\r\nTested with:\r\n- REST Framework 3.7.1 and 3.7.7\r\n- Windows 10, Version 1709\r\n- Django 1.11.6 and 1.11.9\r\n- Postgres 10.1\r\n- MySQL 5.7\r\n\r\n"},{"labels":["documentation"],"text":"## Checklist\r\n\r\nI have verified that that issue exists against the master branch of Django REST framework.\r\nI have searched for similar issues in both open and closed tickets and cannot find a duplicate.\r\n\r\n## Steps to reproduce\r\n\r\nMissing details in API documentation: schemas\r\n\r\nhttps://github.com/encode/django-rest-framework/blob/master/docs/api-guide/schemas.md#get_manual_fieldsself-path-method\r\n\r\n```\r\ndef get_manual_fields(self, path, method):\r\n    \"\"\"Example adding per-method fields.\"\"\"\r\n\r\n    extra_fields = []\r\n    if method=='GET':\r\n        extra_fields = # ... list of extra fields for GET ...\r\n    if method=='POST':\r\n        extra_fields = # ... list of extra fields for POST ...\r\n\r\n    manual_fields = super().get_manual_fields()\r\n    return manual_fields + extra_fields\r\n```\r\n\r\nmanual_fields should be\r\n```\r\nmanual_fields = super().get_manual_fields(path, method)\r\n```\r\n\r\nThe problem seems to be only documentation related."},{"labels":["documentation"],"text":"## Checklist\r\n\r\n- [x] I have verified that that issue exists against the `master` branch of Django REST framework.\r\n- [x] I have searched for similar issues in both open and closed tickets and cannot find a duplicate.\r\n- [x] This is not a usage question. (Those should be directed to the [discussion group](https://groups.google.com/forum/#!forum/django-rest-framework) instead.)\r\n- [ ] This cannot be dealt with as a third party library. (We prefer new functionality to be [in the form of third party libraries](http://www.django-rest-framework.org/topics/third-party-resources/#about-third-party-packages) where possible.)\r\n- [x] I have reduced the issue to the simplest possible case.\r\n- [ ] I have included a failing test as a pull request. (If you are unable to do so we can still accept the issue.)\r\n\r\n## Steps to reproduce\r\n1. create a simple model `models.py`\r\n```python\r\nfrom django.db import models\r\n\r\n\r\nclass TestModel(models.Model):\r\n    flag = models.BooleanField()\r\n    integer = models.IntegerField()\r\n\r\n```\r\n2. create a simple serializer `serializers.py`\r\n```python\r\nfrom rest_framework import serializers\r\nfrom .models import TestModel\r\n\r\n\r\nclass TestSerializer(serializers.ModelSerializer):\r\n\r\n    class Meta:\r\n        model = TestModel\r\n        fields = 'flag', 'integer'\r\n```\r\n\r\n3. run these commands in django shell\r\n```python\r\nfrom <app-name>.models import TestModel\r\nfrom <app-name>.serializers import TestSerializer\r\n\r\nserializer = TestSerializer()\r\nprint(repr(serializer))\r\n```\r\nit shows:\r\n```python\r\nTestSerializer():\r\n    flag = BooleanField(required=False)\r\n    integer = IntegerField()\r\n```\r\n\r\n## Expected behavior\r\nI am expecting `flag = BooleanField()`\r\n\r\n## Actual behavior\r\n`flag` is set to `required=False`."},{"labels":["documentation"],"text":"## Checklist\r\n\r\n- [x] I have verified that that issue exists against the `master` branch of Django REST framework.\r\n- [x] I have searched for similar issues in both open and closed tickets and cannot find a duplicate.\r\n- [x] This is not a usage question. (Those should be directed to the [discussion group](https://groups.google.com/forum/#!forum/django-rest-framework) instead.)\r\n- [x] This cannot be dealt with as a third party library. (We prefer new functionality to be [in the form of third party libraries](http://www.django-rest-framework.org/topics/third-party-resources/#about-third-party-packages) where possible.)\r\n- [x] I have reduced the issue to the simplest possible case.\r\n- [ ] I have included a failing test as a pull request. (If you are unable to do so we can still accept the issue.)\r\n\r\n## Steps to reproduce\r\nWith new changes to django.core.urlresolvers (1.11.7) -> django.urls (2.0): as per [the instructions](http://www.django-rest-framework.org/api-guide/routers/#using-include-with-routers) :\r\nRegister a router\r\n`router = DefaultRouter()`\r\nRegister a viewset with the router\r\n`router.register('foo', FooViewSet, base_name='foo')`\r\nAdd the url patterns:\r\n`urlpatterns += [ url('API/', include(router.urls, namespace='foo-api'), ]`\r\n\r\n## Expected behavior\r\nurlpatterns now contains the foo API url patterns, accessible using the namespace if needing to get the url string with `django.urls.reverse`\r\n\r\n## Actual behavior\r\n\r\n> django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.\r\n\r\nIs the router providing the `app_name`? If so, the documentation needs updating with the right syntax for including router url patterns. Otherwise, the router itself needs updating."},{"labels":["documentation"],"text":"Righty - I'm going to work this into a pull request shortly, but want to start getting it up for review quickly.\r\n\r\nWe need to draw up a post giving a retrospect of the impact that the MOSS award has had on the project. This is super important, as it will help Mozilla continue to make the business case for their award program, which has a huge knock-on effect on other open source projects.\r\n\r\nHere's what I've got so far. Will be working on this more over the rest of the day and weekend...\r\n\r\n---\r\n\r\n# Mozilla Award - A Retrospective.\r\n\r\n## Background\r\n\r\nIn summer 2016 the Django REST framework project [was awarded $50,000 from Mozilla](https://blog.mozilla.org/blog/2016/04/13/mozilla-open-source-support-moss-update-q1-2016/), through its ongoing MOSS program.\r\n\r\nThe project was already well-established, but the scope of the framework and the size of our userbase meant that it was becoming unsustainable to continue to push the project forward without a significant amount of funded time being made available.\r\n\r\nOur proposal included adding client libraries, improving support for API schema generation, and improved integration with WebSockets, for realtime API endpoints.\r\n\r\n## Work to date\r\n\r\nOver 2016 and 2017 the award has helped fund time from Tom Christie, Anna Ossowski, and Carlton Gibson. Together with the project's other contributors, we've been able to make a series of major releases from 3.4 through to 3.7.\r\n\r\nMajor functionality we've added in that period has included:\r\n\r\n* Python client library.\r\n* JavaScript client library.\r\n* Command line client.\r\n* Integrated schema support. (Swagger, RAML, CoreJSON)\r\n* New test client.\r\n* Interactive API documentation.\r\n\r\nThere has also been work not on REST framework itself, but in the surrounding ecosystem.\r\n\r\nTom has been able to help navigate the \"Simplified URL routing syntax\" feature into Django 2.0, alongside a number of other contributors.\r\n\r\nThere has been work around async and realtime, although not yet directly in REST framework itself. This has included developing [a new Python webserver, with an ASGI-like asyncio interface](https://github.com/encode/uvicorn), as well as significant exploratory work towards [a new API framework](https://github.com/encode/apistar).\r\n\r\nOver the last 18 months we've been closing incoming issues and pull requests at a sustained rate of [around 80 issues/month](https://github.com/encode/django-rest-framework/issues?utf8=%E2%9C%93&q=state%3Aclosed+created%3A%3E2016-06-01+).  \r\n\r\nWe've gone from standing at around 210 open issues and pull requests at the start of the period, to being at  around 110 to date.\r\n\r\n## Sustainability\r\n\r\nThe Mozilla Award has also been a foundational part of allowing us to launch an ongoing, sustainable business model behind the project. Having a significant amount of runway funding meant that Tom Christie was in a position to leave full-time employment, and launch a sponsorship model for funding REST framework.\r\n\r\nThe result of this is that although the MOSS funding is now exhausted, the project still has money in the bank, and a decent amount of monthly recurring revenue.\r\n\r\nWe're aiming to keep our finances transparent through our monthly reports.\r\n\r\nAs a rough guide we are currently at around £5,500 monthly recurring revenue. Against this Tom draws a salary of £60k/year. Together with short amounts of freelancing we've also been in a position to take on freelance work from both Anna Ossowski (Fundraising & Operations), and Carlton Gibson (Triage & Feature Work).\r\n\r\n## Impact\r\n\r\nThere are now around [100 third party packages](https://djangopackages.org/grids/g/django-rest-framework/) available for use with REST framework, and we've had over [700 contributors](https://github.com/encode/django-rest-framework/graphs/contributors) to date.\r\n\r\nWe'd currently estimate something like 100,000 monthly active developers working with the framework, supporting perhaps some tens of thousands of companies, and certainly impacting many millions of end-users.\r\n\r\nA project supporting this many developers and companies cannot realistically operate without dedicated working hours towards its support. We wouldn't be in such a strong position without the MOSS award giving us enough runway to be able to launch our sponsorship model.\r\n\r\n## What's next\r\n\r\n[TODO]\r\n\r\n[TODO - Call to action]"},{"labels":["documentation"],"text":"## Checklist\r\n\r\n- [ x ] I have verified that that issue exists against the `master` branch of Django REST framework.\r\n- [ x ] I have searched for similar issues in both open and closed tickets and cannot find a duplicate.\r\n- [ x ] This is not a usage question. (Those should be directed to the [discussion group](https://groups.google.com/forum/#!forum/django-rest-framework) instead.)\r\n- [ x ] This cannot be dealt with as a third party library. (We prefer new functionality to be [in the form of third party libraries](http://www.django-rest-framework.org/topics/third-party-resources/#about-third-party-packages) where possible.)\r\n- [ x ] I have reduced the issue to the simplest possible case.\r\n- [ ] I have included a failing test as a pull request. (If you are unable to do so we can still accept the issue.)\r\n\r\n## Steps to reproduce\r\nCreate a simple ViewSet with a detail route with method name `dispatch`\r\n\r\n```\r\nclass TestViewSet(ModelViewSet):\r\n    queryset = Test.objects.all()\r\n    serializer_class = serializers.TestSerializer\r\n    filter_class = filters.TestFilter\r\n\r\n    @detail_route(url_path='dispatch', methods=['post'])\r\n    def dispatch(self, request, pk=None):\r\n\r\n        return Response(\"hello\", status=status.HTTP_200_ACCEPTED)\r\n```\r\n\r\n## Expected behavior\r\nNot really sure here as it is colliding with the dispatch method under the hood of DFR\r\n\r\n## Actual behavior\r\nThe DRF router exhibits very odd behavior but does not function in any useful manor. It looks like the base path for the ViewSet is lost so all requests result in a 404.\r\n\r\nI am not entirely sure what is going on but I can speculate that the detail route method is overlapping with the detail route method of the base ViewSet class. After looking deeper into DRF I understand why this is probably happening and why it probably can't easily be fixed. However, I think it would be fair to document this to say that a detail route method name should _not_ be named `dispatch`.\r\n"},{"labels":["documentation"],"text":"## Steps to reproduce\r\nIn django 1.10+, when coding the `urls.py` of the project file with the function `format_suffix_patterns`, an exception may occurred when dealing with the urlpatterns in a particular order.\r\n\r\nthis is the code of urls.py\r\n\r\n```\r\nurlpatterns = [\r\n    url(r'^admin/', admin.site.urls),\r\n    url(r'^zufang/', zufang_views.RentingRecords.as_view()),\r\n    url(r'^ershou/', ershou_views.UsedItems.as_view()),\r\n    url(r'^shunfengche/', include('shunfengche.urls', namespace='shunfengche')),\r\n    url(r'^yp/', include('yellowpage.urls', namespace='yellowpage')),\r\n    url(r'^bugs/', sfc_views.bugs), \r\n] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)\r\n\r\n\r\nurlpatterns = format_suffix_patterns(urlpatterns)\r\nurlpatterns.append(url(r'^users/', include('users.urls')))\r\nurlpatterns.append(url(r'^courses/', include('courses.urls')))\r\nurlpatterns.append(url(r'^official/', include('official.urls')))\r\nurlpatterns.append(url(r'^', include('official.urls')))\r\n```\r\nwhen moving the formatting function to the bottom, like this:\r\n\r\n```\r\nurlpatterns.append(url(r'^users/', include('users.urls')))\r\nurlpatterns.append(url(r'^courses/', include('courses.urls')))\r\nurlpatterns.append(url(r'^official/', include('official.urls')))\r\nurlpatterns.append(url(r'^', include('official.urls')))\r\nurlpatterns = format_suffix_patterns(urlpatterns)\r\n\r\n```\r\n## Expected behavior\r\nIt was expected to be the same or throw an exception that is not confusing \r\n## Actual behavior\r\ndjango throws two exceptions when performing the system checks\r\n\r\n>Django version 1.11.2, using settings 'app.settings'\r\nStarting development server at http://127.0.0.1:8000/\r\nQuit the server with CONTROL-C.\r\nPerforming system checks...\r\n\r\n>Unhandled exception in thread started by <function check_errors.<locals>.wrapper at 0x7f282956d0d0>\r\nTraceback (most recent call last):\r\n  File \"/root/pyenv/lib/python3.5/site-packages/django/urls/resolvers.py\", line 105, in _compile\r\n    return re.compile(regex, re.UNICODE)\r\n  File \"/root/pyenv/lib/python3.5/re.py\", line 224, in compile\r\n    return _compile(pattern, flags)\r\n  File \"/root/pyenv/lib/python3.5/re.py\", line 293, in _compile\r\n    p = sre_compile.compile(pattern, flags)\r\n  File \"/root/pyenv/lib/python3.5/sre_compile.py\", line 536, in compile\r\n    p = sre_parse.parse(p, flags)\r\n  File \"/root/pyenv/lib/python3.5/sre_parse.py\", line 829, in parse\r\n    p = _parse_sub(source, pattern, 0)\r\n  File \"/root/pyenv/lib/python3.5/sre_parse.py\", line 437, in _parse_sub\r\n    itemsappend(_parse(source, state))\r\n  File \"/root/pyenv/lib/python3.5/sre_parse.py\", line 774, in _parse\r\n    raise source.error(err.msg, len(name) + 1) from None\r\nsre_constants.error: redefinition of group name 'format' as group 2; was group 1 at position 32\r\n\r\n>During handling of the above exception, another exception occurred:\r\n\r\n>Traceback (most recent call last):\r\n  File \"/root/pyenv/lib/python3.5/site-packages/django/utils/autoreload.py\", line 227, in wrapper\r\n    fn(*args, **kwargs)\r\n  File \"/root/pyenv/lib/python3.5/site-packages/django/core/management/commands/runserver.py\", line 125, in inner_run\r\n    self.check(display_num_errors=True)\r\n  File \"/root/pyenv/lib/python3.5/site-packages/django/core/management/base.py\", line 359, in check\r\n    include_deployment_checks=include_deployment_checks,\r\n  File \"/root/pyenv/lib/python3.5/site-packages/django/core/management/base.py\", line 346, in _run_checks\r\n    return checks.run_checks(**kwargs)\r\n  File \"/root/pyenv/lib/python3.5/site-packages/django/core/checks/registry.py\", line 81, in run_checks\r\n    new_errors = check(app_configs=app_configs)\r\n  File \"/root/pyenv/lib/python3.5/site-packages/django/core/checks/urls.py\", line 16, in check_url_config\r\n    return check_resolver(resolver)\r\n  File \"/root/pyenv/lib/python3.5/site-packages/django/core/checks/urls.py\", line 26, in check_resolver\r\n    return check_method()\r\n  File \"/root/pyenv/lib/python3.5/site-packages/django/urls/resolvers.py\", line 255, in check\r\n    warnings.extend(check_resolver(pattern))\r\n  File \"/root/pyenv/lib/python3.5/site-packages/django/core/checks/urls.py\", line 26, in check_resolver\r\n    return check_method()\r\n  File \"/root/pyenv/lib/python3.5/site-packages/django/urls/resolvers.py\", line 255, in check\r\n    warnings.extend(check_resolver(pattern))\r\n  File \"/root/pyenv/lib/python3.5/site-packages/django/core/checks/urls.py\", line 26, in check_resolver\r\n    return check_method()\r\n  File \"/root/pyenv/lib/python3.5/site-packages/django/urls/resolvers.py\", line 172, in check\r\n    warnings = self._check_pattern_startswith_slash()\r\n  File \"/root/pyenv/lib/python3.5/site-packages/django/urls/resolvers.py\", line 140, in _check_pattern_startswith_slash\r\n    regex_pattern = self.regex.pattern\r\n  File \"/root/pyenv/lib/python3.5/site-packages/django/urls/resolvers.py\", line 93, in __get__\r\n    instance.__dict__['regex'] = self._compile(instance._regex)\r\n  File \"/root/pyenv/lib/python3.5/site-packages/django/urls/resolvers.py\", line 109, in _compile\r\n    (regex, six.text_type(e))\r\ndjango.core.exceptions.ImproperlyConfigured: \"^\\.(?P<format>[a-z0-9]+)/?\\.(?P<format>[a-z0-9]+)/?$\" is not a valid regular expression: redefinition of group name 'format' as group 2; was group 1 at position 32"},{"labels":["documentation",null],"text":"In preparing #5448 I noted that `documentation.py` is essentially undocumented. There is a basic usage example for `include_docs_urls` in the Documenting your API topic page, but that's it. \r\n\r\nWe need documentation for the three functions: \r\n\r\n* `include_docs_urls`\r\n* `get_schemajs_view`\r\n* `get_docs_view`\r\n\r\nThis would help users wanting to customise the defaults here. "},{"labels":["documentation"],"text":"I would like to add a highlevel perspective in the quickstart.\r\n\r\nhttp://www.django-rest-framework.org/tutorial/quickstart/\r\n\r\nI would like to define terms and steps. I am not a native speaker, I guess this could get improved a lot.\r\n\r\n**GET Request**\r\n\r\n1. client sends a GET request to the DRF application\r\n1. A **Serializer** uses the Django ORM and transforms it to ?????? (here I am missing the matching term)\r\n1. A **Renderer** takes ?????? and converts it to a bytestring. This can be JSON, YAML, XML, Protocol Buffers, ...\r\n1. The bytestring gets send to the client as response\r\n\r\n**POST Request**\r\n\r\n1. client sends a POST request to the DRF application. The bytestring in the request can be JSON, YAML, ...\r\n1. A **Parser** takes the bytestring and transforms it to ??????. \r\n1. ?????? gets mapped to a Django Model using a **Deserizalizer**\r\n1. The data gets saved\r\n1. A response gets send to the client.\r\n\r\nMy goal is to speed up new developers and to make them  understand how DRF works quicker.\r\n\r\nWhat do you think?\r\n\r\nIt would be great if there are places in the docs where the terms Serializer, Renderer, Parser gets explained. \r\n\r\nI know, for you (the experts) it is all clear :-)\r\n"},{"labels":["documentation"],"text":"## Checklist\r\n\r\n- [X] I have verified that that issue exists against the `master` branch of Django REST framework.\r\n- [X] I have searched for similar issues in both open and closed tickets and cannot find a duplicate.\r\n- [X] This is not a usage question. (Those should be directed to the [discussion group](https://groups.google.com/forum/#!forum/django-rest-framework) instead.)\r\n- [X] This cannot be dealt with as a third party library. (We prefer new functionality to be [in the form of third party libraries](http://www.django-rest-framework.org/topics/third-party-resources/#about-third-party-packages) where possible.)\r\n- [X] I have reduced the issue to the simplest possible case.\r\n- [ ] I have included a failing test as a pull request. (If you are unable to do so we can still accept the issue.)\r\n\r\n## Short Version\r\n\r\nCan we please add the information in [3.0 Announcement](http://www.django-rest-framework.org/topics/3.0-announcement/#removal-of-transform_field_name) about the use of `to_representation` on serializers __classes__ (cf. _Removal of Transform Field_) to the docs to help better explain how to change the representation of fields in ModelSerializers?\r\n\r\n(Sorry about the non-standard format for the issue text, just made more sense this way given that it's a documentation suggestion (feature/functionality is great!)\r\n\r\nI can do up a pull request which just moves the information in the _3.0 Announcement_ into `serializers.md` (probably into [override-serialization-and-deserialization-behaviour](http://www.django-rest-framework.org/api-guide/serializers/#overriding-serialization-and-deserialization-behavior)) if that suits?\r\n## Long Version\r\n\r\nOutcome desired was to have a related field (i.e. `ForeignKey`) on a `ModelSerializer` that was writable by passing the `pk`, but returned a nested representation. For example:\r\n\r\n```\r\nclass ExampleModel(models.Model):\r\n    user = models.ForeignKey(User)\r\n    ...\r\n\r\nclass ExampleUserSerializer(serializers.ModelSerializer):\r\n    class Meta:\r\n        model = User\r\n        fields = [\"username\", \"email\", ... ]\r\n\r\n\r\nclass TestSerializer(serializers.ModelSerializer):\r\n    class Meta:\r\n        model = ExampleModel\r\n        fields = [\"user\",]`\r\n```\r\n\r\nProblem I struggled with was changing the representation to use the nested `ExampleUserSerializer`, but to accept write input to `TestSerializer` with just the User's `pk`. For example, you could update the `user` on `ExampleModel` by sending a request with:\r\n    \r\n    {\"user\": 3}\r\n\r\nAnd get back the updated `ExampleModel` as:\r\n\r\n    {\"username\": \"myusername\", \"email\": \"me@world.com\", ...}\r\n\r\nWorked it out by adding a `to_representation` method on the `TestSerializer` (etc.) by referring to the bit about _\"Removal of Transform Field\"_ in [3.0 Announcement](http://www.django-rest-framework.org/topics/3.0-announcement/#removal-of-transform_field_name). Found _some_ information about this at [override-serialization-and-deserialization-behaviour](http://www.django-rest-framework.org/api-guide/serializers/#overriding-serialization-and-deserialization-behavior), but the example in the _3.0 Announcement_ just made it so much clearer."},{"labels":["documentation"],"text":"## Checklist\r\n\r\n- [x] I have verified that that issue exists against the `master` branch of Django REST framework.\r\n- [x] I have searched for similar issues in both open and closed tickets and cannot find a duplicate.\r\n- [x] This is not a usage question. (Those should be directed to the [discussion group](https://groups.google.com/forum/#!forum/django-rest-framework) instead.)\r\n- [x] This cannot be dealt with as a third party library. (We prefer new functionality to be [in the form of third party libraries](http://www.django-rest-framework.org/topics/third-party-resources/#about-third-party-packages) where possible.)\r\n- [x] I have reduced the issue to the simplest possible case.\r\n- [ ] I have included a failing test as a pull request. (If you are unable to do so we can still accept the issue.)\r\n\r\n## Steps to reproduce\r\nListField [signature in docs](http://www.django-rest-framework.org/api-guide/fields/#listfield) is misleading. It implies that `child` argument can be passed as positional arg. However `ListField.__init__` [pops `child` from kwargs](https://github.com/encode/django-rest-framework/blob/master/rest_framework/fields.py#L1525).\r\n```\r\n>>> from rest_framework.fields import ListField, CharField\r\n>>> ListField(CharField()).child\r\n```\r\n## Expected behavior\r\n```\r\nCharField()\r\n```\r\n## Actual behavior\r\n```\r\n_UnvalidatedField()\r\n```"},{"labels":["documentation",null],"text":"## Checklist\r\n\r\n- [x] I have verified that that issue exists against the `master` branch of Django REST framework.\r\n- [x] I have searched for similar issues in both open and closed tickets and cannot find a duplicate.\r\n- [x] This is not a usage question. (Those should be directed to the [discussion group](https://groups.google.com/forum/#!forum/django-rest-framework) instead.)\r\n- [x] This cannot be dealt with as a third party library. (We prefer new functionality to be [in the form of third party libraries](http://www.django-rest-framework.org/topics/third-party-resources/#about-third-party-packages) where possible.)\r\n- [] I have reduced the issue to the simplest possible case.\r\n- [] I have included a failing test as a pull request. (If you are unable to do so we can still accept the issue.)\r\n\r\n## Steps to reproduce\r\n1. create api viewset and try to access `self.request`.\r\n2. integrate docs endpoint as described in [docs](http://www.django-rest-framework.org/topics/3.6-announcement/#interactive-api-documentation)\r\n3. hit the docs endpoint in browser\r\n## Expected behavior\r\nAPI docs page should render\r\n\r\n## Actual behavior\r\nError `'NoneType' object has no attribute 'user'`  \r\n[traceback](http://dpaste.com/1Y6MRAB)  \r\n`self.request` is `None`\r\n"},{"labels":["documentation"],"text":"## Checklist\r\n\r\n- [x] I have verified that that issue exists against the `master` branch of Django REST framework.\r\n- [x] I have searched for similar issues in both open and closed tickets and cannot find a duplicate.\r\n- [x] This is not a usage question. (Those should be directed to the [discussion group](https://groups.google.com/forum/#!forum/django-rest-framework) instead.)\r\n- [x] This cannot be dealt with as a third party library. (We prefer new functionality to be [in the form of third party libraries](http://www.django-rest-framework.org/topics/third-party-resources/#about-third-party-packages) where possible.)\r\n- [x] I have reduced the issue to the simplest possible case.\r\n- [x] I have included a failing test as a pull request. (If you are unable to do so we can still accept the issue.)\r\n\r\n## Steps to reproduce\r\n1. Go to:  http://www.django-rest-framework.org/tutorial/1-serialization/\r\n2. See third paragraph that starts with:\r\nNote: The code for this tutorial is available in the tomchristie/rest-framework-tutorial repository on GitHub\r\n3. Click the link:   tomchristie/rest-framework-tutorial \r\n4. It tries to go to:  https://github.com/encode/rest-framework-tutorial and does, but gets a 404 error\r\n\r\n## Expected behavior\r\nExpect to be taken to the source code for the tutorial\r\n\r\n## Actual behavior\r\nGoes to GitHub at:  https://github.com/encode/rest-framework-tutorial and there is nothing there, so it shows 404 error screen."},{"labels":["documentation"],"text":"## Checklist\r\n\r\n- [ ] I have verified that that issue exists against the `master` branch of Django REST framework.\r\n- [x] I have searched for similar issues in both open and closed tickets and cannot find a duplicate.\r\n- [x] This is not a usage question. (Those should be directed to the [discussion group](https://groups.google.com/forum/#!forum/django-rest-framework) instead.)\r\n- [x] This cannot be dealt with as a third party library. (We prefer new functionality to be [in the form of third party libraries](http://www.django-rest-framework.org/topics/third-party-resources/#about-third-party-packages) where possible.)\r\n- [ ] I have reduced the issue to the simplest possible case.\r\n- [ ] I have included a failing test as a pull request. (If you are unable to do so we can still accept the issue.)\r\n\r\n## Steps to reproduce\r\n\r\nUse CursorPagination on a ModelViewSet, ordering by a FloatField.\r\n\r\nPrototype of a test here. (I'm not used to writing project-independent Django application tests, this will need a little tweaking before it runs.)\r\nhttps://gist.github.com/keturn/8bc88525a183fd41c73ffb729b8865be\r\n\r\n## Expected behavior\r\n\r\nExpect ViewSet to provide pages that iterate through all the results with no duplicates.\r\n\r\n## Actual behavior\r\n\r\nAfter following the `next` cursor to the next page, that second page begins with the last item on the first page.\r\n\r\nThis is because the cursor's representation of the floating-point position has been truncated, so the last item falls on the wrong side of the inequality test."},{"labels":["documentation",null],"text":"## Checklist\r\n\r\n- [x] I have verified that that issue exists against the `master` branch of Django REST framework.\r\n- [x] I have searched for similar issues in both open and closed tickets and cannot find a duplicate.\r\n- [x] This is not a usage question. (Those should be directed to the [discussion group](https://groups.google.com/forum/#!forum/django-rest-framework) instead.)\r\n- [x] This cannot be dealt with as a third party library. (We prefer new functionality to be [in the form of third party libraries](http://www.django-rest-framework.org/topics/third-party-resources/#about-third-party-packages) where possible.)\r\n- [x] I have reduced the issue to the simplest possible case.\r\n- [ ] I have included a failing test as a pull request. (If you are unable to do so we can still accept the issue.)\r\n\r\n## Steps to reproduce\r\n\r\nFor me the only logical way to create an endpoint with nested data was to use a nested serializer on GET, but a flat serializer on POST/PATCH/PUT actions. This is easily achieved by doing (from http://stackoverflow.com/a/21325719/3849359 ):\r\n```\r\nclass SwappableSerializerMixin(object):\r\n    def get_serializer_class(self):\r\n        try:\r\n            return self.serializer_classes[self.request.method]\r\n        except AttributeError as e:\r\n            logger.debug('%(cls)s does not have the required serializer_classes'\r\n                         'property' % {'cls': self.__class__.__name__})\r\n            raise AttributeError\r\n        except KeyError:\r\n            logger.debug('request method %(method)s is not listed'\r\n                         ' in %(cls)s serializer_classes' %\r\n                         {'cls': self.__class__.__name__,\r\n                          'method': self.request.method})\r\n            # required if you don't include all the methods (option, etc) in your serializer_class\r\n            return super(SwappableSerializerMixin, self).get_serializer_class()\r\n```\r\n\r\nHowever, for the docs this obviously fails, as self.request is None.\r\n\r\n## Expected behavior\r\n\r\nDetermine the serializer based on other params for the docs.\r\n\r\n## Actual behavior\r\n\r\nAttributeError is raised, because self.request is None."},{"labels":["documentation"],"text":"As explained in this [Stack Overflow post](http://stackoverflow.com/questions/43771032/drf-3-6-how-to-document-input-parameters-in-apiview-for-automatic-doc-generati/43772601?noredirect=1#comment74594577_43772601), the current documentation does not explain how to specify input parameters for non generic API Views, in order to be provided in the new DRF 3.6 doc.\r\n\r\nI don't know if it's possible actually.\r\n"},{"labels":["documentation",null],"text":"I think we can now safely add:\r\n\r\n- include_docs_urls\r\n- get_docs_view\r\n- get_schemajs_view\r\n\r\nto the documentation.\r\nCan take care of it if there's no objections."},{"labels":["documentation"],"text":"The [release notes](https://github.com/tomchristie/django-rest-framework/blob/master/docs/topics/release-notes.md) page covers everything up to `3.5.4`, but `3.6.x` seems to be missing completely.\r\n\r\nThere is the [3.6 announcement](https://github.com/tomchristie/django-rest-framework/blob/master/docs/topics/3.6-announcement.md), but It'd great if the release notes would be updated as well.\r\n\r\nThanks!\r\n\r\n"},{"labels":["documentation"],"text":"## Checklist\r\n\r\n- [x] I have verified that that issue exists against the `master` branch of Django REST framework.\r\n- [x] I have searched for similar issues in both open and closed tickets and cannot find a duplicate.\r\n- [x] This is not a usage question. (Those should be directed to the [discussion group](https://groups.google.com/forum/#!forum/django-rest-framework) instead.)\r\n- [x] This cannot be dealt with as a third party library. (We prefer new functionality to be [in the form of third party libraries](http://www.django-rest-framework.org/topics/third-party-resources/#about-third-party-packages) where possible.)\r\n- [x] I have reduced the issue to the simplest possible case.\r\n- [ ] I have included a failing test as a pull request. (If you are unable to do so we can still accept the issue.)\r\n\r\n## Steps to reproduce\r\nRead docs at https://github.com/tomchristie/django-rest-framework/blob/master/docs/topics/3.0-announcement.md#date-and-time-objects-as-iso-8859-1-strings-in-serializer-data\r\n\r\n## Expected behavior\r\nDocs should state:\r\n> ### Date and time objects as ISO-8601 strings in serializer data.\r\n...\r\n> You can modify this behavior globally by settings the existing DATE_FORMAT, DATETIME_FORMAT and TIME_FORMAT settings keys. Setting these values to None instead of their default value of 'iso-8601' will result in native objects being returned in serializer data.\r\n\r\n## Actual behavior\r\nDocs state:\r\n> ### Date and time objects as ISO-8859-1 strings in serializer data.\r\n...\r\n> You can modify this behavior globally by settings the existing DATE_FORMAT, DATETIME_FORMAT and TIME_FORMAT settings keys. Setting these values to None instead of their default value of 'iso-8859-1' will result in native objects being returned in serializer data."},{"labels":["documentation"],"text":"http://www.django-rest-framework.org/api-guide/foo/ will generate a 404 page that is broken:\r\n\r\n* the links point to ./api-guide/ and ./tutorial/, so they will point to the wrong thing\r\n* the CSS and JS files are similarly linked to, so they won't work either.\r\n\r\nAs a side note, I think for api-guide/ stuff, stripping .html might be worthwile, as they used to have it, you can find links to http://www.django-rest-framework.org/api-guide/serializers.html that'd work just fine if you removed the .html."},{"labels":["documentation"],"text":"I was looking for a way to write  tests against live server. In DRF docs there's a page about live testing, but it appears the the section describing RequestsClient() and working with databases ends abruptly.\r\n\r\n## Steps to reproduce\r\nGo to http://www.django-rest-framework.org/api-guide/testing/#requestsclient-and-working-with-the-database\r\n\r\n## Expected behavior\r\nIt would be good see how the sentence and entire section ends\r\n\r\n## Actual behavior\r\nSection ends in the middle of sentence '...class is useful if'\r\nIt looks like something is missing from that section."},{"labels":["documentation"],"text":"The latest docs have an outdated chunk mentioning \r\n\r\n> A new interface for controlling this behavior is currently planned for REST framework 3.1.\r\n\r\nhttp://django-rest-framework.readthedocs.io/en/latest/api-guide/serializers/#customizing-the-default-fields \r\n\r\nSince we're well past 3.1, it should be updated to document the current interfaces. "},{"labels":["documentation",null],"text":"I'm struggling with a similar scenario of this issue #3373. I have a very specific service layer that gives a pretty well formed return and my views/viewsets have one job, call this service and serialize its result.\r\n\r\nThe thing is, I have two serializers, one to validate query parameters and another one to serialize service's raw return. None of them are used as \"required\" by DRF as `serializer_class` resulting that their fields won't be considered by SchemeGenerator\r\n\r\nI'm failing when trying to create custom documentation to each endpoint, since DRF is kind of model-oriented to generate its schemas (I could write down my own schema, but I would love if DRF generates it for me though), plus I'm using Swagger as interface.\r\n\r\nIn my opinion, it would be nice to permit create docstring to create coreapi.Documents by that it would be way more flexible. Any ideas how I could proceed for now?"},{"labels":["documentation"],"text":"Error when attempting to use the coreAPI tutorial code, mime type is not accepted.\n\n> $ http http://127.0.0.1:8000/schema/ Accept:application/vnd.coreapi+json\n> HTTP/1.0 406 Not Acceptable\n> Allow: GET, HEAD, OPTIONS\n> Content-Type: application/coreapi+json\n> Date: Fri, 21 Oct 2016 02:27:22 GMT\n> Server: WSGIServer/0.2 CPython/3.4.3\n> Vary: Accept\n> X-Frame-Options: SAMEORIGIN\n> \n> {\n>     \"detail\": \"Could not satisfy the request Accept header.\"\n> }\n\nthis however does work\n\n> $ http http://127.0.0.1:8000/schema/ \n> HTTP/1.0 200 OK\n> Allow: GET, HEAD, OPTIONS\n> Content-Type: application/coreapi+json\n> Date: Fri, 21 Oct 2016 02:28:36 GMT\n> Server: WSGIServer/0.2 CPython/3.4.3\n> Vary: Accept, Cookie\n> X-Frame-Options: SAMEORIGIN\n> \n> {\n>     \"_meta\": {\n>         \"title\": \"Pastern API\"\n> \n> ```\n> },\n> \"_type\": \"document\",\n> \"snippets\": {\n> ```\n> \n> ...\n\nI believe \n`http http://127.0.0.1:8000/schema/ Accept:application/vnd.coreapi+json`  \nshould be \n`http http://127.0.0.1:8000/schema/ Accept:application/coreapi+json`\n"},{"labels":["documentation"],"text":"## Checklist\n- [x] I have verified that that issue exists against the `master` branch of Django REST framework.\n- [x] I have searched for similar issues in both open and closed tickets and cannot find a duplicate.\n- [x] This is not a usage question. (Those should be directed to the [discussion group](https://groups.google.com/forum/#!forum/django-rest-framework) instead.)\n- [x] This cannot be dealt with as a third party library. (We prefer new functionality to be [in the form of third party libraries](http://www.django-rest-framework.org/topics/third-party-resources/#about-third-party-packages) where possible.)\n- [x] I have reduced the issue to the simplest possible case.\n- [ ] I have included a failing test as a pull request. (If you are unable to do so we can still accept the issue.)\n## Steps to reproduce\n\nFollow tutorial up to the generic class-based views section of chapter 3. Attempt to access a snippet detail (e.g. in the browser at localhost:8000/snippets/1)\n## Expected behavior\n\nReturn the serialised snippet\n## Actual behavior\n\n> AssertionError: Expected view SnippetDetail to be called with a URL keyword argument named \"pk\"\n> ...\n\nThe problem is that until that point in the tutorial the views were written out in full and used a keyword argument `id`. When changing to the class-based views, the expected argument is `pk`. Either `urls.py` should be updated to capture the argument as `pk` or the SnippetDetail class needs to have a `lookup_field` option.\n"},{"labels":["documentation"],"text":"[CONTRIBUTING.md](https://github.com/tomchristie/django-rest-framework/blob/master/CONTRIBUTING.md) gives the following instructions:\n\n> To run the tests, clone the repository, and then:\n> \n> ```\n> # Setup the virtual environment\n> virtualenv env\n> source env/bin/activate\n> pip install -r requirements.txt\n> \n> # Run the tests\n> ./runtests.py\n> ```\n\nHowever doing these steps does not install Django, and it will result in the following error output:\n\n```\nINTERNALERROR> Traceback (most recent call last):\nINTERNALERROR>   File \"/home/gpanther/greypanther/django-rest-framework/env/local/lib/python2.7/site-packages/_pytest/main.py\", line 90, in wrap_session\nINTERNALERROR>     config._do_configure()\nINTERNALERROR>   File \"/home/gpanther/greypanther/django-rest-framework/env/local/lib/python2.7/site-packages/_pytest/config.py\", line 839, in _do_configure\nINTERNALERROR>     self.hook.pytest_configure.call_historic(kwargs=dict(config=self))\nINTERNALERROR>   File \"/home/gpanther/greypanther/django-rest-framework/env/local/lib/python2.7/site-packages/_pytest/vendored_packages/pluggy.py\", line 729, in call_historic\nINTERNALERROR>     self._hookexec(self, self._nonwrappers + self._wrappers, kwargs)\nINTERNALERROR>   File \"/home/gpanther/greypanther/django-rest-framework/env/local/lib/python2.7/site-packages/_pytest/vendored_packages/pluggy.py\", line 338, in _hookexec\nINTERNALERROR>     return self._inner_hookexec(hook, methods, kwargs)\nINTERNALERROR>   File \"/home/gpanther/greypanther/django-rest-framework/env/local/lib/python2.7/site-packages/_pytest/vendored_packages/pluggy.py\", line 333, in <lambda>\nINTERNALERROR>     _MultiCall(methods, kwargs, hook.spec_opts).execute()\nINTERNALERROR>   File \"/home/gpanther/greypanther/django-rest-framework/env/local/lib/python2.7/site-packages/_pytest/vendored_packages/pluggy.py\", line 596, in execute\nINTERNALERROR>     res = hook_impl.function(*args)\nINTERNALERROR>   File \"/home/gpanther/greypanther/django-rest-framework/tests/conftest.py\", line 2, in pytest_configure\nINTERNALERROR>     from django.conf import settings\nINTERNALERROR> ImportError: No module named django.conf\n```\n\nEither the file should mention that Django needs to be pip installed-ed, or Django needs to be added into one of the requirements file.\n"},{"labels":["documentation"],"text":"## Checklist\n- [x] I have verified that that issue exists against the `master` branch of Django REST framework.\n- [x] I have searched for similar issues in both open and closed tickets and cannot find a duplicate.\n- [x] This is not a usage question. (Those should be directed to the [discussion group](https://groups.google.com/forum/#!forum/django-rest-framework) instead.)\n- [x] This cannot be dealt with as a third party library. (We prefer new functionality to be [in the form of third party libraries](http://www.django-rest-framework.org/topics/third-party-resources/#about-third-party-packages) where possible.)\n- [x] I have reduced the issue to the simplest possible case.\n- [ ] I have included a failing test as a pull request. (If you are unable to do so we can still accept the issue.)\n\nHello, first thanks for this great piece code.\nI am referring to the issue  ##1725 because it still seems like a bug to me even in version 3.x.\n## Steps to reproduce\n\nIf a partial update is performed and a field marked as required is passed with a an empty value (even null if allow_null is set to true) the validation passes.\n## Expected behavior\n\nIn my humble opinion, required fields should be checked and validated as such even in partial update, if they are passed in the payload.\n## Actual behavior\n\nThe required fields are saved with the passed value even if empty and even null if allow_null is set to true.\n"},{"labels":["documentation"],"text":"## Checklist\n- [x] I have verified that that issue exists against the `master` branch of Django REST framework.\n- [x] I have searched for similar issues in both open and closed tickets and cannot find a duplicate.\n- [x] This is not a usage question. (Those should be directed to the [discussion group](https://groups.google.com/forum/#!forum/django-rest-framework) instead.)\n- [x] This cannot be dealt with as a third party library. (We prefer new functionality to be [in the form of third party libraries](http://www.django-rest-framework.org/topics/third-party-resources/#about-third-party-packages) where possible.)\n- [x] I have reduced the issue to the simplest possible case.\n- [ ] I have included a failing test as a pull request. (If you are unable to do so we can still accept the issue.)\n## Issue\n\nThe docstring of `Field.get_default` says:\n\n> If a default has not been set for this field then this will simply\n>         return `empty`, indicating that no value should be set in the\n>         validated data for this field.\n\nBut if default has not been set the method raises `SkipField` instead.\n\n``` python\nif self.default is empty or getattr(self.root, 'partial', False):\n    # No default, or this is a partial update.\n    raise SkipField()\n```\n\nI suggest either to change the documentation to reflect the actual behaviour or change the code to reflect the doc.\n\nhttps://github.com/tomchristie/django-rest-framework/blob/master/rest_framework/fields.py#L434\n"},{"labels":["documentation"],"text":"Include OpenAPI/Swagger in the tutorial, and in the schema generation guide.\n\nRefs #4179\n"},{"labels":["documentation"],"text":"I see the API Guide on the site is sorted by most important (?).\nSeeing as this is the primary way to peruse the docs I'd suggest sorting the items alphabetically.\n<img width=\"227\" alt=\"screen shot 2016-06-23 at 3 37 18 pm\" src=\"https://cloud.githubusercontent.com/assets/587438/16317378/dce6f55e-3958-11e6-923d-6032f837b1e6.png\">\n\nUnless there is another place the api is documented.\n"},{"labels":["documentation"],"text":"## Steps to reproduce\n\n```\nclass MyViewSet(viewsets.ModelViewSet):\n    queryset = MyModel.objects.all()\n    serializer_class = MySerializer\n    authentication_classes = (MyAuth, )\n    permission_classes = (MyPermissions, )\n\n    @detail_route(methods=[\"GET\", ])\n    def custom(self, request, pk=None):\n        return Response('whatever')\n\nfrom rest_framework import routers\nrouter = routers.SimpleRouter() \nrouter.register('mymodel', MyViewSet)\nurlpatterns = [\n    url(r'^api/', include(router.urls)),\n]\n```\n\nmake a GET request to /api/mymodel/123/custom/\n## Expected behavior\n\nhas_object_permission() should be called with `MyModel.objects.get(pk=123)` as object.\n## Actual behavior\n\nrequest to the custom route in the form of /api/mymodel/123/custom/ will call has_permission() in MyPermissions, but not has_object_permission() even though it is a detail route.  \n"},{"labels":["documentation"],"text":"The ObtainAuthToken class starts as follows:\n\n```\nclass ObtainAuthToken(APIView):\n    throttle_classes = ()\n```\n\nThis prevents it from using throttling if configured project-wide. I believe this is not a good practice. Throttling the authentication system is essential to prevent brute-force attacks. \n\nI know I could create a new class that extends that one and use it for my specific purposes, but i believe that removing the `throttle_classes` parameter from the class would be a more intuitive solution and benefit the project.\n\nAlso aligned with my argument, I couldn't find nothing in the documentation stating that `ObtainAuthToken` doesn't comply with the project-wide throttling configurations.\n"},{"labels":["documentation"],"text":"## Checklist\n- [x] I have verified that that issue exists against the `master` branch of Django REST framework.\n- [x] I have searched for similar issues in both open and closed tickets and cannot find a duplicate.\n- [x] This is not a usage question. (Those should be directed to the [discussion group](https://groups.google.com/forum/#!forum/django-rest-framework) instead.)\n- [x] This cannot be dealt with as a third party library. (We prefer new functionality to be [in the form of third party libraries](http://www.django-rest-framework.org/topics/third-party-resources/#about-third-party-packages) where possible.)\n- [x] I have reduced the issue to the simplest possible case.\n- [x] I have included a failing test as a pull request. (If you are unable to do so we can still accept the issue.)\n## Steps to reproduce\n\nThe website for the DRF 2.x docs is down, which should be here: http://www.tomchristie.com/rest-framework-2-docs/\n\nThe site was working fine about 1-2 weeks ago. Perhaps the registrar was recently changed, and/or DNS records need to be updated?\n\nSome links to the broken site can be found here: http://www.django-rest-framework.org/, and at the top of the README for this repo. At the very least, it would be nice to remove these links, or explain why the site no longer exists.\n## Expected behavior\n\nThe site should take us to the docs for DRF version 2.x\n## Actual behavior\n\nThe site is down.\n## Note:\n\nI am in the process of upgrading from DRF 2.3 to DRF 3.x, so the DRF version 2 docs are helpful in this process. Hopefully I won't need them much longer! But I imagine others may need the link to the version 2.x docs as well, so it would be nice to keep them around.\n"},{"labels":["documentation"],"text":"In `docs/api-guide/authentication.md`, section \"API Reference\" / \"TokenAuthentication\" / \"Schema migrations\", a migration requirement is mentioned if a custom user model is being used. However, it is explained how to do that only for South and not when using its official successor (Django migrations).\n\n> You can do so by inserting a needed_by attribute in your user migration\n> ...\n> For more details, see the south documentation on dependencies.\n\nIt seems replacing `needed_by` with `run_before` is enough but I'm not sure.\n## Checklist\n- [x] I have verified that that issue exists against the `master` branch of Django REST framework.\n- [x] I have searched for similar issues in both open and closed tickets and cannot find a duplicate.\n- [x] This is not a usage question. (Those should be directed to the [discussion group](https://groups.google.com/forum/#!forum/django-rest-framework) instead.)\n- [x] This cannot be dealt with as a third party library. (We prefer new functionality to be [in the form of third party libraries](http://www.django-rest-framework.org/topics/third-party-resources/#about-third-party-packages) where possible.)\n- [x] I have reduced the issue to the simplest possible case.\n- [ ] I have included a failing test as a pull request. (If you are unable to do so we can still accept the issue.)\n## Steps to reproduce\n\nN/A\n## Expected behavior\n\nN/A\n## Actual behavior\n\nN/A\n"},{"labels":["documentation"],"text":"## Checklist\n- [X] I have verified that that issue exists against the `master` branch of Django REST framework.\n- [X] I have searched for similar issues in both open and closed tickets and cannot find a duplicate.\n- [X] This is not a usage question. (Those should be directed to the [discussion group](https://groups.google.com/forum/#!forum/django-rest-framework) instead.)\n- [X] This cannot be dealt with as a third party library. (We prefer new functionality to be [in the form of third party libraries](http://www.django-rest-framework.org/topics/third-party-resources/#about-third-party-packages) where possible.)\n- [X] I have reduced the issue to the simplest possible case.\n- [ ] I have included a failing test as a pull request. (If you are unable to do so we can still accept the issue.)\n\nAs referenced in\nhttps://github.com/tomchristie/django-rest-framework/pull/2575\nhttps://github.com/miki725/django-rest-framework-bulk/issues/30\n\nListSerializer attempts to apply unique together validation on the queryset passed to it, but some part of the code is passed the full queryset, where it attempts to look up attributes on what it expects to be individual instances.\n## Steps to reproduce\n\nI've modified a test case found in the above links, and run them against master. I'm not sure what the file should be named, and if it follows your quality standards, so I have not submitted  a PR with it.\n\n``` python\nfrom django.db import models\nfrom django.test import TestCase\n\nfrom rest_framework import serializers\n\n\nclass ManyUniqueTogetherModel(models.Model):\n    foo = models.IntegerField()\n    bar = models.IntegerField()\n    class Meta:\n        unique_together = (\"foo\", \"bar\")\n\n\nclass ManyUniqueTogetherSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = ManyUniqueTogetherModel\n\n\nclass ManyUniqueTogetherTestCase(TestCase):\n\n    def test_partial_false(self):\n        obj = ManyUniqueTogetherModel.objects.create(foo=1, bar=2)\n        serializer = ManyUniqueTogetherSerializer(\n            instance=ManyUniqueTogetherModel.objects.all(),\n            data=[{\n                \"id\": obj.pk,\n                \"foo\": 5,\n                \"bar\": 6,\n            }],\n            many=True\n        )\n        self.assertTrue(serializer.is_valid())\n\n    def test_partial_true(self):\n        obj = ManyUniqueTogetherModel.objects.create(foo=1, bar=2)\n        serializer = ManyUniqueTogetherSerializer(\n            instance=ManyUniqueTogetherModel.objects.all(),\n            data=[{\n                \"id\": obj.pk,\n                \"foo\": 5,\n            }],\n            partial=True,\n            many=True\n        )\n        self.assertTrue(serializer.is_valid())\n```\n## Expected behavior\n\nThe code path looks up properties on individual instances in the queryset, is_valid() returns either True or False depending on the actual data, the tests pass.\n## Actual behavior\n\n```\n====================================================================== FAILURES ======================================================================\n___________________________________________________ ManyUniqueTogetherTestCase.test_partial_false ____________________________________________________\ntests/test_unique_together.py:35: in test_partial_false\n    self.assertTrue(serializer.is_valid())\nrest_framework/serializers.py:213: in is_valid\n    self._validated_data = self.run_validation(self.initial_data)\nrest_framework/serializers.py:557: in run_validation\n    value = self.to_internal_value(data)\nrest_framework/serializers.py:593: in to_internal_value\n    validated = self.child.run_validation(item)\nrest_framework/serializers.py:409: in run_validation\n    self.run_validators(value)\nrest_framework/fields.py:499: in run_validators\n    validator(value)\nrest_framework/validators.py:142: in __call__\n    queryset = self.exclude_current_instance(attrs, queryset)\nrest_framework/validators.py:135: in exclude_current_instance\n    return queryset.exclude(pk=self.instance.pk)\nE   AttributeError: 'QuerySet' object has no attribute 'pk'\n____________________________________________________ ManyUniqueTogetherTestCase.test_partial_true ____________________________________________________\ntests/test_unique_together.py:50: in test_partial_true\n    self.assertTrue(serializer.is_valid())\nrest_framework/serializers.py:213: in is_valid\n    self._validated_data = self.run_validation(self.initial_data)\nrest_framework/serializers.py:557: in run_validation\n    value = self.to_internal_value(data)\nrest_framework/serializers.py:593: in to_internal_value\n    validated = self.child.run_validation(item)\nrest_framework/serializers.py:409: in run_validation\n    self.run_validators(value)\nrest_framework/fields.py:499: in run_validators\n    validator(value)\nrest_framework/validators.py:141: in __call__\n    queryset = self.filter_queryset(attrs, queryset)\nrest_framework/validators.py:120: in filter_queryset\n    attrs[field_name] = getattr(self.instance, field_name)\nE   AttributeError: 'QuerySet' object has no attribute 'bar'\n```\n"},{"labels":["documentation"],"text":"Something is going wrong with how this line (299 in the md file)\n\n   https://github.com/tomchristie/django-rest-framework/blame/master/docs/api-guide/fields.md#L299\n\nis being rendered when output as HTML here\n\n   http://www.django-rest-framework.org/api-guide/fields/#date-and-time-fields\n\nThat header has become mangled. Not sure about the nature of the problem since the markdown seems to render fine when viewed via Github.\n"},{"labels":["documentation"],"text":"`Serializing objects` section in the `Serializers` documentation page does not matches the real behaviour in a python shell.\n\nDocumentation shows:\n\n```\n{'email': u'leila@example.com', 'content': u'foo bar', 'created': datetime.datetime(2012, 8, 22, 16, 20, 9, 822774)}\n```\n\nas the expected result for\n\n```\nserializer.data\n```\n\nwhen running the code in the shell it will give:\n\n```\n{'content': u'foo bar', 'email': u'leila@example.com', 'created': '2016-01-27T19:00:52.355728'}\n```\n\nI'm not sure but I suspect this is due some change from DRF 2 to 3.\n"},{"labels":["documentation"],"text":"Hi,\n\nI have an issue when trying to serialize data from instances. My serializers have a lot of non-required fields, some of which have default values. My  instance objects do not have _all_ attributes defined on the serializer, but they do have all _mandatory_ attributes defined there. I see a difference in behavior between these two types of non-required fields:\n\nA non-required field is simply skipped from serialization:\n\n``` python\nclass Ser1(Serializer):\n  field = CharField(required=False)\n\ninstance = object()\nassert Ser1(instance).data == {}\n```\n\nA non-required field with a default value however throws an error\n\n``` python\nclass Ser2(Serializer):\n  field = CharField(default='value1')\n\ninstance = object()\nassert Ser2(instance).data == {'field': 'value1'} # throws AttributeError\n```\n\nI would expect the latest assertion to be true. At least this is how _deserialization_ works:\n\n``` python\nclass Ser3(Ser1, Ser2): pass\n\ns = Ser3(data={})\ns.is_valid()\nassert s.data == {'field': 'value1'}\n```\n\nIs there a reason why serialization between these two field types is implemented differently and in contrast to its deserialization counterpart?\n"},{"labels":["documentation"],"text":"In the [Writable nested representations](http://www.django-rest-framework.org/api-guide/serializers/#writable-nested-representations) the link to \"this blogpost on using model and manager classes\" is broken.\n"},{"labels":["documentation"],"text":"The docs at http://www.django-rest-framework.org/topics/browsable-api/#customizing describe that one should create an api.html template to customize the browseable api. However, when using the AdminRenderer the template admin.html needs to be used/customized. This is missing from the docs.\n"},{"labels":["documentation"],"text":"Hi,\n\nIn docs (http://www.django-rest-framework.org/api-guide/validators/) is not clear that you can write a custom validator by naming your validator function as: validate_'serializer_field_name'.\n\nI think that many users would find that information useful.\n\nRegards.\n"},{"labels":["documentation",null],"text":"Typo in code example for HTML and Forms.\n\nhttp://www.django-rest-framework.org/topics/html-and-forms/\n\nIn the following code on the page there is a single quote `'` before the second `%` which should not be there (removed below)\n\n```\n{% load rest_framework %}\n\n<html><body>\n\n<h1>Profile - {{ profile.name }}</h1>\n\n<form action=\"{% url 'profile-detail' pk=profile.pk %}\" method=\"POST\">\n    {% csrf_token %}\n    {% render_form serializer %}\n    <input type=\"submit\" value=\"Save\">\n</form>\n\n</body></html>\n```\n\nSolution does not work out of the box in testing and wondering if there is extra code required such as what the valid urls.py should be.  Assumption is the following would be the urls.py\n\n```\nurlpatterns = [\n    url(r'^profiles/$', views.ProfileList.as_view(), name='profile-list'),\n    url(r'^profiles/(?P<pk>[0-9]+)/$', views.ProfileDetail.as_view(), name='profile-detail'),\n]\n```\n\nWhich does not seem to address the problem.  Relevant stackoverflow here - \n\nhttp://stackoverflow.com/questions/33979468/drf-reverse-for-widget-detail-with-arguments-and-keyword-arguments-u/33981162#33981162\n"},{"labels":["documentation"],"text":"Following [the documentation](http://www.django-rest-framework.org/api-guide/fields/#listfield) of ListField, a user may expect that it is to be declared as:\n\n``` python\nfield_name = ListField(NestedField())\n```\n\nThis looks quite natural and in consistency with former [drf-compound-fields](https://github.com/estebistec/drf-compound-fields).\n\nHowever, [the implementation](https://github.com/tomchristie/django-rest-framework/blob/master/rest_framework/fields.py#L1431) expects the `child` to be specified in kwargs rather then args. This prevents a child to be specified as first arg and requires declaration to be:\n\n``` python\nfield_name = ListField(child=SubField())\n```\n\nWhich is a bit confusing.\n\nTe same applies to DictField.\n"},{"labels":["documentation"],"text":"The current docs for [Generic views](http://www.django-rest-framework.org/api-guide/generic-views/) has examples using `get_paginate_by()` but this method no longer exists (since 3.0.5?).\n"},{"labels":["documentation"],"text":"Version: 3.3.1\n\nThe documentation for `versioning.URLPathVersioning` (both the docstring and the [API guide](http://www.django-rest-framework.org/api-guide/versioning/#urlpathversioning)) provides the following example for the URL regex: `r'^(?P<version>[v1|v2]+)/bookings/$'`. Unless I am misunderstanding, I think that `[v1|v2]` is supposed to be `(v1|v2)`, and that the `+` should be removed. Also, I am not sure whether it is customary to add a mandatory trailing slash or not.\n\n(From git blame I see the regex was changed to the above in pull request #3037).\n"},{"labels":["documentation"],"text":"http://djangorestframework.readthedocs.org/en/latest/api-guide/pagination/ says\n\n> Note that using a paginate_by value of None will turn off pagination for the view.\n\nBut correct way for current version seems `paginator = None`\n"},{"labels":["documentation"],"text":"The documentation for writing a custom ListSerializer uses book.id to determine matches between instances and validated data. It appears that the validation of ListSerializers calls the child Serializers' validation methods. This validation by default removes non-writable values from data, including any id information, making it impossible to match instances and validated data.\n\nThis is preventable by making the ID not read_only in the child serializer, but that is not documented or even included in the example (though it would have saved me a lot of time).\n"},{"labels":["documentation"],"text":"### Problem\n\nWhen a site is using DRF without the need for authentication they will likely end up with a Django + 3rd party app list similar to this:\n\n```\n(\n    'django.contrib.staticfiles',\n    'rest_framework',\n)\n```\n\nNow the problem is that any request to a URL using DRF will produce deprecation warnings from the use of ContentType, Permission, Group and User models from contrib.auth and contrib.contenttypes. Each warning looks similar to the following.\n\n```\n(snip).models.ContentType doesn't declare an explicit app_label and either isn't in an application in INSTALLED_APPS or else was imported before its application was loaded. This will no longer be supported in Django 1.9.\n  class ContentType(models.Model):\n```\n\nI have confirmed that if Django 1.9a1 is used this warning turns into a runtime error:\n\n```\nException Type:     RuntimeError\nException Value:    \nModel class django.contrib.contenttypes.models.ContentType doesn't declare an explicit app_label and either isn't in an application in INSTALLED_APPS or else was imported before its application was loaded. \n```\n### Workaround\n\nUse this `REST_FRAMEWORK` setting to disable the referencing of AnonymousUser\n\n``` python\nREST_FRAMEWORK = {\n    'UNAUTHENTICATED_USER': None,\n}\n```\n"},{"labels":["documentation"],"text":"The documentation topic, [documenting your api](https://github.com/tomchristie/django-rest-framework/blob/3.2.4/docs/topics/documenting-your-api.md) describes overriding the `metadata` view method as described in the [version 3.0 updates notes](https://github.com/tomchristie/django-rest-framework/blob/3.2.4/docs/topics/3.0-announcement.md). However since commit f4b1dcb167be0bbdaae2cc2a92f651536896dc16 I think this method has been changed to `options`.\n\nHere is a patch:\n\n```\n--- documenting-your-api.md.orig    2015-10-12 14:52:15.036110300 -0700\n+++ documenting-your-api.md 2015-10-12 14:52:45.168944300 -0700\n@@ -81,11 +81,11 @@\n\n You can modify the response behavior to `OPTIONS` requests by overriding the `metadata` view method.  For example:\n\n-    def metadata(self, request):\n+    def options(self, request):\n         \"\"\"\n         Don't include the view description in OPTIONS responses.\n         \"\"\"\n-        data = super(ExampleView, self).metadata(request)\n+        data = super(ExampleView, self).options(request)\n         data.pop('description')\n         return data\n```\n"},{"labels":["documentation"],"text":"Problem described in #760 takes some hours to be investigated. May it be possible to describe in drf docs the difference between django/drf auth scheme used? Due to my poor english i can't do it myself, sorry.\n"},{"labels":["documentation"],"text":"## env\n\n```\n>>> import rest_framework,sys,django\n>>> rest_framework.__version__\n'3.2.3'\n>>> sys.version_info\nsys.version_info(major=2, minor=7, micro=9, releaselevel='final', serial=0)\n>>> django.get_version()\n'1.8.4'\n```\n## Issue\n\n**location** /docs/tutorial/1-serialization.md\n**section**\n\n```\n serializer = SnippetSerializer(Snippet.objects.all(), many=True)\n serializer.data\n # [{'pk': 1, 'title': u'', 'code': u'foo = \"bar\"\\n', 'linenos': False, 'language': u'python', 'style': u'friendly'}, {'pk': 2, 'title': u'', 'code': u'print \"hello, world\"\\n', 'linenos': False, 'language': u'python', 'style': u'friendly'}]\n```\n### should be\n\n```\n>>> serializer = SnippetSerializer(Snippet.objects.all(), many=True)\n>>> serializer.data\n#[OrderedDict([('pk', 1), ('title', u''), ('code', u'foo = \"bar\"\\n'), ('linenos', False), ('language', 'python'), ('style', 'friendly')]), OrderedDict([('pk', 2), ('title', u''), ('code', u'print \"hello, world\"\\n'), ('linenos', False), ('language', 'python'), ('style', 'friendly')]), OrderedDict([('pk', 3), ('title', u''), ('code', u'print \"hello, world\"'), ('linenos', False), ('language', 'python'), ('style', 'friendly')])]\n>>>\n```\n"},{"labels":["documentation"],"text":"serpy is now compatible with REST framework generic views as a serialization-only alternative.\n\nhttps://github.com/clarkduvall/serpy\n"},{"labels":["documentation"],"text":"1. [The docs](http://www.django-rest-framework.org/api-guide/renderers/) show a confusing `.` as the prefix for the format. For example:\n\n> .format: `'.html'`\n\nwhereas the class has:\n\n``` python\nclass TemplateHTMLRenderer(BaseRenderer):\n...\n    format = 'html'\n```\n1. The docs don't give a suggestion as to what should `format` be set to when the `media_type = 'image/*'` or `*/*`.\n"},{"labels":["documentation"],"text":"I'm using Django REST Framework for an API integration project (i.e. presenting a unified API that abstracts a subset of the APIs for multiple backend services), and aiming to keep the abstraction layer as stateless as possible.\n\nI think it's excellent for this purpose, but the regular ViewSet examples in the documentation all assume the use of local model objects, and so have required a bit reverse engineering to figure out the key patterns needed to implement my own custom ViewSet classes that work correctly with the rest of the framework (including the browsable API). So far I've figured out that the bare minimum is:\n- define a `Serializer` subclass, and set that as `serializer_class` on the custom ViewSet (this is needed to get the submission forms to appear correctly on the browsable API)\n- return `Response(self.serializer_class(data, many=True).data)` from list methods\n- return `Response(self.serializer_class(data).data)` from retrieve methods\n- to pass along an unstructured JSON blob retrieved from another API without parsing it locally, use a field definition like `raw_data = serializers.DictField(read_only=True)`\n\nI'm still figuring out the right implementation patterns for create, update, partial update, and destroy...\n\nAs far as where this could go in the documentation, it seems to me that the current \"Marking extra extractions for routing\" section in http://www.django-rest-framework.org/api-guide/viewsets/ could be broken up to have a preceding section on \"Integrating with Routers and the Browsable API\" that covers the default methods the routers look for, and how the browsable API generates the default forms.\n\nIf this seems reasonable, I'd be happy to work on a PR for it. \n"},{"labels":["documentation"],"text":"In the [Generic Relationships](http://www.django-rest-framework.org/api-guide/relations/#generic-relationships) section of the documentation, `self.tag` might need to be replaced with `self.tag_name`. See below:\n\n![django_rest_generic_relationships](https://cloud.githubusercontent.com/assets/3136908/9634149/3caa7134-5145-11e5-956a-7216a2008f93.jpg)\n\nWith `self.tag`, an AttributeError would be raised. See below:\n\n![tagged_item_object_no_tag_attribute](https://cloud.githubusercontent.com/assets/3136908/9634556/1ed4b65e-5147-11e5-9948-36b9d3e5af37.jpg)\n\n`self.tag_name` returns the expected admin\n"},{"labels":["documentation"],"text":"Feedback: Per your request for feedback, one thing that I still do is try to click a red text code item in the docs to navigate to the API for it. For example, it would be nice for the **APIView** to link to the details.\n\n![screen shot 2015-08-24 at 9 36 22 am](https://cloud.githubusercontent.com/assets/5033139/9441452/255f05c4-4a44-11e5-8ef0-98d8b0a04156.png)\n"},{"labels":["documentation"],"text":"<blockquote class=\"twitter-tweet\" lang=\"en\"><p lang=\"en\" dir=\"ltr\"><a href=\"https://twitter.com/_tomchristie\">@_tomchristie</a> maybe - certainly a quick glossary of key terms + a little detail on each might help too</p>&mdash; Steve Jalim (@stevejalim) <a href=\"https://twitter.com/stevejalim/status/634362634784088069\">August 20, 2015</a></blockquote>\n\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n"},{"labels":["documentation"],"text":"Requires support in MkDocs\n"},{"labels":["documentation"],"text":"If you field name \"title\" is defined so that it's not required\n\n``` python\ntitle = serializers.CharField(required=False)\n```\n\nand you have \n\n``` python\ndef validate_title(self, title):\n  pass\n```\n\nthen validate_title is never to be called on request:\n\n``` js\n{\n  \"something_but_not_title\": \"value\"\n}\n```\n\nCause there will be a SkipField exception https://github.com/tomchristie/django-rest-framework/blob/master/rest_framework/fields.py#L436.\nIt may seem to be a correct behaviour and it's not documented http://www.django-rest-framework.org/api-guide/serializers/#validation.\nBut may be it's not correct. What do you think?\n"},{"labels":["documentation"],"text":"As per https://twitter.com/pydanny/status/633129209045479424\n"},{"labels":["documentation"],"text":"Apparently, there is no way to use has_object_permission with function based views that use the @api_view decorator.\n\nIdeally, there should be a way to do this, but if that won't be provided, then the docs should be reflected to indicate that CBVs and FBVs are not functionally equal in this regard.\n"},{"labels":["documentation"],"text":"As of 3.2 we now require Django 1.5 minimum - we should call this out in the release announcement.\n"},{"labels":["documentation"],"text":"I am not sure if this is a bug, or just a documentation issue, but in the quickstart guide it states:\n\n> For trivial cases you can simply set a model attribute on the ViewSet class and the serializer and queryset will be automatically generated for you. Setting the queryset and/or serializer_class attributes gives you more explicit control of the API behaviour, and is the recommended style for most applications.\n\nWhen I tried this using 3.1.0 however I get the following error:\n\n```\nAssertionError: `base_name` argument not specified, and could not automatically determine the name from the viewset, as it does not have a `.queryset` attribute.\n```\n\nI had another project which is still using 2.3.8 and when I tried it there it worked fine.\n\nIn order to verify I didn't do anything wrong, I took the users examples from the [quickstart](http://www.django-rest-framework.org/tutorial/quickstart/#views) and turned it into a \"trivial\" example:\n\n```\nclass UserViewSet(viewsets.ModelViewSet):\n    \"\"\"\n    API endpoint that allows users to be viewed or edited.\n    \"\"\"\n    model = User\n    # queryset = User.objects.all()\n    # serializer_class = UserSerializer\n```\n\nThe error is very informative so kudos for that. Additionally the fix is pretty easy.  Since this works on 2.3.8 I wonder if that quote is left over from the older version, or if it should be refined to explain that in those simple cases you'll need a basename on the router entry?\n\nI don't consider this to be a major issue at all (especially given the ease of a fix given the very useful error message), but I thought I'd open this to help clarify the quickstart guide a little.\n"},{"labels":["documentation"],"text":"I quite often want to link to the `perform_create`, `perform_update` and `perform_destroy` hooks in the [generic views documentation](http://www.django-rest-framework.org/api-guide/generic-views/#genericapiview), but the closest anchor above is `#genericapiview`, which is a lot of scrolling away. The `#mixins` anchor is closer, but requires scrolling up.\n"},{"labels":["documentation"],"text":"The [documentation](http://www.django-rest-framework.org/api-guide/fields/#ipaddressfield) states that the IPAddressField takes `unpack_ipv4` as an argument, which is False by default and can only be used when protocol is 'both' (which is in line with Django's GenericIPAddressField).\n\nWhen I try to use this option, I get an exception: \n\n> TypeError: **init**() got an unexpected keyword argument 'unpack_ipv4'\n\nIt looks like `IPAddressField.__init__` sets unpack_ipv4 to True if the protocol is 'both' (which is contrary to the docs): https://github.com/tomchristie/django-rest-framework/blob/dee5fb56479edc05cd0dcc827607696e58710eda/rest_framework/fields.py#L683\n"},{"labels":["documentation"],"text":"The current design of rest framework doesn't seem to support object-level validations on partial updates. \n\nQuick example:\n\n``` python\nfrom rest_framework import serializers\n\nclass ItemInListSerializer(serializers.Serializer):\n    options=serializers.ListField()\n    item=serializers.CharField()\n\n    def validate(self, attrs):\n        options = attrs.get('options')\n        item = attrs.get('item')\n\n       if item not in options:\n            raise serializers.ValidationError('Item is not a valid option!')\n\n    def update(self, instance, validated_data):\n        instance.attributes = validated_data\n        return instance\n\n    def create(self, validated_data):\n        # create some object\n```\n\nThis is just a toy example, but the issue should be pretty clear: if you're creating an object with the serializer, then `attrs` contains both `options` and `item`, and the validations pass and the object is created. If you attempt a partial update to set `item` (for example), the `validate` method will always run before `update`, and will always fail, because `options` does not exist.\n\nIs there any standard solution to this scenario? I could certainly write validations before anything gets to the serializer, or push them down into models, but it seems like (and correct me if I'm wrong) DRF is attempting to be that validation layer and, in theory, these validations should and could live on the serializer.\n\nAlso just to note, I'm not the only person with this problem, I found this on SO: http://stackoverflow.com/questions/28646454/django-rest-framework-partial-update-and-validation\n\nAny help would be appreciated! Thanks!\n"},{"labels":["documentation"],"text":"See #3049 for the initial motivation behind this.\n\nNeed to explain how this interacts with non-`read_only` fields, and describe why a dictionary is expected from `to_internal_value` in that case.\n"},{"labels":["documentation"],"text":"I've been wrestling with how to encode my ManyToManyField for a couple days.  One thing that makes it very difficult is the lack of any example in the documentation.  It's also frustrating that all the documentation on relations uses the same, reverse relation example: tracks.  So it's not even clear to me how to code up a forward relation and get the nested lists like the tracks lists.  Could someone add\n\na) a forward relation example?\nb) a ManyToMany example?\nc) more clarification to the ManyToMany section about the implications of setting the read_only flag and some hint about whether it is possible to get write behavior on ManyToMany fields with custom classes and some hint about how to go about that?\n\nNote that I'm about to give up on any nested representation of ManyToMany slugs and use a custom serializer to code up the list as a flat string.  I am also finding little documentation on how to create a custom field class, though.\n"},{"labels":["documentation"],"text":"It's taken me quite a bit of reading of the DRF documentation to get some idea what the read_only flag is supposed to do.  I think somewhere (but not in the section about the read_only flag) it says that read_only fields will not be treated as fields in model objects and will be ignored when creating or updating these objects.  Is that the essence?  Could the documentation be updated to explain what it does when you set it?\n"},{"labels":["documentation"],"text":"Was wondering why I couldn't see `Exceptions` under the API Guide section dropdown.\n\n![screen shot 2015-06-11 at 3 54 32 pm](https://cloud.githubusercontent.com/assets/83319/8116824/5a1a7e96-1052-11e5-8f18-67c687076407.png)\n\nWe could set it a height for it.\n![screen shot 2015-06-11 at 3 57 27 pm](https://cloud.githubusercontent.com/assets/83319/8116861/972df2fe-1052-11e5-93fb-27f55ad76448.png)\n\nAny better ideas?\n"},{"labels":["documentation"],"text":"I noticed that it is hard to find out which is the **current release version** (3.1.3 currently) when I visit [the website](http://www.django-rest-framework.org). I like to suggest that you add the most recent version to the **start page** so people do not have to search or go to this GitHub account.\n\n![website](https://cloud.githubusercontent.com/assets/144518/8078593/12499b36-0f5f-11e5-9b2a-4969c0bec97b.png)\n\nAlso the screenshot of the contains version `2.0.0` which might be misleading to a few users.\n"},{"labels":["documentation"],"text":"[django-rest-framework](http://www.django-rest-framework.org/api-guide/generic-views/)\n i read about method _get_filter_backends_, but in code i see that this module not exist  \n\n``` python\n    def filter_queryset(self, queryset):\n        for backend in list(self.filter_backends):\n                queryset = backend().filter_queryset(self.request, queryset, self)\n        return queryset \n```\n\nis it norm?\n"},{"labels":["documentation"],"text":"If you have a nested serializer which model does have a unique constraint on a field you're not able to reference an existing instance.\n\n```\nclass Task(serializers.ModelSerializer):\n    class Meta:\n        model = models.Task\n        fields = ('id', 'name')\n\n\nclass Category(serializers.ModelSerializer):\n    tasks = Task(many=True)\n    class Meta:\n        model = models.Category\n        fields = ('id', 'name', 'tasks')\n```\n\nLet's say I created a category & task which I'm updating with the very same data they already have:\n\n```\nc = Category(data={\"id\": 1, \"name\": \"Django\", \"tasks\": [{\"id\": 1, \"name\": \"Demo\", \"owner\": \"admin\"}]})\nc.is_valid()  # Returns False\nc.errors  # Returns {'tasks': [{'name': ['This field must be unique.']}]}\n```\n\nThe point is, `name` remains unique because it matches its own `id` \n"},{"labels":["documentation"],"text":"Currently, the documentation site of django rest framework is not versioned. It caused much inconvenience to me, especially when I was reading a book whose code snippets use an older version of django rest framework. It would be great if drf's doc can be versioned (with links in every pages linking to different versions), just as how Python's official documentation and Django's documentation do it.\n"},{"labels":["documentation"],"text":"Many people have posted questions about the best way to hook into API views to add logging, e.g., https://groups.google.com/forum/#!topic/django-rest-framework/n7iZK2l4VB0. I've done this myself in a couple projects now, so I made a reusable app that implements the recommended strategy and saves the data to a db model:\n\nhttps://github.com/aschn/drf-tracking\n\nIf this package would be useful to others, it could be added to the docs somewhere. Not sure where would be best, though.. maybe [here](http://www.django-rest-framework.org/api-guide/views/#dispatch-methods)? \n"},{"labels":["documentation"],"text":"the doc for\n\n```\ndef exception_handler(exc, context):\n```\n\nsays:\n\n```\nBy default we handle the REST framework `APIException`, and also\nDjango's built-in `ValidationError`, `Http404` and `PermissionDenied`\nexceptions.\n```\n\nbut the part for ValidationError is missing\n"},{"labels":["documentation"],"text":"The view.action property on viewsets is useful for introducing dynamic behavior (eg modify serializer class depending on the action being invoked.)\n\nIt should be documented on the ViewSets page with an example of it's usage... http://www.django-rest-framework.org/api-guide/viewsets/\n"},{"labels":["documentation"],"text":"http://www.django-rest-framework.org/api-guide/relations/#nested-relationships\n\nThe docs have a great explanation for how to create nested relationships between serializers, but no explanation (that I can find) for how to use them.\n\nAs per the example above, lets say I have two querysets, one called 'album', and one called 'tracks'. How do I serialize these querysets into a single python object?\n\nI get that if they weren't nested you could just do:\n\nAlbumSerializer(album).data\nTrackSerializer(tracks, many=True).data\n\nBut how do you do this when they're nested and get back a single python object?\n"},{"labels":["documentation"],"text":"The class `class MultipleOf:` doesn't inherit from object. \nThis is a little confusing to people new to python. I think it would be worth documenting the syntax for inheriting from \"old-style\" python classes.\n\n``` python\nMultipleOf.__init__(self, *args, **kwargs)\n```\n\ninstead of\n\n``` python\nsuper(<ClassName>, self).__init__(*args, **kwargs)\n```\n"},{"labels":["documentation"],"text":"From the docs on generic views under [examples](https://github.com/tomchristie/django-rest-framework/blob/master/docs/api-guide/generic-views.md#examples), there is mention of support for passing a model keyword arg to `as_view()` like:\n\n``` Python\nurl(r'^/users/', ListCreateAPIView.as_view(model=User), name='user-list')\n```\n\nHowever, that situation results in:\n\n```\nListCreateAPIView() received an invalid keyword 'model'. as_view only accepts arguments that are already attributes of the class\n```\n\nIs this behavior still supported on 3.x or is a doc fix needed here?\n"},{"labels":["documentation"],"text":"The documentation for [GenericAPIView](http://www.django-rest-framework.org/api-guide/generic-views/#genericapiview) shows that the function signature for `get_serializer` is `get_serializer(self, instance=None, data=None, files=None, many=False, partial=False, allow_add_remove=False)`.\n\nThis implies that it should be possible to do something like this:\n\n``` python\nclass TestViewSet(viewsets.ModelViewSet):\n    serializer_class = TestModelSerializer\n    def get_serializer(self, instance=None, data=None, files=None, many=False,  \n                       partial=False, allow_add_remove=False):                     \n        # Do custom stuff here                                                     \n        return super(TestViewSet, self).get_serializer(instance=instance, data=data,\n                                                       files=files, many=many, partial=partial,\n                                                       allow_add_remove=allow_add_remove)\n```\n\nHowever, this fails with `TypeError: __init__() got an unexpected keyword argument 'files'` (and the same message for `allow_add_remove` if `files` is removed).\n\nIf those two parameters are removed, list and detail endpoints fail with `AssertionError: When a serializer is passed a`data`keyword argument you must call`.is_valid()`before attempting to access the serialized`.data`representation.` This is because the ListModelMixin and RetrieveModelMixin calls `self.get_serializer(instance)` rather than `self.get_serializer(instance=instance)`.\n\nI'm not exactly sure what the best resolution for this is; I expect that `allow_add_remove` and `files` may be used in other places such that removing them from the documentation would be inappropriate. However, it seems that the `GenericAPIView` should allow subclasses to call e.g. `serializer = self.get_serializer(files=files)` without raising errors, which doesn't appear to be the case currently.\n\nSimilarly, the AssertionError above is surprising since there is no indication in the documentation that `get_serializer` will be called with an object instance as an argument rather than a keyword argument.\n"},{"labels":["documentation"],"text":"Hello,\n\nI'm having some trouble clearing a `ManyToMany` field in a multipart PATCH request. \n\nIn a JSON request, I would clear my `ManyToMany` field, `'many_to_many_field'` by PATCHing something like:\n\n``` json\n{\"many_to_many_field\": []}\n```\n\nHowever, in a multipart PATCH request, sending values including `'[]'`, `''`, `'null'`, `'None'`,  etc all yield the following error:\n\n``` python\n[\"Incorrect type. Expected pk value, received unicode.\"]\n```\n\nIt seems that [`ManyRelatedField.get_value()`](https://github.com/tomchristie/django-rest-framework/blob/master/rest_framework/relations.py#L344-L354) does not recognize any of those options as special indicators of `empty`.\n"},{"labels":["documentation"],"text":"Unlike the documentation suggests, the function `exception_handler` does not actually handle Django's built-in ValidationError.\n\nhttps://github.com/tomchristie/django-rest-framework/blob/master/rest_framework/views.py#L52\n"},{"labels":["documentation"],"text":"When checkbox is checked, field is passed to validated_data, but when checkbox is unchecked, field is omitted.\n"},{"labels":["documentation"],"text":"It seems that the methods get_paginated_response and get_pagination_serializer are the same yet the real method that is implemented is get_paginated_response and get_pagination_serializer is referred to a number of times in the docs:\n\nhttp://www.django-rest-framework.org/api-guide/viewsets/#marking-extra-actions-for-routing\nhttp://www.django-rest-framework.org/api-guide/generic-views/#genericapiview\n"},{"labels":["documentation"],"text":"You should mention in the docs that it is possible to raise ValidationError in `perform_create` and `perform_update` to cancel the save if it can't succeed.  \nFor exemple :  \nWe have a `OneToOneField` linking a model and an user. If the model already exists we can't do `serializer.save(user=self.request.user)`\n"},{"labels":["documentation"],"text":"A 500 occurs when I try to use this renderer and I do not have permissions to the view\n\nException Type: AttributeError\nException Value:    'dict' object has no attribute 'serializer'\n\nIn the render method it looks for the serializer that is normally attached to the data (https://github.com/tomchristie/django-rest-framework/blob/master/rest_framework/renderers.py#L333), but cannot find it when a permission or nonauthenticated exception is raised.\n"},{"labels":["documentation"],"text":"Clicking the [\"please see the version 2.x documentation\"](http://www.django-rest-framework.org/topics/release-notes/) link on the bottom of the release notes page returns 404.\n"},{"labels":["documentation"],"text":"I think the documentation would be improved by more information on the benefits of each feature, rather than just how to implement it.\n\nBefore getting into examples, I'll briefly describe my personal use case for some context:\n\nI got into DRF mainly because we wanted JWT auth for Django. We are building an API for our angular front end, but it's not going to be a public API (at first), so we don't necessarily get a ton of benefit from being able to serialize into formats other than JSON. We are using Django's ORM, but on some of our endpoints we're doing some complex validation and transformation of data coming from the client before we can store it.\n\nSpecific examples:\n\n1) Serializers - there are dozens of pages of documentation on serializers, but only a couple paragraphs about the actual benefits. I'm trying trying to figure out the best practices on:\n- When to use vs. not use serializers.\n- More information on the benefits that serializers provide.\n- Best practices and examples of endpoints that use DRF without serializers.\n\n2) \"Most of the time you're dealing with validation in REST framework you'll simply be relying on the default field validation, or writing explicit validation methods on serializer or field classes.\"\n\nThis could really be expanded into a paragraph or two. E.g. when should you rely on default field validation, vs. writing explicit validation methods. \n\n3) How do serializer relationships correspond with model relationships? E.g. if I have two models with a relationship, do my serializers need to reflect that relationship? Can I have extra relationships between serializers that aren't in my models? If so, what are the benefits as opposed to having the relationship in the models.\n\nMost of the docs and tutorial material assume that you're going to be on the 'happy path' of having a model and turning some of the fields on that model into an endpoint. And even if that's true for most of your endpoints, inevitably most apps are going to have some endpoints where you're going to need to do things that don't fit into this model. More guidance here on best practices would be super useful.\n"},{"labels":["documentation"],"text":"Time to remove the 'docs for 3.0' banners from API guide pages, and only continue including on the homepage and GitHub README.\n\nThe text for those should also change, now that we're on 3.1.\n\n![screen shot 2015-03-06 at 23 15 30](https://cloud.githubusercontent.com/assets/647359/6538178/d206a76a-c456-11e4-82a7-4782deba66fd.png)\n"},{"labels":["documentation"],"text":"Saw the announcement and looks like some great improvements. Thanks!\n\nhttp://www.django-rest-framework.org/api-guide/serializers/\n\nhttps://github.com/tomchristie/django-rest-framework/blob/master/docs/api-guide/serializers.md :1017\n\n\"Customizing the default fields\"\nMakes reference to a part of the 3.0 which has now been updated in 3.1.\n"},{"labels":["documentation"],"text":"As per a previous conversation with @tomchristie, we're wondering if we should be recommending [djangorestframework-jwt](http://getblimp.github.io/django-rest-framework-jwt/) as a preferred package for _proper_ token authentication.\n"},{"labels":["documentation"],"text":"The `rest_framework.views.exception_handler` method is defined as [1]:\n\n```\ndef exception_handler(exc, context):\n    ...\n```\n\nWhich requires a context parameter that is never used in the method itself.  I would suggest either removing the context param, or adding **kwargs instead so no context has to be passed.\n\nOr add documentation as to why it would be needed there or what it even is.\n\n[1] https://github.com/tomchristie/django-rest-framework/blob/4248a8d3fc725d9ae3fe7aaaad7ee12479ab07ab/rest_framework/views.py#L52\n"},{"labels":["documentation"],"text":"Link at `http://www.django-rest-framework.org/api-guide/testing/#apiclient` is dead.\nThe one at `Extends Django's existing Client class.`. It should point to `https://docs.djangoproject.com/en/dev/topics/testing/tools/#the-test-client`\n\nAlso `The APIClient class supports the same request interface as APIRequestFactory.` should have been `The APIClient class supports the same request interface as Client.`?\n"},{"labels":["documentation"],"text":"https://github.com/tomchristie/django-rest-framework/blob/master/docs/tutorial/1-serialization.md#creating-a-serializer-class\n\nThe section on creating a serializer class has a line saying \n\n\"The {'base_template': 'textarea.html'} flag above is equivelent to using widget=widgets.Textarea ....\"\nThe example actually however has \n`code = serializers.CharField(style={'type': 'textarea'})`\n"},{"labels":["documentation"],"text":"As stated [here](http://www.django-rest-framework.org/api-guide/exceptions/), all error responses based on `APIException` should include a `detail` key in the response body.\n\nBecause of the special handling of `list` and `dict` in `exception_handler(exc)` (see [here](https://github.com/tomchristie/django-rest-framework/blob/master/rest_framework/views.py#L67)) this is not the case for ValidationErrors.\n\nI think the behavior should be changed, such that `dict` and `list` details are also wrapped in a `detail` key.\n"},{"labels":["documentation"],"text":"See: https://github.com/tomchristie/django-rest-framework/blob/master/docs_theme/404.html#L64\n\nPossibly also see https://github.com/tomchristie/mkdocs/issues/77 may not be as simple as adding the nav in.\n"},{"labels":["documentation"],"text":"I just realized the nested section should be extended. There are some questions about it and it isn't that documented (#2309 for example).\n"},{"labels":["documentation"],"text":"In the /tutorial/1-serialization/ documentation it says to do the following.\n\n``` python\n# This import will use either `StringIO.StringIO` or `io.BytesIO`\n# as appropriate, depending on if we're running Python 2 or Python 3.\nfrom rest_framework.compat import BytesIO\n\nstream = BytesIO(content)\ndata = JSONParser().parse(stream)\n```\n\nHowever I'm getting this ...\n\n``` console\n>>> from rest_framework.compat import BytesIO\nTraceback (most recent call last):\n  File \"<console>\", line 1, in <module>\nImportError: cannot import name BytesIO\n>>> import rest_framework\n>>> print(rest_framework.VERSION)\n3.0.1\n```\n"},{"labels":["documentation"],"text":"Hello,  \nI just found something confusing while reading the docs about generic relations in the serializer relations section :  \n![rest_typo](https://cloud.githubusercontent.com/assets/5165169/5446969/169bf774-84c7-11e4-901b-d8814df2b4c5.png)\n\nThe sentence mentions the `.to_native()` method while the example code shows `def to_representation()`.\n\nBtw, thank you for your wonderful work !\n"},{"labels":["documentation"],"text":"Using [i18n_patterns](https://docs.djangoproject.com/en/dev/topics/i18n/translation/#django.conf.urls.i18n.i18n_patterns) as the following:\n\n``` python\nurlpatterns = i18n_patterns('',\n    url('news', 'myviews.news', name='news')\n)\nurlpatterns = format_suffix_patterns(urlpatterns)\n```\n\nBreaks the [LocaleMiddleware](https://docs.djangoproject.com/en/dev/ref/middleware/#django.middleware.locale.LocaleMiddleware)'s assumption that localized urls are resolved using the `LocaleRegexURLResolver` class resulting in:\n\n``` python\n>>> from django.core.urlresolvers import reverse\n>>> from django.utils.translation import activate\n>>> reverse('news')\n'/en-us/news/'\n>>> activate('ja')\n>>> reverse('news')\n'/en-us/news/' # The returned value should be /ja/news/\n```\n\nRemoving the call to `format_suffix_patterns` causes the reverse method to resolve the URLs correctly.\n\n``` python\nurlpatterns = i18n_patterns('',\n    url('news', 'myviews.news', name='news')\n)\n```\n\n``` python\n>>> from django.core.urlresolvers import reverse\n>>> from django.utils.translation import activate\n>>> reverse('news')\n'/en-us/news/'\n>>> activate('ja')\n>>> reverse('news')\n'/ja/news/'\n```\n\nCould this be fixed and backported to 2.4?\n"},{"labels":["documentation"],"text":"If the API requires a hyperlinked relationship that does not have a single `lookup_field` then the user will need to create a custom relationship in order to handle this. We should document an example of how to do this.\n"},{"labels":["documentation"],"text":"We should outline our project managment processes.\n- To help contributors see what they need to do to become maintainers.\n- In order to help current and future maintainers.\n- In order to codify everything and ensure transparency.\n- In order to demonstrate  the increasing bus-factor of the project and show that we've moving towards long-term stability.\n\nIn particular we should document our policy on selecting and renewing the maintenance team, see #2190. And our release process, see #2233.\n"},{"labels":["documentation"],"text":"Opening this pre-emptively so that we don't forget.\n- `README.md`\n- `docs/index.md`\n- `rest_framework/__init__.py`\n"},{"labels":["documentation"],"text":"There is almost no documentation about what `has_permission` is for. The permission documentation page directly jumps to \"Object level permissions\"\n"},{"labels":["documentation"],"text":"As for this morning, the tutorial code is broken on master.\nIdeally we should find a way to have some tests against it.\n"},{"labels":["documentation"],"text":"We should add .validated_data here. Opening the issue as I've not had time to check what it would return, but wanted to make sure we track this...\n\n```\nserializer = SnippetSerializer(data=data)\nserializer.is_valid()\n# True\nserializer.save()\n# <Snippet: Snippet object>\n```\n"},{"labels":["documentation"],"text":"Working through [Django Rest Framework Tutorial - Serialization](http://www.django-rest-framework.org/tutorial/1-serialization/)\n\nIn `SnippetSerializer(serializers.Serializer)`:\n\n``` python\ntitle = serializers.CharField(required=False, max_length=100)\n```\n\nGives an error: `('title': ['This field may not be blank.'])`\n\nModel:\n\n``` python\n# Added null=True to see if that had any effect which it did not.\ntitle = models.CharField(max_length=100, blank=True, null=True, default='') \n```\n\n``` python\nPython 3.4.2 (default, Nov 20 2014, 15:46:21) \n[GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.54)] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n(InteractiveConsole)\n>>> from snippets.models import Snippet\n>>> from snippets.serializers import SnippetSerializer\n>>> from rest_framework.renderers import JSONRenderer\n>>> from rest_framework.parsers import JSONParser\n>>> snippet = Snippet(code='foo = \"bar\"\\n')\n>>> snippet.save()\n>>> snippet = Snippet(code='print \"hello, world\"\\n')\n>>> snippet.save()\n>>> serializer = SnippetSerializer(snippet)\n>>> serializer.data\nReturnDict([('pk', 5), ('title', ''), ('code', 'print \"hello, world\"\\n'), ('linenos', False), ('language', 'python'), ('style', 'friendly')])\n>>> content = JSONRenderer().render(serializer.data)\n>>> content\nb'{\"pk\":5,\"title\":\"\",\"code\":\"print \\\\\"hello, world\\\\\"\\\\n\",\"linenos\":false,\"language\":\"python\",\"style\":\"friendly\"}'\n>>> from rest_framework.compat import BytesIO\n>>> stream = BytesIO(content)\n>>> data = JSONParser().parse(stream)\n>>> serializer = SnippetSerializer(data=data)\n>>> serializer.is_valid()\nFalse\n>>> serializer.errors\nReturnDict([('title', ['This field may not be blank.'])])\n>>> \n```\n"},{"labels":["documentation"],"text":"The search button on the old docs archive returns results from the new 3.0 docs.\n"},{"labels":["documentation"],"text":"Problem:\nIt seems as though the code listed under the .update() method for nested serializers in /docs/api-guide/serializers.md might be potentially incorrect. The variable 'user' does not exist in the method's context, and looking at the internals for the .update() method on the ModelSerializer class - it seems as though 'user' might really want to be 'instance'. I _think_ the flow is that instance is the model object that you are potentially updating, and the validated data is what your going to potentially update the model object 'instance' with in the scope of the function. The earlier documentation on that page also seems to suggest that you want to be using 'instance' inside the nested .update() function. \n\nCurrent Documentation:\nHere's an example for an update() method on our previous UserSerializer class.\n\n```\ndef update(self, instance, validated_data):\n    profile_data = validated_data.pop('profile')\n    # Unless the application properly enforces that this field is\n    # always set, the follow could raise a `DoesNotExist`, which\n    # would need to be handled.\n    profile = instance.profile\n\n    user.username = validated_data.get('username', instance.username)\n    user.email = validated_data.get('email', instance.email)\n    user.save()\n\n    profile.is_premium_member = profile_data.get(\n        'is_premium_member',\n        profile.is_premium_member\n    )\n    profile.has_support_contract = profile_data.get(\n        'has_support_contract',\n        profile.has_support_contract\n     )\n    profile.save()\n\n    return user\n```\n\nBecause the behavior of nested creates and updates can be ambiguous, and may require complex dependancies between related models, REST framework 3 requires you to always write these methods explicitly. The default ModelSerializer .create() and .update() methods do not include support for writable nested representations.\n\nPotential Rework:\n\n```\ndef update(self, instance, validated_data):\n    profile_data = validated_data.pop('profile')\n    # Unless the application properly enforces that this field is\n    # always set, the follow could raise a `DoesNotExist`, which\n    # would need to be handled.\n    profile = instance.profile\n\n    instance.username = validated_data.get('username', instance.username)\n    instance.email = validated_data.get('email', instance.email)\n    instance.save()\n\n    profile.is_premium_member = profile_data.get(\n        'is_premium_member',\n        profile.is_premium_member\n    )\n    profile.has_support_contract = profile_data.get(\n        'has_support_contract',\n        profile.has_support_contract\n     )\n    profile.save()\n\n    return instance\n```\n"},{"labels":["documentation"],"text":"Opened issued to not forget it.\n\nFrom IRC:\n\n```\ntomchristie > Maybe worth raising an issue on https://github.com/jpadilla/django-rest-framewo... that it should also point to OAuth toolkit as an alternative on the README.me and index.md?\nmaryokhin > wouldn't it be a bit confusing to go to that package and then find you're supposed to use the other one? \nmaybe just point in DRF docs that recommended now is oauth-toolkit, \nbut here's the thingy we moved out of core for those that don't want to stir up life too much? \ntomchristie > That's exactly how we should describe it, yes ^\n```\n"},{"labels":["documentation"],"text":"Imports are missing in various places in the documentations and is frustrating for beginners. Update documentation in one of two ways:\n- have imports in every example\n  _OR_\n- have general import indications at the beginning of each topic, e.g. at validators topic something like \"Validators can be imported from rest_framework.validators\"\n"},{"labels":["documentation"],"text":"I create a barebones `ModelSerializer` for a model with a required `ForeignKey` to `User`. Intending to set the relation in `perform_create` I add the field to the `read_only_fields` Meta attribute. \n\nIf I do nothing else I get an AssertionError as the auto generated field is:\n\n```\nPrimaryKeyRelatedField(read_only=True, required=True)\n```\n\nOK. Rightly this doesn't make sense. \n\nBut I here need to declare the `PrimaryKeyRelatedField` in order to set `required=False` manually. Better would be that setting `read_only=True` makes `required=False`.\n\nNo problem at all putting a test together for this. I haven't looked re a fix.\n"},{"labels":["documentation"],"text":""},{"labels":["documentation"],"text":"It's a useful pattern for raising `serializers.ValidationError` with a message take from the `error_messages` dictionary. We should promote it to public API.\n"},{"labels":["documentation"],"text":"Including, but not necessarily limited to:\n- Textarea vs input for string inputs.\n- Radio vs select for choices, and for relations.\n- Ensure boolean fields support choice styles.\n\nPrimarily documentation, but may also include some development work on finalizing the API.\n"},{"labels":["documentation"],"text":"Hi there so my question is probably about best practices when organizing ViewSets and the corresponding Routers in Django Rest Framework.\n\nAccording to the official documentation, the routers should be stored in the urls.py and the viewsets should be stored in views.py.\n\nMy idea of an approach would be having the viewsets in a separate file like for example viewsets.py so that we don't end up mixing the normal Django views and the DRF Viewsets in the same file, improving readability.\n\nThe same would go for the routers where we would creaate a file called routers inside each app and register then with the main Default router instance.\n\nThese are my thoughts, but i am not sure how to:\n\n1º Do this the proper way (the registering of the viewsets routers and all, should i place DefaultROuter in the **init**.py ?)\n\n2º Is there a better approach?\n\nBasically i want to separate the logic per app and inside each app separate by django views and DRf viewsets\n"},{"labels":["documentation"],"text":"It's probably time for a refresh of the homepage.\n\nGiven that REST framework is being used by folks like Mozilla, Eventbrite, Heroku, Sentry, Disqus, Ansible we really should make the best of highlighting this.\n\nWe could also consider if we need a simpler `@api_view` type example or if we need to refresh the example in any way.\n\nDrop the twitter badge in favor of a PyPI version badge.\n"},{"labels":["documentation"],"text":"I've found myself digging through the source code of rest_framework a lot to really get a grasp on how DRF processes a requests; sometimes I'm unsure of who calls what.\n\nTasty pie has an [excellent writeup on the its general flow from request to response flow for a simple GET request](http://django-tastypie.readthedocs.org/en/latest/resources.html#flow-through-the-request-response-cycle):\n\n> - The Resource.urls are checked by Django’s url resolvers.\n> - On a match for the list view, Resource.wrap_view('dispatch_list') is called. wrap_view provides basic error handling & allows for returning serialized errors.\n> - Because dispatch_list was passed to wrap_view, Resource.dispatch_list is called next. This is a thin wrapper around Resource.dispatch.\n> - dispatch does a bunch of heavy lifting. It ensures:\n>   - the requested HTTP method is in allowed_methods (method_check),\n\nDRF has excellent documentation for many of its individual components; it would be tremendously helpful if DRF had a page that outlined, generally, how the package works.  What is the general flow of the innards--how does DRF process a typical request --> response?\n\nThanks @tomchristie for such an excellent package!\n"},{"labels":["documentation"],"text":"In 2.x save_object was documented as follows:\n\n> You can override the default save behaviour by overriding the .save_object(obj) method on the serializer class.\n\nsave_object is no longer available in 3.x. Whilst it's not a big issue to override save, create or update depending on your need, it might be worth mentioning in the release notes to ease migration?\n"},{"labels":["documentation"],"text":"Nicer and more usable than curl.\n\nhttps://github.com/jakubroztocil/httpie\n"},{"labels":["documentation"],"text":"We don't currently document that we support translatable error messages or detail how a client or the developer can select the language. We should also ensure that we are wrapping everything in proper translation strings consistently.\n"},{"labels":["documentation"],"text":"Include some examples of dealing with nested serialization, including demonstrations of cases when automatic behaviors would be ambiguous.\n\nRelated to this: consider if and how we support something similar to allow_add_remove.\n"},{"labels":["documentation"],"text":"Typically I would consider this sort of thing as out of scope, but given the large ecosystem we're encouraging I think this would actually be worth the effort/reward.\n- Document writing and publishing third party packages.\n- Include cookiecutter with sane `setup.py`, `runtests.py`, `MAINFEST.in`, `tox.ini`, `.travis.yml` etc. etc. to make it super easy for package authors to push a new package.\n\nRight now the barrier to new packages is simply too high. If we could bring that down we could encourage more folks to publish their own base classes, and have a better story when asking tickets for built-in functionality to be closed in favour of a more distributed ecosystem.\n"},{"labels":["documentation"],"text":"Right now the docs for the special value just say:\n\n> The value source='*' has a special meaning, and is used to indicate that the entire object should be passed through to the field. This can be useful for creating nested representations. (See the implementation of the PaginationSerializer class for an example.)\n\nAnd as far as the `PaginationSerializer`, the entire [implementation is just this](https://github.com/tomchristie/django-rest-framework/blob/b106ebd2c0a19107f12d5b87cfbe0083aaaa60b9/rest_framework/pagination.py#L77).\n\nWhat exactly does the `*` do and what would happen in the case of `PaginationSerializer` if it were omitted? \n"},{"labels":["documentation"],"text":"See discussion in #1994.\n\nReiterating my comment there...\n\nStrongly in favour of documenting something like this...\n\n```\ndef obj_to_representation(self, obj):\n      return dict([(f.field_name, f.to_representation(getattr(obj, f.field_name)))\n                        for f in self.fields.values()])\n```\n\nNot sure about pulling the source into the package tho - rather call it out very explicitly as an example, but _force_ folks to deal with any of the subtleties of the limitations it introduces themselves. Pulling it into core we'd almost certainly get 'but it doesn't work in XYZ case' etc...\n\nThis would also be a good conversation to have around where we introduce `BaseSerializer`...\n\nhttps://github.com/tomchristie/django-rest-framework/blob/version-3.0/docs/topics/3.0-announcement.md#the-baseserializer-class\n\nNoting that you  don't always need to be using `BaseSerializer` in order to get big performance improvements.\n"},{"labels":["documentation"],"text":"The project maintainers should be properly called out in the documentation.\nThat could either be in the credits, in the README/homepage, or in the contributing section.\n(Or most likely several of the above places)\n\nWe also need to codify the privileges, responsibilities and processes of maintainership in the documentation, so that it's transparent and to reduce bus-factor.\n"},{"labels":["documentation"],"text":"Currently relationships do not automatically apply the same set of permissions and filtering that are applied to views. If you need permissions or filter on relationships you need to deal with it explicitly.\n\nPersonally I don't see any good ways of dealing with this automatically, but it's obviously something that we could at least do with documenting better.\n\nRight now my opinion is that we should try to come up with a simple example case and document how you'd deal with that explicitly. Any automatic code for dealing with this should be left for third party package authors to handle. This allows other contributors to explore the problem and see if they can come up with any good solutions that could potentially be included in core.\n\nIn the future this issue might get promoted from 'Documentation' to 'Enhancement', but unless there's any concrete proposals that are backed up by a third part package then it'll stay in this state.\n"},{"labels":["documentation"],"text":"In both the generic view and serializer sections we need to make sure we're pointing out appropriate usage of `select_related`/`prefetch_related`.  (To review: is there anything in there at the moment?)\n\nAlso see #1976.\n"},{"labels":["documentation"],"text":"General style & usage tips etc. Including:\n- Good API style.\n- querysets and `select_related`, `prefetch_related`, `only`.\n- DB indexes, particularly wrt filters, relationships, view lookups.\n- Model encapsulation.\n- Thin serializers, thick models.\n- Avoid mixins where possible.\n- Don't set instance attributes on views.\n"},{"labels":["documentation"],"text":"I get this error:\n\n```\nTraceback (most recent call last):\n  File \"./mkdocs.py\", line 149, in <module>\n    main_title = main_title + ' - Django REST framework'\nTypeError: unsupported operand type(s) for +: 'NoneType' and 'str'\n```\n"},{"labels":["documentation"],"text":"If I run `tox` — to test everything — followed by `runtests.py` — to test what I'm working on more quickly — I get a `ValueError` (or lots of them) as `pytest` tries to collect tests. \n\n```\n../../../.pyenv/versions/drf2.7/lib/python2.7/site-packages/py/_path/local.py:642: in pyimport\n    __import__(modname)\n../../../.pyenv/versions/drf2.7/lib/python2.7/site-packages/_pytest/assertion/rewrite.py:134: in find_module\n    co = _read_pyc(fn_pypath, pyc)\n../../../.pyenv/versions/drf2.7/lib/python2.7/site-packages/_pytest/assertion/rewrite.py:311: in _read_pyc\n    co = marshal.load(fp)\nE   ValueError: bad marshal data (unknown type code)\n```\n\nNoting the `in _read_pyc` I resolve the issue simply: \n\n```\n $ find . -name '*.pyc' -delete\n```\n\nI'm just wondering if this would be handy as part of `runtests.py`? (Anyone else bumping into this?)\n\nIf so I'm happy to make the pull request. If not do close. \n"},{"labels":["documentation"],"text":"Hi,\nI'm building an API that needs Hyperlinked Relations and some Object Permissions which are handled well by Django Guardian. While I was doing some tests, I saw that Rest Framework doesn't check if I have the permissions to update an object posted as related.\n\nLet's say I got these two models in Django : \n\n``` python\nclass Identity(models.Model):\n    name = models.CharField(_('name'), max_length=250, blank=False, null=False)\n\nclass Contact(models.Model):\n    identity = models.ForeignKey(Identity, null=False, related_name='contact_methods')\n    value = models.CharField(_('value'), max_length=250, blank=False)\n```\n\nand these serializers : \n\n``` python\nclass IdentitySerializer(HyperlinkedModelSerializer):\n\n    class Meta:\n        model = Identity\n        fields = ('url',\n                  'name',)\n\nclass ContactSerializer(HyperlinkedModelSerializer):\n\n    class Meta:\n        modal = Contact\n        fields = ('url',\n                  'value',\n                  'identity',)\n```\n\nNow let's imagine that in my App there are a lot of identities, but I can only access mine thanks to Django Guardian. Let's say that the URL of my identity is : \nhttp://api.example.com/identities/1\nI'm supposed to have the permission to update only this identity.\nNow if I make a POST request of a Contact object with this URL as 'identity' field, this should work: \n\n``` bash\ncurl -X POST\n    -L http://api.example.com/contacts/\n    -H 'Authorization: Token 78087744a51bd55c5145ea6110422f053dd31a6e'\n    -H 'ContentType: application/json'\n    --data '{\"value\": \"555-555-555\", \"identity\": \"http://api.example.com/identities/1\"}'\n```\n\nand we expect this one to fail because we don't have the permissions on the identity 46747\n\n``` bash\ncurl -X POST\n    -L http://api.example.com/contacts/\n    -H 'Authorization: Token 78087744a51bd55c5145ea6110422f053dd31a6e'\n    -H 'ContentType: application/json'\n    --data '{\"value\": \"555-555-555\", \"identity\": \"http://api.example.com/identities/46747\"}'\n```\n\nBut the two requests succeed, and the second object gets updated without having permission on it.\nI looked up into the Rest Framework code to know where exactly the problem is, and I came up on this method in **relations.py** : \n\n``` python\n    def get_object(self, queryset, view_name, view_args, view_kwargs):\n        \"\"\"\n        Return the object corresponding to a matched URL.\n\n        Takes the matched URL conf arguments, and the queryset, and should\n        return an object instance, or raise an `ObjectDoesNotExist` exception.\n        \"\"\"\n        lookup = view_kwargs.get(self.lookup_field, None)\n        pk = view_kwargs.get(self.pk_url_kwarg, None)\n        slug = view_kwargs.get(self.slug_url_kwarg, None)\n\n        if lookup is not None:\n            filter_kwargs = {self.lookup_field: lookup}\n        elif pk is not None:\n            filter_kwargs = {'pk': pk}\n        elif slug is not None:\n            filter_kwargs = {self.slug_field: slug}\n        else:\n            raise ObjectDoesNotExist()\n\n        return queryset.get(**filter_kwargs)\n```\n\nThere isn't any implementation of permissions checking here. The framework just checks if the object exists on a given URL and that's all.\n\nFor the moment I made a little patch on my App by rewriting the create methods of my ContactViewSet and manually checking if the user has the permission by getting the object myself and performing a `user.has_perm(obj, 'can_update_object')` on it but I think this isn't clean at all. \nDo you have any other suggestions to fix this ?\n\nFor the long term, is there any implementation of permission checking on related objects planned ?\n"},{"labels":["documentation"],"text":"URL confs do not use `url` in 1.7+\nWe should update the tutorial and include an explicit note that it is against 1.7.\n"},{"labels":["documentation"],"text":"At some point in the past we stopped being consistent in adding contributers [to the credits](http://www.django-rest-framework.org/topics/credits), and eventually gave up on adding anyone at all, due to:\n- Wasn't clear if we should add folks for single-character docs fixes.\n- Not clear if we add someone if they did some work, that got rolled into a subsequant PR from someone else.\n- We simply had too many ! :) new contributions and it was awkward updating that page all the time.\n\nWe need to decide what to do with this page.\nGitHub's [list of contributors](https://github.com/tomchristie/django-rest-framework/graphs/contributors) only includes 100 people of 291. Can we get everyone through the GitHub API. Do we want to try to update that page all the time or is it too difficult? What process do we use for updating the page if we do want to? Perhaps just include text on that page saying something along the lines of \"If you've made a contribution to Django REST framework please feel free to make a pull request adding yourself to this list\" etc.etc.\n\nFor context:\n\n![screen shot 2014-09-05 at 13 05 54](https://cloud.githubusercontent.com/assets/647359/4164475/168510e4-34f5-11e4-99f1-8868795d8034.png)\n...[continues]\n"},{"labels":["documentation"],"text":"Docs say rest_framework.authtoken has Django 1.7-compatible migrations, but this is only true for Github. The canonical version on PyPi does not. Either the docs should be reverted, or a new release should be pushed.\n"},{"labels":["documentation"],"text":"Currently the documentation is built using the `mkdocs.py` script in the repo.\nThis is pretty hacky. It's awkward to add new sections and easy to miss something when you do add a new section. We should move to using [MkDocs](http://mkdocs.org), for the documentation, as be a better supported, cleaner version of the current script.\n\nUsing MkDocs will also allow us to use richer interlinking, once it properly supports nicer topic links, and will make it easier for us to notice when links are broken or missing etc...\n\nWe could either use the MkDocs default theme, or stick with the existing style, as a custom MkDocs theme.\n\nTo do (for anyone): Build the current docs with `MkDocs`, figure out what features we're still missing, which parts of the docs will need work etc...\n"},{"labels":["documentation"],"text":"1)\nI believe that `data` is a list here so if there is an exception, then this assignment will fail:\n\n```\n    def resolve_context(self, data, request, response):\n        if response.exception:\n            data['status_code'] = response.status_code\n        return RequestContext(request, data)\n```\n\n2) These dict reads use `[ ]` rather than `get` so will fail if `renderer_context` is null or empty when passed in even with the `or`:\n\n```\n        renderer_context = renderer_context or {}\n        view = renderer_context['view']\n        request = renderer_context['request']\n        response = renderer_context['response']\n```\n\n3) There is no documentation on how to write a template that works with this renderer. Specifically it is not clear what gets set in the context. \n\n4) I actually think that nothing gets set in the context and this render should be fixed as (at least for Listing):\n\n```\nclass TemplateHTMLRenderer2(TemplateHTMLRenderer):\n    def context_object_name(self, renderer_context):\n        renderer_context = renderer_context or {}\n        view = renderer_context['view']\n\n        if hasattr(view, 'get_context_object_name'):\n            return view.get_context_object_name()\n        elif hasattr(view, 'context_object_name'):\n            return view.context_object_name\n\n    def render(self, data, accepted_media_type=None, renderer_context=None):\n        data = {self.context_object_name(renderer_context): data}\n        return super(TemplateHTMLRenderer2, self).render(data, accepted_media_type, renderer_context)\n```\n"},{"labels":["documentation"],"text":"I find that, particularly when it comes to POST methods, that I often need a different serializer for input than for output. E.g., for a a particular model I may need only two or three input values, but the server will calculate/retrieve/whatever some additional values for fields on the model, and all those values need to get back to the client.\n\nSo far, my method has been to override `get_serializer_class()` to specify a separate input serializer for the request, and then override `create()` to use a different serializer for my output. That pattern works, but it took me some time to figure it out because the docs don't  really suggest that option; the assumption that the generic APIViews are built around is that you specify one serializer and that is used for both input and output. I agree this generally works in the common case, but using my method breaks a little bit of the CBV magic. In particular, it can be difficult to troubleshoot if you make a mistake specifying a custom output serializer.\n\nI propose two solutions:\n1. Build a consistent way to optionally specify different input and output serializers, or\n2. Add some additional documentation explaining the presumption that one serializer is intended for input _and_ output, and best practices for overriding that in the case that the default behavior doesn't suit your use case.\n"},{"labels":["documentation"],"text":"Hello all,\n\nI don't know it is a bug or a documentation omission.\n\nWe can notice in the documentation:\n\"Note that using a paginate_by value of None will turn off pagination for the view.\"\n\nBut if we use in settings `PAGINAGE_BY` and `PAGINGATE_BY_PARAM`, for example:\n\n```\n'PAGINATE_BY': 25,\n'PAGINATE_BY_PARAM': 'limit'\n```\n\nand if we have the following view:\n\n```\nclass MyList(generics.ListAPIView):\n    # turn off pagination\n    paginate_by = None\n    queryset = MyEntity.objects.all()\n    serializer_class = MySerializer\n```\n\ndue to this code:\n(from generics.py):\n\n```\ndef get_paginate_by(self, queryset=None):\n    ....\n    if self.paginate_by_param:\n        try:\n            return strict_positive_int(\n                self.request.QUERY_PARAMS[self.paginate_by_param],\n                cutoff=self.max_paginate_by\n            )\n        except (KeyError, ValueError):\n            pass\n    return self.paginate_by\n```\n\nIf we make request to this view with param limit (it's specified as PAGINATE_BY_PARAM), the pagination would work.\n\n```\nGET /myentity/ pagination doesn't work. (GOOD)\nGET /myentity/?limit=10 pagination works (BAD. Even though we set paginate_by=None in the view pagination works)\n```\n\nIn order to achieve turning off pagination for all requests, we also have to set paginate_by_param = None:\n\n```\nclass MyList(generics.ListAPIView):\n    # turn off pagination\n    paginate_by = None\n    paginate_by_param = None  # added to turn off pagination for requests that contain paginate_by_param\n    queryset = MyEntity.objects.all()\n    serializer_class = MySerializer\n```\n\nOr of course, we can achieve it by changing the code in generics.py\n"},{"labels":["documentation"],"text":"I (and maybe others) will have a bit of time during December/January for DRF related matters.\n\nThe main difficulty is staying on top of where we're at. It would be **really good** if @tomchristie could find an hour or so before then to review the Roadmap. (This hasn't been edited in 7 months, and a lot has happened since then.)\n\nI like seeing what's been crossed off but what's pressing now? And where's the latest discussion on that? What are the goals for 2014?\n"},{"labels":["documentation"],"text":"I'm a new user to django-rest-framework and ran into several issues, so I thought I'd post them here to see if any pieces of the quickstart docs should be updated to help others avoid the same.\n\n1) A quick first backwards-incompatible django change to consider updating for a new-users focused quickstart:\n\nOn django 1.6 the first line of the home page example blows up:\n\nfrom django.conf.urls.defaults import url, patterns, include\n\nneeds to be:\n\nfrom django.conf.urls import url, patterns, include\n\n2) The framework doesn't seem to work with django-admin.  \n\nI took the basic poll site with django 1.6 (I also tried 1.5.5 and ran into the same issues) with py3.3.2 and pip installed the framework, updated the settings.py as per home page, and completely overrode the urls.py with what was on the home page of django-rest-framework.\n\nAt first, everything didn't work due to:\n\nIn template /home/taras/Envs/django1/lib/python3.3/site-packages/rest_framework/templates/rest_framework/form.html, error at line 9\n\nCould not resolve URL for hyperlinked relationship using view name \"permission-detail\". You may have failed to include the related model in your API, or incorrectly configured the `lookup_field` attribute on this field.\n\nI tested in another browser where I was not logged into django-admin as an admin beforehand, and that worked perfectly.\n\nI also tried this on another site, leaving the main urls.py file with /admin/ urls intact and had the same issue.\n\nI tried changing the default permissions thinking that might be somehow related to:\n\n'DEFAULT_PERMISSION_CLASSES': ('rest_framework.permissions.IsAdminUser',),\n\n and the non-logged browers got a correct json message saying credentials were not provided, and still a stack trace on the other.\n\nAny help with #2 would be great, and let me know if you need additional info.  Thanks!\n"},{"labels":["documentation"],"text":"http://django-rest-framework.org/api-guide/relations.html#hyperlinkedrelatedfield\n\nif I have already defined the viewset and added it to the router for a target related field, isnt the view and its name defined already by DRF somewhere? Seems redundant to define a view by hand for the default case.. thanks in advance.. \n"},{"labels":["documentation"],"text":"Dot character \".\" is valid non special character of URL path, but it can not be used by framework is router is set up with trailing slash disabled.\n\nThis causes a bug which is hard to locate because this is undocumented side-effect.\n"},{"labels":["documentation"],"text":"http://django-rest-framework.org/api-guide/viewsets.html#modelviewset\n\nIt says:\n\n> Because ModelViewSet extends GenericAPIView, you'll normally need to provide at least the queryset and serializer_class attributes.\n\nBut I can also use the model attribute and create a ModelViewSet that does not need a serializer:\n\n``` python\nfrom app1.models import Dish\n\nclass DishViewSet(viewsets.ModelViewSet):\n    model = Dish\n```\n\nI consider that even less than providing `at least the queryset and serializer_class attributes`.\n"},{"labels":["documentation"],"text":"First of all, I am quite new to Django and installed your framework today. I love to dive into new things, rather than study them beforehand. Learning by doing.\n\nHaving this said, I found it quite difficult to understand the content of the [installation example](http://django-rest-framework.org/) (IE) and the [quickstart](http://django-rest-framework.org/tutorial/quickstart.html) (QS).\n\nThe IE uses the very basic way to provide a working API. I used this to implement your framework. Later I dived into the QS, which let me quite confused because the approach is very different. (This is related to #1127.)\n\nFrom a beginners point-of-view I would suggest to quickly take up the IE code and explain that you can enhance it to have more control over the way the framework handles models. State that the serialiser is used to hide certain fields. Explain the differences of the view sets. Also state that for simple things, the IE code is fine. (It works for most of my purposes and it's nice to keep it slim.)\n\nI would even dare to propose to have both in the quickstart and make two chapters: _basic_ or _simple_ and something like _quickstart with more control_.\n\nJust throwing this thought out in the open. I believe it could help beginners like me to dive into your framework.\n"},{"labels":["documentation"],"text":"I propose to change the [serializer part](https://github.com/tomchristie/django-rest-framework/blob/master/docs/tutorial/quickstart.md) and explain, that it is only necessary if you need more control and that, in the case of the quickstart guide, it is used to only display certain fields (and hide fields like `date_joined` and `last_logon`).\n\nIt's not necessarly required for easy models, e. g. like:\n\n``` python\nclass Dish(models.Model):\n    name = models.TextField()\n\n    def __unicode__(self):\n        return self.name\n```\n\nCurrently it looks like it is required and I find that confusing. That might clear up things.\n"},{"labels":["documentation"],"text":"Let's look at the section on testing: http://django-rest-framework.org/api-guide/testing.html\n\nI'm told to use `APIRequestFactory`. Okay then, what now?\n1. The import location, `rest_framework.tests.APIRequestFactory` is located after numerous code examples, approximately 75% inside. \n2. On the same page, `encode_multipart` is called but there is no import or source provided.\n## Solution\n\nFor core Django, I suggested that the first time any object is used on a page, an import is made. This turns even topical documentation into really useful reference documentation. I submit that django-rest-framework do the same.\n"},{"labels":["documentation"],"text":"I'm on verssion 2.3.7 and documentation states:\n\n```\nNote: In versions 2.0 and 2.1, the signature for the permission checks always included an optional obj parameter, like so: .has_permission(self, request, view, obj=None). The method would be called twice, first for the global permission checks, with no object supplied, and second for the object-level check when required.\n\nAs of version 2.2 this signature has now been replaced with two separate method calls, which is more explicit and obvious. The old style signature continues to work, but its use will result in a PendingDeprecationWarning, which is silent by default. In 2.3 this will be escalated to a DeprecationWarning, and in 2.4 the old-style signature will be removed.\n```\n\nBut when i try to use `.has_object_permission(self, request, view, obj)` the method is not runned. The only way to get my custom permission working properly is using `has_permission(self, request, view, obj=None)` witch is supposed to throw a DeprecationWarning but is actually throwing PendingDeprecationWarning.\n"},{"labels":["documentation"],"text":"I've created sub-class of DefaultRouter and [as the API Guide says is possible](http://django-rest-framework.org/api-guide/routers.html#example), I tried to override the `routes` attribute:\n\n```\nclass LocationRouter(DefaultRouter):\n    routes = [\n        (r'^{prefix}$', {'get': 'list'}, '{basename}-list'),\n        (r'^{prefix}/{lookup}$', {'get': 'retrieve'}, '{basename}-detail')\n    ]\n\n    def get_default_base_name(self, viewset):\n        return 'location-api'\n```\n\nBut it returns this error:\n\n```\n'tuple' object has no attribute 'name'\n```\n\nThe problem line is in `rest_framework.routers.py` in the `get_api_root_view` method:\n\n```\nlist_name = self.routes[0].name  # line 216\n```\n\n**I'm using version 2.3.2 of the framework. Maybe this is fixed in a newer version?**\n\nI noticed there's a named tuple, `rest_framework.routers.Route`, which is what's used elsewhere in the code, not sure if that's what the docs should be suggesting that developers use instead of a plain old tuple.\n"},{"labels":["documentation"],"text":"When attempting to use `@action` to override `permission_classes` on a per-method basis (as the documentation [suggests](http://django-rest-framework.org/api-guide/viewsets.html#marking-extra-methods-for-routing) is possible), it appears that the additional keyword arguments are lost. \n\nTest case:\n\n```\nclass BookViewSet(mixins.RetrieveModelMixin, mixins.UpdateModelMixin,\n                  viewsets.GenericViewSet):\n    queryset = Book.objects.all()\n    serializer_class = BookSerializer\n    permission_classes = []\n\n    @action(permission_classes=[AuthorBookset])\n    def update(self, request, *args, **kwargs):\n        return super(BookViewSet, self). update(request, *args, **kwargs)\n```\n\nThis happens because `APIView.get_permissions()` uses `self.permission_classes` when creating permission instances. `@action` decorates a method on a subclass of `APIView`, and [assigns](https://github.com/tomchristie/django-rest-framework/blob/ae2887ffc41b1e05d6706f51b00266efccad7a58/rest_framework/decorators.py#L127) those additional keyword arguments as a property of the decorated method. Since they are applied to the method and not used to update the class, `APIView.get_permissions()` never sees them and they are lost.\n"},{"labels":["documentation"],"text":"On the page \"Tutorial 4: Authentication & Permissions\" in the \"Updating our serializer\" chapter: Right after instructing the student to add an \"owner\" field to the serializer, it says:\n\n```\nNote: Make sure you also add 'owner', to the list of fields in the inner Meta class.\n```\n\nHowever, in the previous tutorial pages, a meta class for the serializer was never defined and the code for the serializer on the 1st page of the tutorial does not contain a meta class either.\n\nI assume that this meta class here should be added to the serializer (and explained) on the 1st tutorial page:\n\n```\nclass Meta:\n    model = Snippet\n    fields = ('pk', 'title', 'code', 'linenos', 'language', 'style')\n```\n\nThen, on page 4, we can say that the 'owner' field should be added \"to the Serializer's meta class\".\n"},{"labels":["documentation"],"text":"Why the csrf not checked when user is not authenticated even if the SessionAuthentification used and the post request was done.\nAnd if use restframework for login views ( i use it) - this will lead to  login CSRF attacks.\n"},{"labels":["documentation"],"text":"I'm a bit spoiled by Sphinx docs. Are there any plans to make the docs searchable directly on the doc site? I can back out to Google and limit by site, but it'd sure be nice to be able to just search right there.\n"},{"labels":["documentation"],"text":"The documentation should specify if the failure behavior is for both DEBUG=True and DEBUG=False or that DEBUG=True changes the behavior.\n\nRelevant quote:\n\n> HTML error views\n> Typically a renderer will behave the same regardless of if it's dealing with a regular response, or with a response caused by an exception being raised, such as an Http404 or PermissionDenied exception, or a subclass of APIException.\n> \n> If you're using either the TemplateHTMLRenderer or the StaticHTMLRenderer and an exception is raised, the behavior is slightly different, and mirrors Django's default handling of error views.\n> \n> Exceptions raised and handled by an HTML renderer will attempt to render using one of the following methods, by order of precedence.\n> \n> Load and render a template named {status_code}.html.\n> Load and render a template named api_exception.html.\n> Render the HTTP status code and text, for example \"404 Not Found\".\n> Templates will render with a RequestContext which includes the status_code and details keys.\n"},{"labels":["documentation"],"text":"Not setting the content-type of a request is a really easy mistake to make, and it's not  immediately obvious why things aren't working if it's not being set.\n\nWe should probably note in the parsers documentation that clients should make sure to set the right content type.\n\nSee also: #586\n"},{"labels":["documentation"],"text":"I'm using django-rest-framework version 2.1.15. If I have a serializer with this field:\n\nuser = serializers.HyperlinkedIdentityField(view_name='user-detail')\n\nAnd this in my urls.py:\n\nurl(r'^user/(?P&lt;id&gt;\\d+)?/$', views.UserDetail.as_view(), name='user-detail')\n\nNote that I'm calling the id captured from the URL **id** and not **pk**.\n\nThen I get this error when my serializer tries to create the user-detail URL:\n\n<pre>\nTraceback (most recent call last):\n  File \"/home/diamond/.virtualenv/emc/lib/python2.7/site-packages/django/core/handlers/base.py\", line 111, in get_response\n    response = callback(request, *callback_args, **callback_kwargs)\n  File \"/home/diamond/.virtualenv/emc/lib/python2.7/site-packages/django/views/generic/base.py\", line 48, in view\n    return self.dispatch(request, *args, **kwargs)\n  File \"/home/diamond/.virtualenv/emc/lib/python2.7/site-packages/django/views/decorators/csrf.py\", line 77, in wrapped_view\n    return view_func(*args, **kwargs)\n  File \"/home/diamond/.virtualenv/emc/lib/python2.7/site-packages/rest_framework/views.py\", line 363, in dispatch\n    response = self.handle_exception(exc)\n  File \"/home/diamond/.virtualenv/emc/lib/python2.7/site-packages/rest_framework/views.py\", line 360, in dispatch\n    response = handler(request, *args, **kwargs)\n  File \"/home/diamond/emergensee-server/emergensee/api/decorators.py\", line 20, in _checklogin\n    return view_func(view_obj, request, *args, **kwargs)\n  File \"/home/diamond/emergensee-server/emergensee/api/views.py\", line 87, in get\n    return Response(serializer.data)\n  File \"/home/diamond/.virtualenv/emc/lib/python2.7/site-packages/rest_framework/serializers.py\", line 333, in data\n    self._data = self.to_native(self.object)\n  File \"/home/diamond/.virtualenv/emc/lib/python2.7/site-packages/rest_framework/serializers.py\", line 270, in to_native\n    return [self.convert_object(item) for item in obj]\n  File \"/home/diamond/.virtualenv/emc/lib/python2.7/site-packages/rest_framework/serializers.py\", line 200, in convert_object\n    value = field.field_to_native(obj, field_name)\n  File \"/home/diamond/.virtualenv/emc/lib/python2.7/site-packages/rest_framework/relations.py\", line 446, in field_to_native\n    raise ValidationError('Could not resolve URL for field using view name \"%s\"' % view_name)\nValidationError: [u'Could not resolve URL for field using view name \"user-detail\"']\n</pre>\n\n\nHowever, if I change my urls.py so to use **pk** instead of **id**, everything works as expected. That is, this works correctly in urls.py:\n\nurl(r'^user/(?P&lt;pk&gt;\\d+)?/$', views.UserDetail.as_view(), name='user-detail')\n\nYou might want to document this, particularly for people inclined to follow the django docs convention of using id. Otherwise, the error is very confusing.\n"},{"labels":["documentation"],"text":"**EDIT by @tomchristie: Updated title from \"Authorization doesn't work when using Apache/mod_wsgi by default\"**\n\n`mod_wsgi` normally doesn't [pass through the Authorization header](http://code.google.com/p/modwsgi/wiki/AccessControlMechanisms):\n\n> Unlike other HTTP headers, the authorisation header is not passed through to a WSGI application by default. This is the case as doing so could leak information about passwords through to a WSGI application which should not be able to see them when Apache is performing authentication...\n> \n> If it is desired that the WSGI application be responsible for handling user authentication, then it is necessary to explicitly configure mod_wsgi to pass the required headers through to the application. This can be done by specifying the WSGIPassAuthorization directive in the appropriate context and setting it to 'On'.\n\nThus Token authentication for example does not work unless you add the following to your Apache config:\n\n```\nWSGIPassAuthorization on\n```\n\nThis is very confusing as the same application on the same server works fine when run using `runserver`, but fails in Apache. Please could you document this in the relevant Authorization chapters?\n"},{"labels":["documentation"],"text":"As requested by @tomchristie. `django-rest-framework` can use Djangos internal caching mechanism to cache API responses. Document how it can be enabled for DRF (basically it works just like it would in a vanilla Django view, but it might be worth letting people know that DRF supports it).\n"},{"labels":["documentation"],"text":"The HTML anchors in the documentation aren't working when there is a forward slash in the anchor name.  An example of this is the \"PrimaryKeyRelatedField / ManyPrimaryKeyRelatedField\" section in the serializer fields page.  This is certainly a problem in Chrome and I expect it will be in other browsers as well.\n\nFixing this is probably a case of chaining another replace into mkdocs.py but since I can't get the docs to build I don't want to commit this blind and break something.\n"},{"labels":["documentation"],"text":"Hi there,\n\nI've setup a class to do custom authentication, like so:\n\n```\nclass TokenAuthentication(BaseAuthentication):\n    model = ClientApplication\n\n    def authenticate(self, request):\n        auth = request.META.get('HTTP_AUTHORIZATION', '').split()\n\n        if len(auth) == 2 and auth[0].lower() == 'token':\n            key = auth[1]\n            try:\n                token = self.model.objects.get(api_key=token)\n            except self.model.DoesNotExist:\n                return None\n            return (token, token.api_key)\n```\n\nI've set this in my settings and have `rest_framework.authtoken` in `INSTALLED_APPS`\n\n```\nREST_FRAMEWORK = {\n    'DEFAULT_AUTHENTICATION_CLASSES': (\n        'core.permissions.TokenAuthentication',\n    ),\n}\n```\n\nHowever, when I curl a view I made, the authentication is never hit. Why?\n\nCurl is simply: `curl -H \"Authorization: Token abc123\" http://localhost:8000/api/agent/999/`\n\nMy view is as follows:\n\n```\nclass AgentDetail(APIView):\n    def get(self, request, agent_code):\n       # removed for brevity\n       # ...\n       return Response(context)\n```\n\nAny ideas? I did a little looking around and tracing in the Request, and although `self.authenticators` is populated in the `Request` class it never seems to take use of them.\n\nThanks!\n"},{"labels":["documentation"],"text":"Write an example custom authentication that checks for a fixed given secret, and authenticates as a given user.\n"},{"labels":["documentation"],"text":"Write a global throttle as an example of custom throttles\n"},{"labels":["documentation"],"text":"- Write an example custom permission that only allows a single given user.\n- Write an example custom object permission `IsOwnerOrReadOnly` to demonstrate object level permissions.\n"}]