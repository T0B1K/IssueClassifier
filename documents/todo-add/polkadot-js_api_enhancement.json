[{"labels":[null,null,"enhancement"],"text":"https://github.com/paritytech/substrate/pull/6969"},{"labels":[null,null,"enhancement"],"text":"As per discussion in Riot, ApiPromise currently exposes WsProvider.disconnect() via ApiPromise.disconnect(), but it does not expose WsProvider.connect() via the ApiPromise interface. In order to make an intuitive interface and not cause any breaking changes, ApiPromise could expose a connect() method.\r\n\r\nI don't see this as urgent at all, but just nice to have in the long term in order to avoid confusion. I would be happy to take a stab at it myself."},{"labels":[null,null,"enhancement"],"text":"Hi! I'm using ApiPromise with websocket provider as singleton like this:\r\n\r\n```\r\nlet wsProvider;\r\nlet client;\r\n\r\nfunction createClientInstance() {\r\n  wsProvider = new WsProvider('wss://rpc.polkadot.io');\r\n\r\n  client = new ApiPromise({ provider: wsProvider });\r\n}\r\n\r\nasync function buildDotClient() {\r\n  try {\r\n    if (!wsProvider) {\r\n      createClientInstance();\r\n    }\r\n\r\n    await client.isReady;\r\n\r\n    return client;\r\n  } catch (e) {\r\n    throw new Error('service_unavailable');\r\n  }\r\n}\r\n```\r\n\r\nAnd then use client in some script inside interval. But from time to time I get such errors:\r\n`API-WS: disconnected from wss://rpc.polkadot.io code: '1006' reason: 'Connection dropped by remote peer.'`\r\n`API-WS: disconnected from wss://rpc.polkadot.io code: '1006' reason: 'connection failed'`\r\n\r\nAnd after throwing such error from ApiPromise, script gets stuck. It's even impossible to catch for following restart.\r\nI even tried to add event emitter listenings, but still the same:\r\n```\r\n    client.on('disconnected', () => {\r\n      createClientInstance();\r\n    });\r\n\r\n    client.on('error', () => {\r\n      createClientInstance();\r\n    });\r\n```\r\n\r\nMaybe it is possible to restart connection manually?\r\n\r\nPackage version:\r\n\"@polkadot/api\": \"^1.30.1\""},{"labels":[null,null,"enhancement"],"text":""},{"labels":[null,null,"enhancement"],"text":""},{"labels":[null,null,null,"enhancement"],"text":"There're cases we want to query metadata of a past block for comparison and don't want to have any side effects for such query. But with current implementation, it actually call `registry.setMetadata()`.\r\nI believe this is an unexpected behavior for most people.\r\n\r\nhttps://github.com/polkadot-js/api/blob/9c1327ea22e1e8600fa8d216ce36f6618ffdb093/packages/metadata/src/Metadata/MetadataVersioned.ts#L44"},{"labels":[null,null,"enhancement"],"text":"**Example:**\r\n```\r\nconst vec = api.createType('Vec<u32>', [0, 1, 2])\r\nconst vec2 = api.createType('Vec<u32>', [3, 4, 5]);\r\nconst vec3 = vec.concat(vec2);\r\n```\r\nThis results in an error like:\r\n```\r\nTypeError: registry.createClass is not a function\r\n```\r\nBut because `Vec` extends an `Array` through `AbstractArray` - this is perfectly valid script according to TypeSciprt compiler, which makes the issue hard to detect.\r\n\r\nOther methods like `.filter()` and `.map()` seem to be handled correctly (since `AbstractArray` provides the overrides for them)"},{"labels":[null,null,"enhancement"],"text":"API version of https://github.com/polkadot-js/common/issues/656\r\n\r\nThis needs unpacking, but some things I can immediately think of -\r\n\r\n- [x] `AccountId` needs to use 20-bytes, not 32\r\n- [x] `AccountId` needs to encode to the Ethereum version (display)\r\n- [x] `Address` needs to use the above\r\n- [x] `Extrinsic`, probably need hashing support as per this https://github.com/polkadot-js/common/issues/656#issuecomment-677974552 (However this really is config dependent, i.e. is all hashes replaced, or just this singular, i.e. for large payloads)\r\n- ...\r\n\r\nThere will be more, needs to be unpack actually looking at what Rust does"},{"labels":[null,null,"enhancement"],"text":"As per https://github.com/paritytech/substrate/pull/6720"},{"labels":[null,null,"enhancement"],"text":"I would like to query historical account balances for all accounts at a particular block, something like\r\n\r\n```\r\nconst accounts = await api.query.system.account.at(blockHash).entries()\r\n```\r\n\r\nBut looks like not possible with current polkadot.js.\r\n\r\nOne way is add `blockHash` to `.entries()` and pass it to `getKeysPaged`"},{"labels":[null,null,"enhancement"],"text":"Type definition\r\n```\r\nexport default {\r\n    types: {\r\n        ID: \"H256\",\r\n        IDS: \"Vec<ID>\",\r\n        Value: \"Vec<u8>\",\r\n\r\n        Change: {\r\n            primary: \"ID\",\r\n            relation: \"IDS\",\r\n            before: \"Option<Value>\",\r\n            after: \"Option<Value>\"\r\n        },\r\n        \r\n        Mutation: {\r\n            changes: 'Vec<Change>',\r\n        }\r\n    }\r\n}\r\n```\r\nlead to error\r\n```\r\nGenerating from metadata, 17,573 bytes\r\n/Users/dmitriyshabanov/Trucks/types/src/interfaces/augment-api-consts.ts\r\n\tGenerating\r\n\tWriting\r\n\r\n/Users/dmitriyshabanov/Trucks/types/src/interfaces/augment-api-query.ts\r\n\tGenerating\r\n\r\n/Users/dmitriyshabanov/Trucks/types/node_modules/@polkadot/typegen/util/derived.js:116\r\n    if (subDef.info === _types.TypeDefInfo.Plain) {\r\n               ^\r\nTypeError: Cannot read property 'info' of undefined\r\n```\r\nbecause it can't proper handle `relation: \"IDS\"`"},{"labels":[null,null,"enhancement"],"text":"FixedI64, FixedI128 and FixedU128 are Substrate build-in types. `@polkadot/types` should support them out of box."},{"labels":[null,null,"enhancement"],"text":"As per https://github.com/paritytech/polkadot/pull/1369"},{"labels":[null,null,"enhancement"],"text":"As per https://github.com/paritytech/substrate-api-sidecar/pull/164#discussion_r453167482"},{"labels":[null,"enhancement"],"text":"HI!\r\n\r\nI'd love to be able to create a provider that includes custom headers. We'd use this to authenticate to a node that we don't want open to the Internet.\r\n\r\nIf you're open to this, I can open up a PR that includes it."},{"labels":[null,null,null,"enhancement"],"text":"Basically we need to decorate the `new (...)` on the interface in the same way we do for the API decorated methods, allowing guidance to the user."},{"labels":[null,null,"enhancement"],"text":"Currently, the metadata API containing items like `api.consts.system.extrinsicBaseWeight` always returns the value extracted from the latest metadata. For some applications like calculating fees of historical transactions it is necessary to access metadata of the block (or rather its parent) where the transaction resides in.\r\n\r\nIt would be nice to have an API similar to the one provided for accessing storage using the `at` function:\r\n```\r\napi.query.transactionPayment.nextFeeMultiplier.at(blockHash);\r\n```"},{"labels":[null,null,null,"enhancement"],"text":"https://github.com/paritytech/substrate/pull/6300\r\n\r\nRPC `system_dryRun` allow to dry run an extrinsic before submit it."},{"labels":[null,null,"enhancement"],"text":"https://github.com/paritytech/substrate/pull/6330 adds `Status` to encode/decode for events. Add this type to the API."},{"labels":[null,null,null,"enhancement"],"text":"We have some breaking changes between our old and new testnet and we would like to have a single API that support both testnet.\r\n\r\nBut seems like the filterVersions is not been called on user provided types and we cannot know which types without knowing the spec version first.\r\n\r\nhttps://github.com/polkadot-js/api/blob/e6beb6554dff7ac61fd2e9d16b2631978e6ec626/packages/types-known/src/index.ts#L59-L62\r\n\r\nFor now we can use the chain name to distinguish between versions, but won't work once we introduce breaking changes in our public testnet via runtime upgrade.\r\n\r\nWe would like to pass something like this to API contractor and have it detect and use correct types based on spec version\r\n\r\n```\r\nexport const typeChain: Record<string, OverrideVersionedType[]> = {\r\n  acala: [\r\n    {\r\n      minmax: [undefined, 403],\r\n      types: {\r\n        Weight: 'u32'\r\n      }\r\n    }\r\n  ]\r\n};\r\n```"},{"labels":[null,null,"enhancement"],"text":"Introduced in https://github.com/paritytech/substrate/pull/5954"},{"labels":[null,null,null,"enhancement"],"text":"Reproduce:\r\n\r\n```\r\nawait api.disconnect()\r\n\r\nawait api.derive.staking.stakerRewards(`FPstA2NF8wH4d8Z3VWhmALLSpcMi8Tttsv8jsJNZvL1y7GA`, 581)\r\n  .catch(console.error);\r\nconsole.log(\"Should be reached\");\r\n```\r\n\r\n\"Should be reached\" will never be called"},{"labels":[null,null,"enhancement"],"text":"Is it possible to use `.multi` and `.queryMulit` together with `.at`. I am trying to minimize number of calls I make to the node."},{"labels":[null,null,"enhancement"],"text":""},{"labels":[null,null,null,"enhancement"],"text":"### Goal:\r\n\r\nEnhance `WsProvider` to allow it support multiple endpoints. On reconnect, switch to next endpoint in a round robin way.\r\n\r\n### Background:\r\n\r\nCurrently `WsProvider` only takes one endpoint, and incase this particular node is down, it will lose access to the network. While it is possible to detect disconnect event and create a new api instance, the existing subscription will be lost.\r\n\r\n### Actions:\r\n\r\nModify `WsProvider` to change type of `endpoint` to `string | string[]`.\r\n\r\nUpdate `WsProvider#connect` to use next endpoint.\r\n\r\nProvide appropriate unit tests.\r\n\r\n----\r\n\r\n@jacogr please tag this if you are happy about this. The tags are come from W3F bounties doc.\r\n\r\nTags:\r\n`bounty-awaiting-approval`\r\n`bounty-XS`"},{"labels":[null,null,null,"enhancement"],"text":"### Goal:\r\n\r\nUpdate `keyPrefix` for double map storage to take one argument as the first key and return the key prefix.\r\n\r\n### Background\r\n\r\nCurrently polkadot.js provides two methods to work with the storage key value:\r\n\r\n`keyPrefix()` that return the storage prefix.\r\n`key(args)` that return the whole storage key.\r\n\r\nNone of it able to provide key prefix for a double map with a given first key item.\r\n\r\n### Actions:\r\n\r\nModify `keyPrefix`, change signature to `(key1?: CodecArg): string`\r\n\r\nhttps://github.com/polkadot-js/api/blob/e77050b9f59a0b772d1d0b8c5c1da488a7c36810/packages/api/src/base/Decorate.ts#L347\r\n\r\nCheck if it is double map and have key1, if false, keep existing behavior. else return prefix with key1 happened.\r\n\r\nHow the key prefix for double map with a key can be found here\r\n\r\nhttps://github.com/polkadot-js/api/blob/e77050b9f59a0b772d1d0b8c5c1da488a7c36810/packages/api/src/base/Decorate.ts#L466-L472\r\n\r\nUpdate interface\r\n\r\nhttps://github.com/polkadot-js/api/blob/e77050b9f59a0b772d1d0b8c5c1da488a7c36810/packages/api/src/types/storage.ts#L41\r\n\r\nProvide appropriate unit tests.\r\n\r\n---\r\n\r\n@jacogr please tag this if you are happy about this.\r\n\r\nTags:\r\n`bounty-awaiting-approval`\r\n`bounty-S`"},{"labels":[null,null,"enhancement"],"text":"https://github.com/polkadot-js/api/pull/2208 is not enough.\r\n\r\nGetting error here\r\n\r\nhttps://github.com/polkadot-js/api/blob/1c8bd896e1f0050703119d04854b33048c522fc9/packages/rpc-core/src/index.ts#L391\r\n\r\nkeys is undefined.\r\n\r\nThe type information is coming from `StorageKey`, polkadot.js won't be able to just decode all the change set without extra helps.\r\n\r\nNot sure what's the best solution.\r\n\r\nI am trying to access the raw output instead and it is also not easy. There should be a version that doesn't do all the magics and just give me hex string and I can do the parsing myself."},{"labels":[null,null,"enhancement"],"text":"As per https://github.com/paritytech/substrate/pull/5446"},{"labels":[null,null,"enhancement"],"text":"https://github.com/paritytech/substrate/pull/5576"},{"labels":[null,null,"enhancement"],"text":"This has been dragging locally-WIP for too long, get it in."},{"labels":[null,null,"enhancement"],"text":"Specifically https://github.com/polkadot-js/api/blob/master/packages/api/src/base/Decorate.ts#L505"},{"labels":[null,null,"enhancement"],"text":"As per https://github.com/paritytech/substrate/pull/5406"},{"labels":[null,null,"enhancement"],"text":"... as we have in RPC"},{"labels":[null,null,null,"enhancement"],"text":"As commented here https://github.com/polkadot-js/api/issues/1937#issuecomment-592561157\r\n\r\nExplicitly we want to have the following functionality, https://github.com/polkadot-js/api/blob/master/packages/types/src/known/overrides.ts#L8-L34"},{"labels":[null,null,"enhancement"],"text":"As discussed in riot chat, this function would work like `.at(blockHash)` but return results in a range of blocks"},{"labels":[null,null,"enhancement"],"text":"Right now the only way of using queryMulti is providing a callback that gets called whenever the stored values change. It would be useful if there was also a callback-less version that simply returned the values wrapped in a promise (as with other query methods)"},{"labels":[null,null,"enhancement"],"text":"Should wok exactly the same as `BTreeMap`, but requires aliasing for `createType` & friends.\r\n\r\nCan do `HashMap: 'BTreeMap`, but the `HashMap<Key, Value>` still needs to be available."},{"labels":[null,null,"enhancement"],"text":"Introduced in https://github.com/paritytech/substrate/pull/4979"},{"labels":[null,null,"enhancement"],"text":"Currently -\r\n\r\n- toString returns a string-based representation (generally used in the toJSON)\r\n- toJSON returns something that cane be submitted over RPC\r\n- toU8a returns the SCALE-encoded version\r\n\r\ntoHuman should -\r\n\r\n- apply any chain formatting as needed (e.g. balances)\r\n- apply number formatting to string (e.g. 123456 -> 123,456)\r\n- expand Call/Proposal to yield the system/method\r\n- format addresses (already done in toString)\r\n- where applicable format with the \"hidden\" getters (e.g. args on Call)\r\n- ...\r\n\r\nOverall, it would be specific to _some_ implementations. Would suggest aliasing it to toJSON and then starting from there to wok though what makes sense and it pretty.\r\n\r\nAdditionally, would suggest adding an optional `isExtended`, i.e. `toHuman(isExtended?: boolean)` - when set, for some (e.g. call) it can add more info, e.g. metadata documentation. (Generally not needed in all cases, but can be useful in Events, Calls, ...)"},{"labels":[null,null,"enhancement"],"text":"Introduced in https://github.com/paritytech/substrate/pull/4517\r\n\r\n"},{"labels":[null,null,"enhancement"],"text":"We have u16 bit mask but `CodecSet` always assume it is one byte.\r\n\r\nhttps://github.com/polkadot-js/api/blob/cefeb37ae6b08250e0ac9403d213650fece62015/packages/types/src/codec/Set.ts#L214\r\n"},{"labels":[null,null,null,null,null,"enhancement"],"text":"- Introduced in https://github.com/paritytech/substrate/pull/4474"},{"labels":[null,null,"enhancement"],"text":"It's really hard to handle disconnects, reconnects or changing servers cleanly right now. We managed to be pretty close by using manual connect to ``wsProvider`` and doing some hacks with ``wsProvider.on('error', cb)``, ``wsProvider.on('connected', cb)`` and ``wsProvider.on('disconnected', cb)``\r\n\r\nHowever returning unsubscribe function like when subscribing to API queries would be very helpful in this case. I've already tried to implement this and it solved most of our problems. I'll make it a PR. \r\n\r\nIf that's not acceptable at least returning EventEmitter would be helpful but that might not be as user friendly.\r\n\r\nhttps://github.com/polkadot-js/api/blob/de9f033d994bebe2145e5cd0155f77ef8471a3c0/packages/rpc-provider/src/ws/Provider.ts#L172"},{"labels":[null,null,"enhancement"],"text":"After #1772\r\n\r\nThe first PR in #1774 only deals with the parsing, here we need to adjust the signed extensions based on what is available. Since this required registry additions and logic around the handling (and signing), we keep it separate from the types-parsing details."},{"labels":[null,null,"enhancement"],"text":"Introduced in https://github.com/paritytech/substrate/pull/4774"},{"labels":[null,null,"enhancement"],"text":"As introduced in #1766\r\n\r\nThe issue we have atm (which makes it useful, but limited) is that user defined types (into the user package) is not used in the `{consts, query}.types.ts` files. Expanding in this direction is the next steap."},{"labels":[null,null,"enhancement"],"text":"As introduced in https://github.com/paritytech/substrate/pull/4694"},{"labels":[null,null,null,"enhancement"],"text":"I'm trying to connect to my unsynced node with api 1.0.0-beta.17 \r\n```\r\ntarget=#750431 (25 peers), best: #520014\r\n```\r\nI'm getting \r\n![Screen Shot 2020-01-23 at 16 42 13](https://user-images.githubusercontent.com/3409250/72999295-74938080-3dff-11ea-9667-bd96dcc9c5bd.png)\r\n\r\nwhich is uncatchable with both of these\r\n\r\n```javascript \r\ntry {\r\n  let api = await ApiPromise.create().catch(e => {})\r\n} catch (e) {}\r\n```\r\n\r\nIt also doesn't emit error on \r\n```javascript\r\nprovider.on('error',(e)=>{})\r\n```\r\n\r\nIt results in stuck application since I can't react on anything that happened here. It also happens when you get error while connecting to ``wsprovider`` but it can be handled by wrapping api creation inside another promise, which I can reject. It is not ideal, but it works.\r\n\r\nWhen trying to connect to ``wss://cc3-5.kusama.network/`` I get this on the other hand\r\n\r\n![Screen Shot 2020-01-23 at 16 41 42](https://user-images.githubusercontent.com/3409250/72999309-79583480-3dff-11ea-839f-8dc55b605d44.png)\r\n"},{"labels":[null,null,"enhancement"],"text":"Introduced in https://github.com/paritytech/substrate/pull/4720"},{"labels":[null,null,"enhancement"],"text":"V2 https://github.com/paritytech/substrate/pull/4681/files"},{"labels":[null,null,"enhancement"],"text":"It is quite difficult for users to try and chase down Substrate type changes. If we can have a fallback in the definition (or a range), this can be handled transparently. \r\n\r\nRef #1687 "},{"labels":[null,null,"enhancement"],"text":"We have a runtime method with the following signature:\r\n\r\n```\r\nfn validate_mint(origin, anchor_id: T::Hash, deposit_address: [u8; 20], pfs: Vec<proofs::Proof>, static_proofs: [[u8;32];3]) -> Result {\r\n```\r\n\r\nIt works well in unit tests, but polkadot-js seems to not like the type of `static_proofs`. The error I'm seeing when instanciating the API is:\r\n\r\n```\r\n2019-12-19 20:08:22   API/DECORATOR: Error: FATAL: Unable to initialize the API: Expected '[' closing with ']'\r\n    at EventEmitter.Init._onProviderConnect (/Users/philipstanislaus/go/src/github.com/centrifuge/centrifuge-chain-functional-test/node_modules/@polkadot/api/base/Init.js:55:23)\r\n    at processTicksAndRejections (internal/process/task_queues.js:85:5)\r\n```\r\n\r\nA workaround is to use \r\n\r\n```\r\nInner: ‘[u8;32]’\r\nOuter: ‘[Inner;3]’\r\n```"},{"labels":[null,null,"enhancement"],"text":"There have been breaking changes introduced with https://github.com/paritytech/substrate/pull/4162\r\n\r\nThe `child_storage` rpc functions now expect two additional parameters, namely \r\n```\r\nchild_info: StorageKey,\r\nchild_type: u32,\r\n```\r\n\r\nSee:\r\nhttps://github.com/paritytech/substrate/pull/4162/files#diff-d0e6e9d0dec379376c4381b7b12a0b4fR63"},{"labels":[null,null,"enhancement"],"text":"Introduced in https://github.com/paritytech/substrate/pull/4143"},{"labels":[null,null,"enhancement"],"text":"Conversely, `signAndSend` does support external signers"},{"labels":[null,null,"enhancement"],"text":"Using api beta30 - getting derived session info returns wrong value on current kusama node.\r\nChain height currently at BN:826889 while value for last session(epoch?) change is showing value of 262453039\r\n\r\nIt looks like other data is also wrong - if we look at polkascan and look into events on kusamacc2 - session and era starts do not correspond to data shown in session info.\r\n\r\nAccording to session info, there should have been session starts at blocks  824870, 822470, 820070 which is calculated from \r\n`await api.rpc.chain.getHeader()).number.toNumber() - sessionProgress`\r\n which doesn't look like it's right because \r\n`await api.query.system.events.at(await api.rpc.chain.getBlockHash(824870))` \r\ndoesn't return events that should be emitted on new nession start. Whereas\r\n`await api.query.system.events.at(await api.rpc.chain.getBlockHash(824956))` \r\ndoes return these events\r\n\r\nit looks like eraProgress returns same value as sessionProgress which is also wrong.\r\n\r\nhttps://polkascan.io/pre/kusama-cc2/event \r\n![Screen Shot 2019-11-26 at 01 57 40](https://user-images.githubusercontent.com/3409250/69590640-663c0a80-0ff0-11ea-940c-966209cb5aa7.png)\r\n\r\nhttps://github.com/polkadot-js/api/blob/4cea617b13efa9db9addb17f6c4e31e1df025246/packages/api-derive/src/session/info.ts#L63\r\n"},{"labels":[null,"enhancement"],"text":"- Introduced in paritytech/substrate#4185\r\n- Needs #1599 "},{"labels":[null,null,"enhancement"],"text":"Introduced in https://github.com/paritytech/substrate/pull/4185"},{"labels":[null,null,"enhancement"],"text":"https://github.com/paritytech/ink/pull/264"},{"labels":[null,null,"enhancement"],"text":"https://github.com/paritytech/substrate/pull/3944"},{"labels":[null,null,"enhancement"],"text":"`subscribeNewHeads` only works when the node runtime provides the session module. If this is not the case (when using Aura consensus for example) the method throws an error that `api.query.session` is undefined. "},{"labels":[null,null,"enhancement"],"text":"I'm using an `Option<MyType>` in a custom extrinsic signed payload.\r\nThe expected behavior is unclear for the `None` case. \r\nThe rust side expects a `0` to be encoded for the signature to verify.\r\nThis implementation encodes nothing for `None` when `isBare = true`\r\n\r\n`Option` is an implementation detail so it seems that polkadot-js/api is taking the correct approach here but the change will be much harder to implement on the substrate side.\r\n\r\nhttps://github.com/polkadot-js/api/blob/56dc116d92ed3de5994e3dc7c767940617e088e9/packages/types/src/codec/Option.ts#L133-L149"},{"labels":[null,null,"enhancement"],"text":"e.g. U2048 (atm U256, like u128 is custom defined)\r\n\r\nThis also allows us to move even more primitives to definitions."},{"labels":[null,null,"enhancement"],"text":"https://github.com/paritytech/substrate/pull/3876\r\nhttps://github.com/paritytech/polkadot/pull/504"},{"labels":[null,null,"enhancement"],"text":"The ink! ABI JSON encoding changed with these two issues being fixed:\r\n\r\nhttps://github.com/paritytech/ink/issues/199\r\nKeys in the layout section of a contract metadata were previously encoded as an array of 32 bytes. They are now encoded as a hex string of the form `\"0xABC…\"` (the `0x` prefix is in there, despite the original issue description).\r\n\r\nhttps://github.com/paritytech/ink/issues/200\r\nFunction/constructor selectors in the JSON representation of the contract metadata were previously encoded as `u32`. To prevent issues with misinterpretation because of endian-ness we encode them as four hex-encoded bytes in an array now (`\"selector\":[\"0x07\",\"0x5B\",\"0xCD\",\"0x15\"]`).\r\n\r\nThe old ABI stays the same in both cases."},{"labels":[null,null,"enhancement"],"text":"Currently it does not complain when sending too many args."},{"labels":[null,null,"enhancement"],"text":"Sum of freeBalance & bonded (first includes all locks)"},{"labels":[null,null,"enhancement"],"text":"Introduced in #1473 & #1474 \r\n\r\nSimilar as done recently for `Result` in https://github.com/polkadot-js/api/pull/1451/files, so we can call `createType('BTreeMap<A,B>', ...)` to create an instance. (Supporting JSON type definitions)"},{"labels":[null,null,"enhancement"],"text":"[BTreeMaps](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html) are supported in module and are part of the [SCALE codec implementation](https://github.com/paritytech/parity-scale-codec/search?q=BTreeMap&unscoped_q=BTreeMap), but there's currently no JavaScript-level support for them.\r\n\r\nEdit: There's a PR for this: https://github.com/polkadot-js/api/pull/1474"},{"labels":[null,"enhancement"],"text":"It would be good to have a completely offline `api` object, for example to do offline extrinsics creation.\r\n\r\nRequirements: \r\n- the metadata, genesisHash, blockNumber etc are retrieved by an external party, and can be inputs to the offline `api` object.\r\n- no WsProvider at all, a.k.a completely offline\r\n\r\nOutput:\r\n- be able to create an extrinsic, ready to be broadcasted to the network\r\n\r\n---\r\n\r\n### Possible hack today (it's a hack, not recommended)\r\n\r\nToday, the solution to this is hacky: we use the `injectMethods` which will populate a global singleton object:\r\n\r\n```typescript\r\nimport Call from '@polkadot/types/primitive/Generic/Call';\r\nCall.injectMethods(extrinsics);\r\n```\r\n\r\nThis is hacky, and we want to remove it: https://github.com/polkadot-js/api/issues/580. But with this hack we can\r\n\r\n```typescript\r\ncreateType('Extrinsic', someValue, { version: 3});\r\n```\r\n\r\n---\r\n\r\n### Possible solutions:\r\n\r\n- `new Api({ metadata })` will not create a WsProvider, and will decorate based on inputted metadata. \r\n    - `api.query.balances.freeBalance().then()` could just fail.\r\n    - `api.query.balances.transfer(...).sign(...)` here we pass in blockNumber, genesisHash, specVersion here, will return a ready-to-be-broadcasted tx.\r\n- `createType('Type', value, { metadata, extrinsicVersion, otherParams... })`\r\n    - needs Type signature unification: https://github.com/polkadot-js/api/issues/1224\r\n- instead of decorating `api`, we could decorate `Metadata`?\r\n    - `metadata.query.balances.freebalance(...); // returns a StorageKey`\r\n    -  `metadata` can be offline, and `api` is just a wrapper of promise/rx + provider around `metadata`  "},{"labels":[null,null,null,"enhancement"],"text":"via V8 error definitions introduced in https://github.com/polkadot-js/api/pull/1441"},{"labels":[null,null,"enhancement"],"text":"As introduced here - https://github.com/polkadot-js/api/pull/1448/files#diff-7c87abb5204066c30053817e1823ae7dR7\r\n\r\n(the enum is a good approximation, `0<success data encoded>` or `1<error data encoded>`)"},{"labels":[null,null,"enhancement"],"text":"Starting the API against Substrate fdac986a and other recent versions gives the error\r\n\r\n```\r\n2019-10-04 10:28:30 API/DECORATOR: Error: \"FATAL: Unable to initialize the API: Unable to find plain type for {\"info\":5,\"type\":\"GroupIndex\"}\"\r\n```"},{"labels":[null,null,"enhancement"],"text":"https://github.com/paritytech/substrate/pull/3752"},{"labels":[null,null,"enhancement"],"text":"https://github.com/polkadot-js/api/pull/1397#issue-317565470"},{"labels":[null,null,"enhancement"],"text":"As explained in https://github.com/polkadot-js/apps/blob/master/packages/app-settings/src/md/basics.md types are registered in the order they are supplied. This prevents using some interesting data types such as the familiar [cons list](https://en.wikipedia.org/wiki/Cons).\r\n\r\nIt would be helpful to support such recursive data-types. As an example and test case, consider this rust code and the corresponding non-working type declaration.\r\n\r\n```rust\r\n#[derive(PartialEq, Eq, Clone, Encode, Decode, Debug)]\r\npub enum ConsList {\r\n    End,\r\n    Cons {\r\n        head: u64,\r\n        tail: Box<ConsList>,\r\n    }\r\n}\r\n```\r\n\r\n```json\r\n{\r\n    \"Cons\": {\r\n        \"head\": \"u64\",\r\n        \"tail\": \"ConsList\"\r\n    },\r\n    \"ConsList\": {\r\n        \"_enum\": {\r\n            \"End\": null,\r\n            \"Cons\": \"Cons\"\r\n        }\r\n    }\r\n}\r\n```"},{"labels":[null,null,"enhancement"],"text":"Types that use `rstd::boxed::Box` are declared to the api without the box wrapper. For example if my type is `type BoxedInt = Box<u64>` it should be declared to the api as `{ \"BoxedInt\": \"u64\" }`.\r\n\r\nHowever developers may reasonably guess that it should be declared as `{ \"BoxedInt\": \"Box<u64>\" }` especially considering how `Vec<_>`s are declared. To lower the friction for new developers, it would be nice to automatically strip the unnecessary Box when it is supplied."},{"labels":[null,null,null,"enhancement"],"text":"As per https://github.com/paritytech/substrate/pull/3613"},{"labels":[null,null,"enhancement"],"text":"https://github.com/paritytech/substrate/pull/3563"},{"labels":[null,null,"enhancement"],"text":"`primitive/Extrinsic/Extrinsic.ts` is a nice structured `VersionedExtrinsic`, which is very handy if i can reuse and let my own Extrinsic Impl work with it. The problem I have is it doesn't get ExtrinsicImpl from typeRegistry. \r\n\r\n\r\n"},{"labels":[null,null,"enhancement"],"text":"We probably want to start using this in sumittables as well - the only issue is that it is a non-default RPC, so _may_ not be there. (But will be in 99.9% of the cases). So potentially we want some detection and then use what is available either this or the nonce. (Detection happens up-front)"},{"labels":[null,null,"enhancement"],"text":"The current rpc mocks do something, but don't do it very well and it exceptionally messy to say the least.\r\n\r\nWant to steal some stuff from @jnaviask for this, he actually laid the base for something that actually works properly..."},{"labels":[null,null,"enhancement"],"text":"Code TODO -\r\nhttps://github.com/polkadot-js/api/pull/1317/files#diff-42453350b90abd3faf65d39e023fdc4eR41\r\n\r\nRemoval -\r\nhttps://github.com/polkadot-js/api/pull/1317/files#diff-e4ae210f1f695bace5a518b3cc0b0762L1154"},{"labels":[null,"enhancement"],"text":"The type for VestingSchedule was changed somewhat recently. `@polkadot/api` is still using the old type in the latest beta. The new type is this:\r\n\r\n```\r\n      VestingSchedule: {\r\n        locked: \"Balance\",\r\n        perBlock: \"Balance\",\r\n        startingBlock: \"BlockNumber\",\r\n      }\r\n```"},{"labels":[null,null,"enhancement"],"text":""},{"labels":[null,null,"enhancement"],"text":"I'm trying to migrate my signer lib to use the new signer interface, then i noticed the dependency requirement changed. Before, my signer lib didn't have to depend on `@polkadot/api` or `@polkadot/types`, extrinsic is passed in and i only need to get the key pair what it's asked for.\r\nBut now, I need SignaturePayload from `@polkadot/types`, which means future change from `@polkadot` might break my signer lib.\r\n\r\nso, can we make SignerPayload support toU8a(), which return the same encoded u8a we passed to IKeyringPair.sign(). (cennznet/api/packages/types/src/primitive/Extrinsic/util.ts)\r\n\r\nthen i can remove the dependency of `@polkadot/types` from my lib."},{"labels":[null,null,"enhancement"],"text":"Currently it only allows for Extrinsic payloads."},{"labels":[null,null,"enhancement"],"text":"Should be runnable to any package user via cli, pointing to a definitions folder"},{"labels":[null,null,"enhancement"],"text":""},{"labels":[null,null,"enhancement"],"text":"i.e. `api.type(<Name>, ...args)` to map to as-is to `createType`. Mention `createType` as removed in the future"},{"labels":[null,null,"enhancement"],"text":"https://github.com/paritytech/substrate/pull/3188"},{"labels":[null,null,"enhancement"],"text":"**Expected:**\r\n\r\n```typescript\r\nconst g = createType('Gas', 1234);\r\ng.ad... // should autocomplete because it's a BN\r\n```\r\n\r\n**Actual:**\r\n\r\nDoesn't autocomplete. We need to do the following:\r\n\r\n```typescript\r\nimport { Gas } from '@polkadot/types/smrl/types';\r\n\r\nconst g = createType<Gas>('Gas', 1234);\r\ng.ad... // autocompletes correctly\r\n```\r\n\r\nwhich is okay for 1 or 2 types, but gets really redundant for more, since we're really typing the same word twice\r\n\r\n**Solution:**\r\n\r\nThe idea is to create an `InterfaceRegistry`, empty at first, and the script `srmlTs.ts` populates `InterfaceRegistry` with the types it finds, via module augmentation.\r\n\r\n- Step 1. Create `InterfaceRegistry`. The keys are strings with represent the srml type (like 'Gas'), and the values are the actual interface (like `Gas` in `types/smrl/contracts/types`).\r\n\r\n```typescript\r\n// in `@polkadot/types/smrl/types.ts`\r\n\r\nexport interface InterfaceRegistry {\r\n  // empty at first\r\n}\r\n```\r\n\r\n- Step 2. Modify `srmlTs.ts` to populate `InterfaceRegistry` via module augmentation. For example, for gas, the script would output in `types/srml/contract/types.ts`:\r\n\r\n```typescript\r\ndeclare module '@polkadot/types/srml/types' {\r\n  interface InterfaceRegistry {\r\n    Gas: Gas // maps the key \"Gas\" to the interface `Gas`\r\n  }\r\n}\r\n```\r\n\r\n- Step 3. In `ClassOf`:\r\n    - if we're calling `const a = createType<SomeOtherType>('Gas', 1234)`, then `a` should be of type `SomeOtherType` (overridden by user)\r\n    - if we're calling `const a = createType('Gas', 1234)`, then `ClassOf` should check if `InterfaceRegistry['Gas']` is present, if yes, take it, if no, return `Codec`\r\n\r\nI'm not 100% this will actually work, so needs some exploration first."},{"labels":[null,null,"enhancement"],"text":"Basically only create a type of class once, if we have a class for a specific type string, pull it from cache. (This would allow things like `instanceof` checks to work on generated classes)"},{"labels":[null,"enhancement",null],"text":"Can use this - https://github.com/polkadot-js/api/pull/1171/files#diff-a60854aee74a1ede6dc8edf6544d4240R1404\r\n\r\n- set key\r\n- query to see if it has changed in the map"},{"labels":[null,"enhancement"],"text":"Introduced at https://github.com/paritytech/substrate/pull/2732"},{"labels":[null,null,"enhancement"],"text":"Elections now uses chunking for approvals and voters (see: https://github.com/paritytech/substrate/blob/master/srml/elections/src/lib.rs#L243). It would be useful to have a set of derives that let the caller \"just get everything\" without worrying about the chunking. There is already an internal function that does this (https://github.com/paritytech/substrate/blob/master/srml/elections/src/lib.rs#L1047) but no way to access it via RPC.\r\n\r\nThe derive would also be useful if it converted ApprovalFlag to booleans, as seen here: https://github.com/paritytech/substrate/blob/master/srml/elections/src/lib.rs#L1030\r\n\r\nThanks!"},{"labels":[null,null,"enhancement"],"text":"E.g. here: https://github.com/polkadot-js/api/blob/master/packages/api-derive/src/contracts/fees.ts#L47\r\n\r\nIt should not be BN, but the actual Codec type. derive is one of the rare places where we have typings, so let's make them correct.\r\n\r\ntests should also be updated (e.g expect.any(BN) -> expect.any(BalanceOf))"},{"labels":[null,null,"enhancement"],"text":"**Repro:**\r\n\r\n```javascript\r\n      api.derive.staking.info(stashId, (result) => {\r\n        ++count;\r\n\r\n        console.error('***', count, JSON.stringify(result));\r\n      }).catch(console.error);\r\n```\r\n\r\n**Expected:**\r\n\r\n```\r\n *** 7 {\"accountId\":\"5GNJqTPyNqANBkUVMN1LPPrxXnFouWXoe2wNSmmEoLctxiZY\",\"controllerId\":\"5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY\",\"nextSessionId\":\"5FA9nQDVg267DEd8m1ZypXLBnvN7SFxYwV7ndqSYGiN9TTpu\",\"nominators\":[],\"redeemable\":\"0\",\"rewardDestination\":1,\"stakers\":{\"total\":\"0x0000000000000000002386f26fc10000\",\"own\":\"0x0000000000000000002386f26fc10000\",\"others\":[]},\"stakingLedger\":{\"stash\":\"5GNJqTPyNqANBkUVMN1LPPrxXnFouWXoe2wNSmmEoLctxiZY\",\"total\":\"0x0000000000000000002386f26fc10000\",\"active\":\"0x0000000000000000002386f26fc10000\",\"unlocking\":[]},\"stashId\":\"5GNJqTPyNqANBkUVMN1LPPrxXnFouWXoe2wNSmmEoLctxiZY\",\"validatorPrefs\":{\"unstakeThreshold\":3,\"validatorPayment\":0}}\r\n\r\n...\r\n\r\n *** 8 something slightly different\r\n\r\n```\r\n\r\n**Actual:**\r\n\r\n```\r\n    *** 7 {\"accountId\":\"5GNJqTPyNqANBkUVMN1LPPrxXnFouWXoe2wNSmmEoLctxiZY\",\"controllerId\":\"5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY\",\"nextSessionId\":\"5FA9nQDVg267DEd8m1ZypXLBnvN7SFxYwV7ndqSYGiN9TTpu\",\"nominators\":[],\"redeemable\":\"0\",\"rewardDestination\":1,\"stakers\":{\"total\":\"0x0000000000000000002386f26fc10000\",\"own\":\"0x0000000000000000002386f26fc10000\",\"others\":[]},\"stakingLedger\":{\"stash\":\"5GNJqTPyNqANBkUVMN1LPPrxXnFouWXoe2wNSmmEoLctxiZY\",\"total\":\"0x0000000000000000002386f26fc10000\",\"active\":\"0x0000000000000000002386f26fc10000\",\"unlocking\":[]},\"stashId\":\"5GNJqTPyNqANBkUVMN1LPPrxXnFouWXoe2wNSmmEoLctxiZY\",\"validatorPrefs\":{\"unstakeThreshold\":3,\"validatorPayment\":0}}\r\n\r\n...\r\n\r\n    *** 8 {\"accountId\":\"5GNJqTPyNqANBkUVMN1LPPrxXnFouWXoe2wNSmmEoLctxiZY\",\"controllerId\":\"5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY\",\"nextSessionId\":\"5FA9nQDVg267DEd8m1ZypXLBnvN7SFxYwV7ndqSYGiN9TTpu\",\"nominators\":[],\"redeemable\":\"0\",\"rewardDestination\":1,\"stakers\":{\"total\":\"0x0000000000000000002386f26fc10000\",\"own\":\"0x0000000000000000002386f26fc10000\",\"others\":[]},\"stakingLedger\":{\"stash\":\"5GNJqTPyNqANBkUVMN1LPPrxXnFouWXoe2wNSmmEoLctxiZY\",\"total\":\"0x0000000000000000002386f26fc10000\",\"active\":\"0x0000000000000000002386f26fc10000\",\"unlocking\":[]},\"stashId\":\"5GNJqTPyNqANBkUVMN1LPPrxXnFouWXoe2wNSmmEoLctxiZY\",\"validatorPrefs\":{\"unstakeThreshold\":3,\"validatorPayment\":0}}\r\n```\r\n\r\nNotes:\r\n- I added a distinctUntilChanged in drr in api-derive, but right now it's a bit useless, because it only checks on === for different values, should check at least on `Codec` and `Codec[]`\r\n- The 2nd thing is I'm not sure distinctUntilChanged on api-derive is useful, it should probably take place lower down the level, so that repeated values don't happen on api.query or api.rpc.state.subscribeStorage"},{"labels":[null,null,"enhancement"],"text":""},{"labels":[null,"enhancement"],"text":"As implemented in https://github.com/paritytech/substrate/pull/2930"},{"labels":[null,null,"enhancement"],"text":"Current polkadot master: \r\n\r\nUnknown types found, no types for \r\n\r\nAuctionIndex,Bidder,IncomingParachain,LeasePeriod,LeasePeriodOf,NewBidder,ParaIdOf,SlotRange,SubId,UpwardMessage,WinningData,grandpa::AuthorityId\r\n\r\npolkadot metadata here https://gist.github.com/jacogr/7864197585e12ee751225f25a534129c\r\n\r\nSo some new, some needs to be aliassed (`grandpa::AuthorityId` -> `AuthorityId`) some are just names for existing, e.g. `ParaIdOf` (Same way `Balance` -> `BalanceOf`) gets handled"},{"labels":[null,null,"enhancement",null],"text":"... when available there, i.e. via https://github.com/paritytech/substrate/issues/2921\r\n\r\n- A number of parameters, previously in storage, have already moved, e.g. https://github.com/paritytech/substrate/blob/master/node/runtime/src/lib.rs#L171\r\n- More are on the way/in-progress, e.g. all fees\r\n\r\nOnce available on metadata, add to the api (like we have `genesisHash`, `runtimeVersion`) so it is available to all that want to query it. Additionally, update at least the derive interfaces to pull known/interesting values from here, if available."},{"labels":[null,null,null,"enhancement"],"text":"As implemented in https://github.com/paritytech/substrate/pull/2880"},{"labels":[null,null,"enhancement"],"text":"Intially from https://github.com/polkadot-js/apps/issues/1315\r\n\r\nThe 2.x `democracy.vote` doe not take a `i8` anymore, but rather a `Vote` (alongside a conviction). https://github.com/paritytech/substrate/blob/master/srml/democracy/src/lib.rs#L145\r\n\r\nThis has a specific encoding and decoding override for a compact encoding."},{"labels":[null,null,"enhancement"],"text":"I try to use a special encode(Buffer.from('2453545782b92053d401', 'hex')) as a parameter of the Text. Then, I have no way to restore the input parameter, because the input parameter lost some information in the conversion to a string with utf-8. I guess because “0x82” is a special code in utf-8.\r\n\r\nIn fact, this problem cause me to get an incorrect tx hash. Is there a way to solve it？\r\n\r\n```javascript\r\nBuffer.from(\r\n  new Text(Buffer.from('2453545782b92053d401', 'hex')).toU8a()\r\n).toString('hex') \r\n=== '3c535457efbfbdefbfbd2053efbfbd01'  // it should be 2453545782b92053d401\r\n```"},{"labels":[null,null,"enhancement"],"text":"We've already had an issue in the past where it was due to u32/u64 mismatch. Generally, it is actually NOT supported by the calls (and shouldn't be). I would suggest making this a throw in the constructor with a descriptive message as to why this is a bad idea."},{"labels":[null,null,"enhancement",null],"text":"Same thing as in #987, for `api.rpc.*.*`\r\n\r\nThis is different from #714, since these can be inferred in-editor."},{"labels":[null,null,null,"enhancement"],"text":"This needs to go after https://github.com/polkadot-js/api/pull/1007\r\n\r\nBasically, currently we only allow people to operate directly on the raw contract calls, i.e. https://github.com/polkadot-js/api/blob/master/packages/api/test/e2e/promise-contract.spec.ts#L92\r\n\r\nIn the above, we would really just like something along the following lines -\r\n\r\n```js\r\nimport { Contract } from '@polkadot/api-contract';\r\n\r\nawait new Contract(<api instance>, <abi>, <addr>)\r\n  .flip(<value to go along>, <max gas>, <...params>)\r\n  .signAndSend(<account>, (submittableResult) => {...});\r\n```\r\n\r\nThat is the end-result, earlier in the chain, we want to be able to deploy or attach code -\r\n\r\n```js\r\nimport { Blueprint } from '@polkadot/api-contract';\r\n\r\n// here it becomes a bit fuzzy... we need to \r\n//  - make the deploy call\r\n//  - as a result, we want a Contract instance (previous code block)\r\n//  - basically, it would take the address and abi to construct one\r\nawait new Blueprint(<api instance>, <abi>, <hash>)\r\n  .deploy(<value>, <gas>, <...params>)\r\n  .signAndSend(<account>, (submittableResult, contract) => {...});\r\n\r\n// even better\r\nconst contract = await new Blueprint(...).deploy(<account>, ...);\r\n```\r\n\r\nDeployment of code (putCode) needs something similar -\r\n\r\n```js\r\nimport { Code } from '@polkadot/api-contract';\r\n\r\n// same as above with a bit of fuzziness\r\n//  - as a result, we would like to retrieve a Blueprint instance\r\n//  - basically it would take the retrieved hash and abi, to construct one\r\nawait new Code(<api instance>, <abi>, <wasm bytes>)\r\n  .deploy(<endowment>, <max gas>)\r\n  .signAndSend(<account>, (submittableResult, blueprint) => {...});\r\n\r\n// even better\r\nconst blueprint = await new Code(...).deploy(<account>, ...);\r\n```\r\n\r\nSo as a crazy code returns blueprint, returns contract, it ends up -\r\n\r\n```js\r\nconst blueprint = await new Code(...).deploy(<account>, ...);\r\nconst contract = await blueprint.deploy(<account>, ...);\r\n\r\nawait contract\r\n  .flip(<value to go along>, <max gas>, <...params>)\r\n  .signAndSend(<account>, (submittableResult) => {...});\r\n```\r\n\r\n... or something like that\r\n\r\nAll-in-all, needs some playing to see what works and what doesn't, how to integrate and how to return values. Basically we want to move away from people having to manually inspect events, we can just handle all that transparently and have explicit interfaces.\r\n\r\nAdditionally, need to see how we tie this to all the type of api interfaces we are supporting, current RxJs & Promise (Similar approach as in Submittables?)"},{"labels":[null,null,"enhancement"],"text":"The ApiBase currently provides an `on` function for listening to connection-related events, but there's no way to unregister these event handlers. It would be nice to have an `off` function or similar that allows us to remove them. Thanks!"},{"labels":[null,null,"enhancement"],"text":"the change is that the metadata of the second hasher of a doublemap is the StorageHasher enum and no longer a String.\r\n\r\nhttps://github.com/paritytech/substrate/pull/2836"},{"labels":[null,"enhancement"],"text":"With a Substrate version from yesterday (https://github.com/paritytech/substrate/commit/a7dd2559a7658f11eed101efdcfc26dd8b57a9b5) the address card display seems to be broken.\r\n\r\nThe screenshot was taken on from https://polkadot.js.org/apps/#/accounts with a freshly installed node (pruned db, cleaned cargo cache and rebuilt WASM).\r\n\r\n<img width=\"1517\" alt=\"Screenshot 2019-06-05 at 11 43 11\" src=\"https://user-images.githubusercontent.com/125398/58946940-3a4d7400-8787-11e9-80a2-db3037311cb9.png\">\r\n"},{"labels":[null,null,"enhancement"],"text":"As per https://github.com/paritytech/substrate/pull/2586"},{"labels":[null,null,"enhancement"],"text":"process:\r\n  - construct & sign tx offline (could be external signer or creator)\r\n  - send tx via the api\r\n\r\n```js\r\nconst nonce = await api.query.system.accountNonce(keyring.dave.address());\r\nconst hex = api.tx.balances\r\n  .transfer(keyring.eve.address(), 12345)\r\n  .sign(keyring.dave, { nonce })\r\n  .toHex(); // hex UncheckedMortalExtrinsic\r\n\r\nreturn api.tx(hex).send(({ events, status }) => { ... });\r\n```"},{"labels":[null,null,"enhancement"],"text":"`Option<T>`, `Result<T,E>` and `Vec<T>` (`Vec<T>` not listed below, but has the same form as `Option<T>`)\r\n\r\nExample ABI: (@jacogr & @robbepop has the WASM for this)\r\n\r\n```js\r\n{\r\n    \"name\": \"SharedVec\",\r\n    \"deploy\": {\r\n        \"args\": []\r\n    },\r\n    \"messages\": [\r\n        {\r\n            \"name\": \"push\",\r\n            \"selector\": 865577567,\r\n            \"mutates\": true,\r\n            \"args\": [\r\n                {\r\n                    \"name\": \"value\",\r\n                    \"type\": \"i32\"\r\n                }\r\n            ],\r\n            \"return_type\": {\r\n                \"Result<T,E>\": {\r\n                    \"T\": [],\r\n                    \"E\": \"u32\"\r\n                }\r\n            }\r\n        },\r\n        {\r\n            \"name\": \"register\",\r\n            \"selector\": 572030971,\r\n            \"mutates\": true,\r\n            \"args\": [\r\n                {\r\n                    \"name\": \"mutator\",\r\n                    \"type\": \"AccountId\"\r\n                },\r\n                {\r\n                    \"name\": \"begin\",\r\n                    \"type\": {\r\n                        \"Option<T>\": {\r\n                            \"T\": \"u32\"\r\n                        }\r\n                    }\r\n                },\r\n                {\r\n                    \"name\": \"end\",\r\n                    \"type\": {\r\n                        \"Option<T>\": {\r\n                            \"T\": \"u32\"\r\n                        }\r\n                    }\r\n                }\r\n            ],\r\n            \"return_type\": {\r\n                \"Result<T,E>\": {\r\n                    \"T\": [],\r\n                    \"E\": \"u32\"\r\n                }\r\n            }\r\n        },\r\n        {\r\n            \"name\": \"set\",\r\n            \"selector\": 2028185770,\r\n            \"mutates\": true,\r\n            \"args\": [\r\n                {\r\n                    \"name\": \"at\",\r\n                    \"type\": \"u32\"\r\n                },\r\n                {\r\n                    \"name\": \"to\",\r\n                    \"type\": \"i32\"\r\n                }\r\n            ],\r\n            \"return_type\": {\r\n                \"Result<T,E>\": {\r\n                    \"T\": \"i32\",\r\n                    \"E\": \"u32\"\r\n                }\r\n            }\r\n        },\r\n        {\r\n            \"name\": \"get\",\r\n            \"selector\": 4266279973,\r\n            \"mutates\": false,\r\n            \"args\": [\r\n                {\r\n                    \"name\": \"at\",\r\n                    \"type\": \"u32\"\r\n                }\r\n            ],\r\n            \"return_type\": {\r\n                \"Option<T>\": {\r\n                    \"T\": \"i32\"\r\n                }\r\n            }\r\n        },\r\n        {\r\n            \"name\": \"len\",\r\n            \"selector\": 1403873684,\r\n            \"mutates\": false,\r\n            \"args\": [],\r\n            \"return_type\": \"u32\"\r\n        }\r\n    ]\r\n}\r\n```"},{"labels":[null,null,null,"enhancement"],"text":"Add short description to every type on https://polkadot.js.org/api/types/ so that people looking for information don't need to visit every type detail page to get an idea what a specific type is/ can/ should be used for.\r\n\r\nRelated to https://github.com/polkadot-js/apps/issues/1017\r\n"},{"labels":[null,"enhancement"],"text":"How do I declare `[u8; 16]` type in the apps / settings / developer section?\r\n\r\nI put this issue here instead of apps because I don't think type registry supports this.\r\n"},{"labels":[null,null,"enhancement"],"text":"As defined here https://github.com/Robbepop/pdsl/issues/40\r\n\r\n`types/ContractAbi`"},{"labels":[null,null,"enhancement"],"text":"Currently every new instance of Api will query metadata information and then it will become usable.\r\nThis adds a significantly initialization time which is not ideal. Image someone wants to develop a serverless lambda with polkadot.js.\r\nIt will be good if the constructor of Api takes a metadata json object and if it presents, use it instead of fetch from server.\r\nMay optionally still fetch from server and print a warning if mismatch found.\r\n"},{"labels":[null,"enhancement",null],"text":"As part of HeaderExtended in derive - atm we only look at Seal, and since these are not being produced anymore, we are missing the block author indicator."},{"labels":[null,"enhancement"],"text":"The Treasury module in Substrate exposes a \"Proposal\" type defined here: https://github.com/paritytech/substrate/blob/master/srml/treasury/src/lib.rs#L132\r\n\r\nThis is different than the Proposal type used in the Democracy module, which we have type bindings for here: https://github.com/polkadot-js/api/blob/master/packages/types/src/type/Proposal.ts\r\n\r\nHowever, the METHODS_STORAGE documentation does not distinguish between the two types (see: https://github.com/polkadot-js/api/blob/master/docs/METHODS_STORAGE.md#treasury), and I cannot find an implementation for the Treasury-related Proposal type. Could we add this type? Thanks."},{"labels":[null,"enhancement",null],"text":""},{"labels":[null,"enhancement"],"text":"Related to https://github.com/polkadot-js/api/issues/429\r\n\r\nExample -\r\n\r\n```json\r\n{\r\n    \"name\": \"Incrementer\",\r\n    \"deploy\": {\r\n        \"args\": [\r\n            {\r\n                \"name\": \"init_value\",\r\n                \"type\": \"u32\"\r\n            }\r\n        ]\r\n    },\r\n    \"messages\": [\r\n        {\r\n            \"name\": \"inc\",\r\n            \"selector\": 257544423,\r\n            \"mutates\": true,\r\n            \"args\": [\r\n                {\r\n                    \"name\": \"by\",\r\n                    \"type\": \"u32\"\r\n                }\r\n            ],\r\n            \"return_type\": null\r\n        },\r\n        {\r\n            \"name\": \"get\",\r\n            \"selector\": 4266279973,\r\n            \"mutates\": false,\r\n            \"args\": [],\r\n            \"return_type\": \"u32\"\r\n        },\r\n        {\r\n            \"name\": \"compare\",\r\n            \"selector\": 363906316,\r\n            \"mutates\": false,\r\n            \"args\": [\r\n                {\r\n                    \"name\": \"x\",\r\n                    \"type\": \"u32\"\r\n                }\r\n            ],\r\n            \"return_type\": \"bool\"\r\n        }\r\n    ]\r\n}\r\n```\r\n\r\nDispatch on the contract side is pretty simple:\r\n\r\n- For deploy just take all the parameters (arguments) in the order they are listed in the JSON and decode them using SCALE.\r\n- For call the first 4 bytes are encoding the message selector and the rest is again just the SCALE encoded arguments for the selected message.\r\n\r\ncc @RobbePop"},{"labels":[null,"enhancement",null],"text":"(Please correctly me if I am mistaken)\r\n\r\nSubstrate drops the ws connection if it is idle for a minute. It will be good if there is a way to have polkadot.js sending some ping message in a configurable amount of interval (with a reasonable default) to ensure the connection is alive."},{"labels":[null,null,"enhancement"],"text":"Currently it seems like the “unknown Metadata version” is swallowed and then use of the API spits out wrong errors. \r\n\r\nI believe it it the fallback to v0 that just parses garbage. Can remove v0 parsing support as a start. "},{"labels":[null,"enhancement"],"text":"Currently the type registry is a shared global variable. polkadot.js will fail with unclear error message when multiple versions `@polkadot/types` are installed because each version of the lib have its own type registry.\r\n\r\nUntil the type registry is been refactored to not using shared global variable, it should detects if multiple versions are installed and print a big warning message.\r\n"},{"labels":["enhancement"],"text":"Support `linked_map` which introduced at https://github.com/paritytech/substrate/pull/1763\r\n\r\nNeeds ability to enumerate the collection.\r\n\r\nThis is also required to support the new staking methods."},{"labels":[null,"enhancement"],"text":"- Implemented in https://github.com/paritytech/substrate/pull/1918\r\n- First used in substrate system events, https://github.com/paritytech/substrate/blob/master/srml/system/src/lib.rs#L331-L345"},{"labels":[null,"enhancement"],"text":"Basically, the keyring in the tests need to be constructed with the `isHSKD` param (this needs to bubble through as the default from common)"},{"labels":[null,null,"enhancement"],"text":"(Split from https://github.com/polkadot-js/apps/issues/800)\r\n\r\nThe `state_storage` subs can support multiple keys per subscription. Currently we are only doing a single subscription for each query even when we know from the use side that we need to do multiples in a row. Doing multiples in one-go can reduce and optimise the load/number of subs greatly on both sides.\r\n\r\nEven if at first we only implement this via the same type, maybe even `api.query.balances.freeBalance.multi(Alice, Bob, Dave, ...)` it will drop a lot of the use and can be used to make thing more optimal, for instances in the case of `api.derive.*`\r\n\r\nFrom @amaurymartiny \r\n\r\nThe `.multi` sounds good, it's clear on what it does (principle of least surprise), so I'm okay with this addition.\r\n\r\nBut as you said, it's only on one storage key, so I won't help in most `derive.*` where the storage keys are different, e.g. I can't do a multi-subscription to:\r\n\r\n```js\r\napi.query.balances.freeBalance(Alice)\r\napi.query.system.accountNonce(Alice)\r\n```\r\n\r\nboth in one subscription. I'd see something like:\r\n\r\n```js\r\napi.query.multi(\r\n  api.query.balances.freeBalance(Alice),\r\n  api.query.system.accountNonce(Alice)\r\n).then/subscribe()\r\n```\r\n\r\nThe freeBalance example above would be slightly more verbose:\r\n\r\n```js\r\napi.query.multi(\r\n  api.query.balances.freeBalance(Alice),\r\n  api.query.balances.freeBalance(Bob),\r\n  api.query.balances.freeBalance(Dave),\r\n)\r\n```\r\n\r\nso we could still add the `query.balances.freeBalance.multi` syntax as a shorthand. But I think the `query.multi()` one is more important."},{"labels":[null,"enhancement"],"text":"From Riot -\r\n\r\n\"\r\nD -\r\nI found the issue. When I send it via api.tx.my_runtime.my_runtime_fn() I need to transfer the value as a hex string. StringToU8a didn’t work for me, whereas u8aToHex(stringToU8a(‘my awesome string’)) solved it.\r\n\r\nJaco -\r\nUmpf, not great, but correct. The issue is that when dealing with decoding, the vectors are length prefixed, so the types check for the length prefix when passed a Uint8Array.\r\n\r\nIn this case, it would probably make sense that, when a \"normal string\" (i.e. no-hex), encode it transparently with the length. (So no hoops) Will log an issue for that. (There is also compactAddLength which will add the length prefix, but still a hoop like with hex)\r\n\""},{"labels":[null,"enhancement"],"text":"https://github.com/paritytech/substrate/pull/1884\r\n\r\nThis is along the same lines as ChainProperties, i.e. just a random bag of goodies. It would be good to have a Json base to extend from for both of these since unlike other RPCs they are not fully structured and (mostly) cast in stone with only extensions -\r\n\r\n- NetworkStatus is currently in a POC-phase and can change drastically\r\n- ChainProperties can be anything in the chain specification (user-defined)"},{"labels":[null,null,"enhancement"],"text":"Basically would allow generation of interfaces as specified by metadata on a per chain basis, replacing the full class definitions as we currently have.\r\n\r\n(After https://github.com/polkadot-js/api/pull/712, original idea for generation by @xlc )\r\n"},{"labels":[null,"enhancement"],"text":"Since introduction of Currency trait to substrate srml balances module, several other modules now use `BalanceOf` instead of `Balance`."},{"labels":[null,"enhancement"],"text":"Initial discussion happened on https://github.com/polkadot-js/apps/pull/684#discussion_r255298425\r\n\r\n- Make API more explorable by default and without tools, i.e. if we add something like this for `tx`, `query`, `derive`\r\n```js\r\napi.tx.listAll() // shows all section.methods with description\r\n```\r\n\r\n- dev-only exposure, probably around here - https://github.com/polkadot-js/apps/blob/master/packages/ui-api/src/Api.tsx#L92\r\n\r\n> So expose once initialised and we are on dev chain (we should be able to use this https://github.com/polkadot-js/apps/blob/master/packages/ui-api/src/util/isTestChain.ts - looking at it now, now 100% on the `dev|loc` match, explicit via `local` and `development` is probably better. I know why it is short, dev chains originally retuned `dev` instead of `development`)"},{"labels":[null,"enhancement"],"text":""},{"labels":[null,"enhancement"],"text":"cc @ianhe8x \r\n\r\nStarted playing a bit with the signer, I think it could make sense to make it a bit richer to show the send part to submit the actual status through as well. This way both the dapp and the signer app can actually track what is happening and display status as/when required.\r\n\r\nSo what I'm basically suggesting -\r\n\r\n```js\r\nexport interface Signer {\r\n  sign (e: SubmittableExtrinsic, a: string, o: SignatureOptions): Promise<number>;\r\n  update?: (id: number, status: Hash | SubmittableResult) => void \r\n}\r\n```\r\n\r\nFirst off, the sign returns an internal id that identifies the operation. An optional `update` on the signer interface then can receive status updates from the sending operation -\r\n\r\n- `id: number` - the id that was returned via `sign`\r\n- `status: Hash | SubmittableResult` - returns `Hash` when the `signAndSend` has no callback, otherwise the `SubmittableResult`\r\n\r\nBasically the status updates gets provided to both the signer as well as the underlying call that is made. So we just check `api.signer && api.signer.update` and then provide the status as required to the signer in addition to the actual caller.\r\n\r\nStumbled across this in `apps` when trying to get the JS console to have the updates, but have the signing done by the apps signer. And both the apps UI as well as the actual JS call needs the ability to have the status.\r\n\r\n(As an complete off-topic here, would love to integrate external signers as/when they are available in apps, so if you have something, would love to start working with you on that to integrate over there)"},{"labels":[null,"enhancement"],"text":""},{"labels":[null,null,"enhancement"],"text":"I can't find a way to add custom derives without forking this repo. It will be good if this is extensible.\r\n\r\nThe real issue I am having is that we have implemented a generic asset module using `StorageDoubleMap` which there are no metadata support (https://github.com/paritytech/substrate/issues/1715), so I want to implements the query manually. I can do it via rpc calls but can't find a good way to bind this with UI and everything seems very tacky to me."},{"labels":[null,"enhancement",null],"text":"https://github.com/polkadot-js/api/blob/master/packages/api-derive/src/democracy/referendumInfos.ts#L13\r\n\r\nThe current work-around is along the lines of https://github.com/polkadot-js/apps/blob/master/packages/app-democracy/src/Referendums.tsx#L45-L52\r\n\r\nBut it doesn't quite make sense to have to do this everywhere in multiple apps when derive should have nicely-packaged information. This index is required to (a) get any votes, (b) make a vote, so very relevant to acting on the information presented.\r\n\r\ncc @jnaviask"},{"labels":[null,"enhancement"],"text":"This prevents to node.js program exit cleanly because there is no disconnect / close method so `process.exit` have to be used.\r\n\r\n`WSProviderInterface` should have a `disconnect` method to close ws connection\r\n\r\nIn additional to that, I think following changes can be helpful (not very confident so feel free to ignore those suggestions)\r\n\r\nMove `connect` method to `ProviderInterface` and have `disconnect` on there as well\r\n\r\nAdd `open` and `close` to `ApiBase` method which does connect & setup and disconnect & teardown.\r\n\r\n----\r\n\r\nCurrent we are using `provider.websocket.close()` which logs \r\n\r\n```\r\nAPI-WS: disconnected from ws://127.0.0.1:9944::1000: Normal connection closure\r\n```"},{"labels":[null,"enhancement"],"text":"As a dapp, it doesn't always have access to key pair. Key pairs could be managed in a browser extension or hardware wallet. So I propose to introduce signer to api and let it do the signing. This will allow our browser extension to work with the api by exposing a signer into browser's global.\r\n\r\n```\r\nexport interface Signer {\r\n  sign(extrinsic: Extrinsic, opt: {from: string} & SignatureOptions): Promise<void>;\r\n}\r\n```\r\n\r\nsignAndSend is the place to use the signer. I prefer to changing the signature to below which looks more neat\r\n```\r\n  signAndSend (options: SignAndSendOptions)\r\n  signAndSend (options: SignAndSendOptions, statusCb: StatusCb)\r\n  signAndSend (options: SignAndSendOptions, statusCb?: StatusCb)\r\n\r\ninterface SignAndSendOptions extends Partial<SignatureOptions> {\r\n  from: string | KeyringPair\r\n}\r\n```\r\nthough to keep backward compatible, it could also be like:\r\n```\r\nsignAndSend (account: KeyringPair | string, _options?: Partial<SignatureOptionsPartial> | StatusCb, statusCb?: StatusCb)\r\n```\r\n\r\nI would like to hear from you if it's the right direction before submitting my PR.\r\n"},{"labels":[null,"enhancement"],"text":"Basically just a wrapper (2 lines) around the registry exposing the same. The rationale: no additional imports needed, and it is currently quite core. (Is exposed via the constructor, but injection can happen at any point)"},{"labels":[null,null,"enhancement"],"text":"Related to https://github.com/paritytech/substrate/pull/1624\r\n\r\nThis needs to be coordinated with the testnet rollouts - it breaks everything."},{"labels":[null,null,"enhancement",null],"text":"Contracts has been updated (could probably go after https://github.com/polkadot-js/api/issues/590 - then convert static to be v1 static in inject and doc generation. Basically a small part of #635 )\r\n\r\nBasically -\r\n\r\n- for types/scripts, convert imports to use v1 static (not v0)\r\n- cleanup to make sure it works"},{"labels":[null,"enhancement"],"text":"I'm suggesting that instead of `sign(pair, nonce, era)` we pass through `sign({ pair, nonce, era })`. (Need to look into this exactly)\r\n\r\nCurrently we don't allow the nice `signAndSend` shortcut to set the eras at all. So it is driven from that perspective. So `signAndSend(pair)` can still work as-is. `signAndSend({ pair, ... })` can actually pass in `nonce` (optional, can be detected), `era` (optional) and `blockHash` (optional, generis or detected) then as well.\r\n\r\nI would almost suggest that the `signAndSend` default era be set - not sure how many blocks to allow. So by default we actually do mortal instead of immortal."},{"labels":[null,"enhancement",null],"text":"... is it missing in types/src/Health (relatively new extension)"},{"labels":[null,"enhancement",null],"text":"`eq(other?: any): boolean` - Implement consistency across all. (`eq` name chosen since it matches what is in BN). This would allow use to to eg. `accountId.eq(anotherId)` or `h256.eq(anotherHash)`\r\n\r\nExample for U8a (untested) - \r\n\r\n```js\r\neq (other?: any): boolean {\r\n  if (!other || !(other instanceof Uint8Array) || this.length !== other.length) {\r\n    return false;\r\n  }\r\n\r\n  // find the first index value where the 2 does not match\r\n  const nonMatchIndex = this.find((value: number, index: number) =>\r\n    other[index] !== value\r\n  );\r\n\r\n  return isUndefined(nonMatchIndex);\r\n}\r\n```\r\n\r\nExample for struct (untested) - \r\n\r\n```js\r\neq (other? any): boolean {\r\n  if (!other || !(other instanceof Struct)) {\r\n    return false;\r\n  }\r\n\r\n  // make sure all the same keys are there\r\n  ... (return if no match found)\r\n  \r\n  // compare the values 1-by-one via .eq on those values\r\n  .. (return if no match found)\r\n}\r\n```"},{"labels":[null,"enhancement",null],"text":"- There are valid Rust types and can be used inside the actual types\r\n- Create classes (similar to i8)\r\n- Export these in index.ts"},{"labels":[null,"enhancement"],"text":"Same as sign + send with some signature changes -\r\n\r\n- Takes in `(accountKeypair, statusCallback)`\r\n- Determines nonce by default (makes call to `system.accountNonce(accountKeypair.address()`)\r\n- Uses genesisHash in encoding\r\n\r\nGenerally caters for the basic use-case - for finer control the sign/send pair can be used individually. This just combines the 2 functions and only requires the keypair to operate."},{"labels":[null,"enhancement",null],"text":"When merged - https://github.com/paritytech/substrate/pull/1362"},{"labels":[null,"enhancement"],"text":"The current implementation of metadata decoding decodes the `default` field of metadata storage functions assuming that they are `vec<u8>`, which they are.\r\n\r\nBut the `vec<u8>` actually represents something, so an additional layer of decoding needs to be done. Basically decode this `vec<u8>` using the `type` of the storage.\r\n\r\nThis additional decoding has been commented on purpose for now:\r\nhttps://github.com/polkadot-js/api/blob/master/packages/types/src/Metadata/Modules.ts#L221-L230. It should be enabled when needed."},{"labels":[null,"enhancement"],"text":"After this we are ending up with a lot of boilerplate.\r\n\r\n- add Method is input type ot Extrinsic\r\n- check with `instanceof Method`\r\n- apply `{method: value }` transform"},{"labels":[null,"enhancement"],"text":"So basically currently we can fully specify type as text, i.e. `Compact<u64>` would parse (via `createType`) and create a structure, `(u64, u32, AccountId)` would create a tuple. These are all great for specification, however one of the missing pieces to make text -> type self-sufficient is `Struct` definitions.\r\n\r\nA suggestion would be to allow the input of the struct as text, i.e. `{ \"account\": \"AccountId\", \"blockNumber\": \"BlockNumber\" }` would end up as a \r\n\r\n```\r\nclass MyType extends Struct.with({ account: AccountId, blockNumber: BlockNumber }) {\r\n}\r\n```\r\n\r\nThis moves us closer to being able to inject fully-specified JSON for all types. (We still have `Enum`/`EnumType` to deal with, leaving this be for this issue)\r\n\r\nThe suggestion would be to, in the above case, basically treat the definition as JSON, so parse to find start/end and then use this objects to extract the definition and create."},{"labels":[null,"enhancement"],"text":"(Needs https://github.com/polkadot-js/api/issues/475)\r\n\r\n- submitAndWatch\r\n- track status events\r\n- upon completion (non-Finalization), end\r\n- upon Finalization, track events in next steps\r\n- get block, check for extrinsic inclusion (against data)\r\n- if found, pull system.events for that block\r\n- return events as part of the subscription, i.e. callback becomes `(status: ExtsinsicStatus, events?: Events)` as opposed to the current `(status: ExtinsicStatus)`\r\n\r\nPromise here is easy, I'm not convinced about the RxJS version, i.e. don't want to change the signature to `[ExtrinsicStatus, Vector]` there - not 100% sure how to deal with allowing `.subscribe((status: ExtsinsicStatus, events?: Events) => {...})` there"},{"labels":[null,"enhancement"],"text":"Currently api.query will perform queries (one-shot) leaving out the optional head hash. It is useful to do historic queries as well where it is added. \r\n\r\nSuggesting adding ‘at’ that will take the hash params. So basically current we can only do\r\n\r\n```\r\napi.query.balances.freeBalanceOf(Alice)\r\n```\r\n\r\nwhich performs the query for the latest block. An extension to this could be\r\n\r\n```\r\napi.query.balances.freeBalanceOf.at(hash, Alice) \r\n```\r\n\r\nwhich will perform at a specific block. The reason for the `at` is that it would be simple to determine which route (i.e. which underlying RPC call) to take. It is a bit tougher and messier to try and adjust the calls and determine intent by just using the current endpoints, i.e. it is a one-time query, a subscription query or a one-time-at query. At the same time we still have control of which params goes where. Additionally can be added without breaking old use cases. \r\n\r\n(Suggestions and comments obviously welcome on approach)"},{"labels":[null,null,"enhancement"],"text":"- Description and tracking issue https://github.com/paritytech/substrate/issues/1256\r\n- Implementation in https://github.com/paritytech/substrate/pull/1264\r\n\r\n(Assigning @amaurymartiny since he has been looking at it and playing with it already)"},{"labels":[null,"enhancement",null],"text":"- https://github.com/paritytech/substrate/pull/1269\r\n- Expand to add endpoint in `packages/type-jsonrpc/src/system.ts`\r\n- Add `Health` type to `packages/types`"},{"labels":[null,"enhancement",null],"text":"Exactly the same as Block, it just has Extrinsics as `Bytes`. This is useful for the client development where we don't want to decode the extrinsics"},{"labels":[null,null,"enhancement",null],"text":"Process -\r\n\r\n- API subscribes to runtimeVersion\r\n- When the runtime version changes, retrieve metadata via `state_getMetadata`\r\n- Inject\r\n\r\nBasically we want the initialization that happens in https://github.com/polkadot-js/api/blob/master/packages/api/src/Base.ts#L456-L462 to happen on version updates\r\n\r\nThis is the one area where oo7 does it really well, i.e. `tie` to version, update on changes - https://github.com/paritytech/oo7/blob/master/packages/oo7-substrate/src/bonds.js#L207-L211"},{"labels":[null,"enhancement",null],"text":"Check against Substrate, a number are missing, off the top of my head `state_queryStorage` and `chain_subscribeRuntimeVersion` are at least 2 items (and there are more - check against all RPC modules)\r\n\r\n- check the Rust code, substrate/core/rpc/{author,chain,state, system}\r\n- add the missing methods to jsonrpc"},{"labels":[null,"enhancement",null],"text":"Discussed in https://github.com/polkadot-js/api/issues/440#issuecomment-444760455"},{"labels":[null,"enhancement"],"text":"Right now [I'm adding a LightApi](https://github.com/polkadot-js/light-ui/tree/master/packages/light-api) on top of the ApiRx object. But thinking about it, it could go below.\r\n\r\n**Proposal: Add a LightApi layer below Api**\r\n\r\nIdeally, LightApi is something that is totally invisible to the user, i.e. we keep the exact same final usage: `const api = new Api(new Provider(...))`.\r\n\r\nHowever, add some \"light logic\", i.e. make the minimum viable number of jsonrpc calls to the node, assuming the node doesn't hold state. For example, if the user wants to subscribe on a account's balance, then make a subscription/polling on `newHead`, check the events on new head, and only make a subsequent jsonrpc call `getStorage` if the events show that the relevant part of the state has changed.\r\n\r\nSo, on load, Api will check:\r\n- the provider\r\n- the roles of the node, more specifically if it's a light node\r\n\r\nand perform:\r\n\r\n||Full node|Light Node|\r\n|-|-|-|\r\n|**WsProvider**|Use the current impl.|Use light logic|\r\n|**HttpProvider**|Use light logic|Use light logic|\r\n\r\nIn this case, Providers stay \"dumb\", i.e. this invalidates #435 (dumb polling is enough for HttpProvider). The global idea is to not put the logic in #435 in rpc-provider, but in a layer on top of rpc-provider, but below api.\r\nAnd it's totally transparent to all other layers, e.g. #427 doesn't care if the underlying Api is using full logic or light logic."},{"labels":[null,"enhancement"],"text":"This is very ineffective, adds load to the node and delayed operation since we are not operating in a push fashion. However some users do prefer an HTTP API. So simulate subscriptions -\r\n\r\n1. poll for new heads via `chain_getHead`\r\n2. keep track of \"subscriptions\" (managed inside provider)\r\n3. on new head, retrieve state changes via `state_getStorage` as per subscriptions, push results\r\n\r\nPossibly just trap the subscription methods and hook into the `chain_getHead` loop, so it is transparent to the user. (Using subs in this way would come with an \"inefficient\" warning)"},{"labels":[null,"enhancement"],"text":"Hi, thanks for providing such a great tool for us. May I ask, do you have a plan to let the SDK can generate abi after deploying smart contract?"},{"labels":[null,"enhancement"],"text":"Basically, have an api endpoint, which takes multiple storage values and runs it through a derivation function, returning a result. And example may be of votingBalance, we could do (pseudo-ish code) -\r\n\r\n```\r\n{\r\n  section: 'balance',\r\n  method: 'votingBalance',\r\n  inputs: ['balances.freeBalanceOf', 'balances.reservedBalanceOf`],\r\n  derive: (free, reserved) => free.add(reserved)\r\n}\r\n```\r\n\r\nand then\r\n\r\n```\r\napi.derive.balances.votingBalance(ALICE).toString();\r\n```\r\n\r\nBasically the API will add these and attach them to the derive endpoints. We def. need something to this effect, either we write code or have it more templated. (And needs to support both API types)\r\n\r\nEDIT: The above example is already hairy, how to we cater for params passed in?"},{"labels":[null,"enhancement",null],"text":"Something like\r\n\r\n```\r\nObject.defineProperty(this, 'propName', {\r\n  enumerable: true,\r\n  writable: false,\r\n  get: () => this.get('propName'); // or via index\r\n});\r\n```\r\n\r\n(Obviously looping through the structure provided with the names)"},{"labels":[null,"enhancement"],"text":"Currently it is required to have all types listed in a [single file](https://github.com/polkadot-js/api/blob/master/packages/types/src/index.ts) and I don't know if there is an easy way to add a new type. \r\n\r\nhttps://github.com/polkadot-js/api/blob/2f3af48875dec6aee3b8fa3c8dd674d6e2dd31bf/packages/types/src/codec/createType.ts#L152\r\n\r\nThis causes issues when we want to invoke a new module method that returns a new type.\r\n\r\npolkadot.js should provides ability to:\r\n1. Allow new types to be added at runtime (via a type registry or something similar)\r\n2. Able to generate type files from Rust code so no need to manually keep the typescript definitions in sync with Rust definitions.\r\n\r\nAlternatively, enhance the runtime metadata to include all the type definitions and have the js code construct the types using the metadata in runtime. Then there won't be any needs to worry about type registration. This can also be used to generate .d.ts files to provide documentations and IDE supports for typescript projects. This will also solve the potential type name conflicting issues (that the current types names are not namespaced)."},{"labels":[null,"enhancement"],"text":"Perbill - https://github.com/polkadot-js/api/blob/c42b71a6d8f892e57799f0a43d7c5e637e7d4c52/packages/types/src/Perbill.ts#L9\r\nPermill - https://github.com/polkadot-js/api/blob/c42b71a6d8f892e57799f0a43d7c5e637e7d4c52/packages/types/src/Permill.ts#L9"},{"labels":[null,"enhancement",null],"text":"Reference https://github.com/polkadot-js/api/pull/350/files#diff-95597f67ed68d7dffc27ba1f0501e5b1R190"},{"labels":[null,"enhancement"],"text":"Current when storage entry is empty (null), we don't automagically set the default value. So for instance, we are doing this - https://github.com/polkadot-js/api/pull/231/files#diff-2e3ff95c7b73d14c1a8b2fb9c44197a9R143"},{"labels":[null,null,"enhancement",null],"text":"In Polkadot-JS API Docs https://github.com/polkadot-js/api/docs, what is the current procedure that is used (both in 'development' and in 'production') for generating the Markdown (.md) and HTML (.html) docs for our Gitbook at https://polkadot.js.org/api/?\r\n\r\nNote that I reviewed comments between @jacogr and @amaurymartiny in https://github.com/polkadot-js/api/pull/159, and created this PR https://github.com/polkadot-js/api/pull/167 to address Issue #154, although I'm not sure if what I've done is correct. So I've come up with the following questions:\r\n\r\n1) How are we generating the HTML .html files in docs/ directory?\r\n\t* If I delete a HTML doc file (i.e. docs/api-provider/classes/_http_index_.httpprovider.html) and then run `yarn; yarn run build:htmldoc;`, the Bash Terminal logs says `Documentation generated at /polkadot-js/api/docs/html`, but the file _http_index_.httpprovider.html does not exist (isn't regenerated).\r\n\r\n2) How are we generating the Markdown .md files in docs/ directory?\r\n\t* Were the Markdown .md files that are currently there generated originally generated by running `yarn clean && typedoc --theme markdown --out docs/html` (i.e. using the `markdown` instead of the `default` theme)\r\n\t\t* Note: When I previously ran `yarn; yarn run build:htmldoc;`, the Bash Terminal logs also said `To generate markdown please set option --theme markdown`.\r\n\t* Are we currently just \"manually\" modifying the Markdown .md files (instead of generating them with a script)?\r\n\r\n\t* How are we updating the Markdown .md files in docs/ directory automatically after modifying the Typedoc comments in the code comments? (i.e.\r\n\t\t```\r\n\t\t/**\r\n\t\t * @example\r\n\t\t * ```javascript\r\n\t\t...\r\n\t\t```\r\n\r\n3) Should we by using the `gitbook` command at all? https://toolchain.gitbook.com/\r\n\r\n4) Should https://polkadot.js.org/ have a {.api} link to the Github repo and a link to the docs at https://polkadot.js.org/api/?"},{"labels":["enhancement"],"text":"Cleanup encoding all-round -\r\n\r\nhttps://github.com/polkadot-js/apps/pull/129/files#diff-f4e153119ebcf3e652c624e3d01f6a44R33"},{"labels":[null,null,"enhancement",null],"text":"Convert to ES6 classes in the same fashion as https://github.com/polkadot-js/client/pull/132\r\n\r\nhttps://github.com/polkadot-js/api/blob/master/packages/api-provider/src/http/index.ts\r\nhttps://github.com/polkadot-js/api/blob/master/packages/api-provider/src/ws/index.ts\r\n\r\nNot the only 2 places in the API layer, but a start. (Bonus convert all the closures with self)"},{"labels":["enhancement"],"text":"e.g. in the case of storage, we don't currently do the transform 100% - there really should be no need to call transform on the value (e.g. `encodeAddress` in this case), it should just be done for you in the API.\r\n\r\n```js\r\n// TODO We should unsubscribe from subscriptions\r\n  subscribeProposals () {\r\n    const { api } = this.props;\r\n    const key = createStorageKey(method)();\r\n    const transform = storageTransform(method);\r\n\r\n    api.state\r\n      .getStorage(key)\r\n      .subscribe((value) => {\r\n        this.setState({\r\n          proposals: (transform(value, 0) as any[])\r\n          .reduce((proposals, [propIdx, proposal, accountId]) => {\r\n            const address = encodeAddress(accountId);\r\n\r\n            if (!proposals[address]) {\r\n              proposals[address] = [propIdx];\r\n            } else {\r\n              proposals[address].push(propIdx);\r\n            }\r\n\r\n            return proposals;\r\n          }, {})\r\n        });\r\n      });\r\n  }\r\n```\r\n\r\n(The above from the apps/example/tut-003)\r\n\r\nIt means we would need to pass the actual un-encoded key to the method and use that in the deconstruction. So the call could become `getStorage(storage.staking.public.freeBalanceOf, <params>).subscribe(...)`\r\n\r\nNeeds some thinking around the auto-generation, i.e. how do we specify these types to make it \"just happen\"."},{"labels":[null,"enhancement"],"text":"Currently when the connection is lost (i.e. node restarted), the API will reconnect. However in this case the old/previous subscripts are still active and not updated - basically new subscriptions will work, old ones won't get data resulting in a half-working app.\r\n\r\nSo...\r\n\r\n1. Keep a list of subscriptions,\r\n2. On re-connect, unsubscribe from what we have (the node may be the same one with an internet hiccup) and then re-do the subscription fresh\r\n3. The issue comes in with ids... currently subscriptions are mapped through on the Id from the node, in this case these probably needs to be a mapping layer that takes \"id the app knows it at\" -> \"id the node knows it at\"\r\n\r\nSome through needed still."}]