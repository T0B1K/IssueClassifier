[{"labels":["feature"],"text":"It would be interesting to simulate different values of `prefers-color-scheme`, so developers could write visual tests for light and dark mode.\r\n\r\nPossible API:\r\n```\r\npage.emulate({\r\n  viewport: {\r\n     colorScheme: 'dark'\r\n  }\r\n});\r\n```\r\n\r\nThere is an article of how this could be achieved: https://www.bram.us/2019/09/04/take-both-light-and-dark-mode-screenshots-with-puppeteer/\r\n\r\nBut seems rather hacky and unperformant, since it needs to boot up two completely different chrome instances."},{"labels":["feature"],"text":"<!--\r\nSTEP 1: Are you in the right place?\r\n\r\n- For general technical questions or \"how to\" guidance, please search StackOverflow for questions tagged \"puppeteer\" or create a new post.\r\n\r\nhttps://stackoverflow.com/questions/tagged/puppeteer\r\n\r\n- For issues or feature requests related to the DevTools Protocol (https://chromedevtools.github.io/devtools-protocol/), file an issue there:\r\n\r\nhttps://github.com/ChromeDevTools/devtools-protocol/issues/new.\r\n\r\n- Problem in Headless Chrome? File an issue against Chromium's issue tracker:\r\n\r\nhttps://bugs.chromium.org/p/chromium/issues/entry?components=Internals%3EHeadless&blocking=705916\r\n\r\nFor issues, feature requests, or setup troubles with Puppeteer, file an issue right here!\r\n-->\r\n\r\n### Steps to reproduce\r\n\r\n**Tell us about your environment:**\r\n\r\n* Puppeteer version: 1.19\r\n* Platform / OS version: macOS\r\n* URLs (if applicable):\r\n* Node.js version: 10.16\r\n\r\n**What steps will reproduce the problem?**\r\n\r\nI want to emulate `@media (hover: ...)` to test my CSS at different devices.\r\nExample:\r\n```\r\na {\r\n  color: green;\r\n}\r\n\r\n@media (hover: hover) {\r\n  a:hover {\r\n    background: red;\r\n  }\r\n}\r\n```\r\n\r\n`@media (hover: hover)` works well when I run this code in puppeteer+macOS. But I want to emulate `@media (hover: none)` for mobile device to test it.\r\n\r\n**What is the expected result?**\r\n\r\nAPI to configure input mechanism."},{"labels":[null,"feature",null],"text":"<!--\r\nSTEP 1: Are you in the right place?\r\n\r\n- For general technical questions or \"how to\" guidance, please search StackOverflow for questions tagged \"puppeteer\" or create a new post.\r\n\r\nhttps://stackoverflow.com/questions/tagged/puppeteer\r\n\r\n- For issues or feature requests related to the DevTools Protocol (https://chromedevtools.github.io/devtools-protocol/), file an issue there:\r\n\r\nhttps://github.com/ChromeDevTools/devtools-protocol/issues/new.\r\n\r\n- Problem in Headless Chrome? File an issue against Chromium's issue tracker:\r\n\r\nhttps://bugs.chromium.org/p/chromium/issues/entry?components=Internals%3EHeadless&blocking=705916\r\n\r\nFor issues, feature requests, or setup troubles with Puppeteer, file an issue right here!\r\n-->\r\n\r\n### Steps to reproduce\r\n\r\n**Tell us about your environment:**\r\n\r\n* Puppeteer version: 1.2.0\r\n* Platform / OS version: Windows Server 2008\r\n* URLs (if applicable):\r\n* Node.js version: 8.9.1\r\n\r\n**What steps will reproduce the problem?**\r\nWhen printing web pages that contains hundreds of images.\r\nEven tried the \"pipe\" mode but no avail. If this is a limitation, is there a way to find the size of the write data as it is obviously printing the following statement on the console window\r\n\r\n**[0609/223146.069:ERROR:http_connection.cc(112)] Too large write data is pending: size=725124416, max_buffer_size=268435456**\r\n\r\nTried **Network.dataReceived** option to read the data lengths to get to the overall size but the data size does not match. In my case, I got the data as 521 MB but the write data says 691 MB. \r\n\r\nAttached a picture of the **Network** tab on the devTools. It says 521 MB resources which is correctly matching my reading. However, it says **252 MB** transferred. How do I get this reading? Either way, how do I get the write data size?\r\n<img width=\"529\" alt=\"Screen Shot 2019-06-10 at 9 01 44 AM\" src=\"https://user-images.githubusercontent.com/3056474/59198349-86bafa00-8b61-11e9-9969-fea6e705ebaf.png\">\r\n\r\n\r\n**What is the expected result?**\r\nSuccessfully generate the PDF irrespective of the size of the write data. Else, way to know the size of the write data so that we can document the known limitations.\r\n\r\n**What happens instead?**\r\nFails to generate the PDF when the page contains of hundreds of images. In other words, when the write data is too large."},{"labels":["feature"],"text":"\r\nI have to see the movement of mouse pointer that running by puppeteer for debugging. I red this document : https://github.com/GoogleChrome/puppeteer/issues/374 \r\n\r\nBut the problem is, the test website is not mine, it is other's website like google, github website. So I dont know how to implement above code to client page. When puppeteer launch the browser, I opend developer console and and paste above code and enter it, it doesn't work. Maybe it is removed when page reloaded or redirected. \r\n\r\nIs there a way to show mouse cursor permanently during puppeteer running?"},{"labels":[null,"feature"],"text":"## What's a \"content embedder\"?\r\n\r\nChromium codebase is organized into layers:\r\n- `//blink` - HTML rendering engine\r\n- `//content` - an API for browser implementers (think of it as a library that you'd use if you were to write your own browser). Things like process model are handled here; uses `//blink`.\r\n- `//chrome` - Chromium implementation (uses `//content`).\r\n\r\nContent-embedders are all the products that are based on `//content` layer. Chromium, Chrome Headless, ChromeCast are all different `//content` embedders.\r\n\r\nElectron is a `//content` embedder as well.\r\n\r\n## DevTools Protocol and content embedders\r\n\r\nMajority of DevTools API is implemented in `//blink` and `//content`. However, certain methods are supposed to be implemented by embedders. DevTools team makes sure all the methods needed for Puppeteer operation are supported by both Chromium and Headless.\r\n\r\nElectron is, however, missing out.\r\n\r\n## What exactly goes wrong?\r\n\r\n- Since version v1.5.0, when Puppeteer connects to a browser it requests all existing browser\r\ncontexts with the `Target.getBrowserContexts()` protocol method.\r\n- Method `Target.getBrowserContexts()` is supposed to be implemented by content embedders.\r\n- Electron doesn't implement the method, so Puppeteer connect to electron fails (#3793).\r\n\r\n## What can be done?\r\n\r\n**Option 1: Defer to Embedders.**\r\n\r\nIdeally, `//content`-embedders implement all necessary DevTools protocol methods on their end. This way they'll guarantee 100% compatibility with Puppeteer API. This, however, is a major undertaking for embedders; not sure if there's any interest in this.\r\n\r\n**Option 2: support clicking/typing/evaluation**\r\n\r\nAlternatively, we can aim for a \"good-enough\" compatibility with `//content` embedders. For example, we can make sure that things like clicking, navigation, typing and evaluation work fine with electron app (and add these electron tests to our CI). These should be enough to drive many default testing and automation scenarios.\r\n\r\n# ðŸš€  Vote! \r\n\r\n- If there's an interest in **Option 1**, please file a bug to the repository with the content embedder you'd like to be supported and ask them to implement the `Target.getBrowserContexts()` method. Plz cross-post the link here.\r\n- If there's an interest in **Option 2**, please  ðŸ‘ this issue and share your usecase.\r\n"},{"labels":["feature"],"text":"Since `Copy JS Path` has landed in Chrome DevTools, we now have a way to address nodes inside shadow DOM.\r\n\r\nDetails: https://github.com/GoogleChrome/puppeteer/issues/858#issuecomment-438540596\r\n\r\nThis, however, doesn't simplify life much when it comes to sugar methods, such as `page.click`, `page.select` and others.\r\n\r\nIt'd be nice to have a way to address nodes in shadow DOM in these methods.\r\n\r\nSuggestions:\r\n1. Teach `page.click` and others to accept an array of selectors. ([source](https://github.com/GoogleChrome/puppeteer/issues/858#issuecomment-466186707)). \r\n\r\n```js\r\nawait page.select(['#container', 'select#foo'], 'value');\r\n```\r\n\r\n2. Teach `page.click` and others to treat jsPaths as selectors. \r\n\r\n```js\r\nawait page.select(\"document.querySelector('body > toolbar-component > toolbar-section.left')\", 'value');\r\n```\r\n\r\ncc @JoelEinbinder "},{"labels":["feature"],"text":"According to [this comment](https://github.com/GoogleChrome/puppeteer/issues/426#issuecomment-345830027), `page.authenticate` doesn't work for SOCKS proxy.\r\n\r\nWe should make `page.authenticate` more capable to drive auth for proxies and servers."},{"labels":["feature"],"text":"I'm doing something relatively simple in the request interception:\r\n\r\n```javascript\r\nconst headers = request.headers();\r\nconst modifiedHeaders = { ...headers, \"x-new-header\": \"true\" };\r\n\r\nrequest.continue({ headers: modifiedHeaders });\r\n```\r\n\r\nHowever, later, when I receive the callback for the response, this header is missing from the associated request:\r\n\r\n```javascript\r\nresponse.request().headers()[\"x-new-header\"] !== \"true\";\r\n```\r\nI am trying to mark the request as modified so that later in the response I know this was one of my intercepted requests."},{"labels":["feature"],"text":"I think we can implement a `mouse.wheel` function, which would call [dispatchMouseEvent](https://github.com/ChromeDevTools/devtools-protocol/blob/master/json/browser_protocol.json#L6871) with type [mouseWheel](https://github.com/ChromeDevTools/devtools-protocol/blob/master/json/browser_protocol.json#L6882)\r\n\r\n```js\r\n  async wheel(options = {}) {\r\n    await this._client.send('Input.dispatchMouseEvent', {\r\n      type: 'mouseWheel',\r\n      deltaX: options.deltaX,\r\n      deltaY: options.deltaY\r\n    });\r\n  }\r\n```"},{"labels":["feature",null],"text":"As in the title, will you support tracing and metrics in puppeteer-firefox? The metrics were grayed out on the coverage list, but now they are just failing. Tracing is still grayed out.\r\n\r\nAlso, are there any more detailed puppeteer-firefox docs or changelog?"},{"labels":[null,"feature"],"text":"# Overview\r\nI'm looking for a simpler way to handle clicking on links which open new pages (like target=\"_blank\" anchor tags). \r\n\r\nHere handle means:\r\n- get the new page object\r\n- wait for the new tab to load (with timeout)\r\n\r\n<!--\r\nSTEP 1: Are you in the right place?\r\n\r\n- For general technical questions or \"how to\" guidance, please search StackOverflow for questions tagged \"puppeteer\" or create a new post.\r\n\r\nhttps://stackoverflow.com/questions/tagged/puppeteer\r\n\r\n- For issues or feature requests related to the DevTools Protocol (https://chromedevtools.github.io/devtools-protocol/), file an issue there:\r\n\r\nhttps://github.com/ChromeDevTools/devtools-protocol/issues/new.\r\n\r\n- Problem in Headless Chrome? File an issue against Chromium's issue tracker:\r\n\r\nhttps://bugs.chromium.org/p/chromium/issues/entry?components=Internals%3EHeadless&blocking=705916\r\n\r\nFor issues, feature requests, or setup troubles with Puppeteer, file an issue right here!\r\n-->\r\n\r\n### Steps to reproduce\r\n\r\n**Tell us about your environment:**\r\n\r\n* Puppeteer version: ^1.11.0\r\n* Platform / OS version:  64-bit, win 10 pro\r\n* URLs (if applicable): none\r\n* Node.js version: v10.15.0\r\n\r\nI've looked at related issues:\r\n#386 \r\n#3535 \r\n#978\r\nand more\r\n\r\n\r\n**What steps will reproduce the problem?**\r\n_I've included the code snippet below_\r\n\r\nI'm trying to:\r\n1. Get the object for the new page when clicking on a link opens a new tab. (The links are dynamically generated, capturing href might not be the most elegant way)\r\n2. Wait till the new page loads (with timeout). I'd like it if you can use page.waitForNavigation for consistency\r\n3. close the tab and return the earlier tab to continue further operations\r\n\r\n\r\n\r\n_Please include code that reproduces the issue._\r\n```\r\n// as referenced here on #386 : https://github.com/GoogleChrome/puppeteer/issues/386#issuecomment-425109457\r\n    const getNewPageWhenLoaded =  async () => {\r\n        return new Promise(x =>\r\n            global.browser.on('targetcreated', async target => {\r\n                if (target.type() === 'page') {\r\n                    const newPage = await target.page();\r\n                    const newPagePromise = new Promise(y =>\r\n                        newPage.once('domcontentloaded', () => y(newPage))\r\n                    );\r\n                    const isPageLoaded = await newPage.evaluate(\r\n                        () => document.readyState\r\n                    );\r\n                    return isPageLoaded.match('complete|interactive')\r\n                        ? x(newPage)\r\n                        : x(newPagePromise);\r\n                }\r\n            })\r\n        );\r\n    };\r\n\r\n\r\nconst newPagePromise = getNewPageWhenLoaded();\r\nawait page.click('my-link'); // or just do await page.evaluate(() => window.open('https://www.example.com/'));\r\nconst newPage = await newPagePromise;\r\n```\r\n\r\n\r\n\r\n**What is the expected result?**\r\nAn easier and consistent way to handle new tabs\r\n\r\n\r\n**What happens instead?**\r\nThe developer has to write what looks like plumbing (internal/ low level) commands.\r\nUsage of waitForTarget might simplify this, but I've not been able to get the predicate to return the right types. Here's my non-functional code\r\n\r\n```\r\nprivate async getNewPageWhenLoaded() {\r\n        const newTarget = await this._browser.waitForTarget(async (target) => {\r\n            const newPage = await target.page();\r\n            await newPage.waitForNavigation(this._optionsNavigation);\r\n            // const newPagePromise = new Promise(() => newPage.once('load', () => x(newPage)));\r\n            return await newPage.evaluate(\"true\");\r\n        });\r\n        return await newTarget.page();\r\n    }\r\n\r\n// elsewhere in the code\r\n            const newPagePromise = this.getNewPageWhenLoaded();\r\n            await resultItem.element.click();\r\n            const newPage = <Page>await newPagePromise;\r\n\r\n//I get the following error\r\nDevTools listening on ws://127.0.0.1:31984/devtools/browser/bf86648d-d52d-42d8-a392-629bf96211d4\r\n(node:5564) UnhandledPromiseRejectionWarning: Error: Navigation failed because browser has disconnected!\r\n    at CDPSession.LifecycleWatcher._eventListeners.helper.addEventListener (<path-to-my-project>\\node_modules\\puppeteer\\lib\\FrameManager.js:1181:107)\r\n    at CDPSession.emit (events.js:182:13)\r\n    at CDPSession._onClosed (<path-to-my-project>\\node_modules\\puppeteer\\lib\\Connection.js:231:10)\r\n    at Connection._onMessage (<path-to-my-project>\\node_modules\\puppeteer\\lib\\Connection.js:103:19)\r\n    at WebSocketTransport._ws.addEventListener.event (<path-to-my-project>\\node_modules\\puppeteer\\lib\\WebSocketTransport.js:41:24)\r\n    at WebSocket.onMessage (<path-to-my-project>\\node_modules\\ws\\lib\\event-target.js:120:16)\r\n    at WebSocket.emit (events.js:182:13)\r\n    at Receiver.receiverOnMessage (<path-to-my-project>\\node_modules\\ws\\lib\\websocket.js:741:20)\r\n    at Receiver.emit (events.js:182:13)\r\n    at Receiver.dataMessage (<path-to-my-project>\\node_modules\\ws\\lib\\receiver.js:417:14)\r\n  -- ASYNC --\r\n    at Frame.<anonymous> (<path-to-my-project>\\node_modules\\puppeteer\\lib\\helper.js:144:27)\r\n    at Page.waitForNavigation (<path-to-my-project>\\node_modules\\puppeteer\\lib\\Page.js:644:49)\r\n    at Page.<anonymous> (<path-to-my-project>\\node_modules\\puppeteer\\lib\\helper.js:145:23)\r\n    at newTarget._browser.waitForTarget (<path-to-my-project>\\pageObjects\\MyPage.js:104:27)\r\n    at process._tickCallback (internal/process/next_tick.js:68:7)\r\n(node:5564) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). (rejection id: 1)\r\n(node:5564) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.\r\n(node:5564) UnhandledPromiseRejectionWarning: TimeoutError: Navigation Timeout Exceeded: 300000ms exceeded\r\n    at Promise.then (<path-to-my-project>\\node_modules\\puppeteer\\lib\\FrameManager.js:1276:21)\r\n  -- ASYNC --\r\n    at Frame.<anonymous> (<path-to-my-project>\\node_modules\\puppeteer\\lib\\helper.js:144:27)\r\n    at Page.waitForNavigation (<path-to-my-project>\\node_modules\\puppeteer\\lib\\Page.js:644:49)\r\n    at Page.<anonymous> (<path-to-my-project>\\node_modules\\puppeteer\\lib\\helper.js:145:23)\r\n    at newTarget._browser.waitForTarget (<path-to-my-project>\\pageObjects\\MyPage.js:104:27)\r\n    at process._tickCallback (internal/process/next_tick.js:68:7)\r\n(node:5564) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). (rejection id: 2)\r\n```"},{"labels":[null,"feature",null],"text":"In many ways, users want to intercept targets being created to attach and set them up.\r\n\r\nUsecases:\r\n- when popup is getting opened, attach to it and enable request interception\r\n- when a link click opens a new page, set proper device emulation before website is getting loaded\r\n\r\nWe might be able to do this with CDP using `Target.setAutoAttach` and `waitForDebugger` option. I'd like this to be scoped to browser context though so that's there's a better flexibility.\r\n\r\nThe API might look like this:\r\n\r\n```js\r\nawait browserContext.setTargetInterception(true);\r\nbrowserContext.on('targetcreated', async target => {\r\n  if (target.type() !== 'page') {\r\n    await target.resumeLoading();\r\n    return;\r\n  }\r\n  const page = await target.page();\r\n  await page.setViewport({width: 400, height: 400});\r\n  await target.resumeLoading();\r\n});\r\n```\r\n\r\nRelated issues: #1378, #3648 "},{"labels":["feature"],"text":"Currently `page.exposeFunction` only allows serialization values to to be passed in as arguments, it should also allow JSHandles.\r\n\r\nAs a simple example.\r\n\r\n```\r\nconst filepath =  'element.png';\r\npage.exposeFunction('doScreenshot', element => {\r\n  element.screenshot({ path: filepath })\r\n});\r\n```\r\n```\r\nwindow.doScreenshot(document.querySelector('#myElement'));\r\n```\r\n\r\nI can't use `evaluateHandle` because I need the script on the page's side to initiate the action and I can't create a function using `page.evaluateOnNewDocument` because I need access node and puppeteer APIs."},{"labels":["feature"],"text":"### Steps to reproduce\r\n\r\nWhile using the puppeteer api `page.accessibility.snapshot()` the AXNode model leaves no trace of the DOM implementation. The underlying calls to [CDP](https://chromedevtools.github.io/devtools-protocol/tot/Accessibility#method-getFullAXTree) return `nodeId` (and `backendDOMNodeId`).\r\n\r\nI suggest one or more of the following (will update if more ideas come in comments):\r\n1. Give AXNode a new method 'asElement' which will create an `ElementHandle` from the stored nodeId or remoteObject reference.\r\n1. Expose the nodeId or remoteObjectId on the AXNode (so it can be passed to other CDP calls).\r\n1. Expose AXNode so CDP calls to `Accessibility.getPartialAXTree` can use this code to normalize the result the way `snapshot()` does.\r\n\r\n* Puppeteer version: 1.10+\r\n* Platform / OS version: any\r\n* URLs (if applicable):\r\n* Node.js version: latest\r\n\r\n_Please include code that reproduces the issue._\r\n\r\n```js\r\n// ... open google.com\r\nconst tree = await this.page.accessibility.snapshot();\r\nconsole.log(tree);\r\n```\r\n\r\nYields: \r\n\r\n```js\r\n{ role: 'WebArea',\r\n  name: 'Google',\r\n  children:\r\n   [ { role: 'button', name: 'Dismiss' },\r\n     { role: 'link', name: 'About' },\r\n     { role: 'link', name: 'Store' },\r\n     { role: 'link', name: 'Gmail' },\r\n     { role: 'link', name: 'Images' },\r\n     { role: 'button', name: 'Google apps' },\r\n     { role: 'link', name: 'Sign in' },\r\n     { role: 'combobox',\r\n       name: 'Search',\r\n       description: 'Search',\r\n       focused: true,\r\n       autocomplete: 'both' },\r\n     { role: 'button', name: 'Search by voice' },\r\n     { role: 'button',\r\n       name: 'Google Search',\r\n       description: 'Google Search' },\r\n     { role: 'button',\r\n       name: 'I\\'m Feeling Lucky',\r\n       description: 'I\\'m Feeling Lucky' },\r\n     { role: 'img', name: 'Google' },\r\n     { role: 'link', name: 'Privacy' },\r\n     { role: 'link', name: 'Terms' },\r\n     { role: 'combobox', name: 'Settings', haspopup: 'menu' },\r\n     { role: 'link', name: 'Advertising' },\r\n     { role: 'link', name: 'Business' } ] }\r\n```\r\n\r\nBut more useful would be:\r\n\r\n```js\r\n{ role: 'WebArea',\r\n  name: 'Google',\r\n  nodeId: 1,\r\n  children:\r\n   [ { role: 'button', name: 'Dismiss', nodeId: 4 },\r\n     { role: 'link', name: 'About', nodeId: 6 },\r\n     { role: 'link', name: 'Store', nodeId: 7 },\r\n     { role: 'link', name: 'Gmail', nodeId: 8 },\r\n     { role: 'link', name: 'Images', nodeId: 11 },\r\n     { role: 'button', name: 'Google apps', nodeId: 47 },\r\n     { role: 'link', name: 'Sign in', nodeId: 48 },\r\n // ...\r\n     { role: 'link', name: 'Business', nodeId: 129 } ] }\r\n```\r\n\r\nIf approved, I feel I could make the needed changes to submit a PR."},{"labels":[null,"feature"],"text":"<!--\r\nSTEP 1: Are you in the right place?\r\n\r\n- For general technical questions or \"how to\" guidance, please search StackOverflow for questions tagged \"puppeteer\" or create a new post.\r\n\r\nhttps://stackoverflow.com/questions/tagged/puppeteer\r\n\r\n- For issues or feature requests related to the DevTools Protocol (https://chromedevtools.github.io/devtools-protocol/), file an issue there:\r\n\r\nhttps://github.com/ChromeDevTools/devtools-protocol/issues/new.\r\n\r\n- Problem in Headless Chrome? File an issue against Chromium's issue tracker:\r\n\r\nhttps://bugs.chromium.org/p/chromium/issues/entry?components=Internals%3EHeadless&blocking=705916\r\n\r\nFor issues, feature requests, or setup troubles with Puppeteer, file an issue right here!\r\n-->\r\n\r\n### Steps to reproduce\r\n\r\n**Tell us about your environment:**\r\n\r\n* Puppeteer version: 10.x\r\n* Platform / OS version: mac\r\n* URLs (if applicable):\r\n* Node.js version: 8.x\r\n\r\n**What steps will reproduce the problem?**\r\nUnable to save page as mhtml\r\n\r\n**What is the expected result?**\r\nneed to save page as mthml or .mht exetension\r\n\r\n**What happens instead?**\r\n\r\nnoting"},{"labels":[null,"feature"],"text":"### Description\r\nAdd support for new `browserUrl` property in `options` object passed to `puppeteer.connect(options)`. It would accept url in form of `http://{host}:{port}` which should point to the existing Chromium instance. For example:\r\n\r\n```\r\npuppeteer.connect({\r\n    browserUrl: http://localhost:9222\r\n})\r\n```\r\n\r\nIf this option is passed to `puppeteer.connect`, then  `browserWSEndpoint` is retrieved from `http://{host}:{port}/json/version` and passed `new Connection()`. The rest of the flow remains unchanged.\r\n\r\nIf you're OK with the proposal I could write up the code and the tests\r\n\r\n### Background\r\n\r\nCurrently to attach Puppeteer to an existing Chrome instance, one must provide  url of browser websocket endpoint. For example:\r\n\r\n```\r\npuppeteer.connect({\r\n    browserWSEndpoint: ws://localhost:9222/devtools/browser/b0b8a4fb-bb17-4359-9533-a8d9f3908bd8\r\n})\r\n```\r\n\r\nHowever, as many issues raised here show (#2790, #1645, #940) `browserWSEndpoint` is often not known to the code calling `puppeteer.connect`, for example because Chrome was lunched in a docker container. \r\n\r\nIn such a case, a common and repeating scenario is to:\r\n1. make HTTP request to `http://{host}:{port}/json/version`\r\n2. parse the response JSON\r\n3. get `browserWSEndpoint` from and use it in `puppeteer.connect`\r\n\r\nThe steps above could be done by puppeteer resulting in less code in the user-land."},{"labels":[null,"feature",null],"text":"### Steps to reproduce\r\n\r\n**Tell us about your environment:**\r\n\r\n* Puppeteer version: ^1.6.2\r\n* Platform / OS version: OSX\r\n* Node.js version: v8.11.3\r\n\r\n**What steps will reproduce the problem?**\r\n\r\n_Please include code that reproduces the issue._\r\n\r\n1. Use `createIncognitoBrowserContext`\r\n2. Try to enable an extension using `--load-extension` and `--disable-extensions-except`\r\n\r\n**What is the expected result?**\r\n\r\nI expect the extension to work in incognito mode. This extension works well with `Allow in incognito` switched on in Google Chrome, outside of Puppeteer.\r\n\r\n**What happens instead?**\r\n\r\nGot error `net::ERR_BLOCKED_BY_CLIENT at chrome-extension://nkbihfbeogaeaoehlefnkodbefgpgknn/popup.html`"},{"labels":[null,"feature"],"text":"In devtools we can get the stack trace of warning/error messages like so:\r\n\r\n![screenshot from 2018-10-01 16-33-57](https://user-images.githubusercontent.com/8518303/46268619-e8b96d80-c597-11e8-9418-45d525aadc24.png)\r\n\r\nIt would be useful if `ConsoleMessage` exposed a way of getting those stack traces."},{"labels":[null,"feature"],"text":"Right now we have `page.setDefaultNavigationTimeout(timeout)` which is very useful. If we want to take things forward, we can implement the following,\r\n\r\n## setDefaultWaitTimeout(timeout)\r\nThis will help set a default timeout for `waitFor` function or similar to those. There are obviously more `waitFor` use cases than `goto`. \r\n\r\n## setDefaultTimeouts({ navigation: timeout, waitFor: timeout })\r\nSame like above, this will let one update all timeouts at once or just the one they want. Will remove the need for `setDefaultNavigationTimeout` or `setDefaultWaitTimeout` if happens and window for more useful api\r\n\r\nPS: I have a project where I have at least thousands of waitFor cases for some reason and hundreds of navigation calls, this feels really promising in that sense where people have lots of test cases."},{"labels":[null,"feature",null],"text":"pptr v1.8.0 allows to set permissions per origin in browser context.\r\n\r\nHowever, it'll come very handy to give permissions to all origins in browser context.\r\n\r\nProposal: special '*' value for origin.\r\n```js\r\ncontext.overridePermissions('*', ['geolocation']);\r\n```"},{"labels":[null,"feature",null],"text":"![image](https://user-images.githubusercontent.com/14265482/44673665-d4f77600-a9f1-11e8-8db5-5bfaa75fa290.png)\r\n\r\n**Expected Result**\r\nThe console should log the dialog's message and type (in this case: the \"print screen\" dialog). I wanted to programmatically dismiss the print screen dialog.\r\n\r\n**What happens instead?**\r\nNothing happens\r\n\r\n**Environment:**\r\nPuppeteer version: 1.7.0\r\nPlatform / OS version: Mac OSX Version 10.13.6\r\nNode.js version: 10.7.0\r\n\r\n**Code** \r\npage = await browser.newPage();\r\npage.on(\"dialog\", async dialog => {\r\n   console.log(\"the dialog message is\", dialog.message());\r\n   console.log(\"the dialog type is\", dialog.type());\r\n   await dialog.dismiss();\r\n});\r\n\r\nawait page.waitFor('.print-text'); //this clicks an element and opens up the print screen in google chrome\r\nawait page.click('.print-text');\r\n\r\n\r\n\r\n"},{"labels":[null,"feature"],"text":"what do you think about using headless shell? small size, removed ui lib dependencies\r\n\r\nthere are already build files, e.g. https://storage.googleapis.com/chromium-browser-snapshots/Linux_x64/583214/headless-shell.zip"},{"labels":[null,"feature",null],"text":"Env:\r\nMacBook, Node v10.8.0\r\nâ”œâ”€ puppeteer-har@1.0.2\r\nâ”œâ”€ puppeteer@1.7.0\r\n\r\nIssue:\r\nAdding DNT Header doesn't populate navigator.doNotTrack. Please let me know if you have any questions. I was also having trouble activating this using the chrome modHeader extension. I only had luck activating navigator.doNotTrack by changing privacy settings for my user in chrome (not chromium).\r\n```javascript \r\n// in async function\r\nconst headerOptions = ['1', '0'];\r\nfor (header of headerOptions) {\r\n    for (url of urls) {\r\n      try {\r\n        await page.setExtraHTTPHeaders({'DNT': header})\r\n        await page.goto(`${hostName}${url}`, {timeout: 35000, waitUntil: ['networkidle0', 'load']});\r\n        await page.waitFor(500);\r\n        const doNotTrackValue = await page.evaluate(() => navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);\r\n        const currentURL = await page.url();\r\n        data.push([currentURL, doNotTrackValue]);\r\n      } catch (e) {\r\n        console.log(e)\r\n      }\r\n    }\r\n    fs.writeFileSync(`./domState${header}.json`, JSON.stringify(data), {flags: 'w'});\r\n  }\r\n```\r\n\r\nI expected `navigator.doNotTrack` to equal '1' or '0' depending on the iteration\r\n\r\ninstead `navigator.doNotTrack` equals null\r\n\r\n"},{"labels":[null,"feature"],"text":"Function concerned : ``.type`` - [api here](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagetypeselector-text-options)\r\n\r\nBasically, add a boolean ``clear`` into the options so we specify if we want to clear the field before typing.\r\n\r\n`page.type('#myinput', 'toto', {clear: true})`\r\n\r\nThis would clear any existing input into ``#myinput`` then it would type ``toto``."},{"labels":["feature",null],"text":"If you look at this line, we trying to get referrer from `extraHTTPHeaders`:\r\nhttps://github.com/GoogleChrome/puppeteer/blob/master/lib/Page.js#L565\r\n\r\nSo, at this code example I forced to clear extra headers for proper resources loading:\r\n```js\r\nawait page.setExtraHTTPHeaders({\r\n  referer: 'https://example.com/'\r\n});\r\n\r\nawait page.goto('https://github.com/');\r\n\r\nawait page.setExtraHTTPHeaders({});\r\n```\r\n\r\nThis is really bad way to set referrer, because **even in CDP** referrer is specified as a parameter, not header. This is not even funny!\r\nhttps://github.com/GoogleChrome/puppeteer/blob/master/lib/Page.js#L601\r\n\r\nWhile I'm trying to clear headers after navigation with empty object, page will load resources (like CSS and scripts, images) with a **wrong** referrer!\r\n\r\nTry to set extra header `referer` on your page and load image, and you will see amazing wrong referer:\r\n\r\n![ref](https://user-images.githubusercontent.com/31924884/44154647-e0e6e5f0-a0b3-11e8-9226-e6be3911ddce.png)\r\n\r\nSo wee need smth like this:\r\n* referrer as a optional parameter at `goto`, in this case method will ignore headers `referer` check\r\n* referrer as a parameter only (best way)\r\n\r\nNow I'm forced to rewrite `goto` method a little, can we fix it?"},{"labels":[null,"feature"],"text":"This has been requested quite a few times on the bugtracker already.\r\n\r\nAs a workaround, network idleness [can be emulated](https://github.com/GoogleChrome/puppeteer/issues/1353#issuecomment-356561654) on the puppeteer-side."},{"labels":[null,"feature",null],"text":"[LogEntry](https://chromedevtools.github.io/devtools-protocol/tot/Log#type-LogEntry) object provides url and lineNumber\r\n\r\n```\r\nurl: string - URL of the resource if known.\r\nlineNumber: integer - Line number in the resource.\r\n```\r\n\r\ncan we also expose it?\r\n\r\nRelated source https://github.com/GoogleChrome/puppeteer/blob/25632133e2683c613c97d9088968c48e3c07a086/lib/Page.js#L167-L173\r\n"},{"labels":[null,"feature",null],"text":"### Steps to reproduce\r\n\r\n**Tell us about your environment:**\r\n\r\n* Puppeteer version: 1.6.1\r\n* Platform / OS version:  Ubuntu 14.04.1 LTS (i686)\r\n* Node.js version: 8.11.3\r\n\r\n**What steps will reproduce the problem?**\r\n\r\n1. `npm i puppeteer`\r\n2. \r\n```js\r\nconst puppeteer = require('puppeteer');\r\nconst browser = await puppeteer.launch();\r\nconst page = await browser.newPage();\r\n```\r\n\r\n**What is the expected result?**\r\n\r\nWorking chrome\r\n\r\n**What happens instead?**\r\n\r\n`(node:14901) UnhandledPromiseRejectionWarning: Error: Failed to launch chrome!\r\n/var/www/spiderman/node_modules/puppeteer/.local-chromium/linux-575458/chrome-linux/chrome: 1: /var/www/spiderman/node_modules/puppeteer/.local-chromium/linux-575458/chrome-linux/chrome: Syntax error: word unexpected (expecting \")\")\r\n`\r\n\r\nIf i manually run that chrome, it says `cannot execute binary file: Exec format error`"},{"labels":[null,"feature",null],"text":"Is there any way to handle File Input Dialogs?\r\n\r\nWhen I click an element on the page, it opens up the upload file dialog.\r\n\r\nI can not use `elementHandle.uploadFile` as it is not an `input[type=\"file\"]`. Plus, #1376 will not help as, dragging and dropping in the file upload field does not work, instead, dragging and dropping opens up the file in the browser tab.\r\n\r\nI am using Windows, so there won't be the problem where, file dialog behavior is different across operating systems.\r\n\r\nSo, can you provide some example code on how would I go about doing that? Thanks!"},{"labels":["feature"],"text":"### Steps to reproduce\r\n\r\n**Tell us about your environment:**\r\n\r\n* Puppeteer version: 1.6.0\r\n* Platform / OS version: Linux henrique-Latitude-5480 4.15.0-23-generic #25-Ubuntu SMP Wed May 23 18:02:16 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux\r\n* URLs (if applicable):  http://home.ubalt.edu/abento/frames/myframe.html\r\n* Node.js version: v8.11.3\r\n\r\n**What steps will reproduce the problem?**\r\n\r\n```js\r\n(async () => {\r\n\r\nconst puppeteer = await require('puppeteer');\r\n\r\nconst browser = await puppeteer.launch({headless:false,/* slowMo: 50*/});\r\nconst incognitoContext = await browser.createIncognitoBrowserContext();\r\nconst page = await incognitoContext.newPage();\r\npage.on('dialog', async dialog => {\r\n    await console.log('MESSAGE \"%s\": \"%s\"',dialog.type(),dialog.message());\r\n    await dialog.dismiss();\r\n});\r\nawait page.setCacheEnabled(false);\r\n\r\nawait page.goto('http://home.ubalt.edu/abento/frames/myframe.html', {waitUntil: ['load','domcontentloaded','networkidle0']});\r\n\r\nconst leftFrame = await page.frames().filter( el => el.name() == 'left')[0]\r\nconst rightFrame = await page.frames().filter( el => el.name() == 'right')[0]\r\nawait console.log('URLS: MAIN FRAME: %s ; RIGHT FRAME: %s ; LEFT FRAME: %s ', page.url(), rightFrame.url(), leftFrame.url());\r\nconst navigationPromise = page.waitForNavigation();\r\nawait leftFrame.click('a[href=\"option2.html\"]');\r\nawait console.log('URLS: MAIN FRAME: %s ; RIGHT FRAME: %s ; LEFT FRAME: %s ', page.url(), rightFrame.url(), leftFrame.url());\r\nawait page.waitFor(5000);\r\nawait console.log('URLS: MAIN FRAME: %s ; RIGHT FRAME: %s ; LEFT FRAME: %s ', page.url(), rightFrame.url(), leftFrame.url()); // DISPLAY OTHER URL FOR rightFrame\r\nawait navigationPromise;\r\nawait console.log('URLS: MAIN FRAME: %s ; RIGHT FRAME: %s ; LEFT FRAME: %s ', page.url(), rightFrame.url(), leftFrame.url()); // NOT DISPLAYED, navigationPromise ERROR\r\nawait browser.close();\r\n    \r\n})();\r\n```\r\n\r\n**What is the expected result?**\r\nI was expecting navigationPromise to be resolved, but it doesn't.\r\n\r\n**What happens instead?**\r\n\r\nnavigationPromise isn't resolved. Is it the expected behavior? Is it possible to add a frame.waitForNavigation() function?\r\n\r\nScreenshot:\r\n\r\n![image](https://user-images.githubusercontent.com/19354250/42958092-fdac0fda-8b5a-11e8-8896-ab7ab65fb4fe.png)\r\n\r\n\r\nThanks\r\n\r\nPS: I've also tried with the code below, using waitForNavigation as suggested in frame.click() documentation:\r\n\r\n```js\r\n\"use strict\";\r\n\r\n(async () => {\r\n\r\nconst puppeteer = await require('puppeteer');\r\n\r\nconst browser = await puppeteer.launch({headless:false,/* slowMo: 50*/});\r\nconst incognitoContext = await browser.createIncognitoBrowserContext();\r\nconst page = await incognitoContext.newPage();\r\npage.on('dialog', async dialog => {\r\n    await console.log('MESSAGE \"%s\": \"%s\"',dialog.type(),dialog.message());\r\n    await dialog.dismiss();\r\n});\r\nawait page.setCacheEnabled(false);\r\n\r\nawait page.goto('http://home.ubalt.edu/abento/frames/myframe.html', {waitUntil: ['load','domcontentloaded','networkidle0']});\r\n\r\nconst leftFrame = await page.frames().filter( el => el.name() == 'left')[0]\r\nconst rightFrame = await page.frames().filter( el => el.name() == 'right')[0]\r\n\r\nawait Promise.all([\r\n    page.waitForNavigation(),\r\n    leftFrame.click('a[href=\"option2.html\"]')\r\n]);\r\n\r\n})();\r\n```"},{"labels":[null,"feature",null],"text":"WebWorkers can `fetch` data; we should surface traffic from web workers in puppeteer.\r\n\r\nThis is blocked on #2548 since nested targets are broken with request interception. See https://github.com/GoogleChrome/puppeteer/pull/2717#issuecomment-398899616 for details."},{"labels":["feature",null],"text":"Please, add option to enable covering of anonymous scripts.\r\n\r\nhttps://github.com/GoogleChrome/puppeteer/blob/dcae6bcff49150bec2060667fef7bd7ab71db042/lib/Coverage.js#L111-L114\r\n\r\nChange it to somethink like that:\r\n``` \r\n    if (!event.url && this.ignoreAnonymousScripts)\r\n      return;\r\n```\r\nwhere `this.ignoreAnonymousScripts` defines as `true` by default to do not break current behavior.\r\n"},{"labels":["feature",null],"text":"When an error occures on a Web Worker, it is not collected by `page.on('pageerror'...` event. \r\n\r\nFor example:\r\n\r\n```js\r\nconst puppeteer = require('puppeteer');\r\n(async () => {\r\n  const browser = await puppeteer.launch();\r\n  const page = await browser.newPage();\r\n  page.on('pageerror', message => console.log(message));\r\n\r\n  await page.setContent(`<!DOCTYPE html>\r\n  <script id=\"worker1\" type=\"javascript/worker\">\r\n    throw new Error('this is my error');\r\n  </script>\r\n  <script>\r\n    const blob = new Blob([\r\n      document.querySelector('#worker1').textContent\r\n    ], { type: \"text/javascript\" })\r\n\r\n    new Worker(window.URL.createObjectURL(blob));\r\n  </script>`);\r\n})()\r\n```\r\n"},{"labels":["feature",null],"text":"It would be nice if Chromium used by puppeteer was cached in the npm-cache folder. It's a quite a big download and changing branches/cleaning the local node_modules folder leads to re-downloading from scratch."},{"labels":["feature",null],"text":"### Steps to reproduce\r\n\r\n* Puppeteer version: 1.5.0\r\n* Platform / OS version: macOS 10.13.3\r\n* Node.js version: 10.2.1\r\n\r\n**What steps will reproduce the problem?**\r\n\r\n```\r\nconst puppeteer = require('puppeteer');\r\n\r\n(async () => {\r\n  const browser = await puppeteer.launch({headless: false});\r\n  const page = await browser.newPage();\r\n  page.on('console', () => browser.close());\r\n  page.goto(`data:text/html,<script>console.log(1)</script>`, {timeout: 5000});\r\n})();\r\n```\r\n\r\n**What is the expected result?**\r\n\r\nThe process should quit almost instantly.\r\n\r\n**What happens instead?**\r\n\r\nThe timeout inside of `page.goto` keeps the process running for the duration of the timeout. The problem occurs more often in windowed mode than in headless."},{"labels":["feature",null],"text":"When I run my page in headless mode every colors is rendered right.\r\nBut when I get the pdf with page.pdf() with no options some colors (a few in fact) are wrong - too bright or too dark - Is there any reason for this?\r\n\r\nupdate: I solved this with this css (not sure why it wasn't working without it)\r\n\r\n```css\r\nhtml {\r\n  -webkit-print-color-adjust: exact;\r\n}\r\n```"},{"labels":[null,"feature",null],"text":"I'd like to create an isolated context to execute some js in the same website I'm visiting without polluting the main context. It is possible right now, but it requires to access a lot of internal methods:\r\n\r\n      const mainFrame = page.mainFrame()\r\n\r\n      const isolatedWorldInfo = await page._client.send('Page.createIsolatedWorld', {frameId: mainFrame._id, worldName: 'new-isolated-world'})\r\n      const executionContextId = isolatedWorldInfo.executionContextId\r\n      const JsHandleFactory = page._frameManager.createJSHandle.bind(page._frameManager, executionContextId)\r\n\r\n      const executionContext = new ExecutionContext(page._client, {id: executionContextId}, JsHandleFactory)\r\n      await executionContext.evaluate(..)\r\n\r\n\r\nIt would be nice if puppeteer exposed this as a method. Something like: page.createNewIsolatedContext\r\n\r\nIf necessary I could write up the code and the tests\r\n"},{"labels":["feature",null],"text":"Error: waiting for selector \"#closemsgboxbtn\" failed: timeout 30000ms exceeded\r\n      at Timeout.WaitTask._timeoutTimer.setTimeout (node_modules\\puppeteer\\lib\\FrameManager.js:844:60)\r\n\r\nI always got this kind of error msg, but I still need to spend a lot time finding which exact line in my js file throwing out the error.\r\nIs there any option I can set up?"},{"labels":["feature",null],"text":"### Steps to reproduce\r\n\r\n**Tell us about your environment:**\r\n\r\n* Puppeteer version: \"^1.4.0\"\r\n* Platform / OS version:  macOS 10.13.1\r\n* URLs (if applicable):  https://github.com/webAutomaticTest/pageEvaluate\r\n* Node.js version: v8.11.2\r\nI download the **optimal-select.js** from  https://cdnjs.cloudflare.com/ajax/libs/optimal-select/4.0.1/optimal-select.js\r\n\r\n**What steps will reproduce the problem?**\r\nI want to do automatic test about web applications.\r\n1. run to test with command:  \r\n```\r\nnode index.js\r\n```\r\nthe code in index.js:\r\n```\r\nconst puppeteer = require('puppeteer');\r\n\r\ntest();\r\n\r\nasync function test(){\r\n\tconst browser = await puppeteer.launch({headless: false, args:['--no-sandbox']});\r\n\tconst page = await browser.newPage();\r\n\tawait page.goto('https://twitter.com/');\r\n\t// await page.goto('https://apples-oranges.herokuapp.com/');\r\n\tawait page.addScriptTag({path:'./optimal-select.js'});\r\n\t\r\n\tlet candidateSelector = await page.evaluate(scanCandidateAction);\r\n\tconsole.log(candidateSelector);\r\n}\r\n\r\nfunction scanCandidateAction() {\r\n\tlet actions = [];\r\n\tlet computeCSSSelector = window['OptimalSelect'].select;\r\n\tlet aElements = document.querySelectorAll('a');\r\n\tfor (let i=0 ; i < aElements.length ; i++) {\r\n\t\tif (! isMailTo(aElements[i])) actions.push(computeCSSSelector(aElements[i]));\r\n\t}\r\n\r\n\treturn actions;\r\n\r\n\tfunction isMailTo(element) {\r\n\t\tlet href = element.href;\r\n\t\treturn href && (href.toLowerCase().indexOf('mailto') > -1)\t\t\r\n\t}\r\n}\r\n```\r\n\r\n**What is the expected result?**\r\narray of CSS Selector\r\n**What happens instead?**\r\nit faled with error:\r\n (node:83553) UnhandledPromiseRejectionWarning: Error: Evaluation failed: Event\r\nIt stoped and filed in this line:\r\n```\r\nawait page.addScriptTag({path:'./optimal-select.js'});\r\n```\r\n"},{"labels":[null,"feature"],"text":"We need an API to connect and manage ServiceWorkers.\r\n\r\nAt the very least, we need to:\r\n- have a way to shut down service worker (requested at https://github.com/GoogleChrome/puppeteer/issues/1396)\r\n- have a way to see service worker traffic (requested at https://github.com/GoogleChrome/puppeteer/issues/2617)\r\n- support code coverage for service workers (requested at https://github.com/GoogleChrome/puppeteer/issues/2092)\r\n"},{"labels":["feature",null],"text":"Does Puppeteer has API which help detect if element is visible (or displayed), analogue to Selenium (Webdriver) `.isDisplayed` method?\r\n\r\nI found method [waitForSelector](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagewaitforselectorselector-options) method which has options `visible`, but I think if DOM node has `display: block;` and some parent component has style `overflow: hidden` and my element outside the parent this `waitForSelector` returns wrong"},{"labels":["feature"],"text":"* Puppeteer version: 1.4\r\n* Platform / OS version: ubuntu\r\n* URLs (if applicable): any\r\n* Node.js version: 8.x\r\n\r\nI want to just apply header in just opened page in puppeter not all inside page headers\r\n\r\n  page.setExtraHTTPHeaders({\r\n     'X-Just-Must-Be-Request-In-Main-Request': '1',\r\n  })\r\n\r\nwill apply all pages request headers all css/js/images and etc...\r\n\r\ni want to set just main request headers not all of pages requests.\r\n\r\nno one cares:\r\nhttps://stackoverflow.com/questions/50568054/how-to-set-header-in-puppeter-just-main-page-request-not-all-request\r\n"},{"labels":["feature",null],"text":"Searched issues and could not find any hints, so I opened this. If I missed a issue already has this, please close this. Thanks in advance.\r\n\r\nI read the  api doc and see currently pptr only have 'close' event and found `_target._isClosedPromise` is a promise value which could not be used as a state indicator. Do we have any method or attribute to indicate that the page has been closed after invoke `page.close()` ?\r\n\r\n\r\nFeel free to correct me if I misunderstand sth."},{"labels":[null,"feature",null],"text":"We are relying on puppeteer to automate testing of our extension. I can automate most things except I cannot click the button that our extension adds to the browser's toolbar.\r\n\r\nCould there be an API to interact with browser action buttons?\r\n\r\nSomething to the tune of\r\n```js\r\nlet actionButtons = await browser.actionButtons();\r\nawait actionButtons[0].click();\r\n```\r\nwould be great.\r\n\r\nThis will allow us to fully automate testing of our extension workflow. Thanks!"},{"labels":["feature",null],"text":"https://github.com/GoogleChrome/puppeteer/blob/master/DeviceDescriptors.js doesn't have the Pixel 2 or Pixel 2 XL. Both of these are in DevTools now.\r\n\r\n<img width=\"233\" alt=\"screen shot 2018-04-25 at 6 05 24 pm\" src=\"https://user-images.githubusercontent.com/238208/39280304-6cddd9a0-48b3-11e8-9ce2-f6e147264a61.png\">\r\n"},{"labels":["feature",null],"text":"Related to https://github.com/GoogleChrome/puppeteer/issues/2438.\r\n\r\nThe lighthouse chrome extension tests [check](https://github.com/GoogleChrome/puppeteer/blob/master/lib/Target.js#L60) a private `target._targetInfo` property to verify the target is the LH background page:\r\n\r\n```js\r\nconst targets = await browser.targets();\r\nconst extensionTarget = targets.find(({_targetInfo}) => {\r\n  return _targetInfo.title === 'Lighthouse' && _targetInfo.type === 'background_page';\r\n});\r\n```\r\n\r\nWe should pass through this type through so `target.type()` works as expected. We currently mark it as \"other\":\r\n\r\nhttps://github.com/GoogleChrome/puppeteer/blob/e9dc3ae74fc01a99d1d5b66ffe716b4de4aa39e8/lib/Target.js#L58-L63\r\n\r\n"},{"labels":["feature",null],"text":"Related to https://github.com/GoogleChrome/puppeteer/issues/1215.\r\n\r\nLighthouse has [started testing](https://github.com/GoogleChrome/lighthouse/blob/master/lighthouse-extension/test/extension-test.js#L63-L79) its chrome extension using pptr. They currently use`createCDPSession` to inject code into the extension and run methods:\r\n\r\n```js\r\n    const targets = await browser.targets();\r\n    const extensionTarget = targets.find(({_targetInfo}) => {\r\n      return _targetInfo.title === 'Lighthouse' && _targetInfo.type === 'background_page';\r\n    });\r\n\r\n    if (!extensionTarget) {\r\n      return await browser.close();\r\n    }\r\n\r\n    const client = await extensionTarget.createCDPSession();\r\n    const lighthouseResult = await client.send('Runtime.evaluate', {\r\n      expression: `runLighthouseInExtension({\r\n          restoreCleanState: true,\r\n        }, ${JSON.stringify(lighthouseCategories)})`,\r\n      awaitPromise: true,\r\n      returnByValue: true,\r\n    });\r\n```\r\n\r\nIt would be nice to make this use case easier:\r\n\r\n```js\r\nconst lighthouseResult = target.evaluate(cats => {\r\n  return runLighthouseInExtension({restoreCleanState: true}, cats);\r\n}, lighthouseCategories);\r\n```\r\n\r\n"},{"labels":[null,"feature",null],"text":"### Steps to reproduce\r\n\r\n**Tell us about your environment:**\r\n\r\n* Puppeteer version: 1.3.0\r\n* Platform / OS version: macOS Sierra\r\n* URLs (if applicable): ...\r\n* Node.js version: master\r\n\r\n**What steps will reproduce the problem?**\r\n\r\n_Please include code that reproduces the issue._\r\n\r\n1. Open a new page with puppeteer\r\n2. Run `page.evaluate(() => new Uint8Array(1024 * 1024 * 10)`\r\n\r\n**What is the expected result?**\r\n\r\nPuppeteer takes over 20 seconds to serialize/deserialize 10MB and the resulting object is not a Uint8Array. \r\n\r\n**What happens instead?**\r\n\r\nA Uint8Array should be returned and it should take a reasonable amount of time (single-digit miliseconds tops and not seconds).\r\n\r\n----\r\n\r\nThis basically would require inspecting objects returned from `evaluate`, detecting they're Uint8Arrays and then serializing them differently. \r\n"},{"labels":[null,"feature",null],"text":"Font spacing seems to be inconsistent between headless and non headless mode.\r\nThis is likely a Chromium bug for Puppeteer versions 1.2.0 and above.\r\n\r\n### Steps to reproduce\r\n\r\n**Tell us about your environment:**\r\n\r\n* Puppeteer version: 1.2\r\n* Platform / OS version: Linux\r\n* URLs (if applicable):\r\n* Node.js version: 8.6.0\r\n\r\n**What steps will reproduce the problem?**\r\n\r\n1. screenshot.js\r\n```\r\n'use strict';\r\n\r\nconst puppeteer = require('puppeteer');\r\n\r\n(async() => {\r\n  const browser = await puppeteer.launch({ headless: true }); // toggle to false\r\n  const page = await browser.newPage();\r\n  await page.goto('file:///tmp/test.html');\r\n  await page.waitFor(5000);\r\n  await page.screenshot({path: '/tmp/screenshot.png'});\r\n  await browser.close();\r\n})();\r\n```\r\n2. test.html\r\n```\r\n<html>\r\n  <head>\r\n    <link rel=\"stylesheet\"\r\n          href=\"https://fonts.googleapis.com/css?family=Lato\">\r\n    <style>\r\n      body {\r\n        font-family: 'Lato', serif;\r\n        font-size: 15px;\r\n      }\r\n      div.a {\r\n        line-height: 0.5;\r\n      }\r\n    </style>\r\n  </head>\r\n  <body>\r\n    <div class=\"a\">\r\n      <div>aaaaa..............................................................................|111</div><br>\r\n      <div>qwertyasdfzxcvyuiohjklbnm................................|222</div><br>\r\n      <div>longlonglonglonglonglonglonglongshorty......|333</div>\r\n    </div>\r\n  </body>\r\n</html>\r\n```\r\n3. `node /tmp/screenshot.js`, then repeat with `headless: false` \r\n\r\n**What is the expected result?**\r\nText is correctly aligned and looks the same as opening the HTML in browser. `headless: false`\r\n\r\n![headless_false](https://user-images.githubusercontent.com/1380839/38925691-f36ba690-4332-11e8-96b4-a1cc0e784e60.png)\r\n\r\n**What happens instead?**\r\nText is misaligned with `headless: true`\r\n\r\n![headless_true](https://user-images.githubusercontent.com/1380839/38925690-f33bcfce-4332-11e8-9a19-0ef463f032e9.png)"},{"labels":["feature",null],"text":"* Puppeteer version: v1.3.0-post\r\n* Platform / OS version: Windows 7 x64\r\n* Node.js version: 10.0.0 v8-canary\r\n\r\n```js\r\n(async () => {\r\n  const browser = await require('puppeteer').launch();\r\n  console.log((await browser.pages()).map(page => page.url()));\r\n  await browser.close();\r\n})();\r\n```\r\n```js\r\n[ 'about:blank' ]\r\n```\r\n```js\r\n(async () => {\r\n  const browser = await require('puppeteer').launch({ headless: false });\r\n  console.log((await browser.pages()).map(page => page.url()));\r\n  await browser.close();\r\n})();\r\n```\r\n```js\r\n[ 'chrome-search://local-ntp/local-ntp.html' ]\r\n```\r\n\r\nWould it be more consistent, safe and performance-wise optimal to load `about:blank` initially in both modes?"},{"labels":["feature",null],"text":"I'd like to get a reference to a DOM node and run one-liners against the subtree.\r\n\r\n```js\r\nconst tweetHandle = await page.$('.tweet');\r\nexpect(await tweet.$eval('.like', node => node.innerText)).toBe('100');\r\nexpect(await tweet.$eval('.retweets', node => node.innerText)).toBe('10');\r\n```\r\n\r\nThis will come really handy for unit tests."},{"labels":["feature",null],"text":"Hey! \r\n\r\nAfter using Puppeteer for a little while now in a number of different scenarios (SSR, automated testing) a common piece of functionality that often came up as needed, or at very minimum a nice to have, was the ability to wait for a specific network request to be made, or alternatively for a specific network response to come back. As a result I propose the addition of the following two functions.\r\n\r\n```javascript\r\npage.waitForRequest( match[, options])\r\n```\r\n\r\n- `match` \\<string\\> A regular expression to match against the request URL\r\n- `options` \\<Object\\> Optional parameters\r\n  - `method` \\<string|Array\\> Either a single HTTP request method (GET, POST, etc) as a string or an array of values `[\"GET\", \"POST\"]`. Defaults to all HTTP request methods.\r\n  - `timeout` \\<number\\> Maximum time to wait in milliseconds\r\n\r\nAnd additionally\r\n\r\n```javascript\r\npage.waitForResponse( match[, options])\r\n```\r\nWith a similar set of options. I'd probably also additionally add support for filtering by response code.\r\n\r\n**An example**\r\n\r\n```javascript\r\nawait page.waitForRequest( 'https?://example.com/(users|companies)', { method: 'POST' });\r\n```\r\n\r\nHappy to submit a PR if you all think it's a worthwhile addition!\r\n\r\nThanks!\r\n"},{"labels":["feature"],"text":"We need to develop an API to access WebWorkers and ServiceWorkers.\r\nWorkers:\r\n- have execution context, so `worker.evaluate()` should work\r\n- can issue requests, so `worker.on('request')` should be available as well\r\n\r\nproposal:\r\n```js\r\nconst workers = await page.workers(); // return all the workers \r\nworkers[0].type(); // return either 'webworker' or 'serviceworker'\r\n```"},{"labels":[null,"feature",null],"text":"<!--\r\nSTEP 1: Are you in the right place?\r\n\r\n- For general technical questions or \"how to\" guidance, please search StackOverflow for questions tagged \"puppeteer\" or create a new post.\r\n\r\nhttps://stackoverflow.com/questions/tagged/puppeteer\r\n\r\n- For issues or feature requests related to the DevTools Protocol (https://chromedevtools.github.io/devtools-protocol/), file an issue there:\r\n\r\nhttps://github.com/ChromeDevTools/devtools-protocol/issues/new.\r\n\r\n- Problem in Headless Chrome? File an issue against Chromium's issue tracker:\r\n\r\nhttps://bugs.chromium.org/p/chromium/issues/entry?components=Internals%3EHeadless&blocking=705916\r\n\r\nFor issues, feature requests, or setup troubles with Puppeteer, file an issue right here!\r\n-->\r\n\r\n### Steps to reproduce\r\n\r\n**Tell us about your environment:**\r\n\r\n* Puppeteer version: 1.2.0\r\n* Platform / OS version: ubuntu 16.04\r\n* URLs (if applicable):\r\n* Node.js version: 8.8.1\r\n\r\n**What steps will reproduce the problem?**\r\n\r\n_Please include code that reproduces the issue._\r\nHi guys, i am trying to intercept request and get raw request post data. I send 4 bytes as xhr, and wants to find them at request. But: \r\n\r\n```\r\nvar bytesToSend = [0xac, 0xed, 0x00, 0x05],\r\n    bytesArray = new Uint8Array(bytesToSend);\r\n\r\n    var xhr = new XMLHttpRequest();\r\n    xhr.open('POST', 'http://testsite.loc/tests/testserialized.php', false);\r\n    xhr.setRequestHeader('Content-Type', 'application/octet-stream');\r\n    xhr.send(bytesArray);\r\n```\r\n```\r\nlet text = request.postData();\r\n                const fs = require('fs');\r\n                let filename= __dirname + '/../tests/testserialize.txt';\r\n                fs.writeFile(filename, text, function(err) {\r\n                    if(err) {\r\n                        return console.log(err);\r\n                    }\r\n\r\n                    console.log(\"The file was saved!\");\r\n                });\r\n```\r\n**What is the expected result?**\r\nexpected result to recieve 4 bytes as it was sended\r\n\r\n**What happens instead?**\r\ninstead i recieve 8 bites at request.postData(); As i understand, this function convert post to 2 bytes per symbol string, can i get raw request post data?\r\n"},{"labels":["feature",null],"text":"<!--\r\nSTEP 1: Are you in the right place?\r\n\r\n- For general technical questions or \"how to\" guidance, please search StackOverflow for questions tagged \"puppeteer\" or create a new post.\r\n\r\nhttps://stackoverflow.com/questions/tagged/puppeteer\r\n\r\n- For issues or feature requests related to the DevTools Protocol (https://chromedevtools.github.io/devtools-protocol/), file an issue there:\r\n\r\nhttps://github.com/ChromeDevTools/devtools-protocol/issues/new.\r\n\r\n- Problem in Headless Chrome? File an issue against Chromium's issue tracker:\r\n\r\nhttps://bugs.chromium.org/p/chromium/issues/entry?components=Internals%3EHeadless&blocking=705916\r\n\r\nFor issues, feature requests, or setup troubles with Puppeteer, file an issue right here!\r\n-->\r\nI was writing ahelper function like\r\n```typescript\r\nasync function waitForPopup(page: Page, name: string): Promise<Page> {\r\n    // ...\r\n}\r\n```\r\nwhich waits until popup with `name` as name and whose parent is `page` and return the popup.\r\nBut with current version of puppeteer. I have to add extra `browser` arg like below\r\n```typescript\r\nasync function waitForPopup(browser: Browser, page: Page, name: string): Promise<Page> {\r\n    // ...\r\n}\r\n```\r\nbecause I can't get browser from `page`.\r\nIf `page.browser()` is there, I can omit that redundant `browser`.\r\n```\r\n`\r\n\r\n### Steps to reproduce\r\n\r\n**Tell us about your environment:**\r\n\r\n* Puppeteer version:\r\n* Platform / OS version:\r\n* URLs (if applicable):\r\n* Node.js version:\r\n\r\n**What steps will reproduce the problem?**\r\n\r\n_Please include code that reproduces the issue._\r\n\r\n1.\r\n2.\r\n3.\r\n\r\n**What is the expected result?**\r\n\r\n\r\n**What happens instead?**\r\n\r\n"},{"labels":["feature",null],"text":"<!--\r\nSTEP 1: Are you in the right place?\r\n\r\n- For general technical questions or \"how to\" guidance, please search StackOverflow for questions tagged \"puppeteer\" or create a new post.\r\n\r\nhttps://stackoverflow.com/questions/tagged/puppeteer\r\n\r\n- For issues or feature requests related to the DevTools Protocol (https://chromedevtools.github.io/devtools-protocol/), file an issue there:\r\n\r\nhttps://github.com/ChromeDevTools/devtools-protocol/issues/new.\r\n\r\n- Problem in Headless Chrome? File an issue against Chromium's issue tracker:\r\n\r\nhttps://bugs.chromium.org/p/chromium/issues/entry?components=Internals%3EHeadless&blocking=705916\r\n\r\nFor issues, feature requests, or setup troubles with Puppeteer, file an issue right here!\r\n-->\r\n\r\n### Steps to reproduce\r\n\r\n**Tell us about your environment:**\r\n\r\n* Puppeteer version: 1.1.1\r\n\r\n`page.goto`  support disable timeout. The usage of `timeout` is not the same\r\nNeed:  pass 0 to disable timeout  wait forerve"},{"labels":["feature",null],"text":"Can I get Remote Address with puppteerï¼Ÿ"},{"labels":["feature",null],"text":"It would be convenient if `page.tracing.stop()` returned `Promise<Buffer>` so users could act ton the trace JSON without saving a file to disk. This would also be consistent with the screenshot API.\r\n"},{"labels":["feature",null],"text":"### Steps to reproduce\r\n\r\n**Tell us about your environment:**\r\n\r\n* Puppeteer version:\r\n1.1.1\r\n* Platform / OS version:\r\nubuntu 16.04\r\n* URLs (if applicable):\r\nhttps://a.df-srv.de/v2/view/lePQD7Tyr8SNUYizE5Yy/a.html\r\n* Node.js version:\r\n9.7.1\r\n\r\n**What steps will reproduce the problem?**\r\nLoad a page over `https://` that has a `http://` resource embeded in an `<iframe>` object.\r\n(Example page: https://a.df-srv.de/v2/view/lePQD7Tyr8SNUYizE5Yy/a.html)\r\n\r\nThe debug console if `devtools:true` is enabled will show:\r\n`Mixed Content: The page at 'https://a.df-srv.de/v2/view/lePQD7Tyr8SNUYizE5Yy/a.html' was loaded over HTTPS, but requested an insecure resource 'http://ende.de/'. This request has been blocked; the content must be served over HTTPS.` \r\n\r\nHowever this message is not seen by puppeteer, even in the ` DEBUG=puppeteer:*` logs there is no sign of the blocked request.\r\n\r\n_Please include code that reproduces the issue._\r\n\r\n1. Load https://a.df-srv.de/v2/view/lePQD7Tyr8SNUYizE5Yy/a.html\r\n2. See `Mixed Content: The page at 'https://a.df-srv.de/v2/view/lePQD7Tyr8SNUYizE5Yy/a.html' was loaded over HTTPS, but requested an insecure resource 'http://ende.de/'. This request has been blocked; the content must be served over HTTPS.`\r\n3. Not intercept-able via `requestfailed`, `Network.loadingFailed`, `Network.requestIntercepted`, `Network.requestWillBeSent` or any other event.\r\n\r\n**What is the expected result?**\r\n\r\nSome way to catch the blocked `Mixed Content` log shown in the debug console.\r\n\r\n**What happens instead?**\r\n\r\nNothing."},{"labels":["feature",null],"text":"It would be awesome if puppeteer supported type=module for addScriptTag.\r\n"},{"labels":["feature"],"text":"### Steps to reproduce\r\n\r\n**Tell us about your environment:**\r\n\r\n* Puppeteer version: 1.1.0\r\n* Platform / OS version: Mac OSX\r\n* Node.js version: 9.5.0\r\n\r\n**What steps will reproduce the problem?**\r\n\r\ndevice_test.js:\r\n\r\n```js\r\nconst request = require('request');\r\nconst util = require('util');\r\nconst puppeteer = require('puppeteer');\r\n\r\nconst PORT =  process.env.PORT || 9222;\r\n\r\n(async() => {\r\n  const resp = await util.promisify(request)(`http://localhost:${PORT}/json/version`);\r\n  const {webSocketDebuggerUrl} = JSON.parse(resp.body);\r\n  const browser = await puppeteer.connect({browserWSEndpoint: webSocketDebuggerUrl});\r\n\r\n  const page = await browser.newPage();\r\n  await page.goto('https://example.com');\r\n\r\n  console.log(await browser.version());\r\n  console.log(await page.title());\r\n\r\n  await page.addStyleTag({content: '* {color: red;}'});\r\n\r\n  try {\r\n    // await page.close(); // causes page crash\r\n    // await browser.close(); // causes exception \r\n  } catch (err) {\r\n    console.error(err);\r\n  }\r\n\r\n  // process.exit(0); // only way to exit script.\r\n\r\n})();\r\n```\r\n\r\n1. Use the task switcher to kill all instances of Chrome running on the device\r\n3. Run `adb forward tcp:9222 localabstract:chrome_devtools_remote`\r\n4. Run `node device_test.js`\r\n\r\n**What is the expected result?**\r\n\r\nCalling `page.close()` or `browser.close()` works on Chrome Andorid.\r\n\r\n**What happens instead?**\r\n\r\nCalling `browser.close()` causes an exception:\r\n\r\n```\r\nChrome/66.0.3348.3\r\nExample Domain\r\n{ Error: Protocol error (Browser.close): 'Browser.close' wasn't found undefined\r\n    at Promise (/Users/ericbidelman/projects/puppeteer/puppeteer-examples/node_modules/puppeteer/lib/Connection.js:86:56)\r\n    at new Promise (<anonymous>)\r\n    at Connection.send (/Users/ericbidelman/projects/puppeteer/puppeteer-examples/node_modules/puppeteer/lib/C\r\nonnection.js:85:12)\r\n    at Browser.create (/Users/ericbidelman/projects/puppeteer/puppeteer-examples/node_modules/puppeteer/lib/La\r\nuncher.js:209:71)    at Browser.close (/Users/ericbidelman/projects/puppeteer/puppeteer-examples/node_modules/puppeteer/lib/Bro\r\nwser.js:147:31)    at /Users/ericbidelman/projects/puppeteer/puppeteer-examples/device_testing.js:25:19    at <anonymous>\r\n    at process._tickCallback (internal/process/next_tick.js:160:7)  message: 'Protocol error (Browser.close): \\'Browser.close\\' wasn\\'t found undefined' }\r\n```\r\n\r\nCalling `page.close()` causes a page crash:\r\n\r\n```\r\nericbidelman-macbookpro:puppeteer-examples ericbidelman$ node device_testing.jsChrome/66.0.3348.3\r\nExample Domain\r\n(node:15592) UnhandledPromiseRejectionWarning: Error: Page crashed!    at Page._onTargetCrashed (/Users/ericbidelman/projects/puppeteer/puppeteer-examples/node_modules/puppeteer\r\n/lib/Page.js:116:24)    at CDPSession.Page.client.on.event (/Users/ericbidelman/projects/puppeteer/puppeteer-examples/node_modules\r\n/puppeteer/lib/Page.js:104:56)    at CDPSession.emit (events.js:160:13)\r\n    at CDPSession._onMessage (/Users/ericbidelman/projects/puppeteer/puppeteer-examples/node_modules/puppeteer/lib/Connection.js:215:12)\r\n    at Connection._onMessage (/Users/ericbidelman/projects/puppeteer/puppeteer-examples/node_modules/puppeteer/lib/Connection.js:117:19)    at WebSocket.emit (events.js:160:13)\r\n    at Receiver._receiver.onmessage (/Users/ericbidelman/projects/puppeteer/puppeteer-examples/node_modules/ws/lib/WebSocket.js:143:47)\r\n    at Receiver.dataMessage (/Users/ericbidelman/projects/puppeteer/puppeteer-examples/node_modules/ws/lib/Rec\r\neiver.js:389:14)\r\n    at Receiver.getData (/Users/ericbidelman/projects/puppeteer/puppeteer-examples/node_modules/ws/lib/Receive\r\nr.js:330:12)\r\n    at Receiver.startLoop (/Users/ericbidelman/projects/puppeteer/puppeteer-examples/node_modules/ws/lib/Receiver.js:165:16)\r\n(node:15592) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). (rejection id: 1)\r\n(node:15592) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.\r\n```\r\n"},{"labels":["feature",null],"text":"When a `page.waitFor()` times out, this is all error context a dev gets:\r\n```\r\n     Error: waiting failed: timeout 30000ms exceeded\r\n      at Timeout.WaitTask._timeoutTimer.setTimeout (node_modules/puppeteer/lib/FrameManager.js:695:58)\r\n```\r\n\r\nNo stack trace and no indication _what_ operation timed out.\r\n\r\nAn easy change to an error message like\r\n```\r\n     Error: waiting for selector \".my-selector\" failed: timeout 30000ms exceeded\r\n      at Timeout.WaitTask._timeoutTimer.setTimeout (node_modules/puppeteer/lib/FrameManager.js:695:58)\r\n```\r\n\r\nwould make a huge difference in knowing where to look.\r\n\r\n"},{"labels":["feature"],"text":"In order to help facilitate testing of a web app's accessibility, it would be great if we could inspect the screen reader output of a headless browser."},{"labels":[null,"feature",null],"text":"**Tell us about your environment:**\r\n\r\n* Puppeteer version: 1.0.0\r\n* Platform / OS version: Ubuntu 16.04\r\n* URLs (if applicable):\r\n* Node.js version: 6.12.3\r\n\r\n**What steps will reproduce the problem?**\r\n\r\n```\r\nawait page.pdf({\r\n    headerTemplate: '',\r\n    footerTemplate: '',\r\n});\r\n```\r\n\r\n**What is the expected result?**\r\n\r\nThe header and footer should be blank.\r\n\r\n**What happens instead?**\r\n\r\nThe default header and footer are still shown.\r\n\r\nIt seems that passing any falsey value results in the default template being used instead. I would suggest that only `undefined` should cause it to use the default template. Empty string, `null`, `false` and `0` should all override the default template.\r\n\r\nThanks.\r\n"},{"labels":["feature",null],"text":"* Puppeteer version: 1.0.0-post, chromium_revision 526987\r\n* Platform / OS version: Windows 7 x64\r\n* Node.js version: 9.4.0\r\n\r\n**What steps will reproduce the problem?**\r\n\r\n```js\r\n'use strict';\r\n\r\nconst puppeteer = require('puppeteer');\r\n\r\n(async function main() {\r\n  try {\r\n    const browser = await puppeteer.launch({ headless: false });\r\n    const page = await browser.newPage();\r\n\r\n    page.on('console', (msg) => { console.log(msg.text()); });\r\n    page.on('pageerror', (exceptionMessage) => { console.log(exceptionMessage); });\r\n\r\n    const result = await page.evaluate(async () => {\r\n      try {\r\n        const status = await new Promise((resolve, reject) => {\r\n          const xhr = new XMLHttpRequest();\r\n          xhr.onreadystatechange = () => {\r\n            if (xhr.readyState === 4) {\r\n              if (xhr.status === 200) resolve(`good status: ${xhr.status}`);\r\n              else reject(`bad status: ${xhr.status}`);\r\n            }\r\n          };\r\n          xhr.onerror = () => { reject('xhr error'); };\r\n          xhr.open('GET', 'https://example.org/');\r\n          xhr.send();\r\n        });\r\n        return status;\r\n      } catch (err) {\r\n        return err;\r\n      }\r\n    });\r\n    console.log(result);\r\n  } catch (err) {\r\n    console.error(err);\r\n  }\r\n})();\r\n```\r\n\r\n**What is the expected result?**\r\n\r\nCORS error message is transferred to puppeteer\r\n\r\n**What happens instead?**\r\n\r\nOnly `bad status: 0` in the Node.js console, while this error message in the browser console:\r\n\r\n![err](https://user-images.githubusercontent.com/10393198/35650346-677a22ea-06e4-11e8-9bee-c52734695b1d.png)\r\n\r\nIs there a way to catch this error message, while `page.on('console')` and `page.on('pageerror')` seem to not work here?"},{"labels":[null,"feature"],"text":"Discussed this with @aslushnikov, but documenting here.\r\n\r\nUse case: while a page is loading, report coverage snapshots at various milestones. e.g. at `DOMContLoaded`, `load`, and `networkidle0`. This would allow users to measure the effectiveness of a lazy loading strategy, for example.\r\n\r\nMy goal was to create a breakdown of CSS/JS coverage at given points in time with URL attribution:\r\n<img width=\"627\" alt=\"screen shot 2018-01-24 at 1 58 48 pm\" src=\"https://user-images.githubusercontent.com/238208/35312281-c66f91d0-010e-11e8-93a2-65ebb0d73f84.png\">\r\n\r\nBut this is currently hard to do b/c:\r\n- it would be useful to provide an API call that calculates the used bytes and total bytes for a coverage object. Basically make this [common pattern](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#class-coverage) more convenient.\r\n- coverage is not cumulative, numbers go up and down between snapshots\r\n- `totalBytes` (denominator) in the screenshot doesn't represent the total file size. I'd expect all of them to be `39255`, the same va reported by the devtools:\r\n\r\n<img width=\"1126\" alt=\"screen shot 2018-01-24 at 2 14 55 pm\" src=\"https://user-images.githubusercontent.com/238208/35312715-fcbb68f2-0110-11e8-8cd8-dcdf5c64f8cc.png\">\r\n\r\nPOC code: http://jsbin.com/qohunokalo/1/edit?js,output\r\n\r\n```js\r\n// start coverage\r\n\r\nconst dcl = page.waitForNavigation({waitUntil: 'domcontentloaded'}).then(async response => {\r\n  const {jsCoverage, cssCoverage} = await stopCoverage(page);\r\n  // print metrics by URL @ domcontentloaded \r\n  await startCoverage(page);\r\n});\r\n\r\nconst load = page.waitForNavigation({waitUntil: 'load'}).then(async response => {\r\n  const {jsCoverage, cssCoverage} = await stopCoverage(page);\r\n  // print metrics by URL @ load \r\n  await startCoverage(page);\r\n});\r\n\r\nconst networkidle0 = page.waitForNavigation({waitUntil: 'networkidle0'}).then(async response => {\r\n  const {jsCoverage, cssCoverage} = await stopCoverage(page);\r\n    // print metrics by URL @ networkidle0 \r\n});\r\n\r\nawait Promise.all([dcl, load, networkidle0]);\r\n```\r\n"},{"labels":["feature"],"text":"Thanks for making puppeteer, it's made my life a lot easier. I want to be able to control more features of the browser, so I can automate testing of a Chrome extension that reacts to tab/window state. It would be good to be able to do these things with puppeteer's API:\r\n\r\n- open more than one Chrome window, but in the same browser context, i.e. sharing the same cookies etc. (and each window should be independently resizable)\r\n- when doing `browser.newPage()`, the ability to choose which window the new tab will appear in\r\n- reorder tabs within a window\r\n- move a tab from one window to another\r\n- click a Chrome extension's \"browser action\" or \"page action\" buttons\r\n\r\n Is there any chance these features will be added to puppeteer in future?"},{"labels":["feature",null],"text":"\r\n\r\n### Steps to reproduce\r\n\r\n**Tell us about your environment:**\r\n\r\n* Puppeteer version: v1.0.0\r\n* Platform / OS version: all\r\n* URLs (if applicable):\r\n* Node.js version: all\r\n\r\n**What steps will reproduce the problem?**\r\n\r\n_Please include code that reproduces the issue._\r\n\r\n1. open a page that opens a popup\r\n2. close the page through `page.close()`\r\n3. observe the `browser.targets()`\r\n\r\n**What is the expected result?**\r\n\r\nNo leftover targets created by the page, or at least a way of them closing automatically\r\n\r\n**What happens instead?**\r\n\r\na target for the popup stays open\r\n\r\nI'd suggest to keep track of all targets created by the page and closing them when `page.close()` is called. or maybe with a `page.close(closeChildPages)`."},{"labels":["feature"],"text":"The `request.redirectChain()` should return all the requests that are a part of the redirect chain for the `request`.\r\n\r\n```js\r\nconst response = await page.goto('http://google.com');\r\nconst requests = response.request().redirectChain();\r\nfor (const request of requests)\r\n  console.log(request.url());\r\n```\r\n\r\nThis was requested a few times, e.g. https://github.com/GoogleChrome/puppeteer/issues/1708."},{"labels":["feature"],"text":"Puppeteer automatically downloads Chrome. This is great, I wish I could use this feature for my tests running in Karma as well, and there are probably more use cases.\r\n\r\nI think it would be nice if the Chrome downloader would be extracted from puppeteer, so more tools can depend on it. The export should probably just be the path of the node executable.\r\n\r\nE.g.:\r\n\r\n```js\r\nconst chromePath = require('chrome')\r\n\r\nconsole.log(chromePath) // Something like '/app/node_modules/chrome/bin' or '/app/node_modules/.bin/google-chrome'\r\n```"},{"labels":["feature"],"text":"<!--\r\nSTEP 1: Are you in the right place?\r\n\r\n- For general technical questions or \"how to\" guidance, please search StackOverflow for questions tagged \"puppeteer\" or create a new post.\r\n\r\nhttps://stackoverflow.com/questions/tagged/puppeteer\r\n\r\n- For issues or feature requests related to the DevTools Protocol (https://chromedevtools.github.io/devtools-protocol/), file an issue there:\r\n\r\nhttps://github.com/ChromeDevTools/devtools-protocol/issues/new.\r\n\r\n- Problem in Headless Chrome? File an issue against Chromium's issue tracker:\r\n\r\nhttps://bugs.chromium.org/p/chromium/issues/entry?components=Internals%3EHeadless&blocking=705916\r\n\r\nFor issues, feature requests, or setup troubles with Puppeteer, file an issue right here!\r\n-->\r\n\r\n### Steps to reproduce\r\n\r\n**Tell us about your environment:**\r\n\r\n* Puppeteer version: 0.13.0\r\n* Platform / OS version: OSX\r\n* Node.js version: 8.9.0\r\n\r\n**What steps will reproduce the problem?**\r\n\r\n```js\r\n// compare with .to-screenshot size\r\nawait page.setViewport({width: 500, height: 500}); \r\n\r\nawait page.setContent(`\r\n  something above\r\n  <style>div.spacer {\r\n    border: 2px solid blue;\r\n    background: red;\r\n    height: 600px;\r\n  }\r\n  div.to-screenshot {\r\n    border: 2px solid blue;\r\n    background: green;\r\n    width: 50px;\r\n    height: 1000px;\r\n    margin-left: 1000px;\r\n  }\r\n  </style>\r\n  <div class=\"spacer\"></div>\r\n  <div class=\"to-screenshot\"></div>\r\n  <div class=\"spacer\"></div>\r\n`);\r\nconst elementHandle = await page.$('div.to-screenshot');\r\nconst screenshot = await elementHandle.screenshot();\r\n```\r\n\r\n---\r\n\r\nI'm using `elementHandle.screenshot()` which is working, but if the element is larger than the viewport, it won't capture all of it. This make sense if you look at the source and see that it's using `page.screenshot` with a `clip`, and you know that clip doesn't work with `fullPage`, but it's not intuitive, and doesn't seem like a good default behavior.\r\n\r\nWould it be possible to get `elementHandle.screenshot` to capture the whole element? It already tries to ignore scroll position, but viewport size limits it.\r\n\r\nI tried making it use `Emulation.setDeviceMetricsOverride`, but then clip stopped working. Guessing this is why `clip`+`fullPage` errors.\r\n\r\nOn the project I need this for, I ended up doing:\r\n\r\n```js\r\nconst bounds = await el.boundingBox();\r\nconst initial = Object.assign({}, page.viewport());\r\n\r\nawait page.setViewport({\r\n  width: Math.max(Math.ceil(bounds.width), initial.width),\r\n  height: Math.max(Math.ceil(bounds.height), initial.height),\r\n});\r\n\r\nconst imageRes = await el.screenshot({ type: 'jpeg', quality: 90 });\r\nawait page.setViewport(initial);\r\nreturn imageRes;\r\n```\r\n\r\nOf course, this would impact media queries and 'resize' events, so not high enough quality to be included in puppeteer's source, I think.\r\n\r\nI don't know what a good solution would be, but I use element screenshots a lot so I'm happy to implement any solutions you come up with. Thanks for the great tool!"},{"labels":[null,"feature",null],"text":"Since now headers and footers with page numbers work, I now desperately miss an option to generate a Table of Contents (TOC) out of the h1- h7 headers when generating a pdf file (i.e like wkhtmltopdf is doing this). The TOC should be at the start of the pdf and it should not only be clickable (jump to the page) but also generate the outline pdf element, so that the TOC is displayed in the contents view in any viewer. Although this may sound complicated if this functionality is implemented at the right place it is not that complicated (take a look on how wkhtmltopdf is implementing this).\r\n\r\nBefore posting here I tried a couple of workarounds to achieve this.\r\nSome dead ends:\r\n - CSS3 target_counter() -> proposed a long time ago and only some specialised tools do it, to be honest I've given up to think that it will be implemented in chrome some day (reference issue is now: https://bugs.chromium.org/p/chromium/issues/detail?id=368053 )\r\n - Find a tool or tools to extract the table of contents from the generated pdf and generate a preface.pdf with the TOC witch to merge in-front of the original pdf ... With https://github.com/qpdf/qpdf I was able to generate a readable and searchable \"pdf text-file\" so that theoretically it was possible to find the header in the text file and via reverse search and the added comments find out on wich page it is etc. etc...\r\n\r\nAny chance to get this soon?\r\nThanks\r\nOgnian\r\n "},{"labels":["feature",null],"text":"I love the addition of $x to query for xpath easily. In my code I've also added a waitForXpath function that roughly mirrors the waitForSelector method.\r\n\r\nhere's the snippet:\r\n```\r\nexport const waitForXpath = async (context, xpath) => {\r\n  const inputGetter = function (path) {\r\n    return document.evaluate(path, document, null, XPathResult.ANY_TYPE, null).iterateNext();\r\n  };\r\n  const jsHandle = await context.waitForFunction(inputGetter, { polling: 50 }, xpath);\r\n  return jsHandle.asElement();\r\n};\r\n```\r\n\r\nthis is much a bit simpler than the full waitForSelector, but a start.\r\n\r\nI'd like to not have to write this function myself!\r\n\r\nAny chance we could get a waitForXpath added to puppeteer? and maybe even detect xpath strings so I can just write `page.waitFor(\"//p[normalize-space(.)='hello world']\")`"},{"labels":["feature"],"text":"[Downloader](https://github.com/GoogleChrome/puppeteer/blob/7c9104e1bc118ad227c7c4ff81025d6107317f8a/lib/Downloader.js) provides capabilities to download chromium from the upstream buckets. Exposing the API will drastically simplify devops and simplify everyone's life.\r\n\r\nThis has been requested a few times; one example is https://github.com/GoogleChrome/puppeteer/pull/1652."},{"labels":["feature"],"text":"In browser, we can use querySelector method like this:\r\n\r\n```javascript\r\nconst div = document.querySelector('div');  // lookup \"div\" globally\r\nconst span = div.querySelector('span');  // lookup \"span\" locally, that is bounded to div's scope\r\n```\r\n\r\nIt's helpful to provide waitForSelector method on ElementHandle, thus we can wait for selector locally that is bounded to the ElementHandle instance.\r\n  "},{"labels":["feature"],"text":"According to Chrome DevTool protocol, [Browser.getVersion](https://chromedevtools.github.io/devtools-protocol/tot/Browser/) returns not only `product` but also other properties such as `userAgent`.\r\n\r\nIn my environment, the raw API returns the following object:\r\n\r\n```\r\n{ protocolVersion: '1.2',\r\n  product: 'HeadlessChrome/64.0.3264.0',\r\n  revision: '@7f3cdc3f76faecc6425814688e3b2b71bf1630a4',\r\n  userAgent: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/64.0.3264.0 Safari/537.36',\r\n  jsVersion: '6.4.265' }\r\n```\r\n\r\nHowever, the current `browser.version()` returns only `product` property. The code is [here](https://github.com/GoogleChrome/puppeteer/blob/master/lib/Browser.js#L135).\r\n\r\nI believe it's useful to return other properties. In my case, I need `userAgent` before actually requesting.\r\n\r\nFor me, another solution is to add a method like `browser.userAgent()`. But I feel listing all properties of `Browser.getVersion` is more useful and consistent to Chrome DevTool Protocol.\r\n\r\nActually the [API doc](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#browserversion) already says this:\r\n\r\n```\r\n**NOTE** the format of browser.version() might change with future releases of Chromium.\r\n```\r\n\r\nI can make a small PR if you want."},{"labels":["feature"],"text":"Currently if you open pages with urls like:  chrome-extension://fjjllfpmlaejicjkpknbdicd...\r\nThose get:\r\n\r\n```\r\n_targetInfo:\r\n   { targetId: '(769AF8566CD3629647D0BC2EFBD10E1)',\r\n     type: 'app',\r\n```\r\n\r\nso the type is **app** and target.page() doesn't work to obtain the target page, due to this check:\r\n\r\n```javascript\r\nif (this._targetInfo.type === 'page' && !this._pagePromise) {\r\n```\r\nat https://github.com/GoogleChrome/puppeteer/blob/master/lib/Browser.js#L194\r\n\r\nThe same is also valid for pages within a webview\r\n```\r\n _targetInfo:\r\n   { targetId: '(28682BC78076959FC22B67763A8251DD)',\r\n     type: 'webview',\r\n```\r\n\r\nso the check should be changed to \r\n```javascript\r\nif ((this._targetInfo.type === 'page' || this._targetInfo.type === 'app' || this._targetInfo.type === 'webview') && !this._pagePromise) {\r\n```\r\n\r\n"},{"labels":["feature"],"text":"<sup>Issue template didn't really apply.</sup>\r\n\r\nI can't find anything in the api docs page about error handling. The main type of error that's encountered is a timeout. The issue is that there's no documented way to distinguish the type of error received in the `catch` after awaiting a promise that rejects.\r\n\r\nThe issue is that good code (most of the time) needs to do conditional catches to avoid silencing unexpected errors. There doesn't seem to be a good, stable way to do this currently.\r\n\r\nI tried inspecting some of the errors. For these tests, the output is logging `error` and then logging `{...error}`.\r\n\r\n```js\r\nawait page.click('doesntexist');\r\n\r\n// Result\r\n{ AssertionError [ERR_ASSERTION]: No node found for selector: doesntexist\r\n    at Console.assert (console.js:188:23)\r\n    at Page.click (/private/tmp/temp-puppet-7695/node_modules/puppeteer/lib/Page.js:770:13)\r\n    at <anonymous>\r\n    at process._tickCallback (internal/process/next_tick.js:188:7)\r\n  generatedMessage: false,\r\n  name: 'AssertionError [ERR_ASSERTION]',\r\n  code: 'ERR_ASSERTION',\r\n  actual: false,\r\n  expected: true,\r\n  operator: '==' }\r\n{ generatedMessage: false,\r\n  name: 'AssertionError [ERR_ASSERTION]',\r\n  code: 'ERR_ASSERTION',\r\n  actual: false,\r\n  expected: true,\r\n  operator: '==' }\r\n```\r\n\r\nGives a generic `AssertionError` with no information about the cause, except if you want to parse the error message, which seems very unstable as it can change without much notice.\r\n\r\nThe next issue is `waitFor`:\r\n\r\n```js\r\nawait page.waitFor('doesntexist');\r\n\r\n// Result\r\nError: waiting failed: timeout 30000ms exceeded\r\n    at Timeout.WaitTask._timeoutTimer.setTimeout (/private/tmp/temp-puppet-7695/node_modules/puppeteer/lib/FrameManager.js:593:58)\r\n    at ontimeout (timers.js:475:11)\r\n    at tryOnTimeout (timers.js:310:5)\r\n    at Timer.listOnTimeout (timers.js:270:5)\r\n{}\r\n```\r\n\r\nAgain, the only way I see to extract information is the error message.\r\n\r\n---\r\n\r\nThere are a few potential solutions here:\r\n\r\n1. document the error messages and give an example regex to check them. This requires no code changes, but makes it clear that the error messages changing would be a breaking change. \r\n2. don't change the errors, but give official utility functions like `puppeteer.isTimeoutError(error)`. Very little code changes, but the api will be stable across versions. Better than 1.\r\n3. make each error either an Error subclass, or give it properties e.g. `type: 'PuppeteerTimeout', selector: 'doesntexist'`. This is about tied with 2, since it gives a readable way to check the error type.\r\n\r\n\r\nThoughts? Sorry if this has come up before, but I couldn't find anything relevant."},{"labels":["feature"],"text":"I want to provide Chrome instance with `prefs`/`localState`. Using *ChromeDriver*'s `chromeOptions` (https://sites.google.com/a/chromium.org/chromedriver/capabilities) I could set something like this:\r\n```js\r\nprefs: {\r\n    download: {\r\n        prompt_for_download: false,\r\n        default_directory: DOWNLOAD_PATH,\r\n    }\r\n},\r\nlocalState: {\r\n    browser: {\r\n        \"enabled_labs_experiments\": [\r\n            // All preferences can be found here: https://src.chromium.org/viewvc/chrome/trunk/src/chrome/common/pref_names.cc?view=markup\r\n            \"enable-native-notifications@2\",\r\n        ],\r\n    }\r\n},\r\n```\r\nIs it possible to do the same with *puppeteer*? (I saw the workaround for setting download dir through `_client`, but the question is more general)\r\n\r\nHere is related issue: https://github.com/GoogleChrome/puppeteer/issues/1577"},{"labels":[null,"feature",null],"text":"Sounds a bit old in our age of touch interfaces, but would be great to have native mouse wheel simulation (to use with existing code)."},{"labels":["feature",null],"text":"I am building a suite of automated tests using Puppeteer, Mochajs and Chaijs. While building the tests I rely heavily on the devtools console to find the right way to select elements, to traverse nodelists, to determine what to validate, basically to figure out what i need to do in my Puppeteer scripts. Though there is always a translation that needs to happen which involves experimenting with Puppeteer methods and running my scripts over and over till I get it right.\r\n\r\nWhat I would love is the ability to control the browser step by step in the devtools, using Puppeteer. This would help me to experiment and ultimately determine what I need to use in my scripts without the need to run the scripts with every new step.\r\n\r\nThanks for all the hard work you have put into this tool."},{"labels":["feature"],"text":"Hello,\r\n\r\nI'm using Puppeteer to do an offline mirror of a site. Problem is, I can't save large files. The following code is a simplified version of the mirroring bot, and it fails on the .flv (larger) file. My actual target site contains similar flash players and flv files.\r\n\r\n```javascript\r\nconst puppeteer = require('puppeteer');\r\nconst url = require('url');\r\nconst fs = require('fs');\r\nconst path = require('path');\r\nconst fse = require('fs-extra');\r\n\r\n(async () => {\r\n  const savePath = './site';\r\n  const browser = await puppeteer.launch({\r\n    args: [\r\n      '--no-sandbox',\r\n      '--ppapi-flash-version=28.0.0.126',\r\n      '--ppapi-flash-path=/usr/lib/PepperFlash/libpepflashplayer.so',\r\n      '--user-data-dir=/home/howe/.config/chromium'\r\n    ],\r\n    headless: false,\r\n  });\r\n  const page = await browser.newPage();\r\n  page.on('response', async (res) => {\r\n    const parsed = url.parse(res.url);\r\n    try {\r\n      const fn = path.join(savePath, parsed.pathname);\r\n      console.log(`Saving file ${fn}...`);\r\n      await fse.ensureDir(path.dirname(fn));\r\n      await fse.writeFile(fn, await res.buffer());\r\n    }\r\n    catch (e) {\r\n      console.error('Error:', e)\r\n    }\r\n  });\r\n  await page.goto('http://flash.flowplayer.org/demos/plugins/flash/viralvideos-extconfig.html', { waitUntil: 'networkidle2' });\r\n  // browser.close();\r\n})();\r\n```\r\nAfter downloading a few smaller files, it throws the following cryptic error:\r\n```\r\nProtocol error (Network.getResponseBody): Request content was evicted from inspector cache undefined\r\n```\r\nAny clues? Is this a bug? I have no idea why it works on smaller but not larger files.\r\n\r\nThanks,\r\nHowe"},{"labels":["feature",null],"text":"How can I compare `iframe` element and context?\r\n\r\nI was trying to add `name` attribute for each `<iframe>` element and than find it in `childFrames`:\r\n```js\r\n            for (let child of currentFrame.childFrames()) {\r\n                const listName = await child.evaluate(() => {\r\n                    if (window.frameElement !== null)\r\n                        return window.frameElement.getAttribute('Name');\r\n                });\r\n\r\n                if (listName === frameName) {\r\n                    searchResult = child;\r\n                }\r\n            }\r\n```\r\n\r\nBut that's not work in 80% cases! How can I compare context and frame **without**:\r\n* adding `name`\r\n* adding `hash` to the end of the URL\r\n* using `parent.document`"},{"labels":["feature"],"text":"The page object has the ability to .wait() for the [DOMContentLoaded event](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagegotourl-options). It also emits the ['load' event](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#event-load).\r\n\r\nIt'd be nice to have a way to listen for the DOMContentLoaded event on the main frame, whether through `page.on('domcontentloaded', ...)` or through `page.mainFrame().on('domcontentloaded', ...)`.\r\n\r\nThere are cases where I want to evaluate the DOM as soon as it's ready on every navigation, and injecting JavaScript to handle it or having to call certain methods after every `goto(url, {waitUntil: 'domcontentloaded'})` is cumbersome. Emitting the DOMContentLoaded would keep things consistent between the `goto()` wait options and what is currently offered by the page's event emitter."},{"labels":["feature"],"text":"We should attribute network requests to frames so that we know where requests are coming from.\r\n\r\n```js\r\nconst frame = request.frame();\r\n```\r\n\r\nThis would simplify network traffic analysis.\r\n\r\nOpen question: it might make sense to expose execution contexts instead to attribute requests coming from workers. "},{"labels":["feature"],"text":"It seems that context menu is a native element and outside of the document, and thus belongs in `Page`, similar to screenshot functionality and so on.\r\n\r\nIt can be hacked with keydown events and keyboard events or maybe even selectors, and that's how it is in Selenium, but that's not ideal."},{"labels":["feature",null],"text":"Related to https://github.com/GoogleChrome/puppeteer/issues/1551, it would be useful to have an API call to disable the browser's disk cache. \r\n\r\nUse cases:\r\n- A/B test server caching/config without having to relaunch chrome or use `userDataDir` to do multiple runs.\r\n- Use a single browser instance to test the first load of every view of a SPA. Need to bypass the cache to ensure requests are always fresh for shared resources.\r\n\r\nRef: [`Network.setCacheDisabled`](https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-setCacheDisabled)"},{"labels":["feature",null],"text":"DTP [supports](https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-Response) a `fromDiskCache` and `fromServiceWorker` on the Response object.  It would be useful to expose these props on `Response` so users don't have to hack something together:\r\n\r\n```js\r\npage._client.on('Network.responseReceived', result => {\r\n  if (!resp.fromServiceWorker) {\r\n    console.log('Not cached by sw:', result.response.url);\r\n  }\r\n});\r\n```\r\n\r\n**Use cases**\r\n1. allow authors to verify a sw is caching the expected assets.\r\n2. allow authors to identify which requests are _not_ being cached by sw. Catch regressions on their offline experience.\r\n\r\nI hit number 2 recently. Thought I was caching something that I wasn't:\r\n\r\n<img width=\"1160\" alt=\"screen shot 2017-12-07 at 3 40 46 pm\" src=\"https://user-images.githubusercontent.com/238208/33747868-4066a8c6-db7a-11e7-98a2-6af1ab7b3caf.png\">\r\n\r\n---\r\nI originally approached this similar to the Lighthouse solution: load the PWA, wait for service worker to cache assets, go offline, reload the page and listen for responses that are `!== 200`. \r\n\r\n```js\r\nconst page = await browser.newPage();\r\nawait page.goto('https://www.chromestatus.com/features', {waitUntil: 'networkidle0'});\r\n\r\nawait page.evaluate('navigator.serviceWorker.ready'); // wait for sw to become active\r\n\r\nawait page.setOfflineMode(true); // go offline\r\n\r\npage.on('response', resp => {\r\n  if (resp.status !== 200) {\r\n    ...\r\n  }\r\n});\r\n\r\nawait page.reload({waitUntil: 'networkidle0'});\r\n```\r\n\r\nHowever, this **doesn't work** in Puppeteer. Using Puppeteer, many of the responses will come from the disk cache after the page reload. So, it looks like the responses work offline but they don't!  In Lighthouse, we [disable the disk cache](https://github.com/GoogleChrome/lighthouse/blob/master/lighthouse-core/gather/driver.js#L951-L958) to avoid this issue.\r\n\r\nAnother approach I thought of is to inject code into the page and examine what's in `window.caches`. But that's 1000% overkill.\r\n\r\n...much easier to make`fromDiskCache` and `fromServiceWorker` available ðŸ‘."},{"labels":["feature",null],"text":"The default timeout for most things is 30000ms and each option has the option to set a custom timeout.\r\nIs there a way to change the global timeout to something much longer? I don't want to have to change all of my `waitFor` all over the code base?\r\n"},{"labels":[null,"feature"],"text":"Crashed targets should be handled gracefully:\r\n1. All pending commands should be rejected. This includes protocol messages and watchdogs, such as NavigatorWatcher / WaitTask\r\n2. All subsequent commands to the crashed target should reject right away\r\n\r\nNeither (1) or (2) happen with Puppeteer v0.13.0."},{"labels":[null,"feature"],"text":"Exposing timing information would greatly benefit performance scenarios.\r\nWe shoud:\r\n1. add `DOMContentLoaded` and `NavigationStart` metrics to the `Page.metrics()` struct\r\n2. expose timing information for requests/response objects\r\n\r\nThere's currently a suspicion that [1] is not aligned with [2] in the protocol. We, however, should pick a single time scale and use it throughout the api. "},{"labels":[null,"feature",null],"text":"Requests, that are fired after the basic request is done, are initiated by some source - f.e. a script or something. Since chrome does provide this information in the network tab, I wonder if you can give it via puppeteer?\r\n\r\nExample:\r\n![image](https://user-images.githubusercontent.com/20280311/32839936-68063286-ca16-11e7-8f61-c93bd6054cf0.png)\r\n"},{"labels":["feature"],"text":"I would like to collect garbage in the process of tests so that I can do metrics and doing traces between operations.\r\n\r\nChrome dev tools has a clear garbage button on the performance tab.\r\nCan we get access to the operations of that button please in the same way as you can do it manually  on the performance tab.\r\n\r\nsomething like page.collectGarbage() would be really appreciated."},{"labels":[null,"feature"],"text":"**What steps will reproduce the problem?**\r\nI'm using this code:\r\n\r\n\tasync function interceptHandler(target){\r\n\t\tconst page = await target.page();\r\n\t\tif(!page) return console.log('target opened: wasn\\'t a page');\r\n\t\tconsole.log('target opened: attaching pre-filter for page');\r\n\t\tawait page.setRequestInterception(true);\r\n\t\tpage.on('request',blockLoading);\r\n\t\t}\r\n\r\n\tconst browser=await puppeteer.launch(puppeteerOptions);\r\n\tbrowser.on('targetcreated',interceptHandler);\r\n\tconst page = await browser.newPage();\r\n\r\n**What is the expected result?**\r\nEverything blocked by my `blockLoading` function should end up blocked (css/images/fonts).\r\n\r\n**What happens instead?**\r\nThis works fine for my initial `page` -- probably since there's time to attach the handler.\r\n\r\nBut when I have a new tab opening, triggering a new target, I see several css/images loading before the intercept handler kicks in to block the rest.\r\n\r\n@JoelEinbinder said this is a known issue https://github.com/GoogleChrome/puppeteer/issues/386#issuecomment-343059315 but I couldn't find a ticket.\r\n\r\n\r\nA possible option from a user's standpoint would be to save a global handler that automatically gets attached to all new targets, so it already exists upon creation if that somehow solves a race issue.\r\n"},{"labels":["feature"],"text":"Current version of `boundingBox` is terribly coded as I think ðŸ˜„ :\r\nhttps://github.com/GoogleChrome/puppeteer/blob/master/lib/ElementHandle.js#L123\r\n\r\nLook at DevTools method:\r\nhttps://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getBoxModel\r\n\r\nDevTools method returns `BoxModel`:\r\nhttps://chromedevtools.github.io/devtools-protocol/tot/DOM/#type-BoxModel\r\n\r\n`BoxModel` contains:\r\n* content\r\n* padding\r\n* border\r\n* margin\r\n* width\r\n* height\r\n\r\n1) Why we are calculating width and height? It's already calculated and returned by DevTools, but we have:\r\n```js\r\nconst width = Math.max(quad[0], quad[2], quad[4], quad[6]) - x;\r\nconst height = Math.max(quad[1], quad[3], quad[5], quad[7]) - y;\r\n```\r\n2) Puppeteer use only border position:\r\n```js\r\nconst quad = result.model.border;\r\n```\r\nWhat If I want to get content position? Or padding position or margin position? ðŸ˜¢ \r\n\r\nMy advice is smth like that:\r\n```js\r\nasync boundingBox() {\r\n  const result = await this._client.send('DOM.getBoxModel', {\r\n    objectId: this._remoteObject.objectId\r\n  }).catch(error => void debugError(error));\r\n\r\n  if (!result)\r\n    return null;\r\n\r\n  const borderQuad = result.model.border;\r\n\r\n  return {\r\n    border: {\r\n      x: Math.min(borderQuad[0], borderQuad[2], borderQuad[4], borderQuad[6]),\r\n      y: Math.min(borderQuad[1], borderQuad[3], borderQuad[5], borderQuad[7]),\r\n      width: Math.max(borderQuad[0], borderQuad[2], borderQuad[4], borderQuad[6]) - x,\r\n      height: Math.max(borderQuad[1], borderQuad[3], borderQuad[5], borderQuad[7]) - y\r\n    },\r\n    // same for padding and margin\r\n    width: result.model.width,\r\n    height: result.model.height\r\n  };\r\n}\r\n```"},{"labels":["feature",null],"text":"(Based on discussion in https://github.com/GoogleChrome/puppeteer/issues/854#issuecomment-342247715)\r\n\r\nThere should be a way to run tracing with custom categories.\r\n\r\n@paulirish suggested having a \"sampling\" option with optional \"hires\" parameter.\r\n\r\n```js\r\npage.tracing.start({\r\n  path: 'trace.json',\r\n  sampling: true // could be also |false| and |'hires'|\r\n});\r\n```\r\n\r\nAs a valid alternative, I like letting users specify custom categories:\r\n\r\n```js\r\npage.tracing.start({\r\n  path: 'trace.json',\r\n  // Use these categories instead of the puppeteer defaults\r\n  categories: ['disabled-by-default-v8.cpu_profiler.hires', /* ... other categories.. */ ]\r\n});\r\n```"},{"labels":["feature",null],"text":"Enabling `dumpio` is quite useful as I'm experiencing some instability with headless chrome, but it can be very noisy.\r\n\r\nIt would be good if we could filter chrome's output (e.g. to filter out uninteresting messages based on tags like CONSOLE:), as well as redirect it elsewhere (e.g. to a file, or a buffer)."},{"labels":["feature",null],"text":"A page with CSP will break some of puppeteer methods, such as `page.addScriptTag`. At the very least, we should fail gracefully.\r\n\r\nIt would be ideal to have a way to disable CSP altogether.\r\n\r\nReported in: #1091 "},{"labels":[null,"feature"],"text":"The [documentation](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#overview)  show that Frames can be associated with extensions but there's no documentation on how to register an extension & run a script under one of the extensions environments (option page/background page/page action/ect...).\r\n\r\nIt would be awesome to run automated tests for web-extensions developpers."},{"labels":[null,"feature"],"text":"As of today, we have \"request interception\" that allows puppeteer to intercept and amend requests before they are sent to the server.\r\n\r\nSimilarly to this, it would be really handy to have \"Response interception\" that would allow to intercept and amend responses from server before they are delivered to the browser."},{"labels":["feature"],"text":"**Tell us about your environment:**\r\n\r\n* Puppeteer version: 0.13.0-alpha\r\n* Platform / OS version: macos high sierra 10.13\r\n* URLs (if applicable):\r\n\r\n**What steps will reproduce the problem?**\r\n\r\n_Please include code that reproduces the issue._\r\n\r\n```javascript\r\n// start.js\r\n\r\nconst puppeteer = require('puppeteer')\r\n\r\nconst run = async () => {\r\n  const browser = await puppeteer.launch({\r\n    headless: false,\r\n    slowMo: 250,\r\n    args: [\r\n      '--disable-infobars',\r\n    ],\r\n  });\r\n\r\n  const page = await browser.newPage();\r\n\r\n  await page.goto('https://www.google.com/');\r\n\r\n  await page.waitFor(60000)\r\n  await browser.close();\r\n}\r\n\r\nrun()\r\n```\r\n\r\n1. `node start.js`\r\n\r\n**What is the expected result?**\r\n\r\n1. window inner size and viewport should be equal, all the default 800px x 600px\r\n\r\n**What happens instead?**\r\n\r\n1. window inner size is larger than the viewport size\r\n\r\n![google-puppeteer.png](https://i.loli.net/2017/10/27/59f2f0f3b461e.png)\r\n"},{"labels":["feature",null],"text":"It would be useful to be able to set [data attributes](https://html.spec.whatwg.org/multipage/dom.html#custom-data-attribute) on `script` and `style` elements added by puppeteer.\r\n\r\nFor instance:\r\n\r\n```js\r\nawait page.addScriptTag({\r\n  url: 'https://example.com/script.js',\r\n  attributes: { foo: bar },\r\n});\r\n```\r\nwould add the following tag:\r\n\r\n```html\r\n<script type=\"text/javascript\" src=\"https://example.com/script.js\" data-foo=\"bar\">\r\n```\r\n\r\nFor instance, I inject a script that (for a reason) selects all the `script` elements in my pages, but then it selects itself (and its dependencies). I'd like to be able to filter out all the elements added by puppeteer. Having a custom `data-*` attribute would allow me to do that. I hope it makes sense.\r\n"},{"labels":[null,"feature"],"text":"**What is the expected result?**\r\n\r\nI would like to be able to test how websites behave when a user sets a root font size that is different from the default 16px.\r\n\r\nSo I need a way to tell puppeteer to change the root font size value.\r\n\r\n![image](https://user-images.githubusercontent.com/78213/31995580-58f40256-b985-11e7-9848-9932e74193f2.png)\r\n"},{"labels":["feature"],"text":"<!--\r\nSTEP 1: Are you in the right place?\r\n\r\n- For general technical questions or \"how to\" guidance, please search StackOverflow for questions tagged \"puppeteer\" or create a new post.\r\n\r\nhttps://stackoverflow.com/questions/tagged/puppeteer\r\n\r\n- For issues or feature requests related to the DevTools Protocol (https://chromedevtools.github.io/devtools-protocol/), file an issue there:\r\n\r\nhttps://github.com/ChromeDevTools/devtools-protocol/issues/new.\r\n\r\n- Problem in Headless Chrome? File an issue against Chromium's issue tracker:\r\n\r\nhttps://bugs.chromium.org/p/chromium/issues/entry?components=Internals%3EHeadless&blocking=705916\r\n\r\nFor issues, feature requests, or setup troubles with Puppeteer, file an issue right here!\r\n-->\r\n\r\n### Steps to reproduce\r\n\r\n**Tell us about your environment:**\r\n\r\n* Puppeteer version: 0.12.0\r\n* Platform / OS version: win10 64\r\n* URLs (if applicable): https://www.google.com/search?num=100&newwindow=1&dcr=0&source=hp&q=hotels&oq=hotels\r\n\r\n**What steps will reproduce the problem?**\r\n\r\n_Please include code that reproduces the issue._\r\n\r\n1. when a website request a geo location, chrome will alert a dialog\r\n2. i try to use this code to accept this dialog.\r\n```\r\n    page.on('dialog', async dialog => {\r\n        console.log(dialog.message());\r\n        await dialog.dismiss();\r\n    });\r\n```\r\n3. but it failed, the event didn't trigger.\r\nhow could i capture this geo location dialog?\r\n\r\n**What is the expected result?**\r\ngeo location will trigger the when chrome alert the dialog\r\n\r\n**What happens instead?**\r\nnothing happened\r\n\r\n![1508822756](https://user-images.githubusercontent.com/13128637/31926217-cd30f24e-b8bf-11e7-9f2d-9656a1ccde3d.png)\r\n\r\n"},{"labels":["feature",null],"text":"<!--\r\nSTEP 1: Are you in the right place?\r\n\r\n- For general technical questions or \"how to\" guidance, please search StackOverflow for questions tagged \"puppeteer\" or create a new post.\r\n\r\nhttps://stackoverflow.com/questions/tagged/puppeteer\r\n\r\n- For issues or feature requests related to the DevTools Protocol (https://chromedevtools.github.io/devtools-protocol/), file an issue there:\r\n\r\nhttps://github.com/ChromeDevTools/devtools-protocol/issues/new.\r\n\r\n- Problem in Headless Chrome? File an issue against Chromium's issue tracker:\r\n\r\nhttps://bugs.chromium.org/p/chromium/issues/entry?components=Internals%3EHeadless&blocking=705916\r\n\r\nFor issues, feature requests, or setup troubles with Puppeteer, file an issue right here!\r\n-->\r\n\r\n### Steps to reproduce\r\nWhen I create a new page it will change my active window to my new tab. Which is I don't like it because it will disturb me to type in another application.\r\nActually, I solved the problem by set `headless` mode to `true`. But, that's not what I like to do because I don't see the activity from my browser.\r\n\r\n**Tell us about your environment:**\r\n\r\n* Puppeteer version: 0.12-alpha\r\n* Platform / OS version: Ubuntu 16.04\r\n* URLs (if applicable):\r\n\r\n**What steps will reproduce the problem?**\r\n\r\n_Please include code that reproduces the issue._\r\n\r\n1.\r\n2.\r\n3.\r\n\r\n**What is the expected result?**\r\nWhen Puppeteer launches new tab it wouldn't change my window active, so I can still continue typing in another application.\r\n\r\n**What happens instead?**\r\nWhen Puppeteer creates and launch new tab it's changed my active window to my new tab, so I can't type to my another app.\r\nIf I want to type to my another app I should switch window into it."},{"labels":["feature",null],"text":"<!--\r\nSTEP 1: Are you in the right place?\r\n\r\n- For general technical questions or \"how to\" guidance, please search StackOverflow for questions tagged \"puppeteer\" or create a new post.\r\n\r\nhttps://stackoverflow.com/questions/tagged/puppeteer\r\n\r\n- For issues or feature requests related to the DevTools Protocol (https://chromedevtools.github.io/devtools-protocol/), file an issue there:\r\n\r\nhttps://github.com/ChromeDevTools/devtools-protocol/issues/new.\r\n\r\n- Problem in Headless Chrome? File an issue against Chromium's issue tracker:\r\n\r\nhttps://bugs.chromium.org/p/chromium/issues/entry?components=Internals%3EHeadless&blocking=705916\r\n\r\nFor issues, feature requests, or setup troubles with Puppeteer, file an issue right here!\r\n-->\r\n\r\n### Steps to reproduce\r\n\r\n**Tell us about your environment:**\r\n\r\n* Puppeteer version: 0.12.0\r\n* Platform / OS version: MacOS\r\n* URLs (if applicable): https://h5.m.taobao.com/trip/home/index.html\r\n\r\n**What steps will reproduce the problem?**\r\n\r\n_Please include code that reproduces the issue._\r\n\r\n1. use puppeteer to capture performance for the page.\r\n\r\n```\r\nconst puppeteer = require('puppeteer');\r\nconst devices = require('puppeteer/DeviceDescriptors');\r\nconst iPhone = devices['iPhone 6'];\r\nconst co = require('co');\r\nconst path = require('path');\r\nco(function* () {\r\n  const PAGE_URL = 'https://h5.m.taobao.com/trip/home/index.html';\r\n  const browser = yield puppeteer.launch({\r\n    headless: false,\r\n    ignoreHTTPSErrors: true,\r\n    args: [\r\n      '--auto-open-devtools-for-tabs'\r\n    ],\r\n    userDataDir: path.join(__dirname, 'user-dir')\r\n  });\r\n  const page = yield browser.newPage();\r\n  yield page.emulate(iPhone);\r\n\r\n  try {\r\n    yield page.goto(PAGE_URL);\r\n  } catch (e) {\r\n    console.error(`>> Load page ${PAGE_URL} error encounted: `);\r\n    console.error(e.stack);\r\n  }\r\n  yield page.waitForNavigation({\r\n    waitUntil: 'networkidle',\r\n    networkIdleTimeout: 2000\r\n  });\r\n  const perfEntries = yield page.evaluate(() => performance.getEntries());\r\n  console.log(perfEntries);\r\n\r\n  browser.close();\r\n\r\n  return stats;\r\n}).then((stats) => {\r\n  console.log('END');\r\n  console.log(stats);\r\n}).catch(e => {\r\n  console.error(e.stack);\r\n});\r\n```\r\n\r\n2. allow geolocation permission\r\n3. set the preset geolocation in devtools/sensors:\r\n\r\n![image](https://user-images.githubusercontent.com/2196373/31699270-ab8f517c-b387-11e7-92f2-afbaf403bd8d.png)\r\n\r\n**What is the expected result?**\r\n\r\nThe Geolocation preset config is saved to user-dir, and next time chromium should use the settings here to enable geolocation mock.\r\n\r\n**What happens instead?**\r\n\r\nThe settings in devtools/sensors were not persistent, next time the code runs the geolocation settings were reset, which made the code in the page request geolocation failed.\r\n\r\nOr is there any way to set the geolocation mock by `args` param when chromium launch?\r\n"},{"labels":[null,"feature",null],"text":"Actually the only way to request a page through a POST or/and with custom headers is by trapping the request with `page.setRequestInterceptionEnabled(true)` (as proposed [here](https://github.com/GoogleChrome/puppeteer/issues/669#issuecomment-326797345)) or by building a custom html page with a `<form>` tag and submitting it (this solution prevent us to set custom headers).\r\n\r\nBoth of these solutions are very hackishâ€¦\r\n\r\nIt would be better to have a second parameter to `page.goto()` in which we can specify the request params like [`request.continue()`](https://github.com/GoogleChrome/puppeteer/blob/v0.12.0/docs/api.md#requestcontinueoverrides):\r\n```javascript\r\n{\r\n    method: 'POST',\r\n    postData: 'â€¦', \r\n    headers: {â€¦}\r\n}\r\n```  \r\nWhat do you think?\r\n"},{"labels":["feature",null],"text":"Is there a reason why frames don't have evaluateHandle()? I'm trying to use it like below:\r\n\r\n````\r\nconst windowHandle = await frame.evaluateHandle((selector) => {\r\n  // Do various things\r\n  return aDOMElement;\r\n}, selector);\r\n\r\nconst elementHandle = windowHandle.asElement();\r\nawait elementHandle.click();\r\n````\r\n"},{"labels":[null,"feature"],"text":"Request interception should allow:\r\n- abort request with different errors\r\n- fake the response: headers, status, body."},{"labels":["feature"],"text":"- Fire `browser.closed` event when the underlying browser process gets closed / crashes\r\n- Fire `page.closed` event when the page gets closed / crashes\r\n\r\nThis will help to build reliable scripts that restart browser or reopen pages when they crash.\r\n"},{"labels":[null,"feature"],"text":"When browsing trough the docs and using the API, I noticed that Puppeteer has an `injectFile` method. The name might be confusing, because you might think it works for a CSS file as well. I think it would be better to rename this method to `injectScript` and also add a `injectCSS` method.\r\n\r\nJust an idea though :)."},{"labels":["feature"],"text":"It would be a faster variant for cases when the DOM tree suffices to retrieve some info.\r\n\r\nhttps://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded"},{"labels":["feature"],"text":"The 'requestfailed' event is similar to PhantomJS' onResourceError event, but in Puppeteer the event handler receives only a Request object. There should be a way for a requestfailed handler to determine what the cause of the failure was - for example, a timeout vs an unresolvable hostname.\r\n"},{"labels":["feature"],"text":"Puppeteer has a [`addScriptTag(url)`](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pageaddscripttagurl) method, it would be nice to have a `addStyleTag(url)` as well to easily add external styles.\r\n\r\n// @kevva @sindresorhus"},{"labels":["feature"],"text":"There are certain usecases where it is needed to override default puppeteer launcher flags.\r\n\r\nThere should be a way to do that.\r\n\r\nSuggestion:\r\n```js\r\n// Get default launcher flags.\r\nconst myArgs = puppeteer.defaultArgs();\r\n// Add/remove arguments as needed.\r\nmyArgs = myArgs.filter(argsFilter).concat(secretArgs);\r\n// Launch with exactly these arguments.\r\nconst browser = await puppeteer.launch({\r\n  disableDefaultArgs: true, // do not use default args to launch puppeteer\r\n  args: myArgs\r\n});\r\n```"},{"labels":["feature"],"text":"I am making a wrapper around Puppeteer which is to be used for taking screenshots/pdfs of urls, you can see the code I am using here: https://bitbucket.org/petarvasilev/puppeteer-screenshots\r\n\r\nI am having a problem on line 122 of screenshot.js where I am using .waitForNavigation to wait until all lazy load images are loaded and then proceed with the rest of the script; however when there are no lazy load images the script fails with timeout 30000ms exceeded error.\r\n\r\nYou can replicate the error by running the script using the following command:\r\n\r\nnode app.js --url=http://sailsjs.com/ --lazyLoad=true\r\n\r\nnote that it works without the lazy load part. \r\n\r\nI am not sure but maybe I am using 'waitForNavigation' incorrectly. Also, maybe a new method can be implemented like: 'waitForNetworkIdle()' which would more accurately reflect what I am trying to do.\r\n\r\n"},{"labels":[null,"feature"],"text":"Currently, we don't have a way to find/query nodes with shadow roots. Users need to traverse `.shadowRoot`s themselves.\r\n\r\nIt would be [ideal if the DTP supported an option](https://github.com/ChromeDevTools/devtools-protocol/issues/19) to make this easier, but maybe we can provide options to `page.$eval` to pierce through shadow roots?\r\n"},{"labels":["feature",null],"text":"\r\n![screen shot 2017-09-21 at 7 37 02 pm](https://user-images.githubusercontent.com/12194969/30693950-6bde622a-9e97-11e7-8b2c-9f3ae0fd6e93.png)\r\n"},{"labels":[null,"feature"],"text":"I'm looking for a page navigation lock feature or alternative like phantomjs has http://phantomjs.org/api/webpage/property/navigation-locked.html"},{"labels":[null,"feature"],"text":"Some pages will fire load event before network goes idle, some after. I'd like to wait for both events to have happened before considering a page 'navigated'. Currently looking at the `watchdog` code it seems like it's either one or the other. The way to do it right now is:\r\n\r\n```js\r\nconst timeout = 30000;\r\nconst networkIdleTimeout = 500;\r\nawait Promise.all([\r\n  page.waitForNavigation({ timeout, waitUntil: 'load' }),\r\n  page.waitForNavigation({ timeout, waitUntil: 'networkidle', networkIdleTimeout }),\r\n  page.goto(url)\r\n]);\r\n```\r\n\r\nBut it seems to me that this is a functionality that deserves a more straightforward out-of-the-box solution. for instance:\r\n\r\n```js\r\npage.goto(url, { \r\n  timeout: 3000,\r\n  waitUntil: [ 'load', 'networkidle' ],\r\n  networkIdleTimeout: 500\r\n});\r\n```\r\n\r\nOr assume that people that wait for `'networkidle'` also always want to wait for `'load'`.\r\n\r\nPS: I might be wrong about this, but after digging through the code, it seems to me that this function doesn't take the actual state into account. For instance it won't work if the load event has already fired or if the network is already idle."},{"labels":[null,"feature"],"text":"Keyboard emulation is not perfect\r\n- [x] [`event.code`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code) is not reported\r\n- [x] [`event.location`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/location) is not reported"},{"labels":["feature",null],"text":"Hi all,\r\nNot sure if it's right place to ask question, how can I get frame content (HTML before and after JS rendering). I see page.content() method, but not such thing for frame. Thanks for your time!\r\n"},{"labels":["feature"],"text":"Page offers a console event but it is not possible to know the level of the message (log, error...).\r\n\r\n    page.on('console', function (...args) {\r\n        // No way to know if this is an error\r\n    })\r\n\r\nWould it be possible to implement a way to know the level? I don't know what would be the cleanest way, either one more event per level:\r\n\r\n    page.on('consoleError', ...)\r\n\r\nor a new type of event:\r\n\r\n    page.on('consoleWithType', function ({type, args}) ...\r\n\r\nBasically here: https://github.com/GoogleChrome/puppeteer/blob/master/lib/Page.js#L308 the event type is totally ignored"},{"labels":["feature",null],"text":"(as mentioned in #486 and other places)\r\n\r\nWe need a way to wait for page to load all the resources after the `page.setContent`.\r\n\r\nThe [lifecycle events](https://aslushnikov.github.io/vanilla-protocol-viewer/#Page.lifecycleEvent) might help help."},{"labels":[null,"feature"],"text":"I am unable to get ssl certificate. I went through all the documentation and response object I couldn't figure out a way to get SSL certificate.\r\n\r\nI would like to inspect the details of SSL certificate.\r\n\r\nIs it even possible with current puppeteer API?\r\n\r\nNo luck on stackoverflow: \r\n\r\nhttps://stackoverflow.com/questions/46108756/how-to-access-ssl-certificate-content-using-chrome-puppeteer"},{"labels":["feature"],"text":"The debug option is very helpful! Referring to:\r\n\r\n```\r\nbrowser = await puppeteer.launch({\r\n  headless: false,\r\n  slowMo: 100,\r\n})\r\n```\r\n\r\nHowever, it doesn't activate/focus the opened Chromium app so you need to wait for the app to open then quickly activate it. Example:\r\n\r\n![puppeteer-debug](https://user-images.githubusercontent.com/5497885/30138557-319dfdf4-9326-11e7-9450-06e52a51a025.gif)\r\n\r\nIdeally it would be awesome to have a pause/play button and Chromium opens paused at first by default, but even just automatically focusing the Chromium window when it opens would be helpful (if this can be done cross platform? `electron` does this, but I'm not sure how). I could add a unix-specific `sleep {someAmount}; open -a \"Chromium\"` to the script that runs puppeteer, but this would create race conditions and tie the script to mac/linux.\r\n\r\nAnyways, not a big deal but something to think about :) Thanks for all the great work with Puppeteer."},{"labels":[null,"feature",null],"text":"Hi!\r\n\r\nCould someone tell me, whether there's a possibility to set proxy not only for a chromium instance, but also for a page?\r\n\r\nSo the current solution is:\r\n`const browser = await puppeteer.launch({\r\n  args: [ '--proxy-server=127.0.0.1:9876' ]\r\n});`\r\n\r\nDesired solution in my case is something like this:\r\n`const page = await browser.newPage({\r\n  args: [ '--proxy-server=127.0.0.1:9876' ]\r\n});`\r\n\r\nWith proxy per page there's a possibility to run a single chrome instance, but use different proxies depending on page.\r\n\r\nThanks in advance!"},{"labels":[null,"feature",null],"text":"I mean some response is gzipped, I want to get the size, thanks\r\n\r\n\r\n"},{"labels":[null,"feature",null],"text":"We need a way to fetch, add and remove cookies from browser:\r\n```js\r\nconst cookies = await browser.cookies();\r\nawait browser.deleteCookie(cookies[0])\r\nawait browser.addCookie(cookies[0]);\r\n```\r\n\r\nWhen the #85 is implemented, the cookies will belong to the browser context. This will nicely explain cookie scoping: different pages from the same browser context share cookies, whereas pages from different browser contexts don't.\r\n\r\nAnd once we have cookies on browser / browserContext, we can remove page's cookies api."},{"labels":["feature"],"text":"@paulirish suggested to introduce `page.$eval` and `page.$$eval` that will reduce the need for a lot one-line methods.\r\n\r\nE.g. `elementHandle.attribute` would be replaced with a one-liner:\r\n\r\n```js\r\nlet idAttribute = await page.$eval('div', div => div.id);\r\n```\r\n\r\nSo the plan is:\r\n- introduce `frame.$eval` / `frame.$$eval` / `page.$eval` / `page.$$eval`\r\n- drop the `elementHandle.attribute`"},{"labels":[null,"feature"],"text":"I tried mouse.down but not fire touch eventï¼Œwhat should i do\r\n\r\n```\r\nconst browser = await puppeteer.launch()\r\nconst page = await browser.newPage()\r\nawait page.emulate(iPhone)\r\n\r\nawait page.mouse.down({ button: 'left' })\r\n```"},{"labels":[null,"feature"],"text":"Is there another way without disabling the popup via puppeteer launch ? I tried dialog stuff but it seems not the way.\r\n\r\n<img width=\"1116\" alt=\"screen shot 2017-08-25 at 5 20 42 pm\" src=\"https://user-images.githubusercontent.com/642874/29708177-5db7c8a4-89ba-11e7-8827-917c0d09fa4d.png\">\r\n"},{"labels":[null,"feature",null],"text":"I would like to detect if a page is playing some sound. Is there a way to do that?"},{"labels":["feature"],"text":"Hey, is it possible to launch as a new tab in an existing profile? \r\n\r\nI have an existing session with cookies and authentication bearer, problem is that puppeteer opens a dedicated chrome without the session or profile I want. \r\n\r\nheres my code:\r\n```js\r\n(async () => {\r\n  const browser = await puppeteer.launch({\r\n  \theadless: false,\r\n  \texecutablePath: '/Applications/Google Chrome.app/Contents/MacOS/Google Chrome',\r\n  \targs: ['--user-data-dir']\r\n  }); \r\n  const page = await browser.newPage();\r\n})();\r\n```\r\nif i don't use executablePath it opens a whole new profile and there's no error, but when I do it opens a new window at the correct profile/session yet errors with the following:\r\n\r\n(node:26977) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code."},{"labels":[null,"feature"],"text":"I need to be able to take deterministic screenshots and when animations are running you'll get a different frame from an animation each time.\r\n\r\nThere does appear to be some control of animations in the devtools protocol here: https://chromedevtools.github.io/devtools-protocol/tot/Animation/\r\n\r\nI've tried these without success:\r\n\r\n```javascript\r\nawait page._client.send('Animation.setPlaybackRate', { playbackRate: 0.0 });\r\n```\r\n\r\n```javascript\r\nawait page._client.send('Animation.disable');\r\n```\r\n\r\nThere's also an official extension that disables animations: https://chrome.google.com/webstore/detail/animation-policy/ncigbofjfbodhkaffojakplpmnleeoee?hl=en\r\n\r\nLooking at the source code of that extension it calls this:\r\n\r\n```javascript\r\nchrome.accessibilityFeatures.animationPolicy.set({'value': setting}, function (callback) {});\r\n```\r\n\r\nWhere the ideal value would be 'none'. (https://codereview.chromium.org/785723002/diff/20001/chrome/common/extensions/api/accessibility_features.json#newcode48chrome/common/extensions/api/accessibility_features.json:48)\r\n\r\nRelated: #453 "},{"labels":["feature"],"text":"Maybe add the ability to get child elements on `ElementHandle` instances, using `$`, and `$$`, syntax should work like:\r\n\r\n```js\r\nlet $header = await page.$(\"div.header\")\r\nlet $homeLink = await $header.$(\"a.home\")\r\n\r\nawait $homeLink.click()\r\n```\r\n\r\nAlong with `$$`, this would make iterating pages with recursive structures so much more easier, no longer requiring it all to be kept inside of `.evaluate` callbacks.\r\n\r\nSuch as:\r\n```js\r\nlet $results = await page.$$(\".result\")\r\n\r\nfor (let $result of $results) {\r\n    let $title = await $result.$(\".title\")\r\n\r\n    let title await $title.evaluate(($) => $.innerText)\r\n    console.log(`Title: ${title}`)\r\n\r\n    let resUrl = await $title.evaluate(($) => $.href)\r\n    console.log(`Result URL: ${resUrl}`)\r\n    \r\n    let $sourceLinks = await $result.$$(\".sources\")\r\n\r\n    for (let $sourceLink of $sourceLinks) {\r\n        let sourceUrl = await $sourceLink.evaluate(($) => $.href)\r\n        console.log(`Source URL: ${sourceUrl}`)\r\n    }\r\n}\r\n```\r\nDon't think this would be too hard to implement, and work make automation a lot easier"},{"labels":[null,"feature",null],"text":"Would be great to screencast the page."},{"labels":["feature"],"text":"Is there a convenient way to clean HTTP cache and application data like service workers, cookies, etc.? I couldn't find anything related in the docs."},{"labels":["feature"],"text":"I was playing around with Puppeteer today and I found out that there is no way (that I know of) to run script like this:\r\n```\r\nconst puppeteer = require('puppeteer');\r\n\r\npuppeteer.connect({browserWSEndpoint: <endpoint>}).then(async browser => {\r\n  const page = await browser.currentPage();\r\n  // other actions that would manipulate the current page\r\n  browser.close();\r\n});\r\n```\r\n\r\nThe only way to get a Page instance seems to be browser.newPage() which is rather inconvenient if I want to run several test scripts that all connect to one browser instance."},{"labels":["feature"],"text":"I would like for example to do\r\n\r\n```\r\n   let input = await page.$('input')\r\n   assert.equal(input.value, 'some text')\r\n```\r\n\r\nIt could be input.getAttribute('value') or/and getProperty('value'). Or anything else that could make sense."},{"labels":["feature"],"text":"While attempting to convert Poltergeist from using PhantomJS to Puppeteer I need to select a `Frame` object (returned from `childFrames`) based on the `<iframe>` element which encapsulates it.  Looking through the Puppeteer code I don't see any link between them, or way to generate a link.  Am I missing something, or is this not possible with the functionality provided by the Dev Tools Protocol?"},{"labels":[null,"feature"],"text":"HTTP Authentication could look like this (similar to [Nightmare.js](https://github.com/segmentio/nightmare#authenticationuser-password)):\r\n```js\r\nawait page.authenticate(user, pass);\r\n```"},{"labels":[null,"feature"],"text":"I found an edge case where webfonts don't seem to be loaded for PDF rendering, unless you trigger a screenshot first:\r\n\r\n```js\r\nvar puppeteer = require('puppeteer')\r\n\r\nvar document = `\r\n    <!DOCTYPE html>\r\n    <html>\r\n    <head>\r\n      <style>\r\n        @import url(https://fonts.googleapis.com/css?family=Signika);\r\n        body {\r\n          font-family: 'Signika', sans-serif;\r\n        }\r\n      </style>\r\n    </head>\r\n    <body>\r\n      <h1>Hello world!</h1>\r\n    </body>\r\n    </html>\r\n  `\r\n\r\npuppeteer.launch().then(async browser => {\r\n  let page = await browser.newPage()\r\n  await page.setContent(document)\r\n  // await page.screenshot() // <= Will render a blank PDF without this line\r\n  await page.pdf({\r\n    path: 'print.pdf',\r\n    format: 'A4'\r\n  })\r\n  browser.close()\r\n});\r\n```\r\n\r\nInspecting the PDF without triggering a screenshot reveals only a single `obj`, which I suspect is the text: \r\n\r\n```\r\n2 0 obj\r\n<</Filter /FlateDecode\r\n/Length 96>> stream\r\nxï¿½3T0\u0000B]C aabï¿½ï¿½ï¿½ï¿½Uï¿½\u0005\u00121ï¿½4\u0005\r\n\u0018ï¿½Yï¿½\u001aï¿½+\u0014ï¿½rï¿½k)ï¿½\u0001ï¿½ï¿½ï¿½M\r\nï¿½\r\nMï¿½Lï¿½ï¿½Py@ï¿½ï¿½\r\n \u0018ï¿½ï¿½\u0000a\u0014ï¿½sï¿½ï¿½\u001b(ï¿½\u0017ï¿½ï¿½4ï¿½4V0442\u0002\u0019ï¿½ï¿½\u0015\bï¿½\u0000\r\nh\u0018ï¿½\r\nendstream\r\nendobj\r\n```\r\n\r\nAfter the screenshot the font is registered as a `obj` as well."},{"labels":["feature"],"text":"getting blank screenshots with pages which have meta refresh\r\n\r\nwhat is the best way to handle meta refresh\r\n\r\n```\r\nlet page = await browser.newPage();\r\n        await  page.setUserAgent('Mozilla/5.0 (Windows NT x.y; rv:10.0) Gecko/20100101 Firefox/10.0');\r\n        page.setViewport({width: options.width, height: options.height});\r\n        await page.goto(srcUrl, {timeout: self.timeout, waitUntil: 'networkidle',\r\n          networkIdleTimeout: 2000});\r\n\r\nawait page.screenshot({\r\n          path: '/tmp/test.png',\r\n          clip: {x: 0, y: 0, width: options.width, height: options.height}\r\n        });\r\n```\r\n\r\n\r\nsample page hxxp://www.snehpubliclibrary.org/my.adp/adp\r\n\r\nwarning: redirects to phishing site\r\n\r\nsample code\r\n```\r\n<html xmlns='http://www.w3.org/1999/xhtml'>^M\r\n<head>\r\n<title></title>\r\n<meta http-equiv='refresh' content='0;URL= login.php'>\r\n</head>\r\n</html>\r\n```\r\n"},{"labels":["feature"],"text":"Use case: periodically getting some data from a site that requires authorization. A user can login once and then just use the cookies automatically."},{"labels":[null,"feature"],"text":"Not sure how this would work, or if possible at all with how puppeteer works. A nice feature would be if the browser emit an event with a new `Page` when a new tab is opened by clicking on a `target=\"_blank\"` or through some other means."},{"labels":["feature"],"text":"Having a multi-element selector using ElementHandles would be a very useful feature, API should probably work something like the intuitive:\r\n\r\n```js\r\nlet elements = await page.$$('a'); // <Array<ElementHandle>>\r\nelements.forEach(el => el.click());\r\n```"},{"labels":[null,"feature"],"text":"- Add `page.object(func)` that returns a new `ObjectHandle` type.\r\n- Expose `ObjectHandle.json()` that would return result similar to present `page.evaluate`. That will allow access to the raw object handlers for non-trivial operations.\r\n- Inherit `ElementHandle` from `ObjectHandle` if possible\r\n- Allow object handles to be disposed, expose `evaluateOn` on the objects\r\n- Provide support for object groups (arenas) for bulk dispose"},{"labels":["feature"],"text":"Hi everyone! Currently I use PhantomJS to generate PDF documents from html output. Because PhantomJS isn't really up-to-date, I'd like to switch to Headless Chrome.\r\n\r\nThe thing that keeps me from making the switch is that it's not possible to print the page number on the bottom of every page. I found out that it's possible to set a header and/or a footer on every page with CSS.\r\n\r\n```html\r\nheader {\r\n  display: block;\r\n  position: fixed;\r\n  top: 0px;\r\n  left: 0px;\r\n  right: 0px;\r\n}\r\n\r\nfooter {\r\n  display: block;\r\n  position: fixed;\r\n  bottom: 0px;\r\n  left: 0px;\r\n  right: 0px;\r\n}\r\n```\r\n\r\nThe only downside is that this only works for static data as it's not possible to somehow detect and print the page number in the footer or header. PhantomJS allows to set a [header and footer](http://phantomjs.org/api/webpage/property/paper-size.html#headers-and-footers) of a document and print the page number."},{"labels":["feature"],"text":"I'm having trouble replicating, e.g., Chrome on a Pixel. I tried\r\n\r\n```js\r\nawait page.setViewport({\r\n  width: 1080,\r\n  height: 1920,\r\n  isMobile: true,\r\n  hasTouch: true,\r\n  deviceScaleFactor: 2\r\n});\r\n```\r\n\r\nbut this doesn't replicate what I actually see on a Pixel. (User agent also needs to be set.)"},{"labels":["feature"],"text":"I'm trying to take a full-page screenshot for a website, that contains lots of images. I write below scripts:\r\n\r\n```js\r\nconst puppeteer = require('puppeteer');\r\n\r\n(async() => {\r\n\tconst browser = await puppeteer.launch();\r\n\r\n\tconst page = await browser.newPage();\r\n\r\n\tawait page.goto('https://blog.petehouston.com', {\r\n\t\twaitUntil: 'networkidle'\r\n\t});\r\n\r\n\tawait page.waitForSelector('img');\r\n\r\n\tawait page.screenshot({\r\n\t\tpath: 'capture.jpg',\r\n\t\tfullPage: true\r\n\t});\r\n\r\n\tbrowser.close();\r\n})();\r\n```\r\n\r\nHowever, the result screenshot `capture.jpg` shows that puppeteer hasn't completed loading all images on the site.\r\n\r\nIs there any way to wait for all images `img` completed loading?"},{"labels":["feature"],"text":"Is it possible to setup proxy for request or for user_profile"},{"labels":["feature"],"text":"Hi! First of all thanks for the tool, it's wonderful to have an official API!\r\n\r\nWhat's the reason to only use promises? You could as well also support callbacks, which still are the official way of doing async programming in node.js. They're also not going anywhere as the node team has planned to support them both simultaneously.\r\n\r\nThanks!"},{"labels":["feature",null],"text":"For further parity with https://developer.mozilla.org/en-US/docs/Web/API/Response, these would be useful to add\r\n\r\n- [x]  `Response.statusText `\r\n- [x]  `Response.redirected `\r\n- [x] `Request.type `"},{"labels":["feature"],"text":"Per the [package.json file](https://github.com/GoogleChrome/puppeteer/blob/master/package.json), it looks like puppeteer only works on Node versions `>=7.10.0`. Would you be willing to maintain this package on the Node 6 release line, since it is the current LTS version?"},{"labels":[null,"feature"],"text":"It seems the PDF generation activates the print CSS media type. While that makes sense in the majority of use cases, it would be very useful in some other use cases, like [Decktape](https://github.com/astefanutti/decktape) that exports HTML presentations for which it is preferable to retain the screen media type. "},{"labels":["feature"],"text":"It's easy to run into cases where the return value of `page.evaluate` can't be returned to the calling page b/c it's not a basic JS type:\r\n\r\n```javascript\r\nconst rect = await page.evaluate(async () => {\r\n  const element = document.querySelector('#id');\r\n  return element.getBoundingClientRect();\r\n});\r\n// rect === {}\r\n```\r\n\r\nFor this example, one solution is to pick out values from the `ClientRect`:\r\n\r\n```javascript\r\nconst rect = await page.evaluate(async () => {\r\n  const element = document.querySelector('#id');\r\n  const {x, y, width, height} = element.getBoundingClientRect();\r\n  return {left: x, top: y, width, height};\r\n});\r\n// rect === { left: 0, top: 1282, width: 695, height: 22 }\r\n```\r\nHowever, it would be nice if `page.evaluate` warns for these cases. \r\n\r\nsomewhat related: https://github.com/GoogleChrome/puppeteer/issues/302"},{"labels":[null,"feature"],"text":"Is there a way to get numbers for time before `DOMContentLoaded` and `load` events? First paint time would be nice as well. I see that there is `page.tracing` API, but it produces Chrome trace file. For my task I need only two numbers mentioned above and in format that I can easily parse (e.g. JSON) and without necessity for disk I/O. Something like `page.getMetrics() -> Promise<{DOMContentLoadedTime, loadTime}>`."},{"labels":["feature"],"text":"# Problem\r\nI see there is an API for starting and stoping a timeline recording `await page.tracing.start({path: 'trace.json'});` but I would like to request the ability to take a memory heap snapshot and the ability  to write expectations on the snapshot data.\r\n\r\nMy use case is roughly:\r\n - load a page\r\n - load a component & do stuff\r\n - remove the component\r\n - force a garbage collection (would love a method for this as well!)\r\n - take a heap snapshot\r\n - Verify that the component is not retained in memory somehow\r\n\r\nThis would be amazing to be able to have automated headless memory leak regression testing!\r\n\r\nMaybe something like:\r\n```\r\nvar heapsnap = await page.heap.snapshot('heap1.snapshot');\r\nexpect(!heapsnap.contains('SomeClassName'))\r\n```\r\n\r\nBonus points for an API for the memory allocation timeline that you could query for the number of objects of a type added / removed during the timeline.\r\n"},{"labels":["feature"],"text":"adding support for ElementHandle as both a valid argument and return value to evaluate will make the api more powerful for end users.\r\n\r\ni'd expect both of the following to work.  (they are both broken)\r\n```\r\nconst elem = await page.$('input')\r\nconst b = await page.evaluate((a) => { return a }, elem)\r\nawait b.click()\r\n```\r\n\r\n```\r\nconst b = await page.evaluate(() => { return document.querySelector('input') })\r\nawait b.click()\r\n```"},{"labels":[null,null,"feature",null],"text":"Question: How do I get puppeteer to download a file or make additional http requests and save the response?"},{"labels":["feature"],"text":"We had `keyboard.type` in our plan for quite some time, but it seems to get lost. "},{"labels":["feature"],"text":"In certain cases, it would come handy to:\r\n- launch a long-running chromium instance which is [detached from parent node process](https://nodejs.org/api/child_process.html#child_process_options_detached)\r\n- connect to the instance later (from another script)\r\n\r\nLaunching long-running chromium instance might look like this:\r\n```js\r\nconst {Browser} = require('puppeteer');\r\nconst browserTargetId = Browser.launchDetached({\r\n  // standard Browser options\r\n});\r\n```\r\n\r\nConnecting to the detached instance might be:\r\n```js\r\nconst {Browser} = require('puppeteer');\r\nconst browser = await Browser.connect(browserTargetId);\r\n...\r\n```\r\n\r\nTo think about:\r\n- stderr/stdout streams would not work for `Browser.connect` (unless those are forwarded to a fd?)\r\n- users should do their own profile folder management"},{"labels":[null,"feature",null],"text":"Simulating touch events is difficult.\r\n\r\nFor tapping:\r\n`Input.synthesizeTapGesture` appears to only work on android\r\n`Input.dispatchTouchEvent` doesn't click events like normal tapping would\r\n`Input.emulateTouchFromMouseEvent` fires mouse events, but only after an undefined delay.\r\n\r\nThe best way to emulate touch right now appears to be setting the device mode to iPhone, which sends `touchStart` and `touchEnd` along with every mouse press."},{"labels":["feature"],"text":"There has been a lot of talk about element handles/references. Some points to consider:\r\n\r\n- Should they reference actual nodeIds, or reference a selector/finder function\r\n- Do we need them?\r\n- What happens if the element leaves DOM? If it gets garbage collected?\r\n- Do we still have `page.click(selector)`?\r\n\r\nHow they might look:\r\n```js\r\nlet button = page.$('button');\r\nawait button.click();\r\n```\r\n\r\n```js\r\nlet button = await page.waitForSelector('button');\r\nawait button.click();\r\n```\r\n\r\n```js\r\npage.$('button')\r\n    .focus()\r\n    .click()\r\n    .run(b => b.textContent = 'hello');\r\n```\r\n\r\n```js\r\nlet button = page.$('button')\r\nawait page.waitFor('button')\r\nawait button.click();\r\n```\r\n\r\n```js\r\nlet button = page.$('button')\r\nawait page.waitFor('button')\r\nawait button.click();\r\n```\r\n"},{"labels":["feature"],"text":"Currently we have the following api to emulate devices:\r\n```js\r\nlet names = page.emulatedDevices(); // to get list of emulatable devices\r\npage.emulate('iphone 6'); // to emulate \"iphone 6\"\r\n```\r\n\r\nProblems with this api:\r\n- having `emulatedDevices()` as a getter and under a page makes me feel that the device list might change over time and from page to page.\r\n- it's hard to introspect what kind of options are actually set for the device, e.g. to see device's screen size\r\n- it's hard to do my own device, or import someone's pre-made from npm\r\n\r\nHow about:\r\n```js\r\n// Puppeteer defines the \"Device\" class\r\nclass Device {\r\n  constructor(name, userAgent, viewport, isMobile = true, hasTouch = true) {\r\n    this.name = name;\r\n    this.userAgent = userAgent;\r\n    this.viewport = viewport;\r\n    this.isMobile = isMobile;\r\n    this.hasTouch = hasTouch;\r\n  }\r\n}\r\n\r\n// The Device class and a list of all available devices are exposed\r\n// in the top-level require\r\nconst {Browser, Device, devices} = require('puppeteer');\r\n\r\n// `devices` list is an array with additional string properties. Devices\r\n// could be both iterated and accessed via device names\r\ndevices[0];\r\ndevices.nexus5;\r\n\r\n// If needed, a hand-made device could be done\r\nlet myDevice = new Device('handmade', 'handmade-webkit', {\r\n  width: 100,\r\n  height: 100,\r\n  dpi: 2,\r\n});\r\n\r\n// Devices would be convenient to import from npm\r\nlet exoticDevice = require('list-of-exotic-devices-for-puppeteer');\r\n\r\n// Finally, page can start emulating a device\r\npage.emulateDevice(device);\r\npage.emulatedDevice(); // returns currently-emulated device\r\n\r\n// And we can change page's orientation\r\npage.setOrientation('landscape'); // also could be 'portrait'\r\n```\r\n\r\nThis kind of API would make emulation a first-class citizen in Puppeteer - which makes a lot of sense since devtools device emulation is very comprehensive."},{"labels":["feature",null],"text":"Support browser contexts (Target.createBrowserContext) so to avoid launching multiple instances if one wants a pristine session. See proposal https://github.com/GoogleChrome/puppeteer/issues/66 and original discussion at https://github.com/cyrus-and/chrome-remote-interface/issues/118.\r\n\r\nA viable user scenario might be testing several users logged in simultaneously into the service.\r\nWe might expose browser contexts as a string literal option to the browser.newPage:\r\n```js\r\nbrowser.newPage(); // creates a new page in a default browser context\r\nbrowser.newPage({ context: 'default' }); // same as previous call\r\nbrowser.newPage({ context: 'another-context' }); // creates a page in another browser context\r\n```"},{"labels":["feature"],"text":"There should be a capability to ignore certificate errors during navigation. See https://github.com/GoogleChrome/puppeteer/issues/66 for proposal and https://github.com/cyrus-and/chrome-remote-interface/issues/183 for original discussion.\r\n\r\nFor example, we can add `ignoreSSL` navigation option:\r\n\r\n```js\r\npage.navigate('https://example.com', { ignoreSSL: true })\r\n```"},{"labels":["feature"],"text":"This library is sweet!\r\n\r\nIt would be awesome to add a convenience method to dump the innerHTML of the `body` element."},{"labels":[null,"feature"],"text":"(taken from https://github.com/gr2m/headless-chrome-test/issues/1)\r\n\r\nPuppeteer should have an offline mode to test PWA's. For example:\r\n\r\n```js\r\npage.setOfflineMode(true);\r\n```\r\n\r\nEmulation of other network conditions might be useful as well, but we can wait with them until there are good scenarios."},{"labels":[null,"feature"],"text":"There should be an API to access cookies."},{"labels":["feature"],"text":"The screenshots should follow the following logic:\r\n- The screenshot size should depend on emulated `devicePixelRatio`\r\n- By default, puppeteer should emulate `devicePixelRatio = 1` so that screenshots are consistent across platforms\r\n"},{"labels":["feature"],"text":"e.g.\r\n\r\n```js\r\n// Fill an element \r\nawait browser.fill('#username', 'myUser')\r\n\r\n// set an element's `value` value\r\nawait browser.setValue('#comment', 'my feelings')\r\n\r\n// Type in an element \r\nawait browser.type('#password', 'Yey!ImAPassword!')\r\n```"},{"labels":["feature"],"text":"```js\r\n.mouseMoved(x, y, options = {})\r\n.mousePressed(x, y, options = {})\r\n.mouseReleased(x, y, options = {})\r\n.tap(x, y, options = {})\r\n.touchmove()\r\n.touchend()\r\n```\r\n\r\n"},{"labels":["feature"],"text":"While using puppeteer there are still occasions where I want to use the raw protocol.\r\nI'd certainly want to do this against the Page, and potentially the browser as well.\r\n\r\nI want to send methods and get responses. Additionally, I want to listen for specific events.\r\n\r\nNot sure of the right API and if it needs to be transactional as to not mixup state. "},{"labels":["feature"],"text":"Example:\r\n```js\r\nvar Browser = require('puppeteer').Browser;\r\nvar browser = new Browser();\r\nbrowser.newPage().then(async page => {\r\n    page.on('dialog', dialog => {\r\n        dialog.accept('test');\r\n    });\r\n    console.log(await page.evaluate(() => prompt('q?')));\r\n    browser.close();\r\n});\r\n```\r\n\r\nDialog accepting/dismissing throws on error on headless: \r\n>Error: Protocol error (Page.handleJavaScriptDialog): Could not handle JavaScript dialog\r\n\r\nUpstream bug: [crbug.com/718235](http://crbug.com/718235)\r\n\r\n"}]