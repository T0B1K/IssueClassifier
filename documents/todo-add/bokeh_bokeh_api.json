[{"labels":[null,"api",null,null],"text":"Currently the DataTable NumberFormatter always renders NaNs and Nones as 'NaN' because that's what Numbro.js does. This is rarely desirable formatting so it would be nice to provide an option to override this."},{"labels":[null,"api",null],"text":"We currently have both `Oval` and `Ellipse`, which are nearly identical. There have been approximately ~zero support questions or issues about either of these (that I have observed) in the last 8 years, so my opinion is that there is little reason to maintain both. \r\n\r\nI would propose to deprecate `Oval` (which has the more complicated implementation) now, and remove it in Bokeh 3.0. \r\n\r\nThoughts @bokeh/dev?"},{"labels":[null,"api",null],"text":"#### ALL software version info (bokeh, python, notebook, OS, browser, any other relevant packages)\r\nBokeh 2.1.0\r\n\r\n#### Description of expected behavior and the observed behavior\r\n`Select.options` says that it accepts \r\n```python\r\nEither(List(Either(String, Tuple(Either(Int, String), String))),\r\n       Dict(String, List(Either(String, Tuple(Either(Int, String), String))))\r\n```\r\n\r\nIn reality, it doesn't accept `Int`s there as\r\n1. `Select.value` can only be a string\r\n2. `Select` in BokehJS doesn't use integers at all\r\n\r\nAn easy solution is to just drop `Int` from that field descriptor.\r\nA (maybe) better solution is to allow integers in `Select.value` and `Select` in BokehJS. But it would require remembering the right type and converting the currently selected value in HTML to it so the correct type is stored in the model and used in every callback."},{"labels":["api",null],"text":"A `ColumnDataSource` has selection indices and ongoing work that @mattpap is doing will also allow masking a data source by the current viewport. It would be nice if these masks could be automatically reflected in a derived data source which can be used to generate another plot, which would then automatically reflect the current selection and/or viewport. In combination with a mechanism for expressing column transforms this could be a very powerful way of expressing linked selections entirely on the frontend without having to write custom Javascript."},{"labels":["api",null],"text":"The [Panel library](https://panel.holoviz.org/) builds on Bokeh and ships with a number of custom bokeh models. Some are very clearly out-of-scope for Bokeh itself but others are potentially interesting to port to Bokeh. In particular we have already discussed porting the [Progress bar model](https://panel.holoviz.org/reference/widgets/Progress.html). But we should discuss more generally if there are other models we want to port, so the easiest thing to do would be to look at the [reference gallery](https://panel.holoviz.org/reference/index.html) and/or the [models module](https://github.com/holoviz/panel/tree/master/panel/models) in Panel and decide if there's anything of interest."},{"labels":[null,"api",null],"text":"It is frequently useful to add a string column to a glyph that is being edited using a `EditTool` but for some reason I did not allow string types in my initial implementation. I suggest simply adding String to the empty_value definition."},{"labels":["api",null],"text":"It would be great if we have a measuring tool that reports the distance between the previous and current position of the mouse. This shall simplify the task of people looking to measure the change in coordinate values between different points on the plot.\r\n\r\n**Solution:**\r\nAdding a new tool that activates on a tap of the mouse, setting up an initial anchor, and then displays the distance between the current position of the pointer and the initial anchor ( delta_x, delta_y) as the user pans around anywhere on the canvas. The details shall be displayed and continuously updated in a tooltip that follows the pointer.\r\n\r\n**Alternative Approach:**\r\nRather than the pan, the tool can also be made to work with two taps defining an initial and final anchor and then displaying the distance coordinates.\r\n\r\n\r\nI think the first approach might be more helpful for mobile or touch users. But it would be great if we have multiple opinions.\r\n"},{"labels":[null,"api",null],"text":"Started at https://discourse.bokeh.org/t/possible-to-hide-tooltips-for-muted-lines/5075\r\n\r\n**Describe the solution you'd like**\r\nCurrently, `HoverTool` shows tooltips for all visible glyphs, even if they're muted. It would be good to be able to optionally exclude muted glyphs.\r\n"},{"labels":["api",null],"text":"Bokeh plots sometimes get handed no data. This is relevant in a dashboard type scenario where the queries are fixed and the results change each time you run the query. Or really any type of scenario where you are repeatedly generating plots from a changing data source.\r\n\r\nCurrently you would have to check if the data is empty and either produce a custom 'data empty' plot or insert some other placeholder.\r\n\r\nIt would be very nice if bokeh could degrade gracefully in this situation and perhaps have some sort of sensible \"No Data\" plot. It may also be useful to people in debugging situations who don't realize they are feeding bokeh empty data and just see a no axes blank result with little indicator of what went wrong."},{"labels":["api",null,null],"text":"Hi,\r\n\r\nI've encountered an error with a custom class after upgrading to Bokeh v1.4.0. I’ve created a minimum example which replicates the problem. The code is below, which needs to be in packages organised as follows:\r\n\r\n![cctest](https://user-images.githubusercontent.com/25136779/68809635-4279db80-0664-11ea-8518-74fc7ef07bf5.png)\r\n\r\nCustom.py:\r\n\r\n```\r\nfrom bokeh.plotting import Figure\r\nfrom bokeh.layouts import Column\r\n\r\n\r\nclass Custom(Column):\r\n\r\n    __view_model__ = 'Column'\r\n    __subtype__ = 'Custom'\r\n\r\n    def __init__(self):\r\n\r\n        super().__init__()\r\n\r\n        plot = Figure(plot_height=500, plot_width=500)\r\n        plot.circle([1, 2, 3], [3, 2, 1], size=20)\r\n\r\n        self.children.append(plot)\r\n```\r\n\r\nexample.py:\r\n\r\n```\r\nfrom bokeh.plotting import show\r\nfrom cctest.Custom import Custom\r\n\r\ncustom = Custom()\r\nshow(custom)\r\n```\r\n\r\n(The init.py under both cctest and Examples is empty.)\r\n\r\nThe example runs under Bokeh v1.3.4 but fails under v1.4.0 with the following error:\r\n\r\n**Error: Model ‘cctest.Custom.Column’ does not exist. This could be due to a widget or a custom model not being registered before first usage.**\r\n\r\nNote that if all the code is in a single module it works fine (see the Discourse topic [here](https://discourse.bokeh.org/t/upgrade-to-bokeh-v1-4-needs-custom-model-registration/4222)) - the issue seems to be the module hierarchy."},{"labels":[null,"api",null],"text":"Currently we can define a theme to set specific attributes of specific models like below from the examples in https://docs.bokeh.org/en/latest/docs/reference/themes.html\r\n\r\n```\r\nattrs:\r\n    Figure:\r\n        background_fill_color: '#2F2F2F'\r\n        border_fill_color: '#2F2F2F'\r\n        outline_line_color: '#444444'\r\n    Grid:\r\n        grid_line_dash: [6, 4]\r\n        grid_line_alpha: .3\r\n    Title:\r\n        text_color: \"white\"\r\n```\r\n\r\nWould it be possible to add something a bit more powerfull like matplotlib's rcParams to set attributes like text properties for all the text in the document. For example with matplotlib we can do `rcParams.update({'font.size':15})` and the font size of all text, from titles, to axis labels, to legend labels, is updated.\r\n\r\nAlternatively I loop over all the models I know in the document that have text, look at their .properties_with_values() dictionary, and build the theme dictionary by looking for all the attributes that include e.g. \"text_font_size\".\r\n"},{"labels":[null,"api",null,null],"text":"Hello,\r\n\r\nI was looking for documentation on Tabs and I went to the page :\r\n\r\nhttps://docs.bokeh.org/en/latest/docs/reference/models/widgets.panels.html\r\nHowever it display a blank page :\r\n![image](https://user-images.githubusercontent.com/18531147/67140166-fcde1480-f257-11e9-9c5a-a0bd3bbe2ad7.png)\r\n\r\nThe last time the page was ot empty was on:\r\n\r\nhttps://docs.bokeh.org/en/1.0.4/docs/reference/models/widgets.panels.html\r\n\r\n"},{"labels":[null,"api",null,null],"text":""},{"labels":[null,"api",null],"text":"**Is your feature request related to a problem? Please describe.**\r\nI would like to be able to offset a plot title away from the plot area by an arbitrary amount. Currently the plot border area is dynamically minimized to fit the Title and the Title height appears to be the text height plus a hardcoded offset (https://github.com/bokeh/bokeh/blob/master/bokehjs/src/lib/models/annotations/title.ts#L109)\r\n\r\n**Describe the solution you'd like**\r\nI would like to implement a Title.text_line_height (similar to Text.text_line_height), so that the title annotation could have an arbitrary height. We may have to reconsider the Title.vertical_align property (which sets the title inside of the height + hardcoded offset box). This may be better replaced with a Title.text_baseline prop.\r\n\r\n**Describe alternatives you've considered**\r\nNone\r\n\r\n**Additional context**\r\nNone\r\n"},{"labels":[null,"api",null],"text":"This isn't implemented and is set only `examples/reference/models`:\r\n\r\n```\r\n$ git grep '[hv]_symmetry'\r\nbokeh/models/plots.py:    h_symmetry = Bool(True, help=\"\"\"\r\nbokeh/models/plots.py:    v_symmetry = Bool(False, help=\"\"\"\r\nbokehjs/src/lib/models/plots/plot.ts:    h_symmetry: p.Property<boolean>\r\nbokehjs/src/lib/models/plots/plot.ts:    v_symmetry: p.Property<boolean>\r\nbokehjs/src/lib/models/plots/plot.ts:      h_symmetry:        [ p.Boolean,  true                    ],\r\nbokehjs/src/lib/models/plots/plot.ts:      v_symmetry:        [ p.Boolean,  false                   ],\r\nexamples/reference/models/AnnularWedge.py:    h_symmetry=False, v_symmetry=False, min_border=0, toolbar_location=None)\r\nexamples/reference/models/Annulus.py:    h_symmetry=False, v_symmetry=False, min_border=0, toolbar_location=None)\r\nexamples/reference/models/Arc.py:    h_symmetry=False, v_symmetry=False, min_border=0, toolbar_location=None)\r\nexamples/reference/models/Asterisk.py:    h_symmetry=False, v_symmetry=False, min_border=0, toolbar_location=None)\r\nexamples/reference/models/Bezier.py:    h_symmetry=False, v_symmetry=False, min_border=0, toolbar_location=None)\r\nexamples/reference/models/Circle.py:    h_symmetry=False, v_symmetry=False, min_border=0, toolbar_location=None)\r\nexamples/reference/models/CircleCross.py:    h_symmetry=False, v_symmetry=False, min_border=0, toolbar_location=None)\r\nexamples/reference/models/CircleX.py:    h_symmetry=False, v_symmetry=False, min_border=0, toolbar_location=None)\r\nexamples/reference/models/Cross.py:    h_symmetry=False, v_symmetry=False, min_border=0, toolbar_location=None)\r\nexamples/reference/models/Dash.py:    h_symmetry=False, v_symmetry=False, min_border=0, toolbar_location=None)\r\nexamples/reference/models/Diamond.py:    h_symmetry=False, v_symmetry=False, min_border=0, toolbar_location=None)\r\nexamples/reference/models/DiamondCross.py:    h_symmetry=False, v_symmetry=False, min_border=0, toolbar_location=None)\r\nexamples/reference/models/Ellipse.py:    h_symmetry=False, v_symmetry=False, min_border=0, toolbar_location=None)\r\nexamples/reference/models/HBar.py:    h_symmetry=False, v_symmetry=False, min_border=0, toolbar_location=None)\r\nexamples/reference/models/Hex.py:    h_symmetry=False, v_symmetry=False, min_border=0, toolbar_location=None)\r\nexamples/reference/models/HexTile.py:    h_symmetry=False, v_symmetry=False, min_border=0, toolbar_location=None)\r\nexamples/reference/models/ImageURL.py:    h_symmetry=False, v_symmetry=False, min_border=0, toolbar_location=None)\r\nexamples/reference/models/InvertedTriangle.py:    h_symmetry=False, v_symmetry=False, min_border=0, toolbar_location=None)\r\nexamples/reference/models/Line.py:    h_symmetry=False, v_symmetry=False, min_border=0, toolbar_location=None)\r\nexamples/reference/models/MultiLine.py:    h_symmetry=False, v_symmetry=False, min_border=0, toolbar_location=None)\r\nexamples/reference/models/MultiPolygons.py:    h_symmetry=False, v_symmetry=False, min_border=0, toolbar_location=None)\r\nexamples/reference/models/Oval.py:    h_symmetry=False, v_symmetry=False, min_border=0, toolbar_location=None)\r\nexamples/reference/models/Patch.py:    h_symmetry=False, v_symmetry=False, min_border=0, toolbar_location=None)\r\nexamples/reference/models/Patches.py:    h_symmetry=False, v_symmetry=False, min_border=0, toolbar_location=None)\r\nexamples/reference/models/Quad.py:    h_symmetry=False, v_symmetry=False, min_border=0, toolbar_location=None)\r\nexamples/reference/models/Quadratic.py:    h_symmetry=False, v_symmetry=False, min_border=0, toolbar_location=None)\r\nexamples/reference/models/Ray.py:    h_symmetry=False, v_symmetry=False, min_border=0, toolbar_location=None)\r\nexamples/reference/models/Rect.py:    h_symmetry=False, v_symmetry=False, min_border=0, toolbar_location=None)\r\nexamples/reference/models/Scatter.py:    h_symmetry=False, v_symmetry=False, min_border=0, toolbar_location=None)\r\nexamples/reference/models/Segment.py:    h_symmetry=False, v_symmetry=False, min_border=0, toolbar_location=None)\r\nexamples/reference/models/Square.py:    h_symmetry=False, v_symmetry=False, min_border=0, toolbar_location=None)\r\nexamples/reference/models/SquareCross.py:    h_symmetry=False, v_symmetry=False, min_border=0, toolbar_location=None)\r\nexamples/reference/models/SquareX.py:    h_symmetry=False, v_symmetry=False, min_border=0, toolbar_location=None)\r\nexamples/reference/models/Step.py:    h_symmetry=False, v_symmetry=False, min_border=0, toolbar_location=None)\r\nexamples/reference/models/Text.py:    h_symmetry=False, v_symmetry=False, min_border=0, toolbar_location=None)\r\nexamples/reference/models/Triangle.py:    h_symmetry=False, v_symmetry=False, min_border=0, toolbar_location=None)\r\nexamples/reference/models/VBar.py:    h_symmetry=False, v_symmetry=False, min_border=0, toolbar_location=None)\r\nexamples/reference/models/Wedge.py:    h_symmetry=False, v_symmetry=False, min_border=0, toolbar_location=None)\r\nexamples/reference/models/X.py:    h_symmetry=False, v_symmetry=False, min_border=0, toolbar_location=None)\r\n```"},{"labels":[null,"api",null],"text":"* Python 3.7.1 (default, Dec 10 2018, 22:54:23) [MSC v.1915 64 bit (AMD64)] :: Anaconda, Inc. on win32\r\n* Google Chrome Version 72.0.3626.109 (Official Build) (64-bit)\r\n* Bokeh 1.0.2\r\n\r\nCurrently, [bokeh.models.OpenURL](https://bokeh.pydata.org/en/latest/docs/user_guide/interaction/callbacks.html#openurl) always opens page in a new browser window/tab. It is proposed that `bokeh.models.OpenURL()` gains additional option to open in current tab, with implementation using [window.open(url,\"_self\")](https://stackoverflow.com/questions/40316017/openurl-in-bokeh-open-in-same-tab) or (better) [window.location.href](https://stackoverflow.com/questions/4813879/window-open-target-self-v-window-location-href).\r\n"},{"labels":[null,"api",null],"text":"Currently bokeh uses Ajax polling or web sockets to receive data from a backend server. It would be nice to use server-sent events in some situations, since they can simplify the backend-code and are a good option for one way data streaming."},{"labels":[null,"api",null,null,null],"text":"Using current master it is possible to specify fixed tick locations using the FixedTicker, however I would have expected that these fixed tick locations also determine the locations of the gridlines. Instead the tick locations and the grid lines are completely independent in this configuration. I do not think this behavior is desirable so it would be nice that at least by default the grid lines respect the fixed tick locations.\r\n\r\nTo illustrate the issue, in the plot below I would have expected the x-axis gridlines to align with the four ticks at 0.25, 0.75, 1.25 and 1.75:\r\n\r\n![bokeh_plot](https://user-images.githubusercontent.com/1550771/51051602-32204c80-15cc-11e9-989f-7085c8e36294.png)\r\n\r\nThis problem was noted in the original issue that led to the introduction of the FixedTicker: https://github.com/bokeh/bokeh/issues/2548\r\n"},{"labels":["api",null],"text":"Versions:\r\n\r\n|Name                   |Version                   |Build               |Channel\r\n|-----------------|-------------------|-------------|---------\r\nbokeh                     |  1.0.0                         |py36_1000   | conda-forge\r\npython                    |  3.6.5                       |  1                  |  conda-forge\r\nnotebook                |  5.5.0                     |    py36_0       |   conda-forge\r\n\r\nOS:              macOS Mojave 10.14\r\nBrowser:     Chrome -- Version 70.0.3538.110 (Official Build) (64-bit)\r\n\r\nI would like to specify the location for a BoxAnnotation on a categorical axis\r\nwith help of the category name. \r\nBokeh returns ValueError\r\n\r\n\r\n```\r\nfrom bokeh.io import output_notebook, show\r\nfrom bokeh.models import BoxAnnotation\r\nfrom bokeh.plotting import figure\r\n\r\noutput_notebook()\r\n\r\ncats = ['cat_A','cat_B']\r\n\r\ncat_plot = figure(y_range=cats, x_range=[1,2],  title='Cat')\r\ncat_plot.add_layout(BoxAnnotation(top=['cat_B']))\r\n\r\nshow(cat_plot)\r\n\r\n```\r\n\r\n\r\n```\r\nValueError                                Traceback (most recent call last)\r\n<ipython-input-4-a04e8c1ea9fe> in <module>()\r\n      8 \r\n      9 cat = figure(y_range=cats, x_range=[1,2], plot_width=200, plot_height=200, toolbar_location=None, title='Cat')\r\n---> 10 cat.add_layout(BoxAnnotation(top=['cat_B']))\r\n     11 show(cat)\r\n\r\n~/miniconda3/lib/python3.6/site-packages/bokeh/model.py in __init__(self, **kwargs)\r\n    259         self._document = None\r\n    260         self._temp_document = None\r\n--> 261         super(Model, self).__init__(**kwargs)\r\n    262         default_theme.apply_to_model(self)\r\n    263 \r\n\r\n~/miniconda3/lib/python3.6/site-packages/bokeh/core/has_props.py in __init__(self, **properties)\r\n    252 \r\n    253         for name, value in properties.items():\r\n--> 254             setattr(self, name, value)\r\n    255 \r\n    256     def __setattr__(self, name, value):\r\n\r\n~/miniconda3/lib/python3.6/site-packages/bokeh/core/has_props.py in __setattr__(self, name, value)\r\n    279 \r\n    280         if name in props or (descriptor is not None and descriptor.fset is not None):\r\n--> 281             super(HasProps, self).__setattr__(name, value)\r\n    282         else:\r\n    283             matches, text = difflib.get_close_matches(name.lower(), props), \"similar\"\r\n\r\n~/miniconda3/lib/python3.6/site-packages/bokeh/core/property/descriptors.py in __set__(self, obj, value, setter)\r\n    544             raise RuntimeError(\"%s.%s is a readonly property\" % (obj.__class__.__name__, self.name))\r\n    545 \r\n--> 546         self._internal_set(obj, value, setter=setter)\r\n    547 \r\n    548     def __delete__(self, obj):\r\n\r\n~/miniconda3/lib/python3.6/site-packages/bokeh/core/property/descriptors.py in _internal_set(self, obj, value, hint, setter)\r\n    765 \r\n    766         '''\r\n--> 767         value = self.property.prepare_value(obj, self.name, value)\r\n    768 \r\n    769         old = self.__get__(obj, obj.__class__)\r\n\r\n~/miniconda3/lib/python3.6/site-packages/bokeh/core/property/bases.py in prepare_value(self, obj_or_cls, name, value)\r\n    326                     break\r\n    327             else:\r\n--> 328                 raise e\r\n    329         else:\r\n    330             value = self.transform(value)\r\n\r\n~/miniconda3/lib/python3.6/site-packages/bokeh/core/property/bases.py in prepare_value(self, obj_or_cls, name, value)\r\n    319         try:\r\n    320             if validation_on():\r\n--> 321                 self.validate(value)\r\n    322         except ValueError as e:\r\n    323             for tp, converter in self.alternatives:\r\n\r\n~/miniconda3/lib/python3.6/site-packages/bokeh/core/property/either.py in validate(self, value, detail)\r\n    115         if not (value is None or any(param.is_valid(value) for param in self.type_params)):\r\n    116             msg = \"\" if not detail else \"expected an element of either %s, got %r\" % (nice_join(self.type_params), value)\r\n--> 117             raise ValueError(msg)\r\n    118 \r\n    119     # TODO (bev) implement this\r\n\r\nValueError: expected an element of either Auto or NumberSpec(String, Dict(Enum('expr', 'field', 'value', 'transform'), Either(String, Instance(Transform), Instance(Expression), Float)), Float), got ['cat_B']\r\n\r\n```\r\n"},{"labels":[null,"api",null],"text":"The content of `bokeh/models/__init__.py` indicates the intention that all model classes should also be importable from `bokeh.models`. However, importing `Image` directly from `bokeh.models` brings into scope a class outside of `bokeh.models` package probably due to name collision with other indirect imports.\r\n```\r\n>>> from bokeh.models.glyphs import Image as I1\r\n>>> from bokeh.models import Image as I2\r\n>>> I1\r\n<class 'bokeh.models.glyphs.Image'>\r\n>>> I2\r\n<class 'bokeh.core.property.visual.Image'>\r\n```\r\nI would expect either consistency of imports, or `bokeh.models` should not provide this interface at all, so that only the first line is a valid option.\r\n\r\nbokeh/1.0.1 has this issue\r\nbokeh/0.13.0 doesn't have this issue and correctly imports identical classes"},{"labels":["api",null],"text":"Errors like `DeserializationError('Int expected Integral, got 0')` (mind the zero, which is an effect of badly formatted `str`), especially in a server setup, doesn't give a clue where an issue originates from. At minimum the error message should contain object's name and id, and property's name. However, in large object graphs, a much better solution would be to provide a full path from root the the point of failure, e.g. for `Row(children=[Column(children=[Plot()], rows=\"bad value\")])` this would be:\r\n```py\r\nDeserializationError(\"Row(id=...).children[0].rows of type Int expected Integral, got 'bad value' of type str\")\r\n```\r\nor something along this."},{"labels":[null,"api",null],"text":"I'm curious why `Plot.{x,y}_range` doesn't have a default value? Lack thereof results in examples and especially tests having to specify trivial ranges (like `DataRange1d()` or `Range1d(0, 1)`) everywhere. It would greatly simplify things if ranges defaulted to `DataRange1d`.  This is what `{x,y}_scale` do, just they default to `LinearScale`."},{"labels":[null,"api",null,null],"text":"Please refer to [this thread](https://groups.google.com/a/continuum.io/forum/#!topic/bokeh/AgWWxSUJuzQ) on Google Groups.\r\n\r\nIt would be nice to have this feature for tree data structure.\r\n\r\nThanks.\r\n"},{"labels":[null,"api",null],"text":"Would it be possible to reduce the default font size on the [attributions for tile sources](https://github.com/bokeh/bokeh/blob/a0572fa40c3a59b72ba56a8c300e0ad06a044a23/bokeh/models/tiles.py)?\r\n\r\n![image](https://user-images.githubusercontent.com/1695496/40062037-e05bceca-581f-11e8-87b6-75dac06cfc3f.png)\r\n\r\nSeems like it just needs to be barely readable, while the current size is overwhelming for smaller plots.  Maybe 30% of the tick label size would work?"},{"labels":["api",null],"text":""},{"labels":[null,null,"api",null,null],"text":"Currently only the categorical ticks immediately next the axis can be rotated. Add options to rotate higher level categories as well. \r\n\r\nThis has come up several times now on SO and the ML list, I can't find that anyone has made an issue yet, though I have asked. "},{"labels":[null,"api",null],"text":"When using some of the more specific tools, e.g. the drawing tools, you might want to add multiple copies of the same tool and assign different semantics to each tool instance. As a simple example I wrote a demo that allows drawing two types of polygons to annotate the foreground and background of an image. In this case it is difficult to distinguish the two tool instances. It would therefore be nice if it were possible to assign the tools custom tooltips to distinguish between them.\r\n\r\nCurrently the tooltip simply reflects the ``tool_name`` on the model but it would be great if that could be overridden by another property. I think this only makes sense for certain types of tools, most likely the draw tools and maybe also the select tools."},{"labels":[null,null,"api",null],"text":"Hello,\r\n\r\nIn the example below based on the twin axes example, if a user mis-spells the y_range_name there is no check on the python side for a y_range that matches that name existing at glyph creation or document creation (`show(p)`). Rather an error is reported in JS of `Cannot read property 'v_synthetic' of undefined`.\r\n\r\n\r\nOn Bokeh 0.12.10, Python 2.7, Win64, Chrome (Version 62.0.3202.94 (Official Build) (64-bit)).\r\n\r\n```\r\nfrom numpy import pi, arange, sin, linspace\r\n\r\nfrom bokeh.plotting import output_file, figure, show\r\nfrom bokeh.models import LinearAxis, Range1d\r\n\r\nx = arange(-2*pi, 2*pi, 0.1)\r\ny = sin(x)\r\ny2 = linspace(0, 100, len(y))\r\n\r\noutput_file(\"twin_axis.html\")\r\n\r\np = figure(x_range=(-6.5, 6.5), y_range=(-1.1, 1.1))\r\n\r\np.circle(x, y, color=\"red\")\r\n\r\np.extra_y_ranges = {\"foo\": Range1d(start=0, end=100)}\r\np.circle(x, y2, color=\"blue\", y_range_name=\"oof\")\r\np.add_layout(LinearAxis(y_range_name=\"foo\"), 'left')\r\n\r\nshow(p)\r\n```\r\n\r\n![image](https://user-images.githubusercontent.com/22305345/34007950-b2f1d86e-e0d1-11e7-97e4-25d039212421.png)\r\n\r\n```\r\nUncaught TypeError: Cannot read property 'v_synthetic' of undefined\r\n    at e.r.GlyphView.r.set_data (bokeh-0.12.10.min.js:27)\r\n    at e.r.GlyphRendererView.e.set_data (bokeh-0.12.10.min.js:31)\r\n    at e.r.GlyphRendererView.e.initialize (bokeh-0.12.10.min.js:31)\r\n    at e.t (bokeh-0.12.10.min.js:22)\r\n    at e [as constructor] (bokeh-0.12.10.min.js:1)\r\n    at e [as constructor] (bokeh-0.12.10.min.js:31)\r\n    at new e (bokeh-0.12.10.min.js:31)\r\n    at Object.r.build_views (bokeh-0.12.10.min.js:1)\r\n    at e.r.PlotCanvasView.e.build_levels (bokeh-0.12.10.min.js:30)\r\n    at e.r.PlotCanvasView.e.initialize (bokeh-0.12.10.min.js:30)\r\n```"},{"labels":[null,"api",null],"text":"Bokeh 0.12.13\r\n\r\nRight now, the only possible values for the `attachment` attribute of `HoverTool` are `horizontal` and `vertical`. I think it would be great to allow other values that `Tooltip` supports - `left`, `right`, `above`, `below`."},{"labels":[null,"api",null],"text":"When I take the Explicit Plot example in the graph section of the User Guide, https://bokeh.pydata.org/en/latest/docs/user_guide/graph.html, and display in a notebook I get the following message on the `show(plot)`:\r\n`\r\nE-1001 (BAD_COLUMN_NAME): Glyph refers to nonexistent column name: fill_color [renderer: GlyphRenderer(id='2ee90517-57dc-45e6-8169-288256a4d6cf', …)]\r\n`\r\n\r\nThe plot still displays as expected.\r\n\r\n#### ALL software version info (bokeh, python, notebook, OS, browser, any other relevant packages)\r\nBokeh: 0.12.9\r\nPython: 3.6\r\n\r\n#### Description of expected behavior and the observed behavior\r\nPlot displays as it does now, but the error message does not display.\r\n\r\n#### Complete, minimal, self-contained example code that reproduces the issue\r\n\r\n```\r\nimport math\r\n\r\nfrom bokeh.io import show, output_notebook\r\nfrom bokeh.plotting import figure\r\nfrom bokeh.models import GraphRenderer, StaticLayoutProvider, Oval\r\nfrom bokeh.palettes import Spectral8\r\n\r\noutput_notebook()\r\n\r\nN = 8\r\nnode_indices = list(range(N))\r\n\r\nplot = figure(title=\"Graph Layout Demonstration\", x_range=(-1.1,1.1), y_range=(-1.1,1.1),\r\n              tools=\"\", toolbar_location=None)\r\n\r\ngraph = GraphRenderer()\r\n\r\ngraph.node_renderer.data_source.data = dict(\r\n    index=node_indices,\r\n    fill_color=Spectral8)\r\ngraph.node_renderer.glyph = Oval(height=0.1, width=0.2, fill_color=\"fill_color\")\r\n\r\ngraph.edge_renderer.data_source.data = dict(\r\n    start=[0]*N,\r\n    end=node_indices)\r\n\r\n### start of layout code\r\ncirc = [i*2*math.pi/8 for i in node_indices]\r\nx = [math.cos(i) for i in circ]\r\ny = [math.sin(i) for i in circ]\r\ngraph_layout = dict(zip(node_indices, zip(x, y)))\r\ngraph.layout_provider = StaticLayoutProvider(graph_layout=graph_layout)\r\n\r\n### Draw quadratic bezier paths\r\ndef bezier(start, end, control, steps):\r\n    return [(1-s)**2*start + 2*(1-s)*s*control + s**2*end for s in steps]\r\n\r\nxs, ys = [], []\r\nsx, sy = graph_layout[0]\r\nsteps = [i/100. for i in range(100)]\r\nfor node_index in node_indices:\r\n    ex, ey = graph_layout[node_index]\r\n    xs.append(bezier(sx, ex, 0, steps))\r\n    ys.append(bezier(sy, ey, 0, steps))\r\ngraph.edge_renderer.data_source.data['xs'] = xs\r\ngraph.edge_renderer.data_source.data['ys'] = ys\r\n\r\nplot.renderers.append(graph)\r\n\r\nshow(plot)\r\n```\r\n\r\n#### Stack traceback and/or browser JavaScript console output\r\nNone\r\n\r\n#### Screenshots or screencasts of the bug in action\r\n![06_explicit_path_edges_bokeh 2017-10-04 12-11-22](https://user-images.githubusercontent.com/7515105/31189253-46c863a8-a8fd-11e7-842f-f205c4ab2cb3.png)\r\n"},{"labels":[null,"api",null,null],"text":"Add TS api for models in bokeh.models.graphs, GraphRenderer and figure.graph method\r\n\r\nBokeh 0.12.8dev3"},{"labels":[null,"api",null,null],"text":"Integer sliders should use integer formatting.\r\n"},{"labels":["api",null],"text":"This made sense when `GlyphRenderer` was the only type of renderer. However, now we have annotations, tiles, etc., and those don't work with `HoeverTool` and others (fail due to missing `data_source` property). We should either make tools work with all types of renderers or use a different base class in properties (`GlyphRenderer`).\r\n\r\nMy initial idea was to have a tooltip for a `Label` and I tried to use `HoverTool`, because there is no intrinsic support for tooltips in annotations."},{"labels":[null,"api",null,null],"text":"Would it be possible to add a \"visible\" property to bokeh models ? \r\nWhen set to False It would just add 'display: none' to the style of the div containing the model; or even replace the style of the div with just 'display: none' which would also remove the space between that element and others divs.\r\nWhen set to True the div containing the model would go back to its default style.\r\nThis would allow to quickly show/hide plots, widgets, or Row / Column layouts"},{"labels":[null,"api",null],"text":""},{"labels":["api",null],"text":"This will make the API cleaner and allow us to gain control over mutability and related issues with signaling change events. This should be a 1.0 requirement."},{"labels":[null,"api",null],"text":"Currently the ColumnDataSource constructor is quite inefficient because it iterates over all the columns and calls ``ColumnDataSource.add`` for each of them, which ends up triggering validation for all the columns each time due to the way the data, which is a ``PropertyValueDict``, behaves. In other words validation is triggered on the triangle number of the number of columns.\r\n\r\nAs far as I can tell there is no reason to use ``ColumnDataSource.add`` in the constructor because it really doesn't do anything except giving columns without names new unique names. Since the constructor only accepts dataframe and dict types there appears to be no case where you'd end up with clashing or non-existent column names in the constructor. Therefore it should be possible to simply use ``self.data.update`` to validate the data once and no more.\r\n\r\nHere is some small bit of profiling:\r\n\r\n```python\r\nfrom bokeh.models import ColumnarDataSource\r\ndata = {chr(65+c): np.random.rand(1000) for c in range(50)}\r\n\r\n%%timeit\r\ncds = ColumnDataSource(data=data)\r\n```\r\n\r\nCurrent speed:\r\n\r\n> 1 loop, best of 3: 563 ms per loop\r\n\r\nUsing ``self.data.update``:\r\n\r\n>10 loops, best of 3: 21.6 ms per loop"},{"labels":[null,"api",null],"text":"When using GMapPlot with DataRange1d, the points plotted do not appear in the correct location when the data is updated.  See example code below.  The solution is to use Range1d.  It would be helpful to give a validation error so the developer can be advised to use Range1d instead of DataRange1d.\r\n\r\nThanks,\r\nAndrew\r\n\r\n```\r\nfrom bokeh.io import output_file, show\r\nfrom bokeh.models import GMapPlot, GMapOptions, ColumnDataSource, Circle, DataRange1d, WheelZoomTool, Select\r\nfrom bokeh.plotting import curdoc\r\nfrom bokeh.layouts import layout, row, widgetbox\r\n\r\n# set up map / plot  (my google maps API key: AIzaSyAh1cmN_U6smbyt5uCpMIhttQOYrE4JtLY)\r\nmap_options = GMapOptions(lat=49.74, lng=-123.117, map_type=\"roadmap\", zoom=14)\r\nplot = GMapPlot(\r\n    x_range=DataRange1d(), y_range=DataRange1d(), map_options=map_options,\r\n    api_key='PUT YOUR GOOGLE MAPS API KEY HERE'\r\n)\r\n\r\nc=['red','green','blue']\r\n\r\n# create an initial source object (one color and size on each point)\r\nsource = ColumnDataSource( data=dict(   lat = (49.746504,49.735954,49.744864),\r\n                                        lon = (-123.117835,-123.114313,-123.114587),\r\n                                        color = c ) )\r\n\r\n# set the circle parameters from the source elements\r\ncircle = Circle(x=\"lon\", y=\"lat\", fill_color=\"color\", size=10,  fill_alpha=0.5, line_color=None)\r\n\r\n# add the source to the plot as circles\r\nplot.add_glyph(source, circle)\r\n\r\n# throw on some tools\r\nplot.add_tools( WheelZoomTool() )\r\n\r\n\r\ndef update(attrname, old, new):\r\n\r\n    if color.value == 'RBG': c=['red','green','blue']\r\n    if color.value == 'Greyscale': c=['black','grey','white']\r\n    if color.value == 'CMY': c=['cyan','magenta','yellow']\r\n\r\n    # create the source object with the data to be plotted\r\n    source.data=dict(   lat = (49.746504,49.735954,49.744864),\r\n                        lon = (-123.117835,-123.114313,-123.114587),\r\n                        color=c)\r\n\r\n    # update the plot\r\n    plot.update()\r\n\r\n\r\n# add the selectors\r\ncolor = Select(title='Color', value='None', options=['RBG','Greyscale','CMY'])\r\ncolor.on_change('value', update)\r\n\r\n# add the controls\r\ncontrols = widgetbox([color], width=200)\r\nlayout = row(controls, plot)\r\n\r\ncurdoc().add_root(layout)\r\ncurdoc().title = \"My Google Map\"\r\n```\r\n"},{"labels":[null,"api",null],"text":""},{"labels":[null,"api",null],"text":"bokeh 0.12.3\r\n\r\nLine renderer raises the JS error, while Circle renderer works as expected. There's probably a workaround to define a separate source column for each value of width (highly inefficient).\r\n\r\n```python\r\nfrom bokeh.models import ColumnDataSource\r\nfrom bokeh.plotting import figure, show\r\nfrom bokeh.io import output_notebook, push_notebook\r\n\r\noutput_notebook(hide_banner=True)\r\n\r\nsource = ColumnDataSource(dict(x=[1.2, 3.4], y=[3.2, 4.5], sz=[20.5, 40.1], lw=[1.1, 2.2]))\r\n\r\nplot = figure()\r\nplot.circle('x', 'y', source=source, size='sz') # This line works fine\r\nplot.line('x', 'y', source=source, line_alpha2='sz') # This line raises \r\n# Uncaught Error: attempted to retrieve property value for property without value specification\r\nshow(plot)\r\n```"},{"labels":[null,"api",null],"text":"I am plotting a series of datetime.timedelta values on one of the axes of my chart. I am trying to constraint the axes minimum and maximum by: \r\n\r\n    yrange1 = Range1d(start=datetime.timedelta(minutes=1,seconds=45),end=datetime.timedelta(minutes=3,seconds=30))\r\n\r\nplot.y_range = yrange1\r\n\r\nGot the following: \r\n\r\nException Type:\tValueError\r\nException Value:\t\r\nexpected an element of either Float, Datetime or Int, got datetime.timedelta(0, 210)\r\n\r\nBokeh version 0.12.3\r\nPython version 2.7.12\r\n"},{"labels":["api",null],"text":"Currently to add a Legend to a side panel you have to specify the location in coordinates e.g. `Legend(location=(0, 0))`, any of the strings won't work e.g. 'top_left', 'bottom_right'. \n\nIt wasn't implemented at the time the feature was introduced because `top_left`, `top_right` don't make sense for side panels. Side panels expand to fill the things in them. So if they're left/right side panels then top, bottom, center (vertically) would be meaningful and if they're above/below panels then left, right, center (horizontally) are meaningful.\n\nSo we need to pick an API.\n\nWe should also probably at least think about the consistency with anything that can be put in a side panel - which is anything that gets added with the `Plot.add_layout()` method\n"},{"labels":[null,"api",null],"text":"As mentioned in #5258, when creating an extension, the template cannot be a separate implementation and compiled, instead it must be updated in the JS/Coffescript implementation of the extension.\ne.g.:\n\n```\n ionslidertemplate = require \"models/widgets/slidertemplate\"\n\n # This model will actually need to render things, so we must provide\n # view. The LayoutDOM model has a view already, so we will start with that\n class IonRangeSliderView extends InputWidget.View\n   tagName: \"div\"\n   template: ionslidertemplate\n```\n\nAnd in the `initialize` function:\n\n```\n html = @template(@model.attributes)\n # replace div slider to input slider\n html = html.replace('<div class=\"slider \"','<input type=\"text\" class=\"slider \"')\n html = html.replace('<div class=\"bk-slider-horizontal\">','<div class=\"bk-slider-horizontal bk-ion-slider\">')\n```\n\nv0.12.2\n\nIt would be really helpful if these could be implemented in a `.eco` file to use as the template directly.\n"},{"labels":[null,"api",null],"text":"A plot may not be shown if formats aren't provided for all time scales.\n\nThis is reproduced by the following code:\n\n``` python\nfrom datetime import datetime as dt\nfrom bokeh.models.formatters import DatetimeTickFormatter\nfrom bokeh.plotting import Figure, output_file, show\n\noutput_file('bokeh.html')\n\np = Figure(title='Demo', x_axis_type='datetime')\n\nx = [dt(2016, 1, 1, 0, 0, 0), dt(2016, 1, 1, 0, 0, 10)]\nprint(x[1].day, x[1].hour, x[1].minute, x[1].second)\ny = [1, 2]\n\np.scatter(x=x, y=y)\n\np.xaxis.formatter = DatetimeTickFormatter(formats=dict(\n    seconds=[\"%H:%M:%S\"],\n    # a plot is displayed if the following lines are *not* commented out\n    # minsec=[\"%H:%M:%S\"],\n    # minutes=[\"%H:%M:%S\"],\n    # hourmin=[\"%H:%M:%S\"],\n)\n)\n\nshow(p)\n```\n\nThis has been tested with:\n\nPython version      :  3.5.2 (default, Sep 25 2016, 19:32:42) \nIPython version     :  Not installed\nBokeh version       :  0.12.2\n"},{"labels":[null,"api",null],"text":"There are certain properties in bokehjs like inner plot area that are computed on client-side and it doesn't make sense to allow to configure them in Python, yet it's valuable to get their values in Python.\n"},{"labels":[null,"api",null],"text":"`_repr_html_` was originally implemented on `Plot` to render a plot immediately without need for `show()`, at al. This didn't work well, so the code was commented out to be revised in future. Recently, `_repr_pretty_` was implemented to get insight into objects' properties. This works nicely across the board, but could work better in the notebook.\n\n`_repr_html` should be added, so that it produces a shortened version of what `_repr_pretty_` produces, with a `...` button which would expand object's properties, showing more `...` buttons for embedded objects.\n\nThis is a followup on #5153.\n"},{"labels":[null,"api",null],"text":"This is IPython dependent, but who uses native Python's REPL anyway. This is beneficial over implementing `__str__` (and `__repr__`), because those two in Python are broken by design. Additionally, we get cycle detection for free, pretty printing (e.g. line breaking) and integration with pretty printing of other data structures (e.g. `list`, `dict`).\n"},{"labels":[null,"api",null],"text":""},{"labels":[null,"api",null,null],"text":"It is currently not possible to instantiate and show widgets from javascript, e.g.\n\n``` js\nvar plt = Bokeh.Plotting;\nvar slider = Bokeh.Models('Slider');\nvar wb = new Bokeh.WidgetBox({children: [slider]});\nplt.show(wb); // bokeh-0.12.0.js:3761 Uncaught Error: models must be\n              // owned by only a single document\n```\n1. I have to use the workaround of calling `Bokeh.Models('Slider')` because Bokeh.Slider does not exist\n2. Even then, I get an error with the following trace:\n\n```\nbokeh-0.12.0.js:3761 Uncaught Error: models must be owned by only a single document\n\nHasProps.attach_document    @   bokeh-0.12.0.js:3761\nDocument._recompute_all_models  @   bokeh-0.12.0.js:6268\nDocument._pop_all_models_freeze @   bokeh-0.12.0.js:6228\nDocument.add_root   @   bokeh-0.12.0.js:6316\nshow    @   bokeh-0.12.0.js:1458\n(anonymous function)    @   slider.js:5\n```\n"},{"labels":[null,"api",null],"text":"Is 'defult' not default.\n\n``` python\n    ...\n    behavior = Enum(\"select\", \"inspect\", defult=\"select\", help=\"\"\"\n    ...\n```\n"},{"labels":[null,"api",null],"text":"Specifically: `legend_margin`, `legend_padding`, `legend_spacing`. See discusion in #4511.\n"},{"labels":[null,"api",null],"text":"With the new toolbar and title set-up, there's an increased chance that the title and toolbar might clash with each other. \n\nIf that clash does happen, a user can set `toolbar_sticky=False`.\n\nNone-the-less, I wanted to propose moving the toolbar default position to the right side of a plot.\n\nSee examples/charts/file/scatter_multi.py for an example where a default right toolbar would be more pleasing.\n"},{"labels":["api",null,null],"text":"Currently there is a custom implementation in `TileRenderer` which should be extracted into a model. Follow existing libraries (Leaflet, OpenLayers) for additional features.\n"},{"labels":[null,"api",null],"text":""},{"labels":[null,"api",null,null],"text":"```\nWARNING:bokeh.core.properties:JSON had attr '_bounds_as_factors' on obj <bokeh.models.ranges.FactorRange object at 0x108140208>, which is a client-only or invalid attribute that shouldn't have been sent\n```\n\nI receive this error, but an error for `start` and `end` when using FactorRange with bokeh server. It appears that the bokehjs factorrange utilizes these properties which are not part of the python factorrange. Start and end are introduced in Range1d and FactorRange is a child of Range, which doesn't have them available. I wasn't sure why the _bounds_as_factors was being sent, but it does only appear on the bokehjs side.\n"},{"labels":[null,"api",null,null,null],"text":"Very often want to specify _one_ of width or height, but not _both_ (e.g. almost any financial bar plotting).\n\nPropose:\n\n```\nclass VBar(Glyph):\n    \"\"\" Render vertical bars, given a center coordinate, width and (top, bottom) coordinates. \"\"\"\n\n    __example__ = \"tests/glyphs/VBar.py\"\n\n    # a canonical order for positional args that can be used for any\n    # functions derived from this class\n    _args = ('center', 'width', 'top', 'bottom')\n\n    center = NumberSpec(help=\"\"\"\n    The x-coordinates of the centers of the bars.\n    \"\"\")\n\n    width = NumberSpec(help=\"\"\"\n    The widths of the vertical bars.\n    \"\"\")\n\n    bottom = NumberSpec(help=\"\"\"\n    The y-coordinates of the bottom edges.\n    \"\"\")\n\n    top = NumberSpec(help=\"\"\"\n    The y-coordinates of the top edges.\n    \"\"\")\n\n    line_props = Include(LineProps, use_prefix=False, help=\"\"\"\n    The %s values for the rectangles.\n    \"\"\")\n\n    fill_props = Include(FillProps, use_prefix=False, help=\"\"\"\n    The %s values for the rectangles.\n    \"\"\")\n\nclass HBar(Glyph):\n    \"\"\" Render horizontal bars, given a center coordinate, height and (left, right) coordinates. \"\"\"\n\n    __example__ = \"tests/glyphs/HBar.py\"\n\n    # a canonical order for positional args that can be used for any\n    # functions derived from this class\n    _args = ('center', 'height', 'left', 'right')\n\n    center = NumberSpec(help=\"\"\"\n    The x-coordinates of the centers of the bars.\n    \"\"\")\n\n    height = NumberSpec(help=\"\"\"\n    The heights of the vertical bars.\n    \"\"\")\n\n    left = NumberSpec(help=\"\"\"\n    The x-coordinates of the left edges.\n    \"\"\")\n\n    right = NumberSpec(help=\"\"\"\n    The x-coordinates of the right edges.\n    \"\"\")\n\n    line_props = Include(LineProps, use_prefix=False, help=\"\"\"\n    The %s values for the rectangles.\n    \"\"\")\n\n    fill_props = Include(FillProps, use_prefix=False, help=\"\"\"\n    The %s values for the rectangles.\n    \"\"\")\n```\n"}]