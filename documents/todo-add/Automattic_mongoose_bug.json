[{"labels":["bug"],"text":"**Question**\r\nI have schema type Map in my mongoose model. In this map, each element has reference to another model. I know that it's possible to populate attributes in array, but how about Map type? Be cause nesting like \"map_type_attribute.some_attribute_to_populate\" doesn't work. :)\r\n\r\nThis is my model:\r\n\r\n```ts\r\nconst Mongoose = require('mongoose');\r\n\r\nconst parameter = Mongoose.Schema({\r\n  definition: {\r\n    type: Mongoose.Schema.Types.ObjectId,\r\n    ref:  'Definition',\r\n  },\r\n  value:      {},\r\n}, {_id: false});\r\n\r\nconst schema = Mongoose.Schema({\r\n  model:      {\r\n    type: Mongoose.Schema.Types.ObjectId,\r\n    ref:  'Model'\r\n  },\r\n  name:       String,\r\n  objectid:   Number,\r\n  externalId: String,\r\n  properties: Mongoose.Schema.Types.Mixed,\r\n  parameters: {\r\n    type: Map,\r\n    of:   parameter\r\n  }\r\n});\r\n\r\nmodule.exports = Mongoose.model('Element', schema);\r\n```\r\n\r\nThis is how i'm trying to populate definition field:\r\n\r\n```ts\r\n const request = Element.find(query, projection);\r\n  request.populate('parameters.definition');\r\n  request.exec( (err, docs) => {\r\n...\r\n```\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nnode: v13.13.0\r\nmongoose: 5.9.26\r\nmongodb (docker): bitnami/mongodb:4.2.8-debian-10-r47"},{"labels":["bug"],"text":"### Bug\r\nI'm not sure if provided examples are bugs, but these behaviors are unclear for me. \r\n\r\n1. Let's imagine database schemas which looks like that (`timestamps: true` is set for both schemas):\r\n```js\r\n/// NestedSchama\r\n{\r\n  nestedA: { type: String },\r\n  nestedB: { type: String },\r\n}\r\n\r\n/// MainSchema\r\n{\r\n  content: {\r\n     a: { type: NestedSchama },\r\n     b: { type: NestedSchama },\r\n     c: { type: String }\r\n  }\r\n}\r\n```\r\n### Case 1\r\n```js\r\nconst model = Main.findOne({});\r\nmodel.content.a.nestedA = \"test\";\r\nmodel.save();\r\n```\r\n#### Current behavior.\r\nThis will update `updatedAt` value for **MainSchema**, **NestedSchama a** and **NestedSchama b**. \r\n#### Expected behavior.\r\n`updatedAt` field is being updated for **MainSchema** and **NestedSchama a** (**NestedSchema b** values weren't modified at all - no need for timestamps change).\r\n#### Thoughts.\r\nI believe that this is because `content`, `content.a` and `content.a.nestedA` are marked as modified ðŸ¤”?\r\n\r\n### Case 2\r\n```js\r\nconst updatedModel = Main.findOneAndUpdate({\r\n  c: \"value\",\r\n  $set: {\r\n    'content.a.nestesA': \"value\",\r\n  }\r\n}, { new: true });\r\n```\r\n#### Current behavior.\r\n`updatedAt` field is updated **only** for **MainSchema** while **NestedSchama a** was modified too.\r\n#### Expected behavior.\r\n`updatedAt` field is being updated for **MainSchema** and **NestedSchama a**.\r\n#### Thoughts.\r\nMoving all values to `$set` operator resolves problem ðŸ¤”.\r\n```js\r\nconst updatedModel = Main.findOneAndUpdate({\r\n  $set: {\r\n    c: \"value\",\r\n    'content.a.nestes_a': \"value\",\r\n  }\r\n}, { new: true });\r\n```\r\n\r\n### Case 3\r\n```js\r\nconst updatedModel = Main.findOneAndUpdate({\r\n  c: \"value\",\r\n  $set: {\r\n    'content.a': { nestedA: \"value\", nestedB: \"value\" }, \r\n  }\r\n}, { new: true });\r\n```\r\n#### Current behavior.\r\n`updatedAt` field is updated **only** for **MainSchema** while **NestedSchama a** was modified too.\r\n#### Expected behavior.\r\n`updatedAt` field is being updated for **MainSchema** and **NestedSchama a**.\r\n#### Thoughts.\r\nProviding all values separately resolves problem:\r\n```js\r\nconst updatedModel = Main.findOneAndUpdate({\r\n  c: \"value\",\r\n  $set: {\r\n    'content.a.nestedA': \"value\", \r\n    'content.a.nestedB': \"value\",\r\n  }\r\n}, { new: true });\r\n```\r\n\r\n### Versions:\r\n- **Mongoose**:  `5.10.0`\r\n- **Node.js**: `10.x` / `12.x` / `14.x`"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBug\r\n\r\n**What is the current behavior?**\r\n\r\nI have a key in my Schema that uses the default function to use `this`. When `type` is an array, `this` only includes default values of some of the keys:\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n\r\n```\r\nauthors: {\r\n    default: function () {\r\n        console.log(this);\r\n    },\r\n    type: [mongoose.Schema.Types.ObjectId],\r\n},\r\n```\r\n\r\nLogs to console an object with only keys that have a default value\r\n\r\nvs\r\n\r\n```\r\nauthors: {\r\n    default: function () {\r\n        console.log(this);\r\n    },\r\n    type: mongoose.Schema.Types.ObjectId,\r\n},\r\n```\r\n\r\nLogs to console an object that includes the keys that I'm setting in my 'createCourse' route\r\n```\r\nconst course = await Course.create({\r\n    title: req.body.title,\r\n    publisher: req.account._id,\r\n});\r\n```\r\n\r\n`**What is the expected behavior?**\r\n\r\nShould have access to `this.publisher` when using an array.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nNode.js: 14.7.0\r\nMongoose: 5.10.0\r\nMongoDB: 4.2.3\r\n\r\n\r\nI love mongoose, thanks for the great work!"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBug\r\n\r\n**What is the current behavior?**\r\n\r\nCrashing with an error within an error. That is:\r\n```\r\n  errors: {\r\n    foo: CastError: Cast to Boolean failed for value \"undefined\" at path \"foo\"\r\n        at model.$set (./mongoose-bug/node_modules/mongoose/lib/document.js:1274:9)\r\n        at model._handleIndex (./mongoose-bug/node_modules/mongoose/lib/document.js:996:14)\r\n        at model.$set (./mongoose-bug/node_modules/mongoose/lib/document.js:937:22)\r\n        at model.Document (./mongoose-bug/node_modules/mongoose/lib/document.js:146:12)\r\n        at model.Model (./mongoose-bug/node_modules/mongoose/lib/model.js:106:12)\r\n        at new model (./mongoose-bug/node_modules/mongoose/lib/model.js:4675:15)\r\n        at ./mongoose-bug/node_modules/mongoose/lib/model.js:3041:22\r\n        at ./mongoose-bug/node_modules/mongoose/lib/model.js:3077:7\r\n        at Array.forEach (<anonymous>)\r\n        at ./mongoose-bug/node_modules/mongoose/lib/model.js:3076:15\r\n        at ./mongoose-bug/node_modules/mongoose/lib/helpers/promiseOrCallback.js:31:5\r\n        at new Promise (<anonymous>)\r\n        at promiseOrCallback (./mongoose-bug/node_modules/mongoose/lib/helpers/promiseOrCallback.js:30:10)\r\n        at Function.create (./mongoose-bug/node_modules/mongoose/lib/model.js:3011:10)\r\n        at ./mongoose-bug/test.js:17:15\r\n        at processTicksAndRejections (internal/process/task_queues.js:93:5) {\r\n      stringValue: '\"undefined\"',\r\n      messageFormat: undefined,\r\n      kind: 'Boolean',\r\n      value: undefined,\r\n      path: 'foo',\r\n      reason: TypeError: Cannot read property 'omitUndefined' of undefined\r\n          at SchemaBoolean._castNullish (./mongoose-bug/node_modules/mongoose/lib/schema/boolean.js:233:93)\r\n          at SchemaBoolean.SchemaType.applySetters (./mongoose-bug/node_modules/mongoose/lib/schematype.js:1066:17)\r\n          at model.$set (./mongoose-bug/node_modules/mongoose/lib/document.js:1227:20)\r\n          at model._handleIndex (./mongoose-bug/node_modules/mongoose/lib/document.js:996:14)\r\n          at model.$set (./mongoose-bug/node_modules/mongoose/lib/document.js:937:22)\r\n          at model.Document (./mongoose-bug/node_modules/mongoose/lib/document.js:146:12)\r\n          at model.Model (./mongoose-bug/node_modules/mongoose/lib/model.js:106:12)\r\n          at new model (./mongoose-bug/node_modules/mongoose/lib/model.js:4675:15)\r\n          at ./mongoose-bug/node_modules/mongoose/lib/model.js:3041:22\r\n          at ./mongoose-bug/node_modules/mongoose/lib/model.js:3077:7\r\n          at Array.forEach (<anonymous>)\r\n          at ./mongoose-bug/node_modules/mongoose/lib/model.js:3076:15\r\n          at ./mongoose-bug/node_modules/mongoose/lib/helpers/promiseOrCallback.js:31:5\r\n          at new Promise (<anonymous>)\r\n          at promiseOrCallback (./mongoose-bug/node_modules/mongoose/lib/helpers/promiseOrCallback.js:30:10)\r\n          at Function.create (./mongoose-bug/node_modules/mongoose/lib/model.js:3011:10)\r\n    }\r\n  },\r\n```\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n\r\nHere is a small snippet demonstrating the issue:\r\n```js\r\nconst mongoose = require('mongoose');\r\n\r\nconst Schema = new mongoose.Schema({\r\n  foo: Boolean,\r\n});\r\n\r\nconst Model = mongoose.model('test', Schema);\r\n\r\n(async function () {\r\n  await mongoose.connect('mongodb://localhost:27017');\r\n\r\n  await Model.bulkWrite([\r\n    { insertOne: { document: { foo: undefined } } },\r\n    { updateOne: { filter: {}, update: { $set: { foo: true } } } },\r\n  ]);\r\n\r\n  await Model.create({\r\n    foo: undefined,\r\n  });\r\n\r\n  await mongoose.disconnect();\r\n})().then(console.info.bind(console, 'OK'), console.error.bind(console, 'NOK'));\r\n```\r\n\r\nSimply commenting the `updateOne` line seems to make the issue go away. `updateMany` seems to have the same behavior.\r\n\r\n**What is the expected behavior?**\r\n\r\nNo error.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nNode.js 14.8.0, Mongoose 5.10.0, MongoDB 4.2.8"},{"labels":["bug"],"text":"\r\n**Do you want to request a *feature* or report a *bug*?**\r\nbug\r\n\r\n**What is the current behavior?**\r\nWhen populating a model with a refPath that hasn't been registered, mongoose gives a schema error even if the reference ID contains no values. This wasn't giving an error up until mongoose@5.8.4\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n\r\nThe script below works up to mongoose 5.8.3 and fails for any versions beyond.\r\n\r\n```\r\nconst mongoose = require('mongoose');\r\nconst Schema = mongoose.Schema;\r\n\r\nmongoose.connect('mongodb://localhost:27017/schemaerror');\r\nvar db = mongoose.connection;\r\ndb.on('error', console.error.bind(console,'MongoDB connection error:'));\r\n\r\nconst firstSchema = new Schema({\r\n  ref: String,\r\n  linkedId: {\r\n    type: Schema.ObjectId,\r\n    refPath: 'ref'\r\n  }\r\n});\r\n\r\nconst firstModel = mongoose.model('first', firstSchema);\r\n\r\nconst secondSchema = new Schema({\r\n  foo: String\r\n});\r\n\r\nconst secondModel = mongoose.model('second', secondSchema);\r\n\r\nconst displayError = async () => {\r\n\r\n  try {\r\n    let newSecond = await secondModel.create({foo: 'bar'});\r\n    let populatedFirst = await firstModel.create({ref: 'second', linkedId: newSecond._id});\r\n    let unpopulatedFirst = await firstModel.create({ref: 'third'});\r\n    let result = await firstModel.find({}).populate('linkedId').exec();\r\n    console.log('success');\r\n    process.exit;\r\n  } catch (error) {\r\n    console.error(error);\r\n  }\r\n\r\n}\r\n\r\ndisplayError();\r\n```\r\nThe following error is produced:\r\n\r\n```\r\nMissingSchemaError: Schema hasn't been registered for model \"third\".\r\nUse mongoose.model(name, schema)\r\n    at NativeConnection.Connection.model (...\\node_modules\\mongoose\\lib\\connection.js:1192:11)\r\n    at getModelsMapForPopulate (...\\node_modules\\mongoose\\lib\\helpers\\populate\\getModelsMapForPopulate.js:283:59)\r\n    at populate (...\\node_modules\\mongoose\\lib\\model.js:4309:21)\r\n```\r\n\r\n\r\n**What is the expected behavior?**\r\nNo errors when populating empty references.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nNode: 12.18.3\r\nMongoose: 5.10.0\r\nMongoDB: 4.2.7\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nUsing populate + omitting _id results in the following error if the populated document does not exist and `retainNullValues` is set to true:\r\n\r\n\r\n ```\r\nTypeError: Cannot read property '$__setValue' of null\r\n    at maybeRemoveId (\\node_modules\\mongoose\\lib\\helpers\\populate\\assignVals.js:237:23)\r\n    at valueFilter (\\node_modules\\mongoose\\lib\\helpers\\populate\\assignVals.js:193:7)\r\n    at setValue (\\node_modules\\mongoose\\lib\\helpers\\populate\\assignVals.js:67:12)\r\n```\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n ```\r\n  const options = {\r\n      model: 'Model',\r\n      select: 'title -_id',\r\n      options: { retainNullValues: true },\r\n    }\r\n   let user = await User.findById(_id , 'arrayOfObjectIds').populate({ options, path: 'arrayOfObjectIds' })\r\n```\r\n\r\n**What is the expected behavior?**\r\n\r\nReturning array with populated document/null \r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nNode v12.13.1\r\nMongoose ^5.10.0\r\nMongoDB v4.2.8\r\n\r\n\r\nI suspect that  `subdoc ` should be checked for value null in  `maybeRemoveId` in assignVals.js\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nCurrently when concurrently writing changes to a document instance while saving it, it either resets those tracked changes or never tracks them to begin with.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\nAssume the following code:\r\n```\r\nawait db.init();\r\nconst mySchemaInstance = new MySchema();\r\nawait mySchemaInstance.save();\r\nawait Promise.all([\r\n  new Promise(async resolve => {\r\n    mySchemaInstance.mySimpleInteger = 1;\r\n    console.log('set to 1');\r\n    await new Promise(resolve1 => setTimeout(resolve1, 0));\r\n    mySchemaInstance.mySimpleInteger = 2;\r\n    mySchemaInstance.mySecondSimpleInteger = 2;\r\n    console.log('set to 2');\r\n    await new Promise(resolve1 => setTimeout(resolve1, 0));\r\n    mySchemaInstance.mySimpleInteger = 3;\r\n    mySchemaInstance.mySecondSimpleInteger = 3;\r\n    console.log('set to 3');\r\n    resolve();\r\n  }),\r\n  new Promise(async resolve => {\r\n    await mySchemaInstance.save();\r\n    console.log('saved 1');\r\n    await mySchemaInstance.save();\r\n    console.log('saved 2');\r\n    await mySchemaInstance.save();\r\n    console.log('saved 3');\r\n    resolve();\r\n  }),\r\n]);\r\nconsole.log(JSON.stringify(mySchemaInstance.toObject()));\r\n```\r\n\r\nwhere MySchema is a simple schema defined like so:\r\n```\r\nconst mongoose = require('mongoose');\r\n\r\nconst mySchema = new mongoose.Schema({\r\n  mySimpleInteger: Number,\r\n  mySecondSimpleInteger: Number,\r\n});\r\n\r\nmodule.exports = mongoose.model('MySchema', mySchema);\r\n```\r\n\r\nThis sample code should update the newly created instance integer values, where the last save should include the last update if the save was executed after the modification on the instance was done. However the output with mongoose debug enabled shows differently:\r\n```\r\nMongoose: myschemas.insertOne({ _id: ObjectId(\"5f379a2f08990d259067df88\"), __v: 0 }, { session: null })\r\nset to 1\r\nMongoose: myschemas.updateOne({ _id: ObjectId(\"5f379a2f08990d259067df88\") }, { '$set': { mySimpleInteger: 1 } }, { session: null })\r\nset to 2\r\nset to 3\r\nsaved 1\r\nMongoose: myschemas.findOne({ _id: ObjectId(\"5f379a2f08990d259067df88\") }, { session: null, projection: { _id: 1 } })\r\nsaved 2\r\nMongoose: myschemas.findOne({ _id: ObjectId(\"5f379a2f08990d259067df88\") }, { session: null, projection: { _id: 1 } })\r\nsaved 3\r\n{\"_id\":\"5f379a2f08990d259067df88\",\"__v\":0,\"mySimpleInteger\":3,\"mySecondSimpleInteger\":3}\r\n```\r\nAs you can see the instance property itself is updated correctly, but never written to the DB. This is true for both the property that was included in the first update as well as the property that was only changed while saving.\r\n\r\n**What is the expected behavior?**\r\nI can set instance properties while saving and change tracking still works.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n- Nodejs v12.14.1\r\n- Mongoose v5.10.0\r\n- MongoDB: v4.2.8\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\n*Bug*\r\n\r\n**What is the current behavior?**\r\nInconsistent object saving after `.pull(id)` if you disable `_id` in the scheme of the subfield (`MongooseArray`) and use another field that has an alias `_id`.\r\n\r\n```javascript\r\nnew Schema({\r\n children: [\r\n   new Schema({\r\n     field: {\r\n       type: String,\r\n       alias: '_id'\r\n     }\r\n   }, { _id: false })\r\n ]\r\n});\r\n\r\n```\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```javascript\r\n'use strict';\r\n\r\nconst mongoose = require('mongoose');\r\nmongoose.set('debug', true);\r\n\r\nconst GITHUB_ISSUE = `gh9319`;\r\nconst connectionString = `mongodb://localhost:27017/${GITHUB_ISSUE}`;\r\nconst { Schema } = mongoose;\r\n\r\nrun()\r\n  .then(() => console.log('done'))\r\n  .catch(error => console.error(error.stack))\r\n  .then(() => process.exit(0));\r\n\r\nasync function run() {\r\n  await mongoose.connect(connectionString, { useNewUrlParser: true, useUnifiedTopology: true });\r\n\r\n  await mongoose.connection.dropDatabase();\r\n\r\n  const childSchema = new Schema({\r\n    field: {\r\n      type: String,\r\n      alias: '_id'        // <--------â”\r\n    }                     //          â”œ------ important\r\n  }, {                    //          |\r\n    _id: false            // <--------â”˜\r\n  });\r\n\r\n  const parentSchema = new Schema({\r\n    children: [childSchema]\r\n  });\r\n\r\n  const Parent = mongoose.model('Parent', parentSchema);\r\n\r\n\r\n  // Step 1. Create parent with children and find it.\r\n  await Parent.create({\r\n    children: [\r\n      { field: '1' }\r\n    ]\r\n  });\r\n  // Mongoose: parents.insertOne({ _id: ObjectId(\"5f3395ecd2702ec3f4f70fc4\"), children: [ { field: '1' } ], __v: 0}, { session: null })\r\n\r\n  // Step 2. Find the parent just created\r\n  const parent = await Parent.findOne();\r\n  // Mongoose: parents.findOne({}, { projection: {} })\r\n\r\n  console.log(parent);  // { _id: 5f3395ecd2702ec3f4f70fc4, children: [ { field: '1' } ], __v: 0 }\r\n\r\n  // It's possible to find child by id\r\n  let child = parent.children.id('1');\r\n\r\n  console.log(child); // { field: '1' }\r\n\r\n\r\n  // Step 3. Pull (remove) child by id\r\n  parent.children.pull('1');\r\n  // There will be same final result (and debug log `Mongoose: parents.updateOne(...)`) if use one of the following:\r\n  //   parent.children.pull({_id: '1'})\r\n  // or\r\n  //   parent.children.pull({field: '1'})\r\n  //\r\n  // But\r\n    // child.remove(); // throws new Error('For your own good, Mongoose does not know how to remove an EmbeddedDocument that has no _id')\r\n\r\n\r\n\r\n  // Now `children` is empty array\r\n  console.log(parent); // { _id: 5f3395ecd2702ec3f4f70fc4, children: [], __v: 0 }\r\n\r\n  // And `child` is null\r\n  child = parent.children.id('1');\r\n\r\n  console.log(child); // null\r\n\r\n\r\n  // Step 4. Save parent and find it again\r\n  const parent_1 = await parent.save();\r\n  // Mongoose: parents.updateOne({ _id: ObjectId(\"5f3395ecd2702ec3f4f70fc4\") }, { '$pull': { children: { _id: { '$in': [ '1' ] } } }, '$inc': { __v: 1 }}, { session: undefined })\r\n  //                                                                                                      ^\r\n  //                                                                                                  Look here\r\n\r\n  // `parent_1` equals `parent`\r\n  console.log(parent_1); // { _id: 5f3395ecd2702ec3f4f70fc4, children: [], __v: 1 }\r\n\r\n\r\n  const parent_2 = await Parent.findOne();\r\n  // Mongoose: parents.findOne({}, { projection: {} })\r\n\r\n  // Theoretically `parent_1` and `parent_2` should be equal, but they are NOT.\r\n  console.log(parent_2); // { _id: 5f3395ecd2702ec3f4f70fc4, children: [ { field: '1' } ], __v: 1 }\r\n\r\n\r\n  await mongoose.disconnect();\r\n}\r\n```\r\nThere problem is [here](https://github.com/Automattic/mongoose/blob/master/lib/types/core_array.js#L608). \r\n\r\n\r\n**What is the expected behavior?**\r\nObjects `parent`, `parent_1` and `parent_2` should be equal.\r\n\r\n**Possible solutions:**\r\n\r\n**Solution 0 (_just hotfix_)**\r\nChange this [line](https://github.com/Automattic/mongoose/blob/master/lib/types/core_array.js#L608)\r\n```javascript\r\n        return v._id || v;\r\n```\r\nwith\r\n```javascript\r\n        return v._doc._id || v;\r\n```\r\n\r\n**Solution 1 (_bad_)**\r\nMake `.pull` to mark all array as modified like `.shift()`, `.pop()` etc.\r\n\r\n**Solution 2 (_not so bad_)**\r\nMake `.pull` to mark all array as modified if last element was removed.\r\n\r\n**Solution 3 (_better_)**\r\nMake `.pull` to understand that pathType of `_id` is not `real` but `virtual` (or maybe new one `alias`) and should use smth like `Model.translateAliases()`\r\n\r\n**Solution 4 (_also not bad_)**\r\nAllow to set option `_id` with field alias for Subschemas. Example:\r\n```javascript\r\nconst childSchema = new Schema({\r\n  field: {\r\n    type: String,\r\n  }\r\n}, {\r\n  _id: 'field'\r\n});\r\n```\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n```\r\nNode.js: v14.8.0\r\nMongoose: v5.9.28\r\nMongoDB: v4.4.0\r\n```\r\n\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug \r\n\r\n**What is the current behavior?**\r\n\r\nUsing lodash's `set` method (https://lodash.com/docs/4.17.15#set)  to set a nested property is resulting in all the other properties of the nested object to be set to undefined.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n\r\n```\r\nconst mongoose = require(\"mongoose\");\r\nconst _ = require(\"lodash\");\r\nconst Schema = mongoose.Schema;\r\n\r\nconst schema = new Schema({\r\n  nested: {\r\n    prop1: { type: Number, default: 50 },\r\n\r\n    prop2: {\r\n      type: String, enum: ['val1', 'val2'], default: 'val1', required: true,\r\n    },\r\n    prop3: {\r\n      prop4: { type: Number, default: 0 },\r\n    },\r\n  },\r\n\r\n});\r\n\r\nconst Model = mongoose.model(\"model\", schema);\r\n\r\nmongoose.connect(\"mongodb://localhost:27017/test\").then(async () => {\r\n  let doc = await Model.create({});\r\n  console.log('nested.prop2 after creation', doc.nested.prop2); // nested.prop2 is correctly set to the default value `val1`\r\n\r\n  doc = await Model.findOne(doc._id).exec();\r\n  console.log('nested.prop2 after fetch', doc.nested.prop2);  // nested.prop2 is correctly `val1`\r\n\r\n  _.set(doc, 'nested.prop1', 45); \r\n\r\n  console.log('nested.prop2 after _.set', doc.nested.prop2); //  // nested.prop2 is now undefined, as well as all other properties in the `nested` object apart from `nested.prop1`\r\n\r\n   await doc.save(); // this will fail because nested.prop2 is required\r\n}).catch(err => console.log(err));\r\n```\r\n\r\n**What is the expected behavior?**\r\n\r\nThe properties are set correctly. Note that for some strange reason removing `prop3` from the schema the bug doesn't appear. It looks like it only happens when there are at least 3 nested properties.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nIt started happening in 5.9.28, 5.9.27 works fine. On node 12\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"Mongoose version 5.9.26\r\n\r\nHello there,\r\n\r\nConsider the following code:\r\n\r\n```js\r\n'use strict';\r\n\r\nconst _ = require('lodash');\r\nconst assert = require('assert');\r\nconst Promise = require('bluebird');\r\nconst mongoose = require('mongoose');\r\nmongoose.Promise = Promise;\r\n\r\nrequire('mongoose').set('debug', true);\r\n\r\n// DB\r\nlet connect = mongoose.connect('mongodb://localhost:27018/test', {\r\n  useNewUrlParser: true,\r\n  useUnifiedTopology: true,\r\n});\r\n\r\nconst UserSchema = new mongoose.Schema({\r\n  slug: {\r\n    type: String,\r\n  },\r\n});\r\n\r\nUserSchema.index({slug: 1}, {unique: true});\r\n\r\nconst User = mongoose.model('User', UserSchema);\r\n\r\n// Create test data\r\nconnect.then(async () => {\r\n  mongoose.connection.db.dropDatabase();\r\n\r\n  await User.create({\r\n    slug: 'test',\r\n  });\r\n\r\n  await User.collection.dropIndexes();\r\n\r\n  // Allowed to create duplicate data, we just dropped the index. This is for demonstration purposes.\r\n  await User.create({\r\n    slug: 'test',\r\n  });\r\n\r\n  // Now let's try to restore the index.\r\n\r\n  await User.syncIndexes({background: false});\r\n  await User.ensureIndexes({background: false});\r\n  await User.createIndexes({background: false});\r\n  await User.collection.createIndex({slug: 1}, {unique: true});\r\n});\r\n```\r\n\r\nOnly the last call to direct mongodb \"correctly\" fails and rejects with the expected `E11000 duplicate key error dup key`, `syncIndexes`, `ensureIndexes` and `createIndexes` do _not_ create the index, because it probably errors silently.\r\n\r\nIs there a way to make these function reject with the error? I feel this should be expected behavior.\r\n\r\nAlso, https://mongoosejs.com/docs/api/model.html#model_Model.syncIndexes shows the following code\r\n\r\n```\r\nawait Customer.createIndex({ age: 1 }); // Index is not in schema\r\n```\r\n\r\nBut `createIndex` is not a mongoose function."},{"labels":["bug"],"text":"\r\nGiven a schema:\r\n```\r\n  Country = new mongoose.Schema({\r\n    cities: {\r\n        type: Map,\r\n        of: {\r\n             population: {type: Number}\r\n        }\r\n    });\r\n```\r\n\r\nWhen \r\n`Country.updateOne({_id:\"\"}, {$set: \"cities.newyork.population\": 10000} ).exec()`\r\nthrows Mongoose maps only support string keys, got undefined\r\n\r\nBypassing the mongoose works:\r\n`Country.collection.update({_id:\"\"}, {$set: \"cities.newyork.population\": 10000} )`\r\nBut it is missing schema validation.\r\n\r\nBy changing the mongoose/lib/schema/map.js function cast = (val, doc, init) => val it's working...\r\nBut I am not sure when this should be done in order to create a pull request(maybe when $__schemaType.path ends with \".$*\").\r\n\r\nP.S I can create a pull request with a failing test in order for anyone to investigate it more.\r\n\r\n\r\n"},{"labels":["bug"],"text":"Prior to mongoose 5.9.16 stringify of a validation error returns:\r\n\r\n{\"errors\":{\"accountType\":{\"message\":\"Path \\`accountType\\` is required.\",\"name\":\"ValidatorError\",\"properties\":{\"message\":\"Path \\`accountType\\` is required.\",\"type\":\"required\",\"path\":\"accountType\"},\"kind\":\"required\",\"path\":\"accountType\"}},\"_message\":\"Company validation failed\",\"message\":\"Company validation failed: accountType: Path \\`accountType\\` is required.\",\"name\":\"ValidationError\"}\r\n\r\nFrom mongoose 5.9.16 and beyond:\r\n\r\n{\"errors\":{\"accountType\":{\"properties\":{\"message\":\"Path \\`accountType\\` is required.\",\"type\":\"required\",\"path\":\"accountType\"},\"kind\":\"required\",\"path\":\"accountType\"}},\"_message\":\"Company validation failed\",\"message\":\"Company validation failed: accountType: Path \\`accountType\\` is required.\"}\r\n\r\nThere is no message or name for each error.\r\n\r\nI'm using Express .json to serialize error and this is breaking my error handling.\r\n\r\n\r\nScript to reproduce:\r\n\r\n```javascript\r\n'use strict';\r\n\r\nconst mongoose = require('mongoose');\r\n\r\nmongoose.set('useFindAndModify', false);\r\n\r\nconst { Schema } = mongoose;\r\n\r\nrun().catch(err => console.log(err));\r\n\r\nasync function run() {\r\n  await mongoose.connect('mongodb://localhost:27017/test', {\r\n    useNewUrlParser: true,\r\n    useUnifiedTopology: true\r\n  });\r\n\r\n  await mongoose.connection.dropDatabase();\r\n\r\n  const Model = mongoose.model('Test', Schema({\r\n    name: { type: String, required: true },\r\n    numAddresses: { type: Number, min: 1 }\r\n  }));\r\n\r\n  const doc = new Model({ numAddresses: 0 });\r\n\r\n  const err = await doc.validate().catch(err => err);\r\n  console.log(err.message); // Test validation failed: name: Path \\`name\\` is required., numAdd\r\n  console.log(err.errors['name'].message); // Path \\`name\\` is required.\r\n  console.log(err.errors['numAddresses'].message); // Path \\`numAddresses\\` (0) is less than minimum allowed value (1).\r\n  console.log(JSON.stringify(err)); // No message for name or numAddresses\r\n}\r\n```"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nPossible bug report\r\n\r\n**What is the current behavior?**\r\n\r\nThe get query never ended (infinite loop) when the readPreference=secondary is past on connection URL\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\nUse a multi replica (as Mongo cloud), pass the readPreference=secondary in the connection URL\r\n\r\nTry to find some object\r\nWith mongoose@5.7.13 => works fine\r\nWith mongoose@5.9.26 => infinite loop\r\n\r\nOn connection with 5.9.26, the reconnected event is triggered\r\n\r\n**What is the expected behavior?**\r\n\r\nGet the result on both version\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nNode 12, MongoDb 3.5.9\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\n  Report a bug\r\n**What is the current behavior?**\r\n  A populated object in a nested array is losing its population after I try to assign a new version to it  \r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n\r\n```javascript\r\nconst mongoose = require('mongoose');\r\nconst uriFormat = require('mongodb-uri');\r\n\r\nconst ObjectId = mongoose.Schema.ObjectId;\r\n\r\n// SCHEMAS\r\nlet StepSchema = new mongoose.Schema({\r\n    ride: {\r\n        type: ObjectId,\r\n        ref: 'Ride',\r\n        index: true\r\n    },\r\n    status: {\r\n        type: Number,\r\n        default: 0\r\n    }\r\n}, { usePushEach: true, timestamps: true });\r\n\r\nlet RideSchema = new mongoose.Schema({\r\n    status: {\r\n        type: Number,\r\n        required: true,\r\n        default: 0\r\n    },\r\n    steps: {\r\n        taxi: [{\r\n            type: ObjectId,\r\n            ref: 'Step'\r\n        }],\r\n        rent: [{\r\n            type: ObjectId,\r\n            ref: 'Step'\r\n        }],\r\n        vehicle: [{\r\n            type: ObjectId,\r\n            ref: 'Step'\r\n        }]\r\n    }\r\n}, { usePushEach: true, timestamps: true });\r\n\r\n// MONGOOSE CONNECTION\r\nlet url = \"\";\r\n\r\nconst options = { \r\n    useNewUrlParser: true,\r\n    useUnifiedTopology: true,\r\n    useCreateIndex: true,\r\n    retryWrites: false // using this due to our mLab production replicaSet mongo engine being MMAPv1\r\n};\r\n\r\nmongoose.Schema.Types.String.checkRequired(v => v != null);\r\n\r\nfunction encodeMongoURI (urlString) {\r\n    if (urlString) {\r\n      let parsed = uriFormat.parse(urlString)\r\n      urlString = uriFormat.format(parsed);\r\n    }\r\n    return urlString;\r\n}\r\n\r\nlet mainDbConnection = mongoose.createConnection(encodeMongoURI(url), options);\r\n\r\nmongoose.set('objectIdGetter', false);\r\nmongoose.set('useFindAndModify', false);\r\n\r\nlet Ride = mainDbConnection.model('Ride', RideSchema);\r\nlet Step = mainDbConnection.model('Step', StepSchema);\t\r\n\r\n// LOGIC\r\n(async () => {\r\n\tlet ride = new Ride();\r\n\ttry { ride = await ride.save();\r\n\t} catch (e) {return console.log('error saving ride', e);}\r\n\r\n\tlet taxiStep = new Step({ride: ride._id});\r\n\tlet vehicleStep = new Step({ride: ride._id});\r\n\tlet rentStep = new Step({ride: ride._id});\r\n\r\n\tconsole.log('ride', ride);\r\n\tconsole.log('taxiStep', taxiStep);\r\n\tconsole.log('vehicleStep', vehicleStep);\r\n\tconsole.log('rentStep', rentStep);\r\n\r\n\ttry { taxiStep = await taxiStep.save();\r\n\t} catch (e) {return console.log('error saving ride', e);}\r\n\r\n\ttry { vehicleStep = await vehicleStep.save();\r\n\t} catch (e) {return console.log('error saving ride', e);}\r\n\r\n\ttry { rentStep = await rentStep.save();\r\n\t} catch (e) {return console.log('error saving ride', e);}\t\r\n\r\n\tride.steps = {taxi: [taxiStep._id], vehicle: [vehicleStep._id], rent: [rentStep._id]};\r\n\r\n\ttry { ride = await ride.save();\r\n\t} catch (e) {return console.log('error saving ride', e);}\r\n\r\n\tlet foundRide;\r\n\ttry { foundRide = await Ride.findOne({_id: ride._id}).populate({path:'steps.taxi steps.vehicle steps.rent', model:'Step'});\r\n\t} catch (e) { return console.log('mongo error', e); }\r\n\r\n\tconsole.log('foundRide.steps before', foundRide.steps); // e.g. foundRide.steps.taxi is an array of populated objects from the Step model\r\n\r\n\tfoundRide.steps = doSomething(foundRide);\r\n\tconsole.log('foundRide.steps after', foundRide.steps); // e.g. foundRide.steps.taxi becomes an array of _id .Why does it lose population?\r\n})();\r\n\r\nconst doSomething = ride => ride.steps;\r\n```\r\n\r\n**What is the expected behavior?**\r\n  It's expected for the nested array objects to keep its populated fields\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n  Node.js - 12.13.0  \r\n  Mongoose - 5.9.26\r\n  Mongo - 3.6.18\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\n(I am using [Insomnia](https://insomnia.rest))\r\nI use a RegExp to validate a file path given by [`multer`](https://www.npmjs.com/package/multer).\r\nThe first time I send a request, it goes trough without errors, but if I send another one it throws a RegExp validation error (The request is the same, the filename is generated using `Date.now()`). The cycle repeats, you can see it more clearly like this:\r\n```\r\nrequest 1: 200 OK\r\nrequest 2: 400 Bad Request\r\nrequest 3: 200 OK\r\nrequest 4: 400 Bad Request\r\n...\r\n```\r\n(If I restart the server after each request I only get `200 OK`, but of course I cannot just restart the server in production)\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n\r\n```javascript\r\n// models/data.model.js\r\n\r\nimport mongoose from \"mongoose\";\r\n\r\nconst DataSchema = new mongoose.Schema({\r\n  myFile: {\r\n    type: String,\r\n    required: true,\r\n    trim: true,\r\n    match: /(([^\\\\/]*[\\\\/])*)([^\\\\/]+)$/g // I get consistent results if I remove this line\r\n  }\r\n});\r\n\r\nexport default mongoose.model(\"Data\", DataSchema, \"Data\");\r\n```\r\n\r\n```javascript\r\n// routes/data.js\r\n\r\nimport Data from \"../models/data.model.js\";\r\nimport express from \"express\";\r\nimport fs from \"fs\";\r\nimport multer from \"multer\";\r\nimport path from \"path\";\r\nimport { promisify } from \"util\";\r\n\r\nconst router = express.Router(),\r\n  storage = multer.diskStorage({\r\n    destination: (req, file, cb) => {\r\n      cb(null, \"./uploads/myFiles\");\r\n    },\r\n    filename: (req, file, cb) => {\r\n      cb(null, Date.now() + path.extname(file.originalname).toLowerCase());\r\n    },\r\n  }),\r\n  unlinkAsync = promisify(fs.unlink),\r\n  upload = multer({ storage: storage });\r\n\r\nrouter.post(\"/\", upload.single(\"myFile\"), async (req, res) => {\r\n  try {\r\n    const newData = new Data({\r\n      myFile: req.file.path,\r\n    });\r\n    await newData.save();\r\n    res.status(200).json(newData);\r\n  } catch (error) {\r\n    if (error.errors) {\r\n      unlinkAsync(req.file.path);\r\n      res.status(400).json(error.errors);\r\n    } else {\r\n      unlinkAsync(req.file.path);\r\n      res.status(500).json();\r\n    }\r\n  }\r\n});\r\n\r\nexport default router;\r\n```\r\n\r\n```javascript\r\n// app.js\r\n\r\n// Imports\r\nimport \"dotenv/config.js\";\r\nimport dataRoute from \"./routes/data.js\";\r\nimport express from \"express\";\r\nimport mongoose from \"mongoose\";\r\n\r\n// Constants and variables\r\nconst app = express(),\r\n  db = process.env.DB || \"mongodb://localhost/test\",\r\n  dist = express.static(\"dist\"),\r\n  port = parseInt(process.env.PORT) || 8080;\r\n\r\n// Middlewares\r\napp.use(express.urlencoded({ extended: true }));\r\napp.use(express.json());\r\n\r\n// Routes middlewares\r\napp.use(\"/api/data\", dataRoute);\r\n\r\n// Set mongoose variables to avoid warnings\r\nmongoose.set(\"useNewUrlParser\", true);\r\nmongoose.set(\"useFindAndModify\", false);\r\nmongoose.set(\"useCreateIndex\", true);\r\nmongoose.set(\"useUnifiedTopology\", true);\r\n\r\n// Connect to db\r\nmongoose.connect(db, () => {\r\n  console.log(`db connected to ${db}`);\r\n});\r\n\r\n// Start server\r\napp.listen(port, () => {\r\n  console.log(`server running on port ${port}`);\r\n});\r\n```\r\n\r\n**What is the expected behavior?**\r\nConsistent validation results (`200 OK` or `400 Bad Request` respectively)\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\n**Node.js:** 14.5.0\r\n**Mongoose:** 5.9.25 \r\n**MongoDB:** 4.2.8\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBug\r\n\r\n**What is the current behavior?**\r\n\r\nWhen setting schemas to strict:'throw' and deleting a nested property on refetched document by assigning new value to parent, when document is revalidated, no error is thrown\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\n```js\r\ndescribe('Immutable validator tests', () => {\r\n  let Test = null\r\n\r\n  before(() => {\r\n    const SubSchema = new Schema({\r\n      nestedProp: {\r\n        type: String,\r\n        immutable: true\r\n      }\r\n    }, {\r\n      strict: 'throw'\r\n    })\r\n\r\n    const TestSchema = new Schema({\r\n      object: {\r\n        type: SubSchema\r\n      }\r\n    }, {\r\n      strict: 'throw'\r\n    })\r\n\r\n    mongoose.model('Test', TestSchema)\r\n\r\n    Test = mongoose.model('Test')\r\n  })\r\n\r\n  it('should produce an error, field in subschema is deleted when updating document', async () => {\r\n    const testDoc = new Test({\r\n      object: {\r\n        nestedProp: 'A'\r\n      }\r\n    })\r\n\r\n    await testDoc.save()\r\n\r\n    const testDocRefetched = await Test.findById(testDoc._id)\r\n\r\n    testDocRefetched.object = {}\r\n    // works:  testDocRefetched.object.nestedProp = undefined\r\n\r\n    await testDocRefetched.save().should.be.rejectedWith(\r\n      'Test validation failed: object.nestedProp: Path `nestedProp` is immutable and strict mode is set to throw., object: Validation failed: nestedProp: Path `nestedProp` is immutable and strict mode is set to throw.'\r\n    )\r\n  })\r\n})\r\n```\r\n\r\n**What is the expected behavior?**\r\n\r\nError should be thrown\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\nmongoose: 5.9.20\r\nnode: 12.17.0\r\nmongodb: 3.6.17\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBug\r\n\r\n**What is the current behavior?**\r\n\r\nI have `doc.booleanField = true` and I want to remove this key from my document by this below code\r\n```\r\ndoc.booleanField = undefined\r\ndoc.save()\r\n```\r\nBut the result is `doc.booleanField = null` and the key isn't removed\r\n\r\n**What is the expected behavior?**\r\n\r\nIt should able to set boolean field to `undefined` and can use `doc.save()` to remove it form doc\r\n\r\nI was able to remove boolean field by this way until mongoose update to version 5.9.24\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nNode: 10.20.1\r\nMongoose: 5.9.25\r\nMongoDB: 4.0.18\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nFeature -> docs\r\n\r\n**Problem**\r\n\r\n@vkarpov15 I am not sure to understand the mongoose browser documentation. I have been a user of mongoose for many years now (â¤ï¸ ) but I am struggling to understand it. \r\n- You said there is no pre-build library of mongoose browser but I am still seeing one when installing mongoose on my project\r\n- I am using mongoose to define my schema and models in my library. This project is later consumed by all my backends projects. I'd love to be able to create a different build from the same schemas I have defined. But does it mean I need to re-write all of them and replacing `const mongoose = require('mongoose')` with `const mongoose = require('mongoose/browser')`? I am using ES6 everywhere\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nNode 12\r\nMongoose 5.9.25 \r\nMongo 4.2\r\n"},{"labels":["bug"],"text":"When updating the nested document using bulkWrite operation, it seems that updatedAt does not get updated.\r\n\r\nFrom looking at ``applyTimestampsToChildren.js``, looks like the timestamp was skipped due to ``path.$isSingleNested`` condition (it's undefined). \r\n\r\nHere is the test case I used to validate it:\r\n\r\n```javascript\r\nconst mongoose = require('mongoose');\r\nconst config = require('config');\r\nconst { expect } = require('chai');\r\n\r\nconst Schema = mongoose.Schema;\r\n\r\ndescribe('Bulkwrite nested updatedAt', () => {\r\n  it('should update updatedAt for nested document on bulkWrite', async () => {\r\n    const dbConnection = mongoose.connection.useDb(config.get('dbName'), { useCache: true });\r\n    const NestedSchema = new Schema(\r\n      {\r\n        name: {\r\n          type: String,\r\n        },\r\n      },\r\n      {\r\n        timestamps: true,\r\n        _id: false\r\n      }\r\n    );\r\n    const TestSchema = new Schema({\r\n      nestedDoc: {\r\n        type: NestedSchema,\r\n        required: false\r\n      }\r\n    });\r\n  \r\n    const testModel = dbConnection.model('timestamp-test', TestSchema);\r\n\r\n    const insertResult = await testModel.create({\r\n      nestedDoc: { name: 'test' }\r\n    });\r\n\r\n    const oldDoc = await testModel.findOne({}).lean();\r\n\r\n    await new Promise(resolve => setTimeout(resolve, 5000));\r\n\r\n    await testModel.bulkWrite([\r\n      {\r\n        updateOne: {\r\n          filter: {\r\n            _id: insertResult._id\r\n          },\r\n          update: {\r\n            'nestedDoc.name': 'bla'\r\n          }\r\n        }\r\n      }\r\n    ]);\r\n\r\n    const updatedDoc = await testModel.findOne({}).lean();\r\n    expect(updatedDoc.nestedDoc.updatedAt.toISOString()).to.not.equal(oldDoc.nestedDoc.updatedAt.toISOString());\r\n  });\r\n});\r\n\r\n```\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\nv5.9.25\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBug\r\n\r\n**What is the current behavior?**\r\n\r\nIn the following gist, note how inserting a sub doc by index in example 3 yields a different sub doc type and yields a validation error on save().\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\n```javascript\r\n// example 1\r\ndocument.keys = [{}];\r\ndocument.keys[0].name = 'test';\r\nconsole.log(document.keys.constructor.name); \t// CoreDocumentArray\r\nconsole.log(document.keys[0].constructor.name); // EmbeddedDocument\r\ndocument.save();\t\t\t\t//\r\n\r\n// example 2\r\ndocument.keys = [];\r\ndocument.keys.push({});\r\ndocument.keys[0].name = 'test';\r\nconsole.log(document.keys.constructor.name); \t// CoreDocumentArray\r\nconsole.log(document.keys[0].constructor.name); // EmbeddedDocument\r\ndocument.save();\t\t\t\t//\r\n\r\n// example 3\r\ndocument.keys = [];\r\ndocument.keys[0] = {};\r\ndocument.keys[0].name = 'test';\r\nconsole.log(document.keys.constructor.name); \t// CoreDocumentArray\r\nconsole.log(document.keys[0].constructor.name); // Object\r\ndocument.save();\t\t\t\t// validation failed: keys: Cast to Array failed for value \"[ { name: 'test' } ]\" at path \"keys\"\r\n```\r\n\t\r\n**What is the expected behavior?**\r\n\r\nI expect the same behavior in example 3 as in examples 1 and 2, that proper and transparent type casting takes place.\r\n\r\nDocumentation (https://mongoosejs.com/docs/subdocs.html#adding-subdocs-to-arrays) suggests using \"methods such as push, unshift, addToSet, and others...\"\r\n\r\nI suspect \"and others\" includes using keys[0] as an LVALUE, and not only as an RVALUE. This type of assignment (example 3) seems to have worked similar to examples 1 and 2 in a previous version 5.0.3. The fact that I can actually make the object assignment tells me, that such assignment is intended valid. Alternatively, the assignment should have been failed.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nv5.9.25\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\ni have parent , children relationships. the children have same attribute \"subject\" type number but it reference a different model for each child. **the problem** is when the children have the same subject id and i want to populate them. mongoose cuts them out of the result\r\n\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nMongodb: 4.2.8\r\nMongoose: 5.9.24\r\n\r\n**Script To Reproduce**\r\n```\r\nconst mongoose = require('mongoose');\r\nconst { Schema } = mongoose;\r\nconst assert = require('assert');\r\n\r\n\r\nconst catSchema = new Schema({\r\n  _id: {\r\n    type: Number,\r\n    required: true\r\n  },\r\n  name: {\r\n    type: String,\r\n    required: true\r\n  }\r\n});\r\n\r\n\r\nconst dogSchema = new Schema({\r\n  _id: {\r\n    type: Number,\r\n    required: true\r\n  },\r\n  name: {\r\n    type: String,\r\n    required: true\r\n  }\r\n});\r\n\r\nconst notificationSchema = new Schema({\r\n  title: {\r\n    type: String,\r\n    required: true\r\n  }\r\n}, { discriminatorKey: \"type\" });\r\n\r\nconst notificationTypeASchema = new Schema({\r\n  subject: {\r\n    type: Number,\r\n    required: true,\r\n    ref: 'Cat'\r\n  }\r\n}, { discriminatorKey: 'type' })\r\n\r\n\r\nconst notificationTypeBSchema = new Schema({\r\n  subject: {\r\n    type: Number,\r\n    required: true,\r\n    ref: 'Dog'\r\n  }\r\n}, { discriminatorKey: 'type' })\r\n\r\n\r\n\r\nrun().catch(console.error);\r\n\r\nasync function run() {\r\n  await mongoose.connect('connectionURL', {\r\n    useNewUrlParser: true,\r\n    useUnifiedTopology: true\r\n  });\r\n\r\n  await mongoose.connection.dropDatabase();\r\n\r\n\r\n  const CatModel = mongoose.model('Cat', catSchema);\r\n  const DogModel = mongoose.model('Dog', dogSchema);\r\n  const NotificationModel = mongoose.model('Notification', notificationSchema);\r\n  const NotificationTypeAModel = NotificationModel.discriminator('NotificationTypeA', notificationTypeASchema);\r\n  const NotificationTypeBModel = NotificationModel.discriminator('NotificationTypeB', notificationTypeBSchema);\r\n\r\n  const cat = await CatModel.create({ _id: 1, name: \"mesh mesh\" });\r\n  const dog = await DogModel.create({ _id: 1, name: \"max\" });\r\n\r\n  await NotificationTypeAModel.create({ subject: cat._id, title: `new cat` });\r\n  await NotificationTypeBModel.create({ subject: dog._id, title: `new dog` });\r\n\r\n  const notifications = await NotificationModel.find({}).populate('subject');\r\n\r\n  assert.deepEqual(\r\n    notifications.map((el) => el.subject && el.subject.name),\r\n    ['mesh mesh', 'max']\r\n  );\r\n\r\n  console.log(`Mongoose version: ${mongoose.version}`);\r\n  console.log('All assertions passed.');\r\n\r\n}\r\n```"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBug.\r\n\r\n**What is the current behavior?**\r\n\r\n```js\r\nnew Schema({\r\n  name: {\r\n    type: String,\r\n    required: true,\r\n  },\r\n  status: {\r\n    type: Boolean,\r\n    default: false,\r\n  },\r\n  edit: {\r\n    type: Boolean,\r\n    default: false,\r\n  }\r\n});\r\n```\r\n```js\r\n X.findByIdAndUpdate(\r\n    {\r\n      _id: id\r\n    },\r\n    {\r\n      name,\r\n      status: undefined,\r\n      edit,\r\n    },\r\n    { new: true, omitUndefined: true },\r\n    function (err, res) {\r\n      console.log(res);\r\n    }\r\n  );\r\n```\r\n\r\nIf `status` is passed as `undefined` it won't be ignored despite `omitUndefined` option set to `true`.\r\n\r\nThe problem is within `mongoose/lib/helpers/query/castUpdate.js`:\r\n\r\n```js\r\nobj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\r\n....\r\n        if (options.omitUndefined && obj[key] === void 0) {\r\n          delete obj[key];\r\n          continue;\r\n        }\r\n```\r\nIt first casts Boolean schema value to null (`SchemaBoolean.prototype.castForQuery `) and only after that tries to clean undefined value.\r\n\r\n**What is the expected behavior?**\r\n\r\nIt should omit undefined status value.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nNode 14.4.0, Mongoose 5.9.24, MongoDB 3.6.8.\r\n\r\n"},{"labels":["bug"],"text":"Hello, \r\n\r\nIn file messageModel.js\r\n```\r\n`\r\nconst mongoose = require('mongoose')\r\nconst SmsSchema = new mongoose.Schema({ senderNumber: { type: String } })\r\nconst EmailSchema = new mongoose.Schema({  fromEmailAddress: {type: String} })\r\nconst messageSchema = new mongoose.Schema(\r\n  {  method: { type: String, enum: ['email', 'sms'], required: true }  },\r\n  { discriminatorKey: 'method' }\r\n)\r\n\r\nconst Message = mongoose.model('Message', messageSchema)\r\nMessage.discriminator('email', EmailSchema)\r\nMessage.discriminator('sms', SmsSchema)\r\nmodule.exports = Message`\r\n```\r\nin another file\r\n\r\n```\r\nconst mongoose = require('mongoose')\r\nconst MessageModel = require('./MessageModel')\r\nconst schema = new mongoose.Schema({   actions: [ActionSchema] })\r\n\r\nconst ActionSchema = new mongoose.Schema({}, { discriminatorKey: 'kind', _id: false })\r\nconst actions = schema.path('actions')\r\nactions.discriminator('message', MessageModel.schema)\r\nmodule.exports = schema\r\n```\r\nI am encountering the following error : \r\n```\r\n[worker] /node_modules/mongoose/lib/helpers/model/discriminator.js:144\r\n[worker]           throw new Error('Can\\'t customize discriminator option ' + _key +\r\n[worker]           ^\r\n[worker] \r\n[worker] Error: Can't customize discriminator option pluralization (can only modify toJSON, toObject, _id, id)\r\n[worker]     at merge (/node_modules/mongoose/lib/helpers/model/discriminator.js:144:17)\r\n[worker]     at discriminator (/node_modules/mongoose/lib/helpers/model/discriminator.js:167:3)\r\n```\r\nAny idea of what is happening or if I am missing something ? \r\n\r\nThanks a lot for your help\r\n++\r\n\r\n---\r\nmongoose 5.6.13,\r\nnode v12.16.1"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nbug\r\n\r\n**What is the current behavior?**\r\nsyncIndexes() deletes and recreates text indexes\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\ndeclare an index `{ name: 'text' }`\r\nrun syncIndexes(), creates the index\r\nrun syncIndexes() again, drops and recreates the index\r\n\r\n**What is the expected behavior?**\r\nsecond call to syncIndexes should be a no-op\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nnode 12.17.0, mongodb 4.2.8, mongoose 5.9.22\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"**What is the current behavior?**\r\n\r\nWhen creating a connection with the following option:\r\n```\r\n{\r\n   bufferCommands: true,\r\n   bufferMaxEntries: 99\r\n}\r\n```\r\n\r\nMongoose will default to\r\n```\r\n{\r\n   bufferCommands: true,\r\n   bufferMaxEntries: 0\r\n}\r\n```\r\n**What is the expected behavior?**\r\n\r\nIf bufferCommands is true, it should allow the user to set the bufferMaxEntries. This is the specific line https://github.com/Automattic/mongoose/blob/master/lib/connection.js#L633\r\n\r\nAs far as my knowledge goes for bufferCommands and bufferMaxEntries and default mongo options, the if should change from \r\n\r\n`if (options.bufferCommands != null) {`\r\n\r\nto\r\n\r\n`if (!options.bufferCommands) {`\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nNode: v10.14.1\r\nMongoose: 5.9.22\r\nMongoDB: 3.2 (CosmoDB)\r\n\r\n**Background**\r\n\r\nWe have a serverless environment (aws lambda and azure function app) and we were having problems with the recommended way of running mongo (https://mongoosejs.com/docs/lambda.html). Specifically, bufferCommands = false and bufferMaxEntries = 0. We are caching the database connection and we were getting this error randomly (always during insert, updates or deletes):\r\n\r\n> MongoError: no connection available for operation and number of stored operation \r\n\r\nWe decided to no longer set bufferCommand to false since from our understanding that will make mongo not autoReconnect which is something we would like to happen. After setting it to true, we were getting the same error. Which lead us to go into mongoose and found that it sets bufferMaxEntries to 0 when bufferCommands is not null which means you cannot pass bufferCommands = true.\r\n\r\nThis is the line in the mongo client that throws the error mentioned above because bufferMaxEntries is set to 0 by mongoose.\r\n\r\nhttps://github.com/mongodb/node-mongodb-native/blob/5808e12f13e39bfddb26cc15fe9b4dd751e1f363/src/topologies/topology_base.ts#L36"},{"labels":["bug"],"text":"I have a triple nested array defined in mongoose. When I try to initialize it with a 2 level deep empty array, it adds a third level. See the following code:\r\n\r\n```\r\nimport mongoose, { Schema } from 'mongoose';\r\n\r\nconst foos = mongoose.model(`FooModel`, new Schema({ numbers: [[[Number]]] }));\r\nconst oneFoo = await foos.create({ numbers: [[]] });\r\nconsole.log(oneFoo.numbers);\r\n\r\nExpected: [[]], Actual: [[[]]]\r\n```\r\n\r\n**Wrap up**\r\n\r\n- with [[[Number]]]\r\n  - [] gives [] :white_check_mark:\r\n  - [[]] gives [[[]]] :x:\r\n- with [[Number]]\r\n  - [] gives [] :white_check_mark:\r\n\r\n\r\nVersions:\r\n\r\n```\r\n\"mongodb\": \"3.5.4\",\r\n\"mongoose\": \"5.9.22\",\r\n```\r\n\r\nThe actual code only check for depth of the current value, and if it matches the depth of the declared Schema. The problem I see is that it doesn't check if values are actually array before wrapping everything into an array.\r\n\r\n```\r\n      if (valueDepth.min === valueDepth.max && valueDepth.max < depth) {\r\n        for (let i = valueDepth.max; i < depth; ++i) {\r\n          value = [value];\r\n        }\r\n      }\r\n```\r\n\r\nThe way it is, it looks like it should loop over the entire array to find if depth is not sufficient AND if items are not arrays.\r\n\r\nReproductible unit test:\r\n\r\n```\r\n  it('doesnt wrap empty nested array with insufficient depth', function() {\r\n    const weekSchema = mongoose.Schema({\r\n      days: {\r\n        type: [[[Number]]],\r\n        required: true\r\n      }\r\n    });\r\n\r\n    const Week = db.model('Test', weekSchema);\r\n    const emptyWeek = new Week();\r\n\r\n    emptyWeek.days = [[], [], [], [], [], [], []];\r\n    const obj = emptyWeek.toObject();\r\n    assert.deepEqual(obj.days, [[], [], [], [], [], [], []]);\r\n  });\r\n```\r\n\r\nMaybe @vkarpov15 can have an idea on how to fix it, you already take care of a lot of bug on this type of issue (https://github.com/Automattic/mongoose/commit/2b9d3b181c9ad1e918b41c20afe709e82b8b51ac)"},{"labels":["bug"],"text":"### The bug\r\n\r\nI've found a case where Mongoose's change tracking fails entirely.\r\n\r\nHere's the simplest example I could create to reproduce the issue:\r\n\r\n```javascript\r\nimport mongoose from \"mongoose\";\r\n\r\n// Do whatever setup/connection is needed first of course\r\n\r\nconst TestModel = mongoose.model('Test', new mongoose.Schema({\r\n    nested: new mongoose.Schema({\r\n        myBool: Boolean,\r\n        myString: String,\r\n    })\r\n}));\r\n\r\n(async function run() {\r\n    const test = new TestModel();\r\n\r\n    test.nested = {myBool: true}\r\n    await test.save();\r\n    // DB now has: {nested: {myBool: true}}\r\n\r\n    test.nested = {myString: \"asdf\"};\r\n    await test.save();\r\n    // DB now has: {nested: {myString: \"asdf\"}}\r\n\r\n    test.nested.myBool = true;\r\n    await test.save();\r\n    // DB still has: {nested: {myString: \"asdf\"}}\r\n\r\n    // The change to myBool is completely untracked\r\n\r\n    await test.remove();\r\n})().then(() => process.exit());\r\n```\r\n\r\nHere's the log output of running this code:\r\n\r\n```\r\nMongoose: tests.insertOne({ _id: ObjectId(\"5f02f528449eb2860795c345\"), nested: { _id: ObjectId(\"5f02f52f449eb2860795c346\"), myBool: true }, __v: 0}, { session: null })\r\nMongoose: tests.updateOne({ _id: ObjectId(\"5f02f528449eb2860795c345\") }, { '$set': { nested: { _id: ObjectId(\"5f02f574449eb2860795c347\"), myString: 'asdf' } }}, { session: null })\r\nMongoose: tests.findOne({ _id: ObjectId(\"5f02f528449eb2860795c345\") }, { session: null, projection: { _id: 1 } })\r\nMongoose: tests.deleteOne({ _id: ObjectId(\"5f02f528449eb2860795c345\") }, RemoveOptions { session: null })\r\n```\r\n\r\n**Note the 3rd line where Mongoose fails updating `myBool = true`**\r\n\r\n### Why this is happening\r\n\r\nI've found is that this is happening because each time a SingleNested doc is cast by setting it to an object which contains at least one key - then the existing value for that SingleNested is recorded as the \"priorDoc\". This happens here: https://github.com/Automattic/mongoose/blob/a3f61ad0d3b337f91e48778dd2867a5cdde24414/lib/schema/SingleNestedPath.js#L177-L181\r\n\r\nAnd when setting a value, Mongoose looks at this `priorDoc` to see if it contains a matching value to the one that's currently being set. So if you set a value to the same value that was in the `priorDoc`, then it doesn't consider this to be a change. This happens here: https://github.com/Automattic/mongoose/blob/a3f61ad0d3b337f91e48778dd2867a5cdde24414/lib/document.js#L1121-L1134\r\n\r\n### Workaround\r\n\r\nWhile a fix for this is unavailable, there is a reasonably simple workaround. Never set a nested document to an object other than an empty object literal. Doing this will ensure that the `priorDoc` is not kept in memory.\r\n\r\n```javascript\r\n//Change any situation where a SingleNested is set to an object containing at least one key\r\ntest.nested = {myString: \"asdf\"};\r\n\r\n// To\r\ntest.nested = {};\r\ntest.nested.myString = \"asdf\";\r\n\r\n// Or\r\ntest.nested = {};\r\nObject.entries({myString: \"asdf\"}).forEach(([key, value]) => this.nested[key] = value);\r\n\r\n```\r\n\r\n### Version stuff\r\n\r\nmongoose: 5.9.21\r\nNode.js: 14.3.0\r\nMongoDB: 4.0.3"},{"labels":["bug"],"text":"I've encountered surprising behavior with schemas that use `mongoose.Schema.Types.Array`. The following is a minimal example to demonstrate.\r\n\r\n```\r\nconst mongoose = require('mongoose')\r\n\r\nconst Model = mongoose.model('Foo', {\r\n  array1: Array,\r\n  array2: mongoose.Schema.Types.Array\r\n})\r\n\r\nconst item = new Model({\r\n  array1: [1,2,3],\r\n  array2: [1,2,3]\r\n})\r\n\r\nconsole.log(mongoose.version)\r\nconsole.log(item)\r\n```\r\nThe output is\r\n```\r\n5.9.21\r\n{\r\n  array1: [ 1, 2, 3 ],\r\n  array2: [ [ 1 ], [ 2 ], [ 3 ] ],\r\n  _id: 5efe4b84eae249003167a757\r\n}\r\n```\r\nNotice that `array2`, which is specified as a `mongoose.Schema.Types.Array`, becomes an array of arrays.\r\n\r\nIs this the expected behavior? If so, where is this documented?"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nWhen using the perDocumentLimit option when populating documents, only the first document is populated. This seems contrary to what the [documentation](https://mongoosejs.com/docs/api/model.html#model_Model.populate) states.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```javascript\r\nexport const docModel = new Schema({\r\n  hash: {\r\n    type: Schema.Types.String,\r\n    index: true,\r\n    required: true,\r\n    unique: true,\r\n  },\r\n  subs: [\r\n    {\r\n      type: Schema.Types.ObjectId,\r\n      ref: \"SubDocModel\",\r\n    },\r\n  ],\r\n});\r\n\r\nconst docModel = mongo.model(\"DocModel\", DocModel);\r\nexport default docModel;\r\n```\r\n\r\n```javascript\r\nexport const subDocModel = new Schema({\r\n  docHash: {\r\n    type: Schema.Types.String,\r\n    required: true,\r\n  },\r\n  subs: {\r\n    type: [Schema.Types.String],\r\n    required: true,\r\n  },\r\n});\r\nconst subDocModel = mongo.model(\"SubDocModel\", SubDocModel);\r\nexport default subDocModel;\r\n```\r\n\r\n```javascript\r\nconst docs = Model.find(query).sort({ hash: -1 });\r\nconst populatedDocs = await docs\r\n  .populate({\r\n    path: \"subs\",\r\n    select: \"subs -_id\",\r\n    perDocumentLimit: 2,\r\n  })\r\n  .lean();\r\n\r\nconsole.log(populatedDocs)\r\n> [\r\n  {\r\n    _id: 5ef4c738e491b7299d236252,\r\n    subs: [ [Object], [Object] ],\r\n    hash: '<hash>',\r\n    __v: 0\r\n  },\r\n  {\r\n    _id: 5ef4c738e491b7299d236251,\r\n    subs: [],\r\n    hash: '<hash>',\r\n    __v: 0\r\n  },\r\n  {\r\n    _id: 5ef4c738e491b7299d236250,\r\n    subs: [],\r\n    hash: '<hash>',\r\n    __v: 0\r\n  },\r\n```\r\n\r\n\r\n**What is the expected behavior?**\r\nAccording to [docs](https://mongoosejs.com/docs/api/model.html#model_Model.populate) I understand that the returned documents should **each** hold exactly two subDocument objects.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nMongoose: 5.9.20\r\nNode: v12.13.1\r\nMongoDB: v4.2.8\r\n"},{"labels":["bug"],"text":"\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nbug\r\n\r\n**What is the current behavior?**\r\nUpdate operations (tested findOneAndUpdate & updateOne) store sub doc validation errors regardless of submitted options (storeSubdocValidationError:false), while .save() handles it properly.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nSee script:\r\n```javascript\r\nconst mongoose = require('mongoose');\r\n\r\nconst schemaOpts = {storeSubdocValidationError: false};\r\nconst innerSchema = mongoose.Schema({\r\n    name: {\r\n        type: String,\r\n        required: [true, 'Missing']\r\n    },\r\n    val: {\r\n        type: mongoose.Schema.Types.Mixed,\r\n        required: [true, 'Missing']\r\n    }\r\n}, schemaOpts);\r\n\r\nconst fieldSchema = mongoose.Schema({\r\n    subFieldName: {\r\n        type: [innerSchema]\r\n    }\r\n}, schemaOpts);\r\n\r\nconst parentSchema = mongoose.Schema({\r\n    parentFieldName: {\r\n        type: fieldSchema\r\n    }\r\n}, schemaOpts);\r\n\r\nconst templates = {\r\n    INVALID: {\r\n        parentFieldName:\r\n            {\r\n                subFieldName: [\r\n                    {}\r\n                ]\r\n            }\r\n    },\r\n    VALID: {\r\n        parentFieldName:\r\n            {\r\n                subFieldName: [\r\n                    {\r\n                        name: 'testName',\r\n                        val: 'testVal'\r\n                    }\r\n                ]\r\n            }\r\n    }\r\n};\r\n\r\nconst main = async () => {\r\n    const connectionString = % YOUR CONNECTION STRING %;\r\n    const connOpts = {\r\n        % YOUR CONNECTION OPTIONS %\r\n    };\r\n    console.log('Connecting...');\r\n    const db = await mongoose.createConnection(connectionString, connOpts);\r\n\r\n    const modelName = % YOUR MODEL NAME %;\r\n    const Parent = db.model(modelName, parentSchema, modelName);\r\n\r\n    console.log('Creating...');\r\n    let doc;\r\n    try {\r\n        doc = await new Parent(templates.INVALID).save();\r\n    } catch (err) {\r\n        const found = Object.keys(err.errors);\r\n        console.error(`Bad fields when creating (${found.length}): ${found}`);\r\n\t//Output: Bad fields when creating (2): parentFieldName.subFieldName.0.val,parentFieldName.subFieldName.0.name\r\n    }\r\n\r\n    doc = await new Parent(templates.VALID).save();\r\n    console.log('Updating...');\r\n    try {\r\n        const updateResult = await Parent.findOneAndUpdate({_id: doc._id}, {$set: templates.INVALID}, {new: true, runValidators: true, fields: {_id: 0}, context: 'query'}).exec();\r\n    } catch (err) {\r\n        const found = Object.keys(err.errors);\r\n        console.error(`Bad fields when updating (${found.length}): ${found}`);\r\n\t//Output: Bad fields when updating (3): parentFieldName.subFieldName.0.val,parentFieldName.subFieldName.0.name,parentFieldName\r\n    }\r\n\r\n    console.log('Done');\r\n};\r\n\r\nmain();\r\n```\r\n**What is the expected behavior?**\r\nMongoose should only return return unique validation errors rather than one for the sub doc and one for the doc.\r\n\r\nWhen debugging the src it seems like the issue is associated with the fact in lib/document.js #validatePath(), schemaType  is of the actual field it's currently validating (i.e \"name\" / \"val\" in the attached example).  \r\nWhen using .save(), the schemaType is of the 'parentFieldName' which can then use the storeSubdocValidationError option.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nMongoose: 5.9.20\r\nNodeJS 12.13.0\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?** *bug*\r\n\r\n**What is the current behaviour?**\r\n\r\nWhen setting value on a mixed schema when the only change is number=>string or string=>number with the same value, e.g. \"1\" => 1 or 1 => \"1\" the change is not detected.\r\n\r\n```typescript\r\nimport * as Mongoose from 'mongoose'\r\nimport * as Assert from 'assert'\r\n\r\ninterface IDoc extends Mongoose.Document {\r\n    obj: {\r\n        key: string | number\r\n    }\r\n}\r\n\r\nasync function main() {\r\n    const schema = new Mongoose.Schema({\r\n        obj: {},\r\n    })\r\n\r\n    const Model = Mongoose.model<IDoc>('tmp', schema);\r\n\r\n    const doc = await Model.create({\r\n        obj: {\r\n            key: '1',\r\n        },\r\n    });\r\n    Assert.strictEqual(\r\n        (await Model.findById(doc)).toObject().obj.key,\r\n        '1'\r\n    );\r\n\r\n    doc.obj = {\r\n        key: '2'\r\n    };\r\n    await doc.save();\r\n    Assert.strictEqual(\r\n        (await Model.findById(doc)).toObject().obj.key,\r\n        '2'\r\n    );\r\n\r\n    doc.obj = {\r\n        key: 2\r\n    };\r\n    // change is not detected, doc.modifiedPaths() is empty\r\n    await doc.save();\r\n    // this fails because '2' !== 2\r\n    Assert.strictEqual(\r\n        (await Model.findById(doc)).toObject().obj.key,\r\n        2\r\n    );\r\n}\r\n\r\nmain().catch((err) => {\r\n    console.error(err);\r\n    process.exit(1);\r\n});\r\n```\r\n\r\n**What is the expected behavior?**\r\nShould have detected the change.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nmongoose: 5.9.19\r\nmongodb: 3.5.9\r\nnode: 12.13.0"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nbulkWrite results in below error with **Mongoose: `v5.9.19`** but works fine with **Mongoose:  `v5.7.3`**\r\n\r\n`{ BulkWriteError: Updating the path 'channel' would create a conflict at 'channel'\r\n  name: 'BulkWriteError',\r\n  driver: true,\r\n  code: 40,\r\n  writeErrors: [ WriteError { err: [Object] } ],\r\n  result:\r\n   BulkWriteResult {\r\n     result:\r\n      { ok: 1,\r\n        writeErrors: [Array],\r\n        writeConcernErrors: [],\r\n        insertedIds: [],\r\n        nInserted: 0,\r\n        nUpserted: 0,\r\n        nMatched: 0,\r\n        nModified: 0,\r\n        nRemoved: 0,\r\n        upserted: [] } } }`\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\n```javascript\r\nconst mongoose = require('mongoose');\r\nmongoose.set('debug', true);\r\n\r\nconst connectionString = 'mongodb://localhost:27017/test_db';\r\nconst { Schema } = mongoose;\r\nconsole.log('version:: ', mongoose.version)\r\nrun()\r\n    .then(() => console.log('done'))\r\n    .catch(error => console.error(error))\r\n    .finally(() => {\r\n        process.exit(1)\r\n    })\r\n\r\nasync function run() {\r\n    await mongoose.connect(connectionString);\r\n    await mongoose.connection.dropDatabase();\r\n\r\n    const schema = new Schema(\r\n        {\r\n            name: {\r\n                type: String,\r\n            },\r\n            isActive: {\r\n                type: Boolean,\r\n                default: true\r\n            },\r\n            channel: [{ type: Number }],\r\n            isSoftDeleted: {\r\n                type: Boolean,\r\n                default: false\r\n            }\r\n        },\r\n        {\r\n            timestamps: true\r\n        }\r\n    )\r\n    const M = mongoose.model('Test', schema);\r\n\r\n    const persons = [{ name: 'Test1', isActive: false, channel: [11] },\r\n    { name: 'Test2', isActive: false }]\r\n    const ops = persons.map(person => {\r\n        return {\r\n            updateOne: {\r\n                filter: { name: person.name, isSoftDeleted: false },\r\n                update: person,\r\n                upsert: true,\r\n                setDefaultsOnInsert: true\r\n            }\r\n        }\r\n    })\r\n   await M.bulkWrite(ops);\r\n}\r\n```\r\n**What is the expected behavior?**\r\nthe bulk operation should be executed.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nNode: v10.15.3\r\nMongoDB: v4.0.9\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n\r\n**Note: One thing I observed is if `timestamps:true` is removed from schema then bulk write operation works fine in Mongoose: v5.9.19**\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n\r\n**What is the current behavior?**\r\nWe have a schema with (1) nested documents, which (2) use discriminators, and where (3) some of the discriminated types uses a `refPath`. When using `Model.find()`, these references are **not populated**, whereas when getting a **single** document with e.g. `Model.findById()`, the references are properly populated.\r\n\r\n(probably related and/or regressions of earlier filed tickets #8837, #8731)\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```typescript\r\nimport mongoose from 'mongoose';\r\n\r\nbeforeAll(async () => mongoose.connect(process.env.MONGO_URL as string));\r\n\r\nafterAll(async () => mongoose.disconnect());\r\n\r\ndescribe('Mongoose array populate issue with refPath', () => {\r\n  let Model: any;\r\n  let doc2: any;\r\n\r\n  beforeAll(async () => {\r\n    const nested = new mongoose.Schema(\r\n      {\r\n        // nothing here\r\n      },\r\n      { discriminatorKey: 'type' }\r\n    );\r\n\r\n    const mySchema = new mongoose.Schema({\r\n      title: { type: String },\r\n      items: [nested]\r\n    });\r\n\r\n    const itemType = mySchema.path('items') as mongoose.Schema.Types.DocumentArray;\r\n\r\n    itemType.discriminator(\r\n      'link',\r\n      new mongoose.Schema({\r\n        fooType: { type: String },\r\n        foo: {\r\n          type: mongoose.Schema.Types.ObjectId,\r\n          refPath: 'items.fooType' // this fails\r\n          // ref: 'testModel' // this works\r\n        }\r\n      })\r\n    );\r\n\r\n    Model = mongoose.model<any>('testModel', mySchema);\r\n    const doc1 = await Model.create({ title: 'doc1' });\r\n    doc2 = await Model.create({\r\n      title: 'doc2',\r\n      items: [\r\n        {\r\n          type: 'link',\r\n          fooType: 'testModel',\r\n          foo: doc1._id\r\n        }\r\n      ]\r\n    });\r\n  });\r\n\r\n  it('populates when using `find()`', async () => {\r\n    const docs = await Model.find({}).sort({ title: 1 }).populate('items.foo').exec();\r\n    expect(docs[1].items[0].foo.title).toEqual('doc1');\r\n  });\r\n\r\n  it('populates when using `findOne()`', async () => {\r\n    const doc = await Model.findById(doc2._id).populate('items.foo').exec();\r\n    expect(doc.items[0].foo.title).toEqual('doc1');\r\n  });\r\n});\r\n```\r\n\r\n**What is the expected behavior?**\r\nBoth tests should pass and the `foo` property should be properly populated.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n* Mongoose 5.9.19\r\n* NodeJS v12.1.0\r\n* MongoDB 3.6.7\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\na bug\r\n**What is the current behavior?**\r\nWhen an embed object is defined as a nested schema then everything is fine and an array of object ids populates an array of objects that ids belong to. But when it's defined through a discriminator then it returns the first item instead of an array of them\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n```js\r\nconst mongoose = require('mongoose');\r\nconst Promise = require('bluebird');\r\n\r\nconst {Schema} = mongoose;\r\n\r\nconst ContentSchema = new Schema({\r\n    name: String\r\n});\r\n\r\nconst Content = mongoose.model('Content', ContentSchema);\r\n\r\nconst DataSchema = new Schema({\r\n    alias: String\r\n}, {\r\n    discriminatorKey: 'type'\r\n});\r\n\r\nconst ContentRelationSchema = new Schema({\r\n    content: [{type: Schema.Types.ObjectId, ref: 'Content'}]\r\n});\r\n\r\nconst PageSchema = new Schema({\r\n    name: String,\r\n    data: [DataSchema]\r\n});\r\n\r\nPageSchema.path('data').discriminator('content', ContentRelationSchema);\r\n\r\nconst Page = mongoose.model('Page', PageSchema);\r\n\r\nmongoose\r\n    .connect('mongodb://127.0.0.1:27017/test', {\r\n        useNewUrlParser: true,\r\n        promiseLibrary: Promise,\r\n        useUnifiedTopology: true,\r\n    })\r\n    .then(async () => {\r\n        const [contentA, contentB] = await Promise.all([\r\n            Content.create({ name: 'A' }),\r\n            Content.create({ name: 'B' }),\r\n        ]);\r\n\r\n        const { _id } = await Page.create({\r\n            name: 'Index',\r\n            data: [{\r\n                alias: 'my_content',\r\n                type: 'content',\r\n                content: [contentA, contentB]\r\n            }]\r\n        });\r\n\r\n        const page = await Page.findById(_id);\r\n        console.log(page.data[0].content); // [\"5eeb3e07148282899210d9c8\",\"5eeb3e07148282899210d9c9\"]\r\n\r\n        await page.populate('data.content').execPopulate();\r\n        console.log(page.data[0].content); // { _id: 5eeb3e07148282899210d9c8, name: 'A', __v: 0 }\r\n\r\n    })\r\n    .catch(console.log)\r\n    .finally(() => mongoose.connection.close())\r\n\r\n```\r\n**What is the expected behavior?**\r\nThe population of arrays should return an array\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\n- node: 10.16.0\r\n- mongoose: 5.9.19\r\n- mongoDB: 4.2.8\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBug\r\n\r\n**What is the current behavior?**\r\n\r\nWhen using an embedded discriminator, schema validation seems to fail when using the `tiedValue` parameter when defining the discriminator.\r\n\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n```js\r\n\"use strict\";\r\nconst mongoose = require(\"mongoose\");\r\nconst { Schema } = mongoose;\r\nconst assert = require(\"assert\");\r\n\r\nmongoose.set(\"debug\", true);\r\n\r\nrun()\r\n  .then(process.exit)\r\n  .catch(console.error);\r\n\r\nasync function run() {\r\n  await mongoose.connect(\r\n    \"mongodb://localhost:27017,localhost:27018,localhost:27019/test?replicaSet=rs\",\r\n    {\r\n      useNewUrlParser: true,\r\n      useUnifiedTopology: true,\r\n    },\r\n  );\r\n\r\n  await mongoose.connection.dropDatabase();\r\n  var eventSchema = new Schema(\r\n    { message: String },\r\n    { discriminatorKey: \"kind\", _id: false },\r\n  );\r\n\r\n  var batchSchema = new Schema({ events: [eventSchema] });\r\n\r\n  // `batchSchema.path('events')` gets the mongoose `DocumentArray`\r\n  var docArray = batchSchema.path(\"events\");\r\n\r\n  // The `events` array can contain 2 different types of events, a\r\n  // 'clicked' event that requires an element id that was clicked...\r\n  var clickedSchema = new Schema(\r\n    {\r\n      element: {\r\n        type: String,\r\n        required: true,\r\n      },\r\n      elementArray: {\r\n        type: [String],\r\n        required: false,\r\n      },\r\n    },\r\n    { _id: false },\r\n  );\r\n  // Make sure to attach any hooks to `eventSchema` and `clickedSchema`\r\n  // **before** calling `discriminator()`.\r\n  var Clicked = docArray.discriminator(\"Clicked\", clickedSchema, \"click\");\r\n\r\n  // ... and a 'purchased' event that requires the product that was purchased.\r\n  var Purchased = docArray.discriminator(\r\n    \"Purchased\",\r\n    new Schema(\r\n      {\r\n        product: {\r\n          type: String,\r\n          required: true,\r\n        },\r\n      },\r\n      { _id: false },\r\n    ),\r\n    \"purchase\",\r\n  );\r\n\r\n  var Batch = mongoose.model(\"EventBatch\", batchSchema);\r\n\r\n  // Create a new batch of events with different kinds\r\n  var batch = {\r\n    events: [\r\n      { kind: \"click\", element: \"#hero\", message: \"hello\" },\r\n      { kind: \"purchase\", product: \"action-figure-1\", message: \"world\" },\r\n    ],\r\n  };\r\n\r\n  await Batch.create(batch);\r\n\r\n  mongoose.set(\"debug\", true);\r\n\r\n  await Batch.updateOne(\r\n    { events: { $elemMatch: { kind: \"click\", element: \"#hero\" } } },\r\n    { \"events.$.elementArray\": [\"test\"] },\r\n    { strict: \"throw\" }, // change to false and it works\r\n  );\r\n\r\n  const results = await Batch.find()\r\n    .lean()\r\n    .exec();\r\n  console.dir(JSON.stringify(results), { depth: 1000 });\r\n}\r\n```\r\n\r\nResults in error:\r\n\r\n```\r\nStrictModeError: Field `events.$.elementArray` is not in schema and strict mode is set to throw.\r\n```\r\n\r\n**What is the expected behavior?**\r\n\r\nShould not throw, and should not need disabling strict mode. With the default strict setting of enabled, the update will just silently fail.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nMongoose 5.9.16\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n\r\nNote that without `tiedValue` it works properly as described here: https://github.com/Automattic/mongoose/issues/9093\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?** Bug\r\n\r\n**What is the current behavior?** If the `timestamps` property is targeting a nested object in the schema, any updates to the aforementioned object fail with `ConflictingUpdateOperators` error.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.** Code attached below.\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\n**What is the expected behavior?** It should be able to update the object\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\n| Software | Version |\r\n|-|-|\r\n| NodeJS | 12.18.0 |\r\n| mongoose | 5.9.18 |\r\n| mongodb | 4.2.6 |\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n\r\n<details>\r\n<summary>Minimal code to reproduce bug</summary>\r\n\r\n```js\r\nconst mongoose = require(\"mongoose\");\r\n\r\nconst SampleSchema = new mongoose.Schema(\r\n  {\r\n    someComplexObject: {\r\n      someProperty: String,\r\n    },\r\n  },\r\n  {\r\n    timestamps: {\r\n      updatedAt: \"someComplexObject.timestamp\",\r\n    },\r\n  }\r\n);\r\n\r\nconst model = mongoose.model(\"SampleModel\", SampleSchema);\r\n\r\n(async () => {\r\n  // Connect to database\r\n  await mongoose.connect(\"mongodb://localhost:27017/dummy\", {\r\n    useNewUrlParser: true,\r\n    useUnifiedTopology: true,\r\n    useFindAndModify: false,\r\n  });\r\n\r\n  // Insert a dummy value to the db\r\n  const createResult = await model.create({\r\n    someComplexObject: {\r\n      someProperty: \"someValue\",\r\n    },\r\n  });\r\n\r\n  try {\r\n   // Try to update the same nested object\r\n    const updateResult = await model.findByIdAndUpdate(createResult.id, {\r\n      someComplexObject: {\r\n        someProperty: \"updatedString\",\r\n      },\r\n    });\r\n  // Should log the result here\r\n    console.log(\"Result\", updateResult);\r\n  } catch (error) {\r\n  // Instead throws the error here\r\n    console.error(error);\r\n  } finally {\r\n    await mongoose.disconnect();\r\n  }\r\n})();\r\n```\r\n\r\n</details>\r\n\r\n<details>\r\n<summary>Error</summary>\r\n\r\n```\r\nMongoError: Updating the path 'someComplexObject' would create a conflict at 'someComplexObject'\r\n    at MessageStream.messageHandler (/mongoose-issue/node_modules/mongodb/lib/cmap/connection.js:261:20)\r\n    at MessageStream.emit (events.js:315:20)\r\n    at processIncomingData (/mongoose-issue/node_modules/mongodb/lib/cmap/message_stream.js:144:12)\r\n    at MessageStream._write (/mongoose-issue/node_modules/mongodb/lib/cmap/message_stream.js:42:5)\r\n    at doWrite (_stream_writable.js:403:12)\r\n    at writeOrBuffer (_stream_writable.js:387:5)\r\n    at MessageStream.Writable.write (_stream_writable.js:318:11)\r\n    at Socket.ondata (_stream_readable.js:717:22)\r\n    at Socket.emit (events.js:315:20)\r\n    at addChunk (_stream_readable.js:295:12)\r\n    at readableAddChunk (_stream_readable.js:271:9)\r\n    at Socket.Readable.push (_stream_readable.js:212:10)\r\n    at TCP.onStreamRead (internal/stream_base_commons.js:186:23) {\r\n  ok: 0,\r\n  code: 40,\r\n  codeName: 'ConflictingUpdateOperators'\r\n}\r\n```\r\n</details>\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug.\r\n\r\n**What is the current behavior?**\r\nVirtual setters cannot use `doc.$locals` on `new MyModel({ myVirtual: 'someValue' })` since `doc.$locals` doesn't get initialized until after the setters have been called.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nhttps://gist.github.com/ryankeener/4949e0c90eb73d56f6cad9a822d635e4\r\n\r\n**What is the expected behavior?**\r\nVirtual setters should be able to utilize `$locals` on `new`.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nmongoose: `5.9.10`\r\nnode: `v12.16.2`\r\n\r\n\r\nI tried moving https://github.com/Automattic/mongoose/blob/master/lib/document.js#L161 to the top of the constructor and it resolved my issue but I'm unsure of whether that's the best solution.\r\n\r\nThe example gist is simplified to show the effect but the 'why' of this is that I have a document on which I'd like to set fields `key` & `version` indirectly via a virtual, i.e. `doc.myVirtual = 'someKey@1'`. Later (validation/pre-save) I do an async call against another collection to find the latest `@1` version (e.g. `1.1.0`) and then set `doc.version= '1.1.0'; doc.key='someKey'`. "},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBug\r\n\r\n**What is the current behavior?**\r\n\r\nWhen defining an index on a nested discriminator, mongoose knows to change the paths and apply the index on the parent, while properly locating the correct fields within the nested subdocument.\r\n\r\nHowever, the `partialFilterExpression` is not transformed properly.\r\n\r\nHere's an example:\r\n\r\n![image](https://user-images.githubusercontent.com/697707/83761966-ac4ce780-a67f-11ea-8d7e-097b53d9491b.png)\r\n\r\nThe index is defined like this and is part of an embedded schema (child of a parent schema): \r\n```\r\n  { matchday: 1, team: 1, \"players.user\": 1 },\r\n  {\r\n    unique: true,\r\n    partialFilterExpression: { \"players.user\": { $exists: 1 } },\r\n  },\r\n```\r\n\r\nNotice how the indexed fields correctly got nested under `invites`, but the `partialFilterExpression` was not updated.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\nDefine an index like the above.\r\n\r\n**What is the expected behavior?**\r\n\r\nThe `partialFilterExpression` should be adjusted to point to the correct sub-paths. In the screenshot above, the computed result should be `invites.players.user: { $exists: 1 }`.\r\n\r\nFixing this could be a breaking change if someone is relying on the currently broken behavior.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nmongoose 5.9.16\r\n"},{"labels":["bug"],"text":"Hi! I upgraded mongoose from 5.9.9 to 5.9.16 and I noticed that mongoose is validating documents over old setted values.\r\n\r\nFor example, I have a model with a field like this:\r\n\r\n```\r\n...\r\ntags: [ { type: mongoose.Schema.Types.ObjectId, required: true, ref: 'Tag' } ],\r\n...\r\n```\r\n\r\nIf I do this:\r\n```\r\ndocument.tags = [\"hey\"];\r\ndocument.tags = [];\r\nawait document.save();\r\n```\r\nI will get an error like this:\r\n`Article validation failed: tags.0: Cast to ObjectId failed for value \"hey\" at path \"tags\", tags: Cast to Array failed for value \"[ 'hey' ]\" at path \"tags\"`\r\n\r\nI don't know much about mongoose internals. What might be happening?"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n**What is the current behavior?**\r\n```\r\nTypeError: value.validate is not a function\r\n    at /Users/gilles/Documents/omni/poc-mongoose/node_modules/mongoose/lib/schema/SingleNestedPath.js:254:11\r\n    at SingleNestedPath.SchemaType.doValidate (/Users/gilles/Documents/omni/poc-mongoose/node_modules/mongoose/lib/schematype.js:1102:12)\r\n    at SingleNestedPath.doValidate (/Users/gilles/Documents/omni/poc-mongoose/node_modules/mongoose/lib/schema/SingleNestedPath.js:246:35)\r\n    at /Users/gilles/Documents/omni/poc-mongoose/node_modules/mongoose/lib/document.js:2378:18\r\n    at processTicksAndRejections (internal/process/task_queues.js:75:11)\r\n```\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n\r\n```javascript\r\nconst mongoose = require('mongoose')\r\n\r\nconst TabSchema = new mongoose.Schema({ windowId: Number }, { _id: false })\r\n\r\nconst MainSchema = new mongoose.Schema(\r\n  { run: { tab: TabSchema } },\r\n  { timestamps: true, discriminatorKey: `type` },\r\n)\r\n\r\nconst Main = mongoose.model(`Main`, MainSchema)\r\n\r\nconst DiscriminatorSchema = new mongoose.Schema(\r\n  { run: {} },\r\n  { discriminatorKey: `type` },\r\n)\r\n\r\nMain.discriminator(`copy`, DiscriminatorSchema)\r\n\r\nMain.insertMany([\r\n  {\r\n    run: { tab: { id: 2319 } },\r\n    type: 'copy',\r\n  },\r\n])\r\n\r\n```\r\nNote that we do not even need to connect because the error occured before. In real life I have the connection of course but I did not need it for the repro steps\r\n\r\n**What is the expected behavior?**\r\nInserting multiple document\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nmongoose: 5.9.15\r\nnode: v12.13.0"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n**What is the current behavior?**\r\nPassing undefined as a value to a key in a embedded document causes Mongoose to first set the key to its default value and then to overwrite it with undefined\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```javascript\r\nit('Sets default when passing undefined as value for a key in a nested subdoc (gh-9039)', function () {\r\n  const Test = db.model('Test', {\r\n    nested: {\r\n      prop: {\r\n        type: String,\r\n        default: 'some default value'\r\n      }\r\n    }\r\n  });\r\n\r\n  return co(function* () {\r\n    const doc = yield Test.create({ nested: { prop: undefined } });\r\n    assert.equal(doc.nested.prop, 'some default value');\r\n  });\r\n});\r\n```\r\n\r\n**What is the expected behavior?**\r\nSee the provided test\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nNode: 14.2.0\r\nMongoose: 5.9.15\r\nMongoDB: 3.6.17"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nReport a bug\r\n\r\n**What is the current behavior?**\r\n- When using `bulkWrite` for `updateOne` / `updateMany`, it does not honors data type for timestamps.\r\n- According to docs, a timestamp can be stored as an `ISODate` (Default) or an epoch timestamp (via setting the timestamp field as `Number`).\r\n- Mongoose does honors this requirement when using standard `updateOne` / `updateMany` operations, but fails and reverts back to `ISODate` when using same operation via `bulkWrite`\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\n```js\r\n// mongoose v5.9.15\r\n// mongodb v4.0.4\r\n\r\nconst mongoose = require('mongoose');\r\nconst Schema = mongoose.Schema;\r\nconst assert = require('assert');\r\n\r\n// connection\r\nmongoose.set('debug', true);\r\nmongoose.Promise = global.Promise;\r\nmongoose.connect('mongodb://localhost:27017/sandbox', {\r\n  useNewUrlParser: true,\r\n  useUnifiedTopology: true\r\n});\r\n\r\n// model\r\nconst UserSchema = new Schema({\r\n  name: String,\r\n  created_at: Number,\r\n  updated_at: Number,\r\n}, {\r\n  timestamps: {\r\n    createdAt: 'created_at',\r\n    updatedAt: 'updated_at',\r\n  },\r\n});\r\nconst User = mongoose.model('User', UserSchema);\r\n\r\n// operation\r\nasync function run() {\r\n  await User.deleteMany();\r\n  const userInitialTimestamp = Date.now();\r\n\r\n  const user1 = await User.create({name: 'user1'});\r\n\r\n  assert(user1 instanceof User);\r\n  assert(typeof user1.updated_at === 'number');\r\n  assert(user1.updated_at > userInitialTimestamp);\r\n\r\n  await User.updateOne({\r\n    _id: user1._id,\r\n  }, {\r\n    $set: {\r\n      name: 'userAnother1',\r\n    },\r\n  });\r\n\r\n  // works!\r\n  // the actual POJO object still has epoch timestamp for updated_at field\r\n  const userAnother1 = await User.findById(user1._id).lean();\r\n  assert(!(userAnother1 instanceof User));\r\n  assert(userAnother1.name === 'userAnother1');\r\n  assert(typeof userAnother1.updated_at === 'number');\r\n  assert(userAnother1.updated_at > user1.updated_at);\r\n\r\n  await User.bulkWrite([{\r\n    updateOne: {\r\n      filter: {\r\n        _id: user1._id,\r\n      },\r\n      update: {\r\n        $set: {\r\n          name: 'userAnother2',\r\n        },\r\n      },\r\n    },\r\n  }]);\r\n  // bulkwrite won't honor the data type for update_at field\r\n  // sends ISODate over the wire instead of epoch timestamp (check debug)\r\n\r\n  // this will still work!\r\n  // mongoose will convert the ISODate to epoch timestamp\r\n  const userAnother2 = await User.findById(user1._id);\r\n  assert(userAnother2 instanceof User);\r\n  assert(userAnother2.name === 'userAnother2');\r\n  assert(typeof userAnother2.updated_at === 'number');\r\n  assert(userAnother2.updated_at > userAnother1.updated_at);\r\n\r\n  // but this wont!\r\n  // because actual value stored is ISODate, not epoch timestamp anymore\r\n  const userAnother3 = await User.findById(user1._id).lean();\r\n  assert(!(userAnother3 instanceof User));\r\n  assert(userAnother3.name === 'userAnother2');\r\n  assert(typeof userAnother3.updated_at === 'number');\r\n  assert(userAnother3.updated_at > userAnother1.updated_at);\r\n}\r\n\r\nrun()\r\n  .catch(error => console.error(error.stack))\r\n  .finally(async () => {\r\n    await mongoose.connection.close();\r\n  });\r\n```\r\n\r\n**What is the expected behavior?**\r\n\r\nMongoose should have stored epoch timestamp instead of ISODate when `bulkWirte` was run.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\n- Mongoose - 5.9.15\r\n- MongoDb - 4.0.4\r\n- Node - 10.14.1\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nEmbedded object not saving subdocuments when using .save() method\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nWrite an entry to DB with:\r\n```javascript\r\nconst customerDb = await new Customer({\r\n      _id: objectId(),\r\n      userId,\r\n      customerId: customer.id,\r\n      card: { brand: customer.card.brand, last4: customer.card.last4 },\r\n      subscription: { id, status, plan: items.data[0].plan.id, current_period_end },\r\n    }).save()\r\n```\r\nthe _id, userId, and customerId write to the database perfectly. However, there is no 'card' or 'subscription' object. Seemingly just skips them:\r\n\r\n```javascript\r\n_id: \"5ebf61788173562c701bd3d9\"\r\nuserId: \"5ebf616d8173562c7020eb83\"\r\ncustomerId: \"cus_HHxd3f8RPKEZXR\"\r\n```\r\n**What is the expected behavior?**\r\nWrite an entry to DB with:\r\n```javascript\r\nconst customerDb = await new Customer({\r\n      _id: objectId(),\r\n      userId,\r\n      customerId: customer.id,\r\n      card: { brand: customer.card.brand, last4: customer.card.last4 },\r\n      subscription: { id, status, plan: items.data[0].plan.id, current_period_end },\r\n    }).save()\r\n```\r\n\r\nExpected Output:\r\n```javascript\r\n_id: \"5ebf61788173562c701bd3d9\"\r\nuserId: \"5ebf616d8173562c7020eb83\"\r\ncustomerId: \"cus_HHxd3f8RPKEZXR\"\r\ncard: {\r\nname: \"VISA\",\r\nlast4: \"1234\"\r\n}\r\nsubscription: {\r\nid: \"sub_123123\"\r\nstatus: \"active\"\r\nplan: \"plan_123123123\"\r\ncurrent_period_end: 1589777662\r\n}\r\n```\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nNode version: 12.13.1\r\nMongoDB: 3.5.5\r\nMongoose version: When the bug was occurring, i was using ^5.9.9. I rolled back to 5.9.7 and it's now working.\r\n\r\nHere is the Model:\r\n```javascript\r\nimport mongoose from \"mongoose\";\r\nimport objectId from \"../utils/generateObject\";\r\n\r\nconst { ObjectId, Number, String } = mongoose.Schema.Types;\r\n\r\nconst CustomerSchema = new mongoose.Schema(\r\n  {\r\n    _id: {\r\n      type: String,\r\n      default: objectId()\r\n    },\r\n    userId: {\r\n      type: String,\r\n    },\r\n    customerId: {\r\n      type: String,\r\n      required: false\r\n    },\r\n    'card.brand': {\r\n      type: String,\r\n      required: false\r\n    },\r\n    'card.last4': {\r\n      type: String,\r\n      required: false\r\n    },\r\n    'subscription.id': {\r\n      type: String,\r\n      required: false\r\n    },\r\n    'subscription.status': {\r\n      type: String,\r\n      enum: ['active', 'cancelling', 'canceled', 'none', 'trialing'],\r\n      required: false\r\n    },\r\n    'subscription.plan': {\r\n      type: String,\r\n      required: false\r\n    },\r\n    'subscription.current_period_end': {\r\n      type: Number,\r\n      required: false\r\n    }\r\n  }, {collection: \"Customers\"});\r\n\r\nexport default mongoose.models.Customer || mongoose.model(\"Customer\", CustomerSchema);\r\n```"},{"labels":["bug"],"text":"This is almost the same issue as #8399 (root cause seems to be #8356).\r\n\r\nHere is a repro:\r\n\r\n```javascript\r\nconst MyModel = db.model('Test', Schema({\r\n  myArray: [{ name: String }]\r\n}));\r\n\r\nconst doc = new MyModel({\r\n  myArray: [{ name: 'b' }, { name: 'c' }]\r\n});\r\nlet myArray = doc.myArray;\r\n\r\nmyArray = myArray.map(val => ({ name: `${val.name} mapped` }));\r\n\r\nmyArray.unshift({ name: 'a inserted' });\r\n\r\nassert.deepEqual(myArray.map(v => v.name), [\r\n  'a inserted',\r\n  'b mapped',\r\n  'c mapped'\r\n]);\r\n```\r\n\r\nI'll create a PR in a minute for this issue."},{"labels":["bug"],"text":"I don't know whether this is a \"bug\" or a \"what else did you expect to happen?\", but I'll report it just in case...\r\n\r\nWith the following code:\r\n```javascript\r\nconst mongoose = require('mongoose');\r\nmongoose.set('debug', true);\r\nconst connectionString = \"mongodb://localhost:27017/dummy\";\r\nconst {Schema} = mongoose;\r\n\r\nasync function run() {\r\n    await mongoose.connect(connectionString);\r\n    await mongoose.connection.dropDatabase();\r\n\r\n    const childSchema = new Schema({\r\n        values: [Number]\r\n    });\r\n\r\n    const parentSchema = new Schema({\r\n        children: [childSchema],\r\n    });\r\n\r\n    const Parent = mongoose.model('Parent', parentSchema);\r\n    await Parent.create({\r\n            children: [\r\n                {values: [1, 2, 3]},\r\n                {values: [4, 5, 6]}\r\n            ]\r\n    });\r\n\r\n    const parent = await Parent.findOne();\r\n\r\n    const slicedCopy = parent.children[0].values.slice(0);\r\n    const deepCopy = JSON.parse(JSON.stringify(parent.children[0].values));\r\n\r\n    slicedCopy.splice(0);\r\n\r\n    try {\r\n        await parent.save();\r\n    } catch (e) {\r\n        console.error(\"Couldn't save parent:\\n\" + e);\r\n    }\r\n}\r\n\r\nrun().then(() => console.log(\"done\"))\r\n    .catch(e => console.log(\"Unexpected error: \" + e))\r\n    .finally(() => mongoose.connection.close());\r\n```\r\n\r\nI get an error when saving the parent:\r\n```\r\nMongoose: parents.insertOne({ _id: ObjectId(\"5ebfabaf6c72801b5bbcab2d\"), children: [ { values: [ 1, 2, 3 ], _id: ObjectId(\"5ebfabaf6c72801b5bbcab2e\") }, { values: [ 4, 5, 6 ], _id: ObjectId(\"5ebfabaf6c72801b5bbcab2f\") } ], __v: 0}, { session: null })\r\nMongoose: parents.findOne({}, { projection: {} })\r\nMongoose: parents.updateOne({ _id: ObjectId(\"5ebfabaf6c72801b5bbcab2d\"), __v: 0 }, { '$set': { 'children.{ values: [ 1, 2, 3 ], _id: 5ebfabaf6c72801b5bbcab2e }': [ undefined, undefined ] }, '$inc': { __v: 1 }}, { session: undefined })\r\ndone\r\nCouldn't save parent:\r\nMongoError: Cannot create field '{ values: [ 1, 2, 3 ], _id: 5ebfabaf6c72801b5bbcab2e }' in element {children: [ { values: [ 1, 2, 3 ], _id: ObjectId('5ebfabaf6c72801b5bbcab2e') }, { values: [ 4, 5, 6 ], _id: ObjectId('5ebfabaf6c72801b5bbcab2f') } ]}\r\n```\r\n\r\nI do not get this error if I replace `slicedCopy.splice(0)` with `deepCopy.splice(0)` or with `parent.children[0].values.splice(0)`.\r\n\r\nThe reason for this difference is that `.slice()` keeps the mongoose objects that have been added to the array (EmbeddedDocument, Schema, etc.), but `JSON.parse(JSON.stringify(...))` does not.\r\n\r\nI would (naively?) expect that calling `.slice()` on an array then modifying the copy itself should not cause mongoose to fail to save.\r\n\r\nMy versions are:\r\n * mongoose: 5.9.14\r\n * node: 12.16.3\r\n * mongodb: 4.2.6"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nSince #8521, collations are honored when using `Model.syncIndexes()`.  However, if an index specifies a `collation` option, `syncIndexes` will always drop and recreate even if no changes were made to the collation.  There are two reasons for this:\r\n\r\n1. Collations can be specified with a subset of all the allowed properties.  MongoDB will then default the remaining properties and those defaulted properties will be emitted by the database during the `listIndexes` operation.  These extra properties in the collation object from the database will cause the deep equality comparison performed by `isIndexEqual` to return `false` because the properties in the collation specified in the schema are only a subset of those returned from the db.\r\n2. Even if you specify every possible option for the collation, the deep equality comparison will still return `false`.  This is because the returned result from the DB operation adds a `version` property to the collation.  This is not configurable in the collation specification, so that comparison will always fail.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n* Add an index to any schema with a valid `collation` option specified.\r\n* Construct the model, allowing the index to be built.\r\n* Run `syncIndexes()` against the model.\r\n* The index will be dropped and recreated even if there aren't any changes to the collation.\r\n\r\n**What is the expected behavior?**\r\nAt the very least, the `version` property needs to be ignored and have the comparison only check those properties that can be [configured](https://docs.mongodb.com/manual/reference/collation/#collation-document).\r\n\r\nIdeally, if a property is not specified in the schema's index and the DB is returning a result that matches the [default ](https://docs.mongodb.com/manual/reference/collation-locales-defaults/#collation-default-parameters) for the collation, then it should also be treated as equal.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nNode: 10.19.0\r\nMongoose: 5.9.4 (although review of `master` branch indicates problem is still present)\r\nMongoDB: 4.0.9 Community\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nReport a bug\r\n\r\n**What is the current behavior?**\r\nWhen updating a document with`$push` or `$addToSet` onto a discriminator field, it doesn't not work. I have tried with `findOneAndUpdate`, `findByIdAndUpdate`, `updateOne` and `updateMany`. \r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n```js\r\nconst { connect, Schema, model } = require(\"mongoose\");\r\n\r\nconst personSchema = new Schema({\r\n  name: String,\r\n});\r\n\r\nconst Person = model(\"Person\", personSchema);\r\n\r\nPerson.discriminator(\r\n  \"Worker\",\r\n  Schema({\r\n    locations: [String],\r\n  })\r\n);\r\n\r\nconnect(\"mongodb://127.0.0.1:27017/test?gssapiServiceName=mongodb\", {\r\n  useNewUrlParser: true,\r\n  useUnifiedTopology: true\r\n}, async () => {\r\n  console.log(\"Database connected\")\r\n  const person = await Person.create(\r\n    {\r\n      __t: \"Worker\",\r\n      name: \"John\", \r\n      locations: [\"America\"],\r\n    },\r\n  )\r\n\r\n  console.log(person);\r\n\r\n  await Person.findByIdAndUpdate(\r\n    person._id,\r\n    {\r\n      $push: { locations: \"UK\" }, \r\n    },\r\n  )\r\n\r\n  const updated = await Person.findById(person._id);\r\n\r\n  console.log(updated);\r\n});\r\n```\r\nLogs (the document failed to update):\r\n```\r\nDatabase connected\r\n{\r\n  locations: [ 'America' ],\r\n  _id: 5eba65381c8ff1d0df0e7414,\r\n  __t: 'Worker',\r\n  name: 'John',\r\n  __v: 0\r\n}\r\n{\r\n  locations: [ 'America' ],\r\n  __t: 'Worker',\r\n  _id: 5eba65381c8ff1d0df0e7414,\r\n  name: 'John',\r\n  __v: 0\r\n}\r\n```\r\n\r\n**What is the expected behavior?**\r\nThe string `\"UK\"` should've been pushed onto the `locations` field of the document in the second log. \r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nMongoose: 5.9.13\r\nNode: v13.5.0\r\nMongodb: 4.0.8\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nReport a potential bug.\r\n\r\n**What is the current behavior?**\r\n\r\nIn version `^5.8.9` of mongoose error emitted after attempting to find a document using a malformatted (too short) ID contains field `error.kind` with value `\"ObjectId\"`. In version `^5.9.12` that I'm using the field is `undefined` in the same exact scenario.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\n`<someModel>.findById(<someTooShortID>)` throws an error not containing a field that was contained in an earlier version of mongoose, i. e. `error.kind`\r\n\r\n**What is the expected behavior?**\r\n\r\n`error.kind === \"ObjectId\"` should evaluate to `true` for the emitted error.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n\r\n`\"mongoose\": \"^5.9.12\"`"},{"labels":["bug"],"text":"Hi all,\r\n\r\ni', using latest Mongoose (5.9.12) with nodeJs 13.3.0 runnung on Ubuntu 18 on an AWS EC2 vps.\r\nI'm running a simple: \r\n`model.find({ownerId:'xx'}).where(filters)`\r\nwhere \"filters\" is a filter object.\r\n\r\nSuddendly, generally after a lot of positive queries, i get this exception:\r\n\r\n```\r\nTypeError: Cannot read property 'hasOwnProperty' of null\r\n0|CDS  |     at cast (/var/www/html/customerdata-service/node_modules/mongoose/lib/cast.js:36:11)\r\n0|CDS  |     at cast (/var/www/html/customerdata-service/node_modules/mongoose/lib/cast.js:60:18)\r\n0|CDS  |     at cast (/var/www/html/customerdata-service/node_modules/mongoose/lib/cast.js:60:18)\r\n0|CDS  |     at model.Query.Query.cast (/var/www/html/customerdata-service/node_modules/mongoose/lib/query.js:4718:12)\r\n0|CDS  |     at model.Query.<anonymous> (/var/www/html/customerdata-service/node_modules/mongoose/lib/query.js:2256:10)\r\n0|CDS  |     at model.Query._wrappedThunk [as _countDocuments] (/var/www/html/customerdata-service/node_modules/mongoose/lib/helpers/query/wrapThunk.js:16:8)\r\n0|CDS  |     at /var/www/html/customerdata-service/node_modules/kareem/index.js:369:33\r\n0|CDS  |     at processTicksAndRejections (internal/process/task_queues.js:79:11)\r\n```\r\nWhat it can be? Is it a common bug?\r\n\r\nIn \"cast.js\" file at row 36 i have this if statement:\r\n\r\n```\r\n// bson 1.x has the unfortunate tendency to remove filters that have a top-level\r\n  // `_bsontype` property. But we should still allow ObjectIds because\r\n  // `Collection#find()` has a special case to support `find(objectid)`.\r\n  // Should remove this when we upgrade to bson 4.x. See gh-8222, gh-8268\r\n  if (obj.hasOwnProperty('_bsontype') && obj._bsontype !== 'ObjectID') {\r\n    delete obj._bsontype;\r\n  }\r\n```"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug.\r\n\r\n**What is the current behavior?**\r\n`5.9.12`: https://github.com/Automattic/mongoose/commit/c04a50d591c6b778295f7e7e8a578695a43c5504 this commit breaks schemas previously worked.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\nUpgrading from 5.9.9 to 5.9.12 with following:\r\n```\r\nvar mongoose = require('mongoose');\r\nvar encrypt = require('mongoose-encrypt');\r\n\r\nvar accountSchema = new mongoose.Schema({\r\n  account: { type: mongoose.Schema.Types.ObjectId },\r\n  // status: { },\r\n  db: {\r\n    host: { type: String, default: '' },\r\n    name: { type: String, default: '' }\r\n  }\r\n});\r\n                                                                                    \r\n```\r\nAfter the patch level update, this causes process to crash.\r\n```\r\n /app/node_modules/mongoose/lib/schema.js:646\r\n    throw new Error('`' + firstPieceOfPath + '` may not be used as a schema pathname');\r\nError: `db` may not be used as a schema pathname\r\n```\r\n\r\n\r\n**What is the expected behavior?**\r\nMinor patch level bump should not break existing code.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\n```\r\nnpm ls mongoose mongodb\r\nâ””â”€â”¬ mongoose@5.9.12 \r\n  â””â”€â”€ mongodb@3.5.5  deduped\r\n$ node -v\r\nv12.16.2\r\n\r\n```\r\nMy solution in meantime is to pin version in package-lock.json, eager for advice.\r\nThis model is already shipped in software, and non-trivial to change the name.\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug, but maybe a feature\r\n**What is the current behavior?**\r\n\r\nI have Mongoose schema:\r\n```\r\nconst QuestionType = new mongoose.Schema({\r\n  code: { name: 'Type code', type: String, required: true, unique: true },\r\n  text: { name: 'Description of type', type: String, required: true },\r\n  questions: [{ type: mongoose.Types.ObjectId, ref: 'Question' }],\r\n}, { timestamps: true });\r\n```\r\n\r\nAnd I have an API for inserting question types:\r\n```\r\ndb[collection].insertMany(req.body, { ordered: false, rawResult: true }, (err, docs) => {\r\n\t\t\tif (err) return res.status(500).send({ ...handleError(err), writeErrors: err.writeErrors, docs: docs});\r\n\t\t\tif ('mongoose' in docs) {\r\n\t\t\t\treturn res.status(500).json(docs);\r\n\t\t\t}\r\n\t\t\treturn res.json(docs);\t\t\t\r\n});\r\n```\r\n\r\nAnd it's hard to describe in few sentences, what is wrong, because it seems to me that error handling is messed up.\r\n\r\nFor example, if my data is:\r\n`[{\"code\":\"MEDIUM\",\"text\":\"1111\"},{\"code\":\"test\",\"text\":\"222\"},{\"code\":\"HARD\",\"text\":\"2222\"}]`\r\nResponse is:\r\n`{\"error\":{\"title\":\"BulkWriteError\",\"code\":11000,\"message\":\"E11000 duplicate key error collection: game.questiontypes index: code_1 dup key: { code: \\\"MEDIUM\\\" }\"},\"writeErrors\":[{\"code\":11000,\"index\":0,\"errmsg\":\"E11000 duplicate key error collection: game.questiontypes index: code_1 dup key: { code: \\\"MEDIUM\\\" }\",\"op\":{\"questions\":[],\"_id\":\"5eb19d28e646883e3459ce07\",\"code\":\"MEDIUM\",\"text\":\"1111\",\"__v\":0,\"createdAt\":\"2020-05-05T17:06:48.409Z\",\"updatedAt\":\"2020-05-05T17:06:48.409Z\"}},{\"code\":11000,\"index\":2,\"errmsg\":\"E11000 duplicate key error collection: game.questiontypes index: code_1 dup key: { code: \\\"HARD\\\" }\",\"op\":{\"questions\":[],\"_id\":\"5eb19d28e646883e3459ce09\",\"code\":\"HARD\",\"text\":\"2222\",\"__v\":0,\"createdAt\":\"2020-05-05T17:06:48.410Z\",\"updatedAt\":\"2020-05-05T17:06:48.410Z\"}}]}`\r\n\r\nDocuments with **MEDIUM** and **HARD** code types exist, I will get errors for them, but I don't have any information about insterting **test** - no error, no data in **docs** callback parameter, but that one document was actually inserted.\r\n\r\nAnother option of strange behavior:\r\nif my data is `[{\"code\":\"MEDIUM\",\"text\":\"1111\"},{\"code\":\"test2\",\"text\":\"\"}`, I will get only one error - `{\"error\":{\"title\":\"BulkWriteError\",\"code\":11000,\"message\":\"E11000 duplicate key error collection: game.questiontypes index: code_1 dup key: { code: \\\"MEDIUM\\\" }\"}}` though I expect for at least two errors - no text parameter for second array value was provided.\r\n\r\n1) It looks like required fields validation runs only if **every duplicate** validation is correct \r\n2) created documents aren't passed to the callback function if any 'unique' validation error has appeared for array of inserting documents.\r\n3) WriteErrors appear on error object if number of errors is more than 1, though it would be nicer to place it if it's only one error either\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\n1) To have an API something like:\r\n```\r\napp.post('/createMany/QuestionType', (req, res) => {\r\n\t\tdb[collection].insertMany(req.body, { ordered: false, rawResult: true }, (err, docs) => {\r\n\t\t\tif (err) return res.status(500).send({ ...handleError(err), writeErrors: err.writeErrors, docs: docs });\r\n\t\t\tif ('mongoose' in docs) {\r\n\t\t\t\treturn res.status(500).json(docs);\r\n\t\t\t}\r\n\t\t\treturn res.json(docs);\t\t\t\r\n\t\t});\r\n});\r\n```\r\n2) Create at least 2 documents with it\r\n3) Try to create next combinations:\r\na) 1 duplicate, at least 1 new doc without required fields\r\nb) 2 duplicate, at least 1 new doc without required fields\r\nc) only new docs without required fields\r\nd) 1 duplicate, at least 1 new doc with required fields\r\n4) Behold the apocalypse for validation & errors! \r\n\r\n**What is the expected behavior?**\r\n\r\n1) Unified error object? At least mongoose validation for required fields should always run and return errors for those documents which passes mongo check for unique validation but not passes other mongoose validations\r\n2) Return of inserted documents should be correct (not the empty array, when in real case database is +n new valid documents)\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nnode: 13.1.0\r\nmongoose: 5.9.11\r\nmongodb: MongoDB 4.2.1 Community\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nUnable to save modified subdocuments if they are in a multidimensional array. Saving such a document throws an error.\r\n\r\nThe 'modified path' is missing one of the indices in the subdocument's path, and so saving throws an error because it is trying to set a property on an array which is unsupported in Mongo.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\n```js\r\nconst SubchildSchema = new mongoose.Schema({ title: String });\r\n\r\nconst ChildSchema = new mongoose.Schema({\r\n\tsubchilds: [[SubchildSchema]],\r\n});\r\n\r\nconst ParentModel = mongoose.model(\r\n\t'Parent',\r\n\t{ children: [ChildSchema] },\r\n);\r\n\r\nasync function repro() {\r\n\tawait mongoose.connect('mongodb://localhost:27017/test123');\r\n\r\n\tconst { _id } = await ParentModel.create({\r\n\t\tchildren: [\r\n\t\t\t{\r\n\t\t\t\tsubchilds: [\r\n\t\t\t\t\t[{}],\r\n\t\t\t\t],\r\n\t\t\t},\r\n\t\t],\r\n\t});\r\n\r\n\tconst parent = await ParentModel.findById(_id);\r\n\tparent.children[0].subchilds[0][0].title = 'foo';\r\n\treturn parent.save();\r\n}\r\n\r\nrepro()\r\n\t.catch(console.error)\r\n\t.finally(mongoose.disconnect);\r\n\r\n```\r\n\r\n`MongoError: Cannot create field 'title' in element {0: [ { _id: ObjectId('5eaf31d48ba42b1eddc904b8') } ]}`\r\n\r\nSeems the path calculated in `_markModified` in `core_array.js` is missing the index of the nested array. The path is \r\n`'parent.children.0.subchilds.0.title'` but should be `'parent.children.0.subchilds.0.0.title'`.\r\n\r\n\r\n\r\n**What is the expected behavior?**\r\n\r\nAble to save this subdocument update.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nNode: 12.16.3\r\nMongoose: 5.9.11\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?** Bug\r\n\r\n**What is the current behavior?**\r\n\r\nModel A has a subschema which it has a field marked as `select: false`. Model A projection doesn't respect its subschema and returns the whole subschema.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n\r\n```node\r\n// SubSchema\r\n{\r\n  firstName: {type: String, select: false},\r\n  lastName: {type: String}\r\n}\r\n\r\n// Model A\r\n{\r\n  username: {type: String},\r\n  subSchema: {type: SubSchema}\r\n}\r\n\r\n// Find one along with a projection\r\nModelA.findById(id, {username: false}).exec();\r\n\r\n// Expected result > { subSchema: { lastName: 'Lenon' } }\r\n// Actual result > { subSchema: { firstName: 'John', lastName: 'Lenon' } }\r\n```\r\n\r\n**What is the expected behavior?**\r\n\r\nFrom the sample above, returns `{ subSchema: { lastName: 'Lenon' } }`.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\n`MongoDB: 4.2.5`\r\n`Mongoose: 5.9.11`\r\n`Node.js: 12.10.0`\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"**BUG**\r\n\r\n**What is the current behavior?**\r\n\r\nDeep `strict: false` parameter not working on recent versions od mongoose. Schema-defined parameters are saved to DB, but additional parameters are not saved.\r\n\r\nWorking on mongoose 5.9.7\r\nNot working on mongoose 5.9.9 - 5.9.11\r\nCannot install 5.9.8 via npm and test\r\n\r\nSchema:\r\n\r\n```javascript\r\nconst {Schema} = mongoose;\r\n\r\nconst ContactSchema = new Schema({\r\n  email: {\r\n    type: Schema.Types.String,\r\n    required: false\r\n  },\r\n  phone: {\r\n    type: Schema.Types.String,\r\n    required: false\r\n  }\r\n},\r\n{\r\n  _id: false,\r\n  minimize: false,\r\n  strict: false\r\n});\r\n\r\nconst StoreSchema = new Schema({\r\n  contact: {\r\n    type: ContactSchema,\r\n    required: false\r\n  }\r\n},\r\n{\r\n  collection: 'stores',\r\n  timestamps: true,\r\n  minimize: false,\r\n  toObject: {getters: true, setters: true},\r\n  toJSON: {getters: true, setters: true},\r\n  runSettersOnQuery: true\r\n});\r\n```\r\n\r\n**What is the expected behavior?**\r\n\r\nExpected output as seen on 5.9.7\r\n```json\r\n{\r\n  \"_id\": \"5eae8b061fafaf013aebe75f\",\r\n  \"contact\": {\r\n    \"email\": \"1588497423609@example.com\",\r\n    \"phone\": \"1588497423609\",\r\n    \"instagram\": \"https://ig.com/1588497423609\",\r\n    \"facebook\": \"https://fb.com/1588497423609\"\r\n  },\r\n  \"createdAt\": \"2020-05-03T09:12:38.609Z\",\r\n  \"updatedAt\": \"2020-05-03T09:17:03.720Z\",\r\n  \"__v\": 0\r\n}\r\n```\r\n\r\nWring output as seen on 5.9.9 - 5.9.11\r\n```json\r\n{\r\n  \"_id\": \"5eae8b061fafaf013aebe75f\",\r\n  \"contact\": {\r\n    \"email\": \"1588498050937@example.com\",\r\n    \"phone\": \"1588498050937\"\r\n  },\r\n  \"createdAt\": \"2020-05-03T09:12:38.609Z\",\r\n  \"updatedAt\": \"2020-05-03T09:27:31.023Z\",\r\n  \"__v\": 0\r\n}\r\n```\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using?**\r\n\r\nMongoDB: 3.4.23\r\nNode: 12.16.2\r\n\r\nNPM packages:\r\n\r\nmongoose: 5.9.9 - 5.9.11\r\nfeathers-mongoose@8.3.0\r\nmongodb@3.5.7"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nQuestion/Bug\r\n\r\n**What is the current behavior?**\r\nOne level nested document gets timestamps, but 2 level nested document does not get timestamps\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\n**What is the expected behavior?**\r\nExpecting timestamps in **journal** entry\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nMongoose: 5.9.9\r\nNode.js: 12.5.0\r\nMongoDB: 4.0.2\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n\r\n**Additional info:**\r\n\r\n// schema & model\r\n```\r\nconst JournalSchema = new mongoose.Schema({\r\n  message: {type: String},\r\n}, {timestamps: true})\r\n\r\nconst ProductSchema = new mongoose.Schema({\r\n  name: {type: String},\r\n  journal: [JournalSchema]\r\n}, {timestamps: true})\r\n\r\nvar LotSchema = new mongoose.Schema({\r\n  products: [ProductSchema],\r\n}, {timestamps: true})\r\n\r\nconst LotsModel = mongoose.model('Lots', LotSchema)\r\n```\r\n\r\n// wrapper function to add product\r\n```\r\n  function addProductIntLot (lotId, product) {\r\n    const conditions = { _id: lotId }\r\n    const update = { $push: { products: product } }\r\n    const options = { new: true, runValidators: true, fields: { products: { $slice: -1 } } }\r\n\r\n    return LotsModel.model.findOneAndUpdate(conditions, update, options)\r\n  }\r\n```\r\n\r\n// adding product in existing lot\r\n```\r\nconst lotId = '...'\r\nconst product = {\r\n  name: 'mock-name',\r\n  journal: [{message: 'Product has been created.'}]\r\n}\r\naddProductIntLot(lotId, product)\r\n  .then(console.log)\r\n  .catch(console.error)\r\n```\r\n\r\nThe product gets createdAt and updatedAt properties.\r\nHowever, journal entry never gets createdAt & updatedAt fields.\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nbug\r\n\r\n**What is the current behavior?**\r\nArray cast doesn't show the \"position path\" of the element where it failed.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\n```javascript\r\n\r\nconst mongoose = require('mongoose');\r\nconst assert = require('assert');\r\n\r\nconst schema = new mongoose.Schema({ test: [ Number ] });\r\nconst Test = mongoose.model('test', schema);\r\n\r\nconst t = new Test({ test: [ 1, 'world' ] });\r\nconst { errors } = t.validateSync();\r\nconsole.log(errors);\r\n\r\nassert.equal(errors.test.reason.path, 'test.1');\r\nassert.equal(errors.test.reason.message, 'Cast to number failed for value \"world\" at path \"test.1\"');\r\n\r\n//\r\n{\r\n  test: {\r\n    stringValue: `\"[ 1, 'world' ]\"`,\r\n    kind: 'Array',\r\n    value: [ 1, 'world' ],\r\n    path: 'test',\r\n    reason: {\r\n      stringValue: '\"world\"',\r\n      kind: 'number',\r\n      value: 'world',\r\n      path: 'test',     // missing element position: test.1\r\n      message: 'Cast to number failed for value \"world\" at path \"test\"',\r\n      name: 'CastError'\r\n      ...\r\n    },\r\n    message: `Cast to Array failed for value \"[ 1, 'world' ]\" at path \"test\"`,\r\n    name: 'CastError'\r\n  }\r\n}\r\n```\r\n\r\n**What is the expected behavior?**\r\n`reason.path` should have element position\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\n`node  12.16.1`\r\n`mongoose 5.9.10`\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n\r\n\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n*bug*\r\n\r\n**What is the current behavior?**\r\n\r\nPassing the Schema constructor an object with the key `errors` causes a very obscure, non-obvious error to be thrown only once an associated Document is `save()`d or `create()`d, producing an error about priorDoc being undefined:\r\n\r\n```\r\n(node:6930) UnhandledPromiseRejectionWarning: TypeError: Cannot read property 'priorDoc' of undefined\r\n    at /home/node/qproxy-api/node_modules/mongoose/lib/document.js:1118:27\r\n    at model.$set (/home/node/qproxy-api/node_modules/mongoose/lib/document.js:1125:5)\r\n    at model.set [as errors] (/home/node/qproxy-api/node_modules/mongoose/lib/helpers/document/compile.js:137:20)\r\n    at model.Document (/home/node/qproxy-api/node_modules/mongoose/lib/document.js:85:15)\r\n    at model.Model (/home/node/qproxy-api/node_modules/mongoose/lib/model.js:105:12)\r\n    at new model (/home/node/qproxy-api/node_modules/mongoose/lib/model.js:4669:15)\r\n    at /home/node/qproxy-api/node_modules/mongoose/lib/model.js:3106:22\r\n    at /home/node/qproxy-api/node_modules/mongoose/lib/model.js:3142:7\r\n    at Array.forEach (<anonymous>)\r\n    at /home/node/qproxy-api/node_modules/mongoose/lib/model.js:3141:15\r\n    at /home/node/qproxy-api/node_modules/mongoose/lib/helpers/promiseOrCallback.js:31:5\r\n    at new Promise (<anonymous>)\r\n    at promiseOrCallback (/home/node/qproxy-api/node_modules/mongoose/lib/helpers/promiseOrCallback.js:30:10)\r\n    at Function.create (/home/node/qproxy-api/node_modules/mongoose/lib/model.js:3076:10)\r\n    at Object.<anonymous> (/home/node/qproxy-api/test.js:11:7)\r\n    at Module._compile (internal/modules/cjs/loader.js:1158:30)\r\n(node:6930) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). To terminate the node process on unhandled promise rejection, use the CLI flag `--unhandled-rejections=strict` (see https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode). (rejection id: 1)\r\n(node:6930) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.\r\n```\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n```js\r\nconst mongoose = require('mongoose');\r\nconst Schema = mongoose.Schema;\r\nconst Phone = new Schema({\r\n  name: String,\r\n  errors: {\r\n      numErrors: Number,\r\n      lastError: Date\r\n   }\r\n}, {timestamps: true});\r\nvar Phone = mongoose.model('Phone', Phone);\r\nPhone.create({ name: 'test' });\r\n```\r\n\r\n**What is the expected behavior?**\r\n\r\nIdeally, the user should see an error indicating that a restricted keyword was used, or indicate some issue in the Schema constructor. It was very hard to track down the underlying issue in the current format. Searching docs and even google for `priorDoc` undefined yields nothing useful. After scouring the docs I noticed `prototype.errors` being some sort of reserved keyword.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nMongoose 5.9.10\r\nNodeJS 12.16.1\r\nMongoDB 4.2.6\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"According to [Schema docs](https://mongoosejs.com/docs/api.html#schematype_SchemaType-select) select accepts boolean. Therefore when `select` has a value of `undefined` I expect that it will be ignored. Instead, it is treated as `false`.\r\nIgnoring undefined would allow a more flexible definition of dynamic schemas. For example, skip fields on a particular environment without effecting other environments:\r\n```js\r\nnew Schema({\r\n  name: String,\r\n  secretData: {\r\n    select: process.env.NODE_ENV === 'production' ? false : undefined,\r\n    type: String\r\n  }\r\n});\r\n```\r\n\r\n\r\n**Script to reproduce.**\r\n```js\r\nconst mongoose = require('mongoose');\r\nconst { Schema } = mongoose;\r\nconst assert = require('assert');\r\n\r\nrun().catch(console.error);\r\n\r\nasync function run () {\r\n  await mongoose.connect('mongodb://localhost:27017/test', {\r\n    useNewUrlParser: true,\r\n    useUnifiedTopology: true\r\n  });\r\n\r\n  await mongoose.connection.dropDatabase();\r\n\r\n  const productSchema = new Schema({\r\n    name: String,\r\n    secretData: {\r\n      select: undefined,\r\n      type: String\r\n    }\r\n  });\r\n\r\n  const Product = mongoose.model('Product', productSchema);\r\n\r\n  await Product.create({ name: 'test', secretData: '42' });\r\n\r\n  const product = await Product.findOne({ name: 'test' });\r\n\r\n  assert.equal(product.secretData, 42);\r\n\r\n  console.log('Done.');\r\n}\r\n```\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using?**\r\n\r\nNode.js@10, Mongoose@5.9.10, MongoDB: 4.x\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBug\r\n\r\n**What is the current behavior?**\r\n\r\nWe have a schema with (1) nested documents, which (2) use discriminators, and where (3) (only) some of the discriminated types uses a `refPath`. With 5.9.9 and 5.9.10 we get an error `Cannot read property 'schema' of undefined` when we try to populate this reference.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n\r\n```typescript\r\nimport mongoose from 'mongoose';\r\n\r\nbeforeAll(async () => mongoose.connect(process.env.MONGO_URL as string));\r\n\r\nafterAll(async () => mongoose.disconnect());\r\n\r\nit('Mongoose getModelsMapForPopulate issue', async () => {\r\n  const nested = new mongoose.Schema(\r\n    {\r\n      // nothing here\r\n    },\r\n    {\r\n      discriminatorKey: 'type'\r\n    }\r\n  );\r\n\r\n  const main = new mongoose.Schema({\r\n    items: [nested]\r\n  });\r\n\r\n  const nestedDiscriminated = new mongoose.Schema({\r\n    refPath: { type: String, required: true },\r\n    ref: { type: mongoose.Types.ObjectId, refPath: 'items.refPath' }\r\n    // just for illustration; this works:\r\n    // ref: { type: mongoose.Types.ObjectId, ref: 'getModelsMapForPopulateIssue_other' }\r\n  });\r\n\r\n  const itemsType = main.path('items') as mongoose.Schema.Types.DocumentArray;\r\n  itemsType.discriminator('discriminated', nestedDiscriminated);\r\n\r\n  const MainModel = mongoose.model<any>('getModelsMapForPopulateIssue_main', main);\r\n\r\n  const OtherModel = mongoose.model<any>(\r\n    'getModelsMapForPopulateIssue_other',\r\n    new mongoose.Schema({\r\n      name: { type: String }\r\n    })\r\n  );\r\n\r\n  const otherDoc = new OtherModel({ name: 'hello world' });\r\n  await otherDoc.save();\r\n\r\n  await new MainModel({\r\n    items: [\r\n      {\r\n        type: 'not_discriminated'\r\n      },\r\n      {\r\n        type: 'discriminated',\r\n        refPath: 'getModelsMapForPopulateIssue_other',\r\n        ref: otherDoc._id\r\n      }\r\n    ]\r\n  }).save();\r\n\r\n  const result = await MainModel.find({}).populate('items.ref').exec();\r\n  expect(result[0].items[1].ref.name).toEqual('hello world');\r\n});\r\n```\r\n\r\nThis might be a regression related to this?\r\n\r\nhttps://github.com/Automattic/mongoose/issues/8731\r\n\r\n**What is the expected behavior?**\r\n\r\nThe test should pass, and the document should be populated. Instead weâ€™re now receiving the following error:\r\n\r\n```\r\n    TypeError: Cannot read property 'schema' of undefined\r\n\r\n      at getModelsMapForPopulate (node_modules/mongoose/lib/helpers/populate/getModelsMapForPopulate.js:232:94)\r\n      at populate (node_modules/mongoose/lib/model.js:4313:21)\r\n      at _populate (node_modules/mongoose/lib/model.js:4283:5)\r\n      at node_modules/mongoose/lib/model.js:4258:5\r\n      at promiseOrCallback (node_modules/mongoose/lib/helpers/promiseOrCallback.js:9:12)\r\n      at Function.Model.populate (node_modules/mongoose/lib/model.js:4256:10)\r\n      at cb (node_modules/mongoose/lib/query.js:1934:17)\r\n      at node_modules/mongodb/lib/utils.js:731:5\r\n      at handleCallback (node_modules/mongodb/lib/utils.js:128:55)\r\n      at node_modules/mongodb/lib/cursor.js:841:66\r\n      at handleCallback (node_modules/mongodb/lib/utils.js:128:55)\r\n      at completeClose (node_modules/mongodb/lib/cursor.js:929:16)\r\n      at Cursor.close (node_modules/mongodb/lib/cursor.js:948:12)\r\n      at node_modules/mongodb/lib/cursor.js:841:27\r\n      at handleCallback (node_modules/mongodb/lib/core/cursor.js:32:5)\r\n      at node_modules/mongodb/lib/core/cursor.js:685:38\r\n```\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\n* Node.js v13.8.0\r\n* Mongoose 5.9.10\r\n* MongoDB 3.6.7"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nWhen `minimize` is set to false, empty objects will override any defaults set on nested objects.\r\n\r\nFor example, given this cart schema:\r\n```\r\nconst Cart = new mongoose.Schema(\r\n  {\r\n    _id: { type: 'String', required: true },\r\n    item: {\r\n      name: { type: 'String', default: 'Default Name' },\r\n    }\r\n  },\r\n  {\r\n    collection: 'Cart',\r\n    _id: false,\r\n    versionKey: false,\r\n    minimize: false\r\n  }\r\n)\r\n```\r\n\r\ncalling `Cart.save({ item: {} })` will create this cart:\r\n```\r\n{\r\n  _id: '...',\r\n  item: {}\r\n}\r\n```\r\n\r\n**What is the expected behavior?**\r\nEmpty objects should not overwrite nested object default attributes. \r\n\r\nGiven the Cart schema above, I would expect the created cart to include the default attribute in `item`:\r\n\r\n```\r\n{\r\n  _id: '...',\r\n  item: {\r\n    name: \"Default Name\"\r\n  }\r\n}\r\n```\r\n\r\nIf subdocuments are used instead of the nested schema, this issue doesn't exist. For example:\r\n```\r\nconst Item = new mongoose.Schema({\r\n  _id: false,\r\n  name: { type: 'String', default: 'Default Name' }\r\n})\r\n\r\nconst Cart = new mongoose.Schema(\r\n  {\r\n    _id: { type: 'String', required: true },\r\n    item: {\r\n      type: Item,\r\n      default: {}\r\n    }\r\n  },\r\n  {\r\n    collection: 'Cart',\r\n    _id: false,\r\n    versionKey: false,\r\n    minimize: false\r\n  }\r\n)\r\n```\r\n\r\ncalling `Cart.save({ item: {} })` will create this cart:\r\n```\r\n{\r\n  _id: '...',\r\n  item: { 'name': 'Default Name' }\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\n**Node:** v10.16.0\r\n**Mongo:** v4.2.2\r\n**Mongoose:** 5.9.10\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nArray elements which are empty strings don't run through validators\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\nconst TestModelSchema = new mongoose.Schema({\r\n    array: {type: [{type: String, minlength: 1, maxlength: 128, required: true}], default: undefined},\r\n})\r\n\r\nconst TestModel = mongoose.model('TestM', TestModelSchema);\r\nTestModel.validate({array: ['']}).then(console.log)\r\n\r\n**What is the expected behavior?**\r\nValidation should give an error.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nnodejs 12.16.2\r\nmongo 3.6.3\r\nmongoose 5.9.9\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->"},{"labels":["bug"],"text":"Hi, I want to request a feature if it's not available that is a developer should be able to write custom validators for custom nested object that is not a schema.\r\n\r\nI am creating a schema like following:\r\n```\r\n\r\nconst mediaSkeleton = {\r\n    url: { type: String, required: true },\r\n    thumbUrl: { type: String, required: true },\r\n    mediaType: { type: Number, min: 0, max: 1, required: true },\r\n    aspectRatio: { type: Number, required: true }\r\n}\r\n\r\nfunction requiredObj(x) { \r\n       console.log(`requiredObj  called for ${x}!`)\r\n       return x != undefined && x != null \r\n}\r\n\r\nconst mySchema = new Schema({\r\n       ....\r\n       text: String,\r\n       banner: { type: mediaSkeleton, validate: requiredObj }\r\n       ....\r\n})\r\n```\r\n\r\nI am calling save method on model like following:\r\n```\r\nconst model = mongoose.model(\"MySchema\", mySchema)\r\n\r\nawait new FaceOffModel(\r\n      { text: \"Testing requiredObj validator\" }\r\n).save()\r\n```\r\n\r\n`requiredObj` function doesn't call at all. Please help me to fix it.\r\n"},{"labels":["bug"],"text":"https://github.com/mongodb-js/mongoose-autopopulate/issues/71#issuecomment-614697617"},{"labels":["bug"],"text":"I'm using mongoose 5.9.9, use `clone` option with `lean`\r\n*bug*\r\nWhen populate documents with clone: true, i got TypeError: Invalid value used as weak map key\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\nFor example, I have product model and image model. \r\nproduct has primary image, and images array, which are all references to the image model.\r\nWhen I try to get product with primary image and images array populated, \r\n\r\n**Without the options {clone: true},**\r\nIt doesn't matter if my primary image exists or not, or if the primary image id actually really refers to any documents in the image collection, because mongoose just gives me null when it cannot be populated. \r\nThis is similar to images array, mongoose automatically removes the ones cannot be populated from the array. \r\n\r\n**With the options {clone: true},**\r\nWhen documents cannot be populated, I got the error: \r\nTypeError: Invalid value used as weak map key\r\n\r\n**This is the part in the code:**\r\nIt's from assignRawDocsToIdStructure\r\n      if (options.lean) {\r\n        const _model = leanPopulateMap.get(doc);\r\n        doc = utils.clone(doc);\r\n        leanPopulateMap.set(doc, _model);\r\n\r\nThanks for your effort to make this clone true option, and please let me know if the issue is unclear. "},{"labels":["bug"],"text":"$elemMatch (projection) is ignored due selected field in schema, for example schema:\r\n```js\r\n{name: String, attributes: {\r\n  select: true,\r\n  type: [{name: String, group: String}],\r\n}}\r\n```\r\nQuery:\r\n```js\r\nproduct.findOne({name: 'test'}).select({attributes: {$elemMatch: {group: 'beta'}}});\r\n```\r\nExecuted query:\r\n```js\r\nproduct.findOne({name: 'test'}, {projection: {attributes: 1});\r\n```\r\n\r\nIt seems that the issue happens in [applyPaths](https://github.com/Automattic/mongoose/blob/master/lib/queryhelpers.js#L119)\r\n\r\n**What is the expected behavior?**\r\n`$elemMatch` should be preserved\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using?**\r\nNode.js@10, Mongoose@5.9.3, MongoDB: 4.x\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nReport a Bug\r\n\r\n**What is the current behavior?**\r\n\r\nBased on the provided example script the insertion of a document containig nested maps is failling when required flag is enabled, the weirdest part is that this fails only when the subdocument contains another subdocument field which is not initialized as `new Schema` (check the line with the comment \"<- this block produces the failure.\").\r\n\r\nCurrent output:\r\n\r\n```\r\nError [ValidationError]: Main validation failed: level1.0.level2.$*.level3: Path `level3` is required., level1.1.level2.$*.level3: Path `level3` is required., level1.0.level2.0002: Validation failed: level3: Path `level3` is required., level1.1.level2.0001: Validation failed: level3: Path `level3` is required.\r\n    at ValidationError.inspect (/mnt/c/Users/dapr_/workspace/mongoosetest/node_modules/mongoose/lib/error/validation.js:61:24)\r\n    at formatValue (internal/util/inspect.js:563:31)\r\n    at inspect (internal/util/inspect.js:221:10)\r\n    at formatWithOptions (internal/util/inspect.js:1693:40)\r\n    at Object.Console.<computed> (internal/console/constructor.js:277:10)\r\n    at Object.warn (internal/console/constructor.js:287:61)\r\n    at /mnt/c/Users/dapr_/workspace/mongoosetest/index.js:78:11\r\n    at processTicksAndRejections (internal/process/task_queues.js:94:5) {\r\n  errors: {\r\n    'level1.0.level2.$*.level3': MongooseError [ValidatorError]: Path `level3` is required.\r\n        at new ValidatorError (/mnt/c/Users/dapr_/workspace/mongoosetest/node_modules/mongoose/lib/error/validator.js:29:11)\r\n        at validate (/mnt/c/Users/dapr_/workspace/mongoosetest/node_modules/mongoose/lib/schematype.js:1096:13)\r\n        at /mnt/c/Users/dapr_/workspace/mongoosetest/node_modules/mongoose/lib/schematype.js:1150:11\r\n        at Array.forEach (<anonymous>)\r\n        at Map.SchemaType.doValidate (/mnt/c/Users/dapr_/workspace/mongoosetest/node_modules/mongoose/lib/schematype.js:1105:14)\r\n        at /mnt/c/Users/dapr_/workspace/mongoosetest/node_modules/mongoose/lib/document.js:2366:9\r\n        at processTicksAndRejections (internal/process/task_queues.js:76:11) {\r\n      message: 'Path `level3` is required.',\r\n      name: 'ValidatorError',\r\n      properties: [Object],\r\n      kind: 'required',\r\n      path: 'level3',\r\n      value: undefined,\r\n      reason: undefined,\r\n      [Symbol(mongoose:validatorError)]: true\r\n    },\r\n    'level1.1.level2.$*.level3': MongooseError [ValidatorError]: Path `level3` is required.\r\n        at new ValidatorError (/mnt/c/Users/dapr_/workspace/mongoosetest/node_modules/mongoose/lib/error/validator.js:29:11)\r\n        at validate (/mnt/c/Users/dapr_/workspace/mongoosetest/node_modules/mongoose/lib/schematype.js:1096:13)\r\n        at /mnt/c/Users/dapr_/workspace/mongoosetest/node_modules/mongoose/lib/schematype.js:1150:11\r\n        at Array.forEach (<anonymous>)\r\n        at Map.SchemaType.doValidate (/mnt/c/Users/dapr_/workspace/mongoosetest/node_modules/mongoose/lib/schematype.js:1105:14)\r\n        at /mnt/c/Users/dapr_/workspace/mongoosetest/node_modules/mongoose/lib/document.js:2366:9\r\n        at processTicksAndRejections (internal/process/task_queues.js:76:11) {\r\n      message: 'Path `level3` is required.',\r\n      name: 'ValidatorError',\r\n      properties: [Object],\r\n      kind: 'required',\r\n      path: 'level3',\r\n      value: undefined,\r\n      reason: undefined,\r\n      [Symbol(mongoose:validatorError)]: true\r\n    },\r\n    'level1.0.level2.0002': Error [ValidationError]: Validation failed: level3: Path `level3` is required.\r\n        at ValidationError.inspect (/mnt/c/Users/dapr_/workspace/mongoosetest/node_modules/mongoose/lib/error/validation.js:61:24)\r\n        at formatValue (internal/util/inspect.js:563:31)\r\n        at formatProperty (internal/util/inspect.js:1406:11)\r\n        at formatRaw (internal/util/inspect.js:785:9)\r\n        at formatValue (internal/util/inspect.js:591:10)\r\n        at formatProperty (internal/util/inspect.js:1406:11)\r\n        at formatRaw (internal/util/inspect.js:785:9)\r\n        at formatValue (internal/util/inspect.js:591:10)\r\n        at formatValue (internal/util/inspect.js:568:18)\r\n        at inspect (internal/util/inspect.js:221:10)\r\n        at formatWithOptions (internal/util/inspect.js:1693:40)\r\n        at Object.Console.<computed> (internal/console/constructor.js:277:10)\r\n        at Object.warn (internal/console/constructor.js:287:61)\r\n        at /mnt/c/Users/dapr_/workspace/mongoosetest/index.js:78:11\r\n        at processTicksAndRejections (internal/process/task_queues.js:94:5) {\r\n      errors: [Object],\r\n      _message: 'Validation failed',\r\n      name: 'ValidationError'\r\n    },\r\n    'level1.1.level2.0001': Error [ValidationError]: Validation failed: level3: Path `level3` is required.\r\n        at ValidationError.inspect (/mnt/c/Users/dapr_/workspace/mongoosetest/node_modules/mongoose/lib/error/validation.js:61:24)\r\n        at formatValue (internal/util/inspect.js:563:31)\r\n        at formatProperty (internal/util/inspect.js:1406:11)\r\n        at formatRaw (internal/util/inspect.js:785:9)\r\n        at formatValue (internal/util/inspect.js:591:10)\r\n        at formatProperty (internal/util/inspect.js:1406:11)\r\n        at formatRaw (internal/util/inspect.js:785:9)\r\n        at formatValue (internal/util/inspect.js:591:10)\r\n        at formatValue (internal/util/inspect.js:568:18)\r\n        at inspect (internal/util/inspect.js:221:10)\r\n        at formatWithOptions (internal/util/inspect.js:1693:40)\r\n        at Object.Console.<computed> (internal/console/constructor.js:277:10)\r\n        at Object.warn (internal/console/constructor.js:287:61)\r\n        at /mnt/c/Users/dapr_/workspace/mongoosetest/index.js:78:11\r\n        at processTicksAndRejections (internal/process/task_queues.js:94:5) {\r\n      errors: [Object],\r\n      _message: 'Validation failed',\r\n      name: 'ValidationError'\r\n    }\r\n  },\r\n  _message: 'Main validation failed',\r\n  name: 'ValidationError'\r\n}\r\n```\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n\r\nHow to reproduce:\r\n\r\n```js\r\nconst mongoose = require(\"mongoose\");\r\n\r\nconst { Schema } = mongoose;\r\n\r\nconst SERVERS = \"localhost:27017\";\r\nconst DB_NAME = \"mongoosetest\";\r\nconst DATABASE_URI = `mongodb://${ SERVERS }/${ DB_NAME }`;\r\n\r\nasync function connectMongoose() {\r\n  await mongoose.connect(DATABASE_URI);\r\n\r\n  console.info(`Database connection established with ${ DATABASE_URI }`);\r\n\r\n  const { connection } = mongoose;\r\n  connection.on(\"error\", console.warn);\r\n  connection.on(\"close\", connection.removeAllListeners);\r\n}\r\n\r\nasync function main() {\r\n  await connectMongoose();\r\n\r\n  const SubSchema1 = new Schema({\r\n    level2 : {\r\n      type : Map,\r\n      of   : new Schema({\r\n        level3 : {\r\n          type     : Map,\r\n          of       : Number,\r\n          required : true,\r\n        },\r\n      }),\r\n    },\r\n    subdocField : {  // \r\n      a : Boolean, // <- this block produces the failure.\r\n    }                // \r\n  });\r\n\r\n  const MainSchema = new Schema({\r\n    level1 : {\r\n      type     : [SubSchema1],\r\n      required : true,\r\n    },\r\n  });\r\n\r\n  const Main = mongoose.model(\"Main\", MainSchema);\r\n\r\n  const testRecord = new Main({\r\n    level1 : [\r\n      {\r\n        level2 : {\r\n          \"0001\" : {\r\n            level3 : {\r\n              \"aaa1\" : 1\r\n            }\r\n          }\r\n        }\r\n      },\r\n      {\r\n        level2 : {\r\n          \"0002\" : {\r\n            level3 : {\r\n              \"aaa2\" : 1\r\n            }\r\n          }\r\n        }\r\n      }\r\n    ]\r\n  });\r\n\r\n  console.log(JSON.stringify(testRecord.toObject({ flattenMaps : true }), null, 2));\r\n\r\n  await testRecord.save();\r\n  console.info(\"success\");\r\n}\r\n\r\nmain().then(console.info)\r\n  .catch(err => {\r\n    console.error(err);\r\n    return -1;\r\n  })\r\n  .then(process.exit);\r\n```\r\n\r\n**What is the expected behavior?**\r\n\r\n* this insertion should work without raise any error.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\n* Node: v12.14.1\r\n* mongoose: v5.9.7\r\n\r\n\r\nP.S.\r\n\r\nAs a workaround I defined `subdocField` as follows:\r\n\r\n``` js\r\nsubdocField : new Schema({\r\n   a : Boolean,\r\n}, { ... }),\r\n```"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nreport a bug\r\n\r\n**What is the current behavior?**\r\n\r\nOverwriting a document that is from a discriminator schema causes a CastError for the discriminator key because it is reset.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\n```javascript\r\nconst mongoose = require(\"mongoose\");\r\n\r\nconst BaseSchema = new mongoose.Schema({\r\n  value: Number\r\n});\r\n\r\nconst BaseModel = mongoose.model(\"BaseModel\", BaseSchema);\r\nconst ChildModel = BaseModel.discriminator(\"ChildModel\", new mongoose.Schema());\r\n\r\nconst model = new ChildModel({ value: 1 });\r\nmodel.overwrite({ value: 2 });\r\nmodel.save();\r\n```\r\n\r\n```\r\nValidationError: ChildModel validation failed: __t: Cast to String failed for value \"undefined\" at path \"__t\"\r\n```\r\n\r\n**What is the expected behavior?**\r\n\r\nI would expect it to keep the discriminator key. Maybe there is a good reason to overwrite the discriminator key, but right now, I have to remember to pass it in when I call overwrite\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nnode: 12.16.1\r\nmongoose: 5.9.7\r\nmongodb: 3.6.8\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"**What is the current behavior?**\r\nCan not use `clone: true` in populate along with `lean()`, it throws an error:\r\n```\r\nTypeError: doc.constructor.hydrate is not a function\r\n    at assignRawDocsToIdStructure (node_modules\\mongoose\\lib\\helpers\\populate\\assignRawDocsToIdStructure.js:58:29)\r\n    at assignRawDocsToIdStructure (node_modules\\mongoose\\lib\\helpers\\populate\\assignRawDocsToIdStructure.js:41:7)\r\n    at assignVals (node_modules\\mongoose\\lib\\helpers\\populate\\assignVals.js:26:3)\r\n    at _assign (node_modules\\mongoose\\lib\\model.js:4564:3)\r\n    at _done (node_modules\\mongoose\\lib\\model.js:4411:7)\r\n    at _next (node_modules\\mongoose\\lib\\model.js:4403:7)\r\n    at node_modules\\mongoose\\lib\\model.js:4837:16\r\n    at node_modules\\mongoose\\lib\\helpers\\promiseOrCallback.js:24:16\r\n    at node_modules\\mongoose\\lib\\model.js:4860:21\r\n    at node_modules\\mongoose\\lib\\query.js:4366:11\r\n    at node_modules\\kareem\\index.js:135:16\r\n    at processTicksAndRejections (internal/process/task_queues.js:79:11)\r\nEmitted 'error' event on Function instance at:\r\n    at node_modules\\mongoose\\lib\\model.js:4839:13\r\n    at node_modules\\mongoose\\lib\\helpers\\promiseOrCallback.js:24:16\r\n    [... lines matching original stack trace ...]\r\n    at processTicksAndRejections (internal/process/task_queues.js:79:11)\r\n```\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```js\r\nconst mongoose = require('mongoose');\r\nconst { Schema } = mongoose;\r\nconst assert = require('assert');\r\n\r\nmongoose.connect('mongodb://localhost:27017/test', { useNewUrlParser: true, useUnifiedTopology: true });\r\n\r\nconst blogPostSchema = new Schema({\r\n  title: { type: String },\r\n  commentsIds: [{ type: Schema.ObjectId, ref: 'Comment' }]\r\n});\r\n\r\nconst commentSchema = new Schema({\r\n  content: String\r\n});\r\n\r\nconst BlogPost = mongoose.model('BlogPost', blogPostSchema);\r\nconst Comment = mongoose.model('Comment', commentSchema);\r\n\r\nasync function run () {\r\n  await BlogPost.deleteMany();\r\n\r\n  const blogPost = new BlogPost({ title: 'Important post' });\r\n  const comment = new Comment({ content: 'Cool post.' });\r\n\r\n  blogPost.commentsIds = [comment._id];\r\n\r\n  await Promise.all([\r\n    blogPost.save(),\r\n    comment.save()\r\n  ]);\r\n\r\n  const foundBlogPost = await BlogPost.findOne({ _id: blogPost._id }).populate({\r\n    path: 'commentsIds',\r\n    options: { clone: true }\r\n  }).lean();\r\n\r\n  assert.equal(foundBlogPost.commentsIds[0].content, 'Cool post.');\r\n\r\n  console.log('Done.');\r\n}\r\n\r\n\r\nrun().catch(console.error);\r\n```\r\n\r\n**What is the expected behavior?**\r\n\r\nTo populate successfully.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nmongoose v5.9.7\r\nMongoDB v4.0.4\r\nNode v12.0\r\n\r\nWill be putting a PR to solve this sometime soon."},{"labels":["bug",null],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nWhen you try to save a document that has no changes, mongoose will run a `Model.exists()` query to make sure the document is in the DB (I don't know why this is done, but that's a different story). That query is done with a subset of the options that were passed to `Document.save()` call, not the original options. This breaks my middleware because `Model.exists()` triggers a `Document.findOne()` middleware, but the extra options that I have passed in are not sent with this new query.\r\n\r\nThe relevant line is 316 in lib/model.js.\r\n\r\n```js\r\n    } else {\r\n      this.constructor.exists(this.$__where(), saveOptions)\r\n        .then((documentExists)=>{\r\n          if (!documentExists) throw new DocumentNotFoundError(this.$__where(),this.constructor.modelName);\r\n\r\n          this.$__reset();\r\n          callback();\r\n        })\r\n        .catch(callback);\r\n      return;\r\n    }\r\n```\r\n\r\n`saveOptions` there is a stripped down version of the original `options` passed in. I think `options` should be used there, or something similar to it.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```js\r\nconst doc = new MyModel({name: 'john'});\r\nawait doc.save({ customOpt: 1 }); // works\r\nawait doc.save({ customOpt: 1 }); // customOpt isn't passed to the Model.exists query\r\n```\r\n\r\nThis seems like a far fetched case. But I ran into this by having a `Document.save()` call inside a `session.withTransaction()` call. `withTransaction` would then rerun the function after a `TransientTransactionError`, triggering this edge case where the document is saved twice.\r\n\r\n**What is the expected behavior?**\r\nThe custom options should be passed through to the `Model.exists()` method.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nNode: 12.14.0\r\nMongoose: 5.9.6\r\nMongoDB: 4.2.3\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nbug\r\n\r\n**What is the current behavior?**\r\nNested Schema's `strict` is controlling the fields that get saved with that schema even when `useNestedStrict` is false.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n```\r\nimport {Schema} from 'mongoose';\r\nimport * as mongoose from 'mongoose'\r\n\r\nvar EmptySchema = new Schema({}, {strict : false, _id : false, versionKey : false});\r\n\r\nvar OuterSchema = new Schema({\r\n  testfield : String,\r\n  emptyschemafield : EmptySchema\r\n}, {strict : true, versionKey : false, useNestedStrict : false});\r\n\r\nconst db = mongoose.createConnection('mongodb://localhost:27017/test');\r\nconst OuterModel = db.model('OuterModel', OuterSchema);\r\n\r\nvar outerObj = {\r\n  testfield : 'hello',\r\n  emptyschemafield : {\r\n    'shouldntbesaved' : true\r\n  }\r\n}\r\n\r\nconst OuterDocument = new OuterModel(outerObj);\r\nOuterModel.findOneAndUpdate({testfield : 'doesntexist'}, outerObj, {upsert : true, new : true}, function(err, res){\r\n  if (err) {\r\n    console.log(err);\r\n  } else {\r\n    // shouldntbesaved field is being saved and is only controllable by EmptySchema's strict field.\r\n    console.log(res);\r\n  }\r\n});\r\n\r\nOuterDocument.save(function(err, res){\r\n  if (err) {\r\n    console.log(err);\r\n  } else {\r\n    // shouldntbesaved field is being saved and is only controllable by EmptySchema's strict field.\r\n    console.log(res);\r\n  }\r\n});\r\n```\r\n**What is the expected behavior?**\r\nThe expected behavior is that top level schema's strict field controls inner schemas when `useNestedStrict` is false.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nNode: 12.13.0\r\nmongodb: 4.0.12\r\nmongoose: 5.8.12\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBug\r\n\r\n**What is the current behavior?**\r\n\r\nWe have a schema with (1) nested documents, which (2) use discriminators, and where (3) one of the discriminated types uses a `refPath` which is a **function**. Before updating Mongoose to 5.9.6, this setup has worked fine. Now, our server crashes b/c Mongoose tries to call `split` on a function in `getModelsMapForPopulate.js:216:40`.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n\r\n```typescript\r\nimport * as mongoose from 'mongoose';\r\n\r\nbeforeAll(async () => mongoose.connect(process.env.MONGO_URL));\r\n\r\nafterAll(async () => mongoose.disconnect());\r\n\r\nit('Mongoose refPath issue', async () => {\r\n\r\n  const nested = new mongoose.Schema(\r\n    {\r\n      // nothing here\r\n    },\r\n    {\r\n      discriminatorKey: 'type'\r\n    }\r\n  );\r\n  const nestedDiscriminated = new mongoose.Schema({\r\n    fooType: { type: String },\r\n    foo: {\r\n      type: mongoose.Schema.Types.ObjectId,\r\n      refPath: (doc: any, path: string) => path.replace('.foo', '.fooType')\r\n    }\r\n  });\r\n\r\n  const main = new mongoose.Schema({\r\n    items: [nested]\r\n  });\r\n\r\n  const itemsType = main.path('items') as mongoose.Schema.Types.DocumentArray;\r\n  itemsType.discriminator('discriminated', nestedDiscriminated);\r\n\r\n  const MainModel = mongoose.model<any>('refPathIssue_main', main);\r\n\r\n  const OtherModel = mongoose.model<any>('refPathIssue_other', new mongoose.Schema({\r\n    name: { type: String }\r\n  }));\r\n\r\n  const otherDoc = new OtherModel({ name: 'hello world' });\r\n  await otherDoc.save();\r\n\r\n  await new MainModel({\r\n    items: [{\r\n      type: 'discriminated',\r\n      fooType: 'refPathIssue_other',\r\n      foo: otherDoc._id\r\n    }]\r\n  }).save();\r\n\r\n  const result = await MainModel.find({}).populate('items.foo').exec();\r\n  expect(result[0].items[0].foo.name).toEqual('hello world');\r\n});\r\n```\r\n\r\n(fwiw, the test would pass if I move the Schema properties from `nestedDiscriminated` up to `nested`)\r\n\r\n**What is the expected behavior?**\r\n\r\nThe test should pass, and the document should be populated. Instead weâ€™re now receiving the following error:\r\n\r\n```\r\n    TypeError: normalizedRefPath.split is not a function\r\n\r\n      at getModelsMapForPopulate (node_modules/mongoose/lib/helpers/populate/getModelsMapForPopulate.js:216:40)\r\n      at populate (node_modules/mongoose/lib/model.js:4300:21)\r\n      at _populate (node_modules/mongoose/lib/model.js:4270:5)\r\n      at node_modules/mongoose/lib/model.js:4245:5\r\n      at promiseOrCallback (node_modules/mongoose/lib/helpers/promiseOrCallback.js:9:12)\r\n      at Function.Model.populate (node_modules/mongoose/lib/model.js:4243:10)\r\n      at cb (node_modules/mongoose/lib/query.js:1934:17)\r\n      at node_modules/mongodb/lib/utils.js:731:5\r\n      at handleCallback (node_modules/mongodb/lib/utils.js:128:55)\r\n      at node_modules/mongodb/lib/cursor.js:840:66\r\n      at handleCallback (node_modules/mongodb/lib/utils.js:128:55)\r\n      at completeClose (node_modules/mongodb/lib/cursor.js:934:16)\r\n      at Cursor.close (node_modules/mongodb/lib/cursor.js:953:12)\r\n      at node_modules/mongodb/lib/cursor.js:840:27\r\n      at handleCallback (node_modules/mongodb/lib/core/cursor.js:32:5)\r\n      at node_modules/mongodb/lib/core/cursor.js:694:38\r\n```\r\n\r\nLooking at the code comments, this seems to be a regression from this fix:\r\nhttps://github.com/Automattic/mongoose/issues/8452\r\n\r\nDowngrading to **5.8.3** solved the issue.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\n* Node.js v13.8.0\r\n* Mongoose 5.9.6\r\n* MongoDB 3.6.7\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nGetters don't fire on Map values. Setters do fire. \r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n\r\n```\r\nvar mongoose = require('mongoose');\r\n\r\nvar UserSchema = new mongoose.Schema({\r\n    name: { type: String, required: true },\r\n    peerNotes: {\r\n      type: Map,\r\n      of: {\r\n        type: String,\r\n        set: function(n) { return n.toUpperCase(); },\r\n        get: function(n) { return `X${n}X`;},\r\n      },\r\n      default: {},\r\n    }\r\n  }, {\r\n    toObject: { getters: true },\r\n    toJSON: { getters: true },\r\n  }\r\n);\r\n\r\n\r\nasync function main() {\r\n  await require('./getTestConnection.js')();\r\n  var User = mongoose.model('users', UserSchema);\r\n  await User.deleteMany();\r\n\r\n  let users = ['mary', 'alice', 'bob' ].map(async (n) => {\r\n    let user = new User({name: n});\r\n    await user.save();\r\n    return user;\r\n  });\r\n  users = await Promise.all(users);\r\n  let mary = users[0];\r\n  mary.peerNotes.set(String(users[1].id), 'winner');\r\n  console.log(mary.peerNotes.get(String(users[1].id)));\r\n  await mary.save();\r\n  console.log(mary.peerNotes.get(String(users[1].id)));\r\n}\r\n\r\nmain()\r\n.then(() => process.exit())\r\n.catch((err) => { console.log(err); console.log('Exiting..'); process.exit() });\r\n```\r\n\r\n**What is the expected behavior?**\r\nAbove script should print:\r\n\r\n```\r\nXWINNERX\r\nXWINNERX\r\n```\r\n\r\nBut prints:\r\n\r\n```\r\nWINNER\r\nWINNER\r\n```\r\n\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n5.9.6\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n\r\n```\r\n> mongoose.version\r\n'5.9.6'\r\n```\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nbug\r\n\r\n**What is the current behavior?**\r\nwhen using `doc.<map>.set` it will run infinitely the `$set` and `_handleIndex` functions\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nNote: uses typescript types & import\r\n```ts\r\n// NodeJS: 12.16.1\r\n// MongoDB: 4.2-bionic (Docker)\r\nimport * as mongoose from \"mongoose\"; // mongoose@5.9.6\r\n\r\nconst SubSchema = new mongoose.Schema({ someValue: String });\r\nconst ParentSchema = new mongoose.Schema({ mapValue: { _id: false, type: Map, of: SubSchema } });\r\n\r\nconst ParentModel = mongoose.model(\"Parent\", ParentSchema);\r\n\r\n(async () => {\r\n  await mongoose.connect(`mongodb://localhost:27017/`, { useNewUrlParser: true, dbName: \"someDB\", useCreateIndex: true, useUnifiedTopology: true });\r\n\r\n  const doc = await ParentModel.create({\r\n    mapValue: new Map([[\"someKey\", { someValue: \"hi1\" }]])\r\n  }) as mongoose.Document & { mapValue: Map<string, any>; };\r\n\r\n  doc.mapValue.set(\"someKey\", { // will infinitly loop with \"$set\" and \"_handleIndex\"\r\n    ...doc.mapValue.get(\"someKey\")\r\n  });\r\n  await doc.save();\r\n\r\n  console.log(\"this message will never be logged\");\r\n\r\n  await mongoose.disconnect();\r\n})();\r\n```\r\n\r\n**What is the expected behavior?**\r\nto run without any infinite loops\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nnodejs: 12.16.1\r\nmongodb: 4.2-bionic (Docker)\r\nmongoose: 5.9.6\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nReport a bug\r\n\r\n**What is the current behavior?**\r\nSetting the content of an array of arrays throws a MongoError: The positional operator did not find the match needed from the query.\r\n\r\nDoing exactly the same update with `updateOne` works fine.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\nAssuming a connection to a mongo server has been established, the following jest test should demonstrate the issue (I have the same bug outside of the jest environment I just used it for convenience):\r\n\r\n```js\r\ndescribe('Test mongoose', () => {\r\n  const schema = new mongoose.Schema({\r\n    name: String,\r\n    array: [[{\r\n      label: String,\r\n      value: String,\r\n    }]],\r\n  });\r\n  const MyModel = mongoose.model('MyModel', schema);\r\n  const updateQuery = {\r\n    'array.0': [{\r\n      label: 'hello',\r\n      value: 'world',\r\n    }],\r\n  };\r\n\r\n  test('It works to update nested array using updateOne', async () => {\r\n    const doc = await new MyModel({ name: 'foo' }).save();\r\n    await MyModel.updateOne({ _id: doc._id }, { $set: updateQuery });\r\n\r\n    const updatedDoc = await MyModel.findOne({ _id: doc._id });\r\n    expect(updatedDoc.array[0][0].label).toBe('hello');\r\n    expect(updatedDoc.array[0][0].value).toBe('world');\r\n    // Success!\r\n  });\r\n\r\n  test('It works to update nested array using set', async () => {\r\n    const doc = await new MyModel({ name: 'foo' }).save();\r\n    await doc.set(updateQuery).save();  // Fails MongoError: The positional operator did not find the match needed from the query.\r\n\r\n    const updatedDoc = await MyModel.findOne({ _id: doc._id });\r\n    expect(updatedDoc.array[0][0].label).toBe('hello');\r\n    expect(updatedDoc.array[0][0].value).toBe('world');\r\n  });\r\n});\r\n```\r\n\r\nAfter a git bisect I have found the commit that caused the issue: https://github.com/Automattic/mongoose/commit/51c6776a9a67368cd2cb1cf170996912353ee204\r\n\r\nDowngrading to 5.7.12 fixes the issue.\r\n\r\n**What is the expected behavior?**\r\nShould update the nested array using `doc.set`\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nmongoose: 5.7.13\r\nmongoDB: 4.2.0\r\nNode: 10.16.0\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\nUSING version 5.9.4\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBUG\r\n\r\n**What is the current behavior?**\r\nI tried to use the native javascript Array.push on a CoreMongooseArray and received an exception\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n1. have a CoreMongooseArray of strings.\r\n2. `var cloned = aCoreMongooseArrayOfStrings.slice()`\r\n3. `cloned.push(\"2222\");`\r\n4. exception:\r\n```\r\nTypeError: Cannot read property '$set' of undefined\r\n    at CoreMongooseArray._registerAtomic (/opt/nodejs/node_modules/mongoose/lib/types/core_array.js:341:34)\r\n    at CoreMongooseArray.push (/opt/nodejs/node_modules/mongoose/lib/types/core_array.js:693:10)\r\n```\r\n\r\n**What is the expected behavior?**\r\nThat the push will work without exception\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nnode 10.14.2\r\nmongo 4.0.12\r\nmongoose 5.9.4\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"Bug/Clarification\r\n\r\n``` javascript\r\nconst MyModel = new Schema({\r\n    myMap: {\r\n        type: Map,\r\n        of: anotherSchema,\r\n        default: {}\r\n    }\r\n});\r\n\r\nconst anotherSchema = new Schema({\r\n    x: { type: Number }\r\n})\r\n\r\n// create instance\r\nconst aModel = new MyModel();\r\naModel.myMap.set('foo', { x: 1 });\r\naModel.myMap.set('bar', { x: 2 });\r\n// modifiedPaths myMap foo and bar\r\n// save\r\n// retrieve from db\r\naModel.myMap.set('foo', { x: 1 });\r\naModel.myMap.set('bar', { x: 2 });\r\n// modifiedPaths are also foo and bar!\r\n// even though the values did not really change\r\n```\r\nI can solve this manually by comparing the object to be set to an existing one\r\nI would like to do this via set method in myMap SchemaType for example:\r\n\r\n``` javacsript\r\n    myMap: {\r\n        type: Map,\r\n        of: anotherSchema,\r\n        default: {},\r\n        set: function(k, v) {\r\n            if (!this.get(k).deepEqual(v)) {\r\n                this.set(k, v);\r\n            }\r\n        }\r\n    }\r\n```\r\nHow can I achieve that? How can I retrieve the value before it is being set?\r\n\r\nMongoDB 3.2\r\nNode.js 10.18\r\nMongoose ^5.9.3\r\n\r\nRegards,\r\nThanks"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n*bug*\r\n\r\n**What is the current behavior?**\r\n\r\nThis one's a little hard to describe - probably easier to point to code:\r\nhttps://github.com/Automattic/mongoose/blob/master/lib/document.js#L132\r\n\r\nI'm sure there's a good reason for this line that I can't see, but a side-effect is that any fields set to immutable on the initializer will be rejected b/c the new object will have isNew=false during construction.\r\n\r\nIf there's no way around it, maybe some quick documentation would help saying something like \"to initialize a mongoose document using another, it's usually best to .toObject() it and pass its output to the constructor instead.\"\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\n1. create a schema with an immutable field\r\n2. construct a document a with that immutable field set to something on initialization\r\n3. try to new up another document b passing the first document to its constructor\r\nEXPECTED: second document has immutable field set to the same as the first\r\nACTUAL: it doesn't ;)\r\n\r\nWORKAROUND: const b = new Document(a.toObject(), theSchema);\r\n\r\n**What is the expected behavior?**\r\n\r\nSee steps above\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n\r\nnode 12, mongoose 5.8, mongo 3.6\r\n"},{"labels":["bug",null],"text":"Hey there,\r\n\r\nif my mongoose transaction returns an empty, rejected Promise, I get the following error:\r\n\r\n`TypeError: Cannot read property 'code' of undefined`\r\n\r\n**Example code:**\r\n\r\n```\r\nconst transactionSession = await mongoose.startSession()\r\nawait transactionSession.withTransaction(async (tSession) => {\r\ntry {\r\n     // Transaction writes & reads removed for brevity\r\n\r\n     console.log(\"Successfully performed transaction!\")\r\n     return Promise.resolve()\r\n     } catch (error) {\r\n     console.log(\"Transaction aborted due to error:\", error)\r\n     cb(error)\r\n\r\n     return Promise.reject() // this causes the error, an empty promise\r\n     // return Promise.reject(4) // this would work\r\n     }\r\n})\r\n```\r\n\r\n**These is the exact error output:**\r\n\r\n```\r\nTypeError: Cannot read property 'code' of undefined\r\n    at isMaxTimeMSExpiredError (/Users/myapi/auth/node_modules/mongodb/lib/core/sessions.js:308:9)\r\n    at maybeRetryOrThrow (/Users/myapi/auth/node_modules/mongodb/lib/core/sessions.js:376:13)\r\n    at session.abortTransaction.then (/Users/myapi/auth/node_modules/mongodb/lib/core/sessions.js:387:54)\r\n    at process._tickCallback (internal/process/next_tick.js:68:7)\r\n\r\nTypeError: Cannot read property 'code' of undefined\r\n    at isMaxTimeMSExpiredError (/Users/myapi/auth/node_modules/mongodb/lib/core/sessions.js:308:9)\r\n    at maybeRetryOrThrow (/Users/myapi/auth/node_modules/mongodb/lib/core/sessions.js:376:13)\r\n    at session.abortTransaction.then (/Users/myapi/auth/node_modules/mongodb/lib/core/sessions.js:387:54)\r\n    at process._tickCallback (internal/process/next_tick.js:68:7)\r\n```\r\n\r\n**My question:** Is it expected that there's an unhandled type error if the returned Promise does not have data attached to it?\r\n\r\nIs it mandatory to pass a \"code\" to a rejected promise?\r\n\r\n_The current mongoose version I'm using is 5.9.1_"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\n*bug*\r\n\r\n**What is the current behavior?**\r\n\r\ndoc.validate(['subdoc.field']) will false-negative (i.e. NOT throw) on the field when the subdocument's field is invalid.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\n1. Make a schema with a subdocument with a field on it with any validation\r\n2. Make a document with an invalid value for the subdocument's field\r\n3. Validate\r\nEXPECTED: throw\r\nACTUAL: no throw\r\n\r\n**What is the expected behavior?**\r\n\r\nGood question - to ACTUALLY make this work, should validation be run:\r\n1. on the field AND the subdocument?  Or\r\n2. just on the subdocument's field itself?\r\n\r\nOption 1 might be easier to do, but I think option 2 makes more sense.  Looking at the current code, that seems like it's not a very straightforward fix though.\r\n\r\nIt seems the reason is that the specified-path filtering is happening after _getPathsToValidate() is called, which filters out subdoc paths based on the assumption that they'll be handled by the subdoc.  But I can't think of a solution that doesn't involve a fair bit of rewriting :(.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nNode 10, mongoose 5.8, mongodb 3.6\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug since Mongoose >= 5.4.20\r\n**What is the current behavior?**\r\n\r\nSingle nested subdocument's default values are not populated while updating with `.save`. \r\nThis results in validation errors and the returned document does not contain the default values. \r\nHowever,  if you disable validation by setting `modelSchema.set('validateBeforeSave', false)`, now run the code, the document will at least save. If you check the database or do another `findOne` the default values are present.\r\n\r\nArray of subdocuments works though. \r\n\r\nIt looks like the defaults are being set at a later time, this isn't the case with array of subdocuments though.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\nI set up a [repo](https://github.com/louisnow/for-mongoose-bugreport)\r\nThe readme has instructions on how to see the error\r\n\r\n**What is the expected behavior?**\r\nOn updating a document with `.save` I expect defaults to be populated for single nested subdocuments similar to array of subdocuments.\r\nThis bug was introduced in mongoose >= 5.4.20\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nmongodb: 3.5.3\r\nnode: 12.14.1\r\nmongoose: 5.9.1\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n*bug*\r\n\r\n**What is the current behavior?**\r\nI just recently upgraded from 5.8.4 to 5.9, and the new Parellel validation error that was added in 5.8.5 is causing issues with some functionality I have.\r\n\r\nWhen calling `this.validate` in a post validate hook, a Parallel validation error will be thrown. My guess is because `this.$__.validating` must still be set while the hook is running.\r\n\r\nI'm not sure if this would be the desired behavior, what do you think? Perhaps the way I am writing the functionality would be better done another way, but I hadn't really thought of one.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\nGiven a schema:\r\n```\r\nvar EmployeeSchema = new Schema({\r\n  name: {\r\n    type: String,\r\n    required: true,\r\n  },\r\n  employeeNumber: {\r\n    type: String,\r\n    validate: {\r\n      validator: function() { return v.length > 5; },\r\n      message: function(props) {\r\n        return `${props.path} must be 5 characters long'`;\r\n       }\r\n    }\r\n  }\r\n});\r\n```\r\n\r\nFor theoretical purposes similar to mine, let's say employeeNumber must be retrieved from an external API. This is how I have done it:\r\n\r\n```\r\nEmployeeSchema.post('validate', async function() {\r\n  if (!this.employeeNumber && !this._employeeNumberRetrieved) {\r\n    this.employeeNumber = await getEmployeeNumberFromApi(this.name);\r\n    this._employeeNumberRetrieved = true;\r\n    await this.validate();\r\n  }\r\n});\r\n```\r\n\r\nIn my case, it isn't ideal to fetch this data if the other fields are invalid, because it's just going to get thrown out anyway, which is why I am doing it in a post validate hook. But I need to handle the case where if something about the returned employee number is invalid, which is why validation would need to be repeated.\r\n\r\n**What is the expected behavior?**\r\n\r\nA document should be able to be re-validated in a post('validate') hook\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nNode 10.16.0\r\nMongoose 5.9.0\r\nMongodb 4.0.6\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nbug\r\n\r\n**What is the current behavior?**\r\nwhen using a discriminator schema, newly created documents via bulkWrite do not have the discriminatorKey added to them as opposed to those created via `.save()` for example\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nI created a reproducible example here https://github.com/khaledosman/mongo-performance-expirements\r\nsimply run `mongod` on one tab and `node discriminator-test.js` on the other after running `npm install`\r\n\r\n**What is the expected behavior?**\r\nExpected all 3 newly created documents to have the discriminatorKey `animalType`\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nNode v13.8.0\r\nmongoose v5.8.12\r\nmongodb v4.0.5"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nI use a discriminator in my `Customer` model because there are cases where I want to skip running costly hooks, but populating virtuals always throw an error.\r\n```bash\r\n(2020-02-13 11:36:40) error [MongooseError] => If you are populating a virtual, you must set the localField and foreignField options {\r\n  id: '190298da6aff4e9b864822fda9d3bc32',\r\n  stack: 'MongooseError: If you are populating a virtual, you must set the localField and foreignField options\\n' +\r\n    '    at new MongooseError (/home/bk/Repos/elb-backoffice/api/node_modules/mongoose/lib/error/mongooseError.js:10:11)\\n' +\r\n    '    at getModelsMapForPopulate (/home/bk/Repos/elb-backoffice/api/node_modules/mongoose/lib/helpers/populate/getModelsMapForPopulate.js:152:14)\\n' +\r\n    '    at populate (/home/bk/Repos/elb-backoffice/api/node_modules/mongoose/lib/model.js:4272:21)\\n' +\r\n    '    at _populate (/home/bk/Repos/elb-backoffice/api/node_modules/mongoose/lib/model.js:4242:5)\\n' +\r\n    '    at /home/bk/Repos/elb-backoffice/api/node_modules/mongoose/lib/model.js:4217:5\\n' +\r\n    '    at promiseOrCallback (/home/bk/Repos/elb-backoffice/api/node_modules/mongoose/lib/helpers/promiseOrCallback.js:9:12)\\n' +\r\n    '    at Function.Model.populate (/home/bk/Repos/elb-backoffice/api/node_modules/mongoose/lib/model.js:4215:10)\\n' +\r\n    '    at cb (/home/bk/Repos/elb-backoffice/api/node_modules/mongoose/lib/query.js:1934:17)\\n' +\r\n    '    at /home/bk/Repos/elb-backoffice/api/node_modules/mongodb/lib/operations/execute_operation.js:75:17\\n' +\r\n    '    at executeCallback (/home/bk/Repos/elb-backoffice/api/node_modules/mongodb/lib/operations/execute_operation.js:68:9)\\n' +\r\n    '    at handleCallback (/home/bk/Repos/elb-backoffice/api/node_modules/mongodb/lib/utils.js:129:55)\\n' +\r\n    '    at /home/bk/Repos/elb-backoffice/api/node_modules/mongodb/lib/operations/to_array.js:36:13\\n' +\r\n    '    at handleCallback (/home/bk/Repos/elb-backoffice/api/node_modules/mongodb/lib/utils.js:129:55)\\n' +\r\n    '    at completeClose (/home/bk/Repos/elb-backoffice/api/node_modules/mongodb/lib/cursor.js:859:16)\\n' +\r\n    '    at Cursor.close (/home/bk/Repos/elb-backoffice/api/node_modules/mongodb/lib/cursor.js:878:12)\\n' +\r\n    '    at /home/bk/Repos/elb-backoffice/api/node_modules/mongodb/lib/operations/to_array.js:35:25\\n' +\r\n    '    at handleCallback (/home/bk/Repos/elb-backoffice/api/node_modules/mongodb/lib/core/cursor.js:32:5)\\n' +\r\n    '    at /home/bk/Repos/elb-backoffice/api/node_modules/mongodb/lib/core/cursor.js:694:38\\n' +\r\n    '    at /home/bk/Repos/elb-backoffice/api/node_modules/mongodb/lib/core/cursor.js:703:39\\n' +\r\n    '    at Cursor._endSession (/home/bk/Repos/elb-backoffice/api/node_modules/mongodb/lib/core/cursor.js:404:7)\\n' +\r\n    '    at _setCursorNotifiedImpl (/home/bk/Repos/elb-backoffice/api/node_modules/mongodb/lib/core/cursor.js:703:10)\\n' +\r\n    '    at setCursorNotified (/home/bk/Repos/elb-backoffice/api/node_modules/mongodb/lib/core/cursor.js:694:3)'\r\n}\r\n```\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n```js\r\n/// Customer model\r\nimport { model, Schema } from 'mongoose';\r\n\r\nexport const customerSchema = new Schema({\r\n  vid: {\r\n    type: Number,\r\n    index: true,\r\n    unique: true,\r\n    required: true,\r\n  },\r\n});\r\n\r\n// Compile bare schema without hooks\r\nexport const BareCustomer = model('BareCustomer', customerSchema);\r\n\r\ncustomerSchema.virtual('elbCards', {\r\n  ref: 'ELBCard',\r\n  localField: '_id',\r\n  foreignField: 'customer',\r\n});\r\n\r\nfunction autopopulate(next): void {\r\n  this.populate('elbCards'); // throws \"MongooseError: If you are populating a virtual, you must set the localField and foreignField options\"\r\n  next();\r\n}\r\n\r\nfunction postHook(...args) {\r\n  // ... expensive calculation\r\n}\r\n\r\ncustomerSchema.pre('find', autopopulate);\r\ncustomerSchema.post('find', postHook);\r\n\r\ncustomerSchema.pre('findOne', autopopulate);\r\ncustomerSchema.post('findOne', postHook);\r\n\r\ncustomerSchema.pre('findOneAndUpdate', autopopulate);\r\ncustomerSchema.post('findOneAndUpdate', postHook);\r\n\r\nexport const Customer = BareCustomer.discriminator('Customer', customerSchema);\r\n```\r\n\r\n```js\r\n/// ELB Card schema\r\nimport { Schema, model } from 'mongoose';\r\n\r\nexport const elbCardSchema: Schema = new Schema({\r\n  customer: {\r\n    type: ObjectId,\r\n    ref: 'Customer',\r\n    required: true,\r\n  },\r\n\r\n  expirationDate: {\r\n    type: Date,\r\n    required: true,\r\n  },\r\n\r\n  cardNumber: {\r\n    type: String,\r\n    required: true,\r\n  },\r\n});\r\n\r\nexport const ELBCard = model('ELBCard', elbCardSchema);\r\n```\r\n\r\n**What is the expected behavior?**\r\nRemoving the discriminator resolves the issue and the `elbCards` field is populated, but as far as I know, discriminators should not effect populate behavior.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nNode.js v12.15.0\r\nMongoose v5.8.12\r\nMongoDB v4.2\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nReport a bug.\r\n\r\n**What is the current behavior?**\r\nIn mongoose@5.6.8 and higher set() method doesn't update inner field of subdocument if the name of this field is a number. It works in mongoose@5.6.7 though.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n```\r\nconst mongoose = require('mongoose');\r\nconst { Schema } = mongoose;\r\n\r\nconst MONGO_URL = ''; // need to specify\r\nconst options = {}; // need to specify\r\n\r\nconst dbConnection = mongoose.createConnection();\r\ndbConnection.openUri(MONGO_URL, options);\r\n\r\nconst placedItemSchema = new Schema(\r\n  {\r\n    image: String\r\n  },\r\n  { _id: false }\r\n);\r\n\r\nconst subdocumentSchema = new Schema(\r\n  {\r\n    placedItems: {\r\n      '1': placedItemSchema,\r\n      first: placedItemSchema\r\n    }\r\n  },\r\n  {\r\n    collection: 'test',\r\n    strict: true\r\n  }\r\n);\r\n\r\nconst objectSchema = new Schema(\r\n  {\r\n    placedItems: {\r\n      '1': {\r\n        image: String\r\n      },\r\n      first: {\r\n        image: String\r\n      }\r\n    }\r\n  },\r\n  {\r\n    collection: 'test-obj',\r\n    strict: true\r\n  }\r\n);\r\n\r\nconst TestSubdocumentModel = dbConnection.model('TestSubdocumentModel', subdocumentSchema);\r\nconst TestObjectModel = dbConnection.model('TestObjectModel', objectSchema);\r\n\r\nconst test = async () => {\r\n  const subdocDocument = await TestSubdocumentModel.create({\r\n    placedItems: { '1': { image: 'original' }, first: { image: 'original' } }\r\n  });\r\n\r\n  const objDocument = await TestObjectModel.create({\r\n    placedItems: { '1': { image: 'original' }, first: { image: 'original' } }\r\n  });\r\n\r\n  subdocDocument.set({\r\n    'placedItems.1.image': 'updated',\r\n    'placedItems.first.image': 'updated'\r\n  });\r\n\r\n  objDocument.set({\r\n    'placedItems.1.image': 'updated',\r\n    'placedItems.first.image': 'updated'\r\n  });\r\n\r\n  await subdocDocument.save();\r\n  await objDocument.save();\r\n\r\n  console.log(subdocDocument); // placedItems: { '1': { image: 'original' }, first: { image: 'updated' }\r\n  console.log(objDocument); // placedItems: { '1': { image: 'updated' }, first: { image: 'updated' }\r\n};\r\n\r\ntest();\r\n```\r\n\r\n**What is the expected behavior?**\r\nThe set() method should work the same regardless of how we specify the schema.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nNode.js version: 10.15.3\r\nMongoose version: 5.8.11\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"***feature* or *bug*?**\r\nbug (I think)\r\n\r\n## Reproduce:\r\n```js\r\nconst mongoose = require('mongoose')\r\nmongoose.set('useNewUrlParser', true)\r\nmongoose.set('useFindAndModify', false)\r\nmongoose.set('useCreateIndex', true)\r\nmongoose.set('useUnifiedTopology', true)\r\n\r\n;(async () => {\r\n\tawait mongoose.connect('mongodb://localhost/tst')\r\n\t\r\n\tconst db = mongoose.connection\r\n\tdb.on('error', console.error.bind(console, 'DB ERROR:'))\r\n\t\r\n\tconst TestSchema = new mongoose.Schema({\r\n\t\tdata: {type: Buffer, required: true, default: null},\r\n\t})\r\n\t\r\n\tconst Test = db.model('Test', TestSchema)\r\n\t\r\n\tconst doc = {\r\n\t\tdata: Buffer.from('buffer')\r\n\t}\r\n\r\n\t// Save -> OK:\r\n\tnew Test(doc).save()\r\n\t\t\t.then(console.log.bind(console, 'Saved successfully'))\r\n\t\t\t.catch(console.error.bind(console, 'Save Error:'))\r\n\t\r\n\t// Upsert -> Error: Validation failed: data.sub_type: Path `data` is required., data.position: Path `data` is required\r\n\tconst options = {\r\n\t\tupsert: true,\r\n\t\trunValidators: true,\r\n\t\tsetDefaultsOnInsert: true\r\n\t}\r\n\tTest.updateOne({name: 'name'}, doc, options)\r\n\t\t\t.then(console.log.bind(console, 'Upserted successfully'))\r\n\t\t\t.catch(console.error.bind(console, 'Upsert Error:'))\r\n})()\r\n```\r\n\r\n## Current behavior:\r\n\r\n`updateOne` throws validation error on `data` field (it's `required`), although I supplied it (`data: Buffer.from('buffer')`). There's no error on `save` the same `data`. \r\nThe error is not on `data` itself. **It's on `data.sub_type` and `data.position`**:\r\n\r\n*(Note: There is no difference if I **first `save` then `upsert`** or **first `upsert` then `save`**.)*\r\n\r\n```\r\nUpsert Error: Error [ValidationError]: Validation failed: data.sub_type: Path `data` is required., data.position: Path `data` is required.\r\n    at ... {\r\n  errors: {\r\n    'data.sub_type': MongooseError [ValidatorError]: Path `data` is required.\r\n        at ... {\r\n      message: 'Path `data` is required.',\r\n      ...\r\n    },\r\n    'data.position': MongooseError [ValidatorError]: Path `data` is required.\r\n        at ... {\r\n      message: 'Path `data` is required.',\r\n      ...\r\n    }\r\n  },\r\n  _message: 'Validation failed',\r\n  name: 'ValidationError'\r\n}\r\n\r\nSaved successfully {\r\n  data: Binary {\r\n    _bsontype: 'Binary',\r\n    sub_type: 0,\r\n    position: 6,\r\n    buffer: <Buffer 62 75 66 66 65 72>\r\n  },\r\n  _id: 5e4333e1faf4560b54397f89,\r\n  name: 'name9',\r\n  __v: 0\r\n}\r\n```\r\n\r\n*(A complete report with stack traces is provided at the end.)*\r\n\r\n## Expected behavior:\r\n```\r\nUpserted successfully { n: 1, nModified: 1, ok: 1 }\r\nSaved successfully { ...\r\n```\r\n## Versions:\r\n\r\nNode.js: `v13.6.0`\r\nMongoose: `v5.8.11`\r\nMongoDB: `v4.2.3`\r\n\r\n## Complete output log (current behaviour):\r\n\r\n```\r\nUpsert Error: Error [ValidationError]: Validation failed: data.sub_type: Path `data` is required., data.position: Path `data` is required.\r\n    at ValidationError.inspect (...\\node_modules\\mongoose\\lib\\error\\validation.js:61:24)\r\n    at formatValue (internal/util/inspect.js:693:31)\r\n    at inspect (internal/util/inspect.js:264:10)\r\n    at formatWithOptionsInternal (internal/util/inspect.js:1868:40)\r\n    at formatWithOptions (internal/util/inspect.js:1752:10)\r\n    at Object.Console.<computed> (internal/console/constructor.js:292:10)\r\n    at Object.warn (internal/console/constructor.js:302:61)\r\n    at processTicksAndRejections (internal/process/task_queues.js:97:5) {\r\n  errors: {\r\n    'data.sub_type': MongooseError [ValidatorError]: Path `data` is required.\r\n        at new ValidatorError (...\\node_modules\\mongoose\\lib\\error\\validator.js:29:11)\r\n        at validate (...\\node_modules\\mongoose\\lib\\schematype.js:1061:13)\r\n        at ...\\node_modules\\mongoose\\lib\\schematype.js:1115:11\r\n        at Array.forEach (<anonymous>)\r\n        at SchemaBuffer.SchemaType.doValidate (...\\node_modules\\mongoose\\lib\\schematype.js:1070:14)\r\n        at ...\\node_modules\\mongoose\\lib\\helpers\\updateValidators.js:155:22\r\n        at module.exports (...\\node_modules\\mongoose\\lib\\helpers\\updateValidators.js:217:7)\r\n        at ...\\node_modules\\mongoose\\lib\\query.js:3762:9\r\n        at Object.promiseOrCallback (...\\node_modules\\mongoose\\lib\\utils.js:261:12)\r\n        at model.Query.validate (...\\node_modules\\mongoose\\lib\\query.js:3757:16)\r\n        at ...\\node_modules\\kareem\\index.js:369:33\r\n        at processTicksAndRejections (internal/process/task_queues.js:79:11) {\r\n      message: 'Path `data` is required.',\r\n      name: 'ValidatorError',\r\n      properties: [Object],\r\n      kind: 'required',\r\n      path: 'data.sub_type',\r\n      value: 0,\r\n      reason: undefined,\r\n      [Symbol(mongoose:validatorError)]: true\r\n    },\r\n    'data.position': MongooseError [ValidatorError]: Path `data` is required.\r\n        at new ValidatorError (...\\node_modules\\mongoose\\lib\\error\\validator.js:29:11)\r\n        at validate (...\\node_modules\\mongoose\\lib\\schematype.js:1061:13)\r\n        at ...\\node_modules\\mongoose\\lib\\schematype.js:1115:11\r\n        at Array.forEach (<anonymous>)\r\n        at SchemaBuffer.SchemaType.doValidate (...\\node_modules\\mongoose\\lib\\schematype.js:1070:14)\r\n        at ...\\node_modules\\mongoose\\lib\\helpers\\updateValidators.js:155:22\r\n        at module.exports (...\\node_modules\\mongoose\\lib\\helpers\\updateValidators.js:217:7)\r\n        at ...\\node_modules\\mongoose\\lib\\query.js:3762:9\r\n        at Object.promiseOrCallback (...\\node_modules\\mongoose\\lib\\utils.js:261:12)\r\n        at model.Query.validate (...\\node_modules\\mongoose\\lib\\query.js:3757:16)\r\n        at ...\\node_modules\\kareem\\index.js:369:33\r\n        at processTicksAndRejections (internal/process/task_queues.js:79:11) {\r\n      message: 'Path `data` is required.',\r\n      name: 'ValidatorError',\r\n      properties: [Object],\r\n      kind: 'required',\r\n      path: 'data.position',\r\n      value: 6,\r\n      reason: undefined,\r\n      [Symbol(mongoose:validatorError)]: true\r\n    }\r\n  },\r\n  _message: 'Validation failed',\r\n  name: 'ValidationError'\r\n}\r\nSaved successfully {\r\n  data: Binary {\r\n    _bsontype: 'Binary',\r\n    sub_type: 0,\r\n    position: 6,\r\n    buffer: <Buffer 62 75 66 66 65 72>\r\n  },\r\n  _id: 5e433d63cf15542b68eb1934,\r\n  __v: 0\r\n}\r\n```"},{"labels":["bug"],"text":"Mongoose 5.8.2 introduced a regression when saving an unmodified document that was created within a not yet committed transaction. I assume this was introduced with #8428.\r\n\r\nThe following code works with Mongoose 5.8.1, but fails in 5.8.2 & 5.8.11:\r\n\r\n```javascript\r\nconst mongoose = require(\"mongoose\");\r\n\r\nconst TestSchema = new mongoose.Schema({});\r\n\r\nconst Test = mongoose.model(\"Test\", TestSchema);\r\n\r\n(async () => {\r\n  await mongoose.connect(\"mongodb://localhost/test\", {\r\n    useNewUrlParser: true,\r\n    useUnifiedTopology: true\r\n  });\r\n  mongoose.set(\"debug\", true);\r\n\r\n  await Test.createCollection();\r\n  const session = await mongoose.startSession();\r\n  await session.withTransaction(async () => {\r\n    const [test] = await Test.create([{}], { session });\r\n    await test.save(); // throws DocumentNotFoundError\r\n  });\r\n\r\n  await mongoose.disconnect();\r\n})();\r\n```\r\n\r\nOutput is (with Mongoose 5.8.11):\r\n```\r\nMongoose: tests.insertOne({ _id: ObjectId(\"5e3d9eb2e9d4b7aaadb7002f\"), __v: 0 }, { session: ClientSession(\"54ce1f5ca0e94ff082df826867e6cfa0\") })\r\nMongoose: tests.findOne({ _id: ObjectId(\"5e3d9eb2e9d4b7aaadb7002f\") }, { projection: { _id: 1 } })\r\n(node:43693) UnhandledPromiseRejectionWarning: DocumentNotFoundError: No document found for query \"{ _id: 5e3d9eb2e9d4b7aaadb7002f }\" on model \"Test\"\r\n    at new DocumentNotFoundError (node_modules/mongoose/lib/error/notFound.js:34:11)\r\n    at constructor.exists.then (node_modules/mongoose/lib/model.js:317:38)\r\n    at process._tickCallback (internal/process/next_tick.js:68:7)\r\n```\r\n\r\nExpected result:\r\nI would expect the implicitly called `findOne` to run within the document's session.\r\n\r\nError occurs with:\r\nMongoose: 5.8.2, 5.8.11\r\nNode: v10.18.1\r\nMongoDB: 4.0.16\r\n"},{"labels":["bug",null],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nI want to report a bug.\r\n\r\n**What is the current behavior?**\r\nWhen I trying to use the`findOne` method immediately after the `model` creation I get the exception:\r\n```\r\nTypeError: Cannot read property 'findOne' of null\r\n    at NativeCollection.(anonymous function) [as findOne] (/home/ales/Projects/own/mongoose-test/node_modules/mongoose/lib/drivers/node-mongodb-native/collection.js:166:24)\r\n    at NodeCollection.findOne (/home/ales/Projects/own/mongoose-test/node_modules/mquery/lib/collection/node.js:42:19)\r\n    at model.Query.Query.findOne (/home/ales/Projects/own/mongoose-test/node_modules/mquery/lib/mquery.js:2024:20)\r\n    at model.Query.<anonymous> (/home/ales/Projects/own/mongoose-test/node_modules/mongoose/lib/query.js:2129:22)\r\n    at model.Query._wrappedThunk [as _findOne] (/home/ales/Projects/own/mongoose-test/node_modules/mongoose/lib/helpers/query/wrapThunk.js:16:8)\r\n    at process.nextTick (/home/ales/Projects/own/mongoose-test/node_modules/kareem/index.js:369:33)\r\n    at process._tickCallback (internal/process/next_tick.js:61:11)\r\n```\r\n\r\nPlease note that I face this exception only if I use these options simultaneously in the `schema`:\r\n```js\r\nbufferCommands: false,\r\ncapped: { size: 1000000, max: 100 }\r\n```\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\nThere is the example code to reproduce the bug:\r\n\r\n```js\r\n  await mongoose.connect(\"mongodb://localhost:27017/test-db\", {\r\n    useUnifiedTopology: true,\r\n    useNewUrlParser: true\r\n  });\r\n\r\n  const Schema = mongoose.Schema;\r\n  const ObjectId = Schema.ObjectId;\r\n\r\n  const Test = new Schema(\r\n    {\r\n      author: ObjectId,\r\n      title: String\r\n    },\r\n    {\r\n      bufferCommands: false,\r\n      capped: { size: 1000000, max: 100 }\r\n    }\r\n  );\r\n\r\n  const testsModel = mongoose.model(\"test\", Test);\r\n\r\n  try {\r\n    const tests = await testsModel.findOne();\r\n    console.log(tests);\r\n  } catch (e) {\r\n    console.log(e)\r\n  }\r\n```\r\n\r\nIf I add the delay (e.g. 100 milliseconds) between the `mongoose.model` and `findOne` calls the problem disappears. But this doesn't look like a production-ready solution. Can you advice me more stable workaround, please?\r\n Also seems that the problem does not depend on collection existence in the database. \r\n\r\n**What is the expected behavior?**\r\nI should be able to call `findOne` immediately after the `model` call or I should have a possibility to check if the compiled `model` is ready to use.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nNode.js: **v10.15.3**\r\nMongoose: **5.8.11**\r\nMongoDB: **3.4**\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nJust migrated to `mongoose@5.8.11` from `mongoose@5.4.4` and `Document.set` method fails\r\n\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nI have 3 models with schemas like these: \r\n```javascript\r\nconst widgetSessionSchema = new mongoose.Schema({\r\n  plaid: {\r\n    nestedKey: String\r\n  }\r\n})\r\n```\r\n\r\n```javascript\r\nconst subscriptionSchema = new mongoose.Schema({\r\n  plaid: {\r\n    nestedKey: String\r\n  }\r\n})\r\n```\r\n\r\n```javascript\r\nconst chargeSchema = new mongoose.Schema({\r\n  plaid: {\r\n    nestedKey: String\r\n  }\r\n})\r\n```\r\n\r\nwhen Im trying to inherit `plaid` into `charge` document in this way: \r\n```javascript\r\n// widgetSession could either contain plaid or not\r\nconst widgetSession = new WidgetSession({});\r\n\r\nconsole.log(widgetSession.plaid) // {}\r\n\r\nconst subscription = new Subscription({ plaid: widgetSession.plaid });\r\n\r\nconsole.log(subscription.plaid) // MongooseDocument { undefined }\r\n\r\nconst charge = new Charge({});\r\n\r\ncharge.set({\r\n  plaid: subscription.plaid\r\n});\r\n```\r\nIm getting an error: \r\n\r\n```\r\nTypeError: Cannot convert undefined or null to object\r\n    at Function.keys (<anonymous>)\r\n    at model.$set (node_modules/mongoose/lib/document.js:867:21)\r\n    at model._handleIndex (node_modules/mongoose/lib/document.js:915:12)\r\n    at model.$set (node_modules/mongoose/lib/document.js:879:22)\r\n    at Context.<anonymous> (tests/unittests/models/subscription.spec.js:152:14)\r\n    at processImmediate (internal/timers.js:439:21)\r\n    at process.topLevelDomainCallback (domain.js:130:23)\r\n```\r\n\r\n**What is the expected behavior?**\r\n`charge.set` method does not end up in failure\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nNode.js: 12.14.1\r\nMongoose: 5.8.11\r\nMongoDB: 4.2.0\r\n\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nbug\r\n\r\n**What is the current behavior?**\r\nassume that schema not specified any index\r\n\r\ncreate index on Mongo\r\n```\r\nmodel.createIndex({a: 1, _id: 1})\r\nmodel.createIndex({a: 1, b: 1})\r\n```\r\nthen\r\n`model.syncIndexes()`\r\n\r\nIndex {a: 1, b: 1} is cleared but index {a: 1, _id: 1} is not\r\n\r\n**What is the expected behavior?** \r\nindex {a: 1, _id: 1} is removed\r\n\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nMongoose 5.0.15\r\nNodejs 10.18.1\r\nMongoDB 4.0.12\r\n\r\n\r\nIn the source code at\r\nhttps://github.com/Automattic/mongoose/blob/master/lib/model.js#L1390\r\n\r\nbefore index clean it check if key _id is existed to prevent remove {_id: 1} index which MongoDB not allow but it also excludes all the compound index that includes _id as part of keys to be clean.\r\n\r\nis this an expected behavior?\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nthrow `CastError: Cast to ObjectId failed`\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```js\r\nconst mongoose = require('mongoose');\r\nconst { Schema, ObjectId, model } = mongoose;\r\n\r\nmongoose.connect(\r\n  'mongodb://localhost:27017',\r\n  {\r\n    keepAlive: true,\r\n    dbName: 'localTest',\r\n    useNewUrlParser: true,\r\n    useFindAndModify: false,\r\n    useCreateIndex: true,\r\n    autoIndex: true,\r\n  },\r\n);\r\nmongoose.set('debug', true);\r\n\r\n(async () => {\r\n  const ImageSchema = new mongoose.Schema({\r\n    imageName: {\r\n      type: String,\r\n      required: true\r\n    }\r\n  });\r\n  const Image = mongoose.model('Image', ImageSchema);\r\n\r\n  const TextSchema = new mongoose.Schema({\r\n    textName: {\r\n      type: String,\r\n      required: true\r\n    }\r\n  });\r\n  const Text = mongoose.model('Text', TextSchema);\r\n\r\n  const ItemSchema = new Schema({\r\n    objectType: {\r\n      type: String,\r\n    },\r\n  }, {\r\n    discriminatorKey: 'objectType',\r\n    _id: false,\r\n  });\r\n\r\n  const InternalItemSchemaGen = () => new Schema({\r\n    data: {\r\n      type: ObjectId,\r\n      refPath: 'list.objectType',\r\n    },\r\n  }, {\r\n    _id: false,\r\n  });\r\n\r\n  const ExternalItemSchemaGen = () => new Schema({\r\n    data: {\r\n      sourceId: {\r\n        type: Number,\r\n        required: true,\r\n      },\r\n    },\r\n  }, {\r\n    _id: false,\r\n  });\r\n\r\n  const NestedDataSchema = new Schema({\r\n    data: new Schema({\r\n      title: {\r\n        type: String,\r\n      },\r\n      description: {\r\n        type: String,\r\n      },\r\n    }, {\r\n      _id: false,\r\n    }),\r\n  }, {\r\n    _id: false,\r\n  });\r\n\r\n  const ExampleSchema = new Schema({\r\n    test: {\r\n      type: String,\r\n    },\r\n    list: [{\r\n      type: ItemSchema,\r\n      required: false\r\n    }],\r\n  });\r\n  ExampleSchema.path('list').discriminator('Image', InternalItemSchemaGen());\r\n  ExampleSchema.path('list').discriminator('Text', InternalItemSchemaGen());\r\n  ExampleSchema.path('list').discriminator('ExternalSource', ExternalItemSchemaGen());\r\n  ExampleSchema.path('list').discriminator('NestedData', NestedDataSchema);\r\n  const Example = model('Example', ExampleSchema);\r\n\r\n  const image1 = await Image.create({\r\n    imageName: '01image',\r\n  });\r\n  const text2 = await Text.create({\r\n    textName: '02text',\r\n  });\r\n\r\n  // data inside list have no '_id' and the find result(s) \r\n  // include(s) these types of data causes the error\r\n  await Example.create({\r\n    test: 'example',\r\n    list: [\r\n      {\r\n        data: {\r\n          sourceId: 123\r\n        },\r\n        objectType: 'ExternalSource',\r\n      },\r\n      {\r\n        data: {\r\n          title: \"Aut porro\",\r\n          description: \"Iusto cumque iste officiis.\",\r\n        },\r\n        objectType: 'NestedData',\r\n      },\r\n    ],\r\n  });\r\n\r\n  await Example.create({\r\n    test: 'example',\r\n    list: [\r\n      {\r\n        data: image1._id,\r\n        objectType: 'Image',\r\n      },\r\n      {\r\n        data: text2._id,\r\n        objectType: 'Text',\r\n      },\r\n      {\r\n        data: {\r\n          sourceId: 123\r\n        },\r\n        objectType: 'ExternalSource',\r\n      },\r\n      {\r\n        data: {\r\n          title: \"Aut porro\",\r\n          description: \"Iusto cumque iste officiis.\",\r\n        },\r\n        objectType: 'NestedData',\r\n      },\r\n    ],\r\n  });\r\n  const query = Example\r\n    .find({})\r\n    .populate({\r\n      path: 'list.data',\r\n      options: { lean: true },\r\n    })\r\n    .lean()\r\n    .skip(0);\r\n\r\n  // if skip 0, here will throw \r\n  // \"Cast to ObjectId failed for value \"{ sourceId: 123 }\" at path \"_id\" for model \"Example\"\r\n\r\n  // if skip 1, no problem\r\n  const results = await query.exec();\r\n  return results;\r\n})().then(\r\n  async result => {\r\n    await mongoose.disconnect();\r\n    process.exit(0);\r\n  },\r\n  async _ => {\r\n    console.log(_);\r\n    await mongoose.disconnect();\r\n    process.exit(1);\r\n  }\r\n)\r\n```\r\n\r\n**What is the expected behavior?**\r\nreturn the result normally whether the items in list are all have no '_id'\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nnode: v10.17.0\r\nmongoDB: 4.2.1\r\nmongoose: 5.8.10\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nReport a Bug.\r\n\r\n**What is the current behavior?**\r\nIf a variable with the incorrect array nesting is assigned to a schema instance property it mutates the input instead of throwing a validation error. \r\n\r\nIt feels unhygienic to mutate the schema instance in this way but the resulting behaviour here is unexpected...\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nSee the reproduction here.\r\nhttps://codesandbox.io/s/sparkling-rain-dbv7v?fontsize=14&hidenavigation=1&theme=dark\r\n\r\nThe assignment on line 16:\r\n```\r\nposition.coordinates = [1, 2];\r\n```\r\n\r\nResults in the output:\r\n\r\n```\r\n\"coordinates\": [\r\n    [\r\n      1\r\n    ],\r\n    [\r\n      2\r\n    ]\r\n  ]\r\n```\r\n\r\n**What is the expected behavior?**\r\nAn error should be thrown when the incorrect schema object is assigned?\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nnode@11.7.0\r\nmongoose@5.8.10\r\nmongodb@4.2\r\n\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nPossible bug\r\n\r\n**What is the current behavior?**\r\n\r\nDependencies:\r\n* [*mongodb@3.5.2*](https://github.com/OpenUserJS/OpenUserJS.org/blob/1261d161171f0558aa27d4de97f4a9a6c4fc9a15/package.json#L40)\r\n* [*mongoose@5.7.11*](https://github.com/OpenUserJS/OpenUserJS.org/blob/1261d161171f0558aa27d4de97f4a9a6c4fc9a15/package.json#L41)\r\n\r\n\r\n``` console\r\n$ node -v\r\nv12.14.1\r\n\r\n$ node app.js\r\nStarting application...\r\nDisabling GitHub `hooks` in unsecure mode\r\nS3rver initialized\r\nerror: Error creating bucket. Bucket \"openuserjs.org\" already exists\r\ninfo: PUT /openuserjs.org 409 9ms -\r\nDefault dev S3 bucket already exists\r\nMongoDB connection is opened\r\nConnected to MongoDB v3.6.12\r\nGitHub client authenticated\r\nIndex event triggered/trapped for Script model\r\nScript indexes:\r\n [\r\n  {\r\n    v: 2,\r\n    key: { _id: 1 },\r\n    name: '_id_',\r\n    ns: 'openuserjs_devel.scripts'\r\n  },\r\n  {\r\n    v: 2,\r\n    key: { _authorId: 1, flagged: 1, isLib: 1 },\r\n    name: '_authorId_1_flagged_1_isLib_1',\r\n    ns: 'openuserjs_devel.scripts',\r\n    background: true\r\n  },\r\n  {\r\n    v: 2,\r\n    key: { installName: 1 },\r\n    name: 'installName_1',\r\n    ns: 'openuserjs_devel.scripts',\r\n    background: true\r\n  },\r\n  {\r\n    v: 2,\r\n    key: { isLib: 1, author: 1, name: 1 },\r\n    name: 'isLib_1_author_1_name_1',\r\n    ns: 'openuserjs_devel.scripts',\r\n    background: true\r\n  }\r\n]\r\n```\r\n\r\nUpdate to anything above *mongoose@5.7.11* *(Trying 5.8.9 currently)*\r\n\r\n``` console\r\n$ node app.js\r\nStarting application...\r\nDisabling GitHub `hooks` in unsecure mode\r\n(node:22429) UnhandledPromiseRejectionWarning: TypeError: Cannot read property 'createCollection' of undefined\r\n    at NativeConnection.createCollection (~/repo/git/OpenUserJS.org/martii/OpenUserJS.org/node_modules/mongoose/lib/connection.js:356:11)\r\n    at ~/repo/git/OpenUserJS.org/martii/OpenUserJS.org/node_modules/mongoose/lib/connection.js:451:12\r\n    at Object.promiseOrCallback (~/repo/git/OpenUserJS.org/martii/OpenUserJS.org/node_modules/mongoose/lib/utils.js:261:12)\r\n    at NativeConnection.createCollection (~/repo/git/OpenUserJS.org/martii/OpenUserJS.org/node_modules/mongoose/lib/connection.js:445:18)\r\n    at ~/repo/git/OpenUserJS.org/martii/OpenUserJS.org/node_modules/mongoose/lib/model.js:1300:13\r\n    at Object.promiseOrCallback (~/repo/git/OpenUserJS.org/martii/OpenUserJS.org/node_modules/mongoose/lib/utils.js:261:12)\r\n    at Function.createCollection (~/repo/git/OpenUserJS.org/martii/OpenUserJS.org/node_modules/mongoose/lib/model.js:1297:16)\r\n    at ~/repo/git/OpenUserJS.org/martii/OpenUserJS.org/node_modules/mongoose/lib/model.js:1341:10\r\n    at ~/repo/git/OpenUserJS.org/martii/OpenUserJS.org/node_modules/mongoose/lib/utils.js:283:5\r\n    at new Promise (<anonymous>)\r\n    at Object.promiseOrCallback (~/repo/git/OpenUserJS.org/martii/OpenUserJS.org/node_modules/mongoose/lib/utils.js:282:10)\r\n    at Function.syncIndexes (~/repo/git/OpenUserJS.org/martii/OpenUserJS.org/node_modules/mongoose/lib/model.js:1338:16)\r\n    at Object.<anonymous> (~/repo/git/OpenUserJS.org/martii/OpenUserJS.org/models/script.js:86:8)\r\n    at Module._compile (internal/modules/cjs/loader.js:955:30)\r\n    at Object.Module._extensions..js (internal/modules/cjs/loader.js:991:10)\r\n    at Module.load (internal/modules/cjs/loader.js:811:32)\r\n(node:22429) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). (rejection id: 1)\r\n(node:22429) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.\r\nS3rver initialized\r\nerror: Error creating bucket. Bucket \"openuserjs.org\" already exists\r\ninfo: PUT /openuserjs.org 409 10ms -\r\nDefault dev S3 bucket already exists\r\nMongoDB connection is opened\r\nConnected to MongoDB v3.6.12\r\nGitHub client authenticated\r\n```\r\n\r\n* Where we've disabled `autoIndex` for this partcular Schema at https://github.com/OpenUserJS/OpenUserJS.org/blob/1261d161171f0558aa27d4de97f4a9a6c4fc9a15/models/script.js#L44-L46\r\n* Code point failure on dev at https://github.com/OpenUserJS/OpenUserJS.org/blob/1261d161171f0558aa27d4de97f4a9a6c4fc9a15/models/script.js#L86-L92 \r\n* Connecting to the DB code point at https://github.com/OpenUserJS/OpenUserJS.org/blob/1261d161171f0558aa27d4de97f4a9a6c4fc9a15/app.js#L68-L103\r\n* Using `useUnifiedTopology` at https://github.com/OpenUserJS/OpenUserJS.org/blob/1261d161171f0558aa27d4de97f4a9a6c4fc9a15/app.js#L78 and https://github.com/OpenUserJS/OpenUserJS.org/blob/1261d161171f0558aa27d4de97f4a9a6c4fc9a15/app.js#L88 *(Production vs Development)*\r\n\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\nUpdate https://github.com/OpenUserJS/OpenUserJS.org/blob/1261d161171f0558aa27d4de97f4a9a6c4fc9a15/package.json#L41 to use `5.8.9` *(or anything above `5.7.11`)*\r\n\r\n**What is the expected behavior?**\r\n\r\nPrint out the secondary indexes we add and not throw the `UnhandledPromiseRejectionWarning` event.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nSee dependency list links and code blocks above.\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n\r\nBeen trying to figure this out for some weeks in spare time, even with some other issues regarding `.catch` which didn't work on `connect`, and I'm stumped. We can trap the global `UnhandledPromiseRejectionWarning` with `process` but that doesn't seem to be the correct methodology. I assume, hopefully correct,  that our secondary indexes aren't being synchronized with Mongo backend with this warning event.\r\n\r\nThanks so much for your assistance."},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug (not sure)\r\n\r\n**What is the current behavior?**\r\nthrow `\"Schema hasn't been registered for model \"NestedData\".\r\nUse mongoose.model(name, schema)\"` when create entry\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```js\r\nconst mongoose = require('mongoose');\r\nconst { Schema, ObjectId, model } = mongoose;\r\n\r\nmongoose.connect(\r\n  'mongodb://localhost:27017',\r\n  {\r\n    keepAlive: true,\r\n    dbName: 'localTest',\r\n    useNewUrlParser: true,\r\n    useFindAndModify: false,\r\n    useCreateIndex: true,\r\n    autoIndex: true,\r\n  },\r\n);\r\nmongoose.set('debug', true);\r\n\r\n(async () => {\r\n  const ImageSchema = new mongoose.Schema({\r\n    imageName: {\r\n      type: String,\r\n      required: true\r\n    }\r\n  });\r\n  const Image = mongoose.model('Image', ImageSchema);\r\n\r\n  const TextSchema = new mongoose.Schema({\r\n    textName: {\r\n      type: String,\r\n      required: true\r\n    }\r\n  });\r\n  const Text = mongoose.model('Text', TextSchema);\r\n\r\n  const ItemSchema = new Schema({\r\n    objectType: {\r\n      type: String,\r\n    },\r\n  }, {\r\n    discriminatorKey: 'objectType',\r\n    _id: false,\r\n  });\r\n\r\n  const InternalItemSchemaGen = () => new Schema({\r\n    data: {\r\n      type: ObjectId,\r\n      refPath: 'list.objectType',\r\n    },\r\n  }, {\r\n    _id: false,\r\n  });\r\n\r\n  const ExternalItemSchemaGen = () => new Schema({\r\n    data: {\r\n      sourceId: {\r\n        type: Number,\r\n        required: true,\r\n      },\r\n    },\r\n  }, {\r\n    _id: false,\r\n  });\r\n\r\n  const NestedDataSchema = new Schema({\r\n    // This Schema leads to 'MissingSchemaError'\r\n    // if use plain Object instead of 'new Schema', it works normally\r\n    data: new Schema({\r\n      title: {\r\n        type: String,\r\n      },\r\n      description: {\r\n        type: String,\r\n      },\r\n    }),\r\n  }, {\r\n    _id: false,\r\n  });\r\n\r\n  const ExampleSchema = new Schema({\r\n    test: {\r\n      type: String,\r\n    },\r\n    list: [{\r\n      type: ItemSchema,\r\n      required: false\r\n    }],\r\n  });\r\n  ExampleSchema.path('list').discriminator('Image', InternalItemSchemaGen());\r\n  ExampleSchema.path('list').discriminator('Text', InternalItemSchemaGen());\r\n  ExampleSchema.path('list').discriminator('ExternalSource', ExternalItemSchemaGen());\r\n  ExampleSchema.path('list').discriminator('NestedData', NestedDataSchema);\r\n  const Example = model('Example', ExampleSchema);\r\n\r\n  const image1 = await Image.create({\r\n    imageName: '01image',\r\n  });\r\n  const image2 = await Image.create({\r\n    imageName: '02image',\r\n  });\r\n  const text1 = await Text.create({\r\n    textName: '01text',\r\n  });\r\n  const text2 = await Text.create({\r\n    textName: '02text',\r\n  });\r\n\r\n  // error occurs here\r\n  const example = await Example.create({\r\n    test: 'example',\r\n    list: [\r\n      {\r\n        data: image1._id,\r\n        objectType: 'Image',\r\n      },\r\n      {\r\n        data: text2._id,\r\n        objectType: 'Text',\r\n      },\r\n      {\r\n        data: {\r\n          sourceId: 123\r\n        },\r\n        objectType: 'ExternalSource',\r\n      },\r\n      {\r\n        data: image2._id,\r\n        objectType: 'Image',\r\n      },\r\n      {\r\n        data: {\r\n          title: \"Aut porro\",\r\n          description: \"Iusto cumque iste officiis.\",\r\n        },\r\n        objectType: 'NestedData',\r\n      },\r\n      {\r\n        data: text1._id,\r\n        objectType: 'Text',\r\n      },\r\n    ],\r\n  });\r\n  const query = Example\r\n    .findById(example._id)\r\n    .populate({\r\n      path: 'list.data',\r\n    })\r\n    .lean()\r\n  const results = await query.exec();\r\n  return results;\r\n})().then(\r\n  async result => {\r\n    await mongoose.disconnect();\r\n    process.exit(0);\r\n  },\r\n  async _ => {\r\n    console.log(_);\r\n    await mongoose.disconnect();\r\n    process.exit(1);\r\n  }\r\n)\r\n```\r\n\r\n**What is the expected behavior?**\r\ncreate without error no matter the nested schema is a plain Object or an instance of `Schema`\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nnode: v10.17.0\r\nmongoDB: 4.2.1\r\nmongoose: 5.8.9\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nbug\r\n\r\n**What is the current behavior?**\r\nWhenever I use pipeline array instead of old `{ $set: { ...values } }` object as `update` argument, `__v` and `updatedAt` of document is not bumped.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nExecute findOneAndUpdate for model based on following schema: \r\n```ts\r\nconst BlogPost = new Schema({\r\n  title: String\r\n}, { timestamps: true });\r\n\r\nconst BlogPostModel = mongoose.model('BlogPost', BlogPost);\r\nconst post = new BlogPost({ title: 'a' });\r\nawait post.save();\r\nawait sleep(5000);\r\nconst updatedPost = await BlogPostModel.findOneAndUpdate({ title: 'a' }, [{ $set: { title: 'b' } }], { new: true });\r\n\r\n// updatedPost.__v is 0\r\n// updatedPost.updatedAt is the same as updatedPos.createdAt\r\n```\r\n**What is the expected behavior?**\r\n`updatedAt` and `__v` should act the same not matter if update document or aggregation pipeline is passed.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nNode.js - 9.9.0 \r\nmongoose - 5.8.9\r\nmongo - 4.2.1\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nsyncIndexes() does not check `collation` option, and index does not update. \r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nFirst run:\r\n```javascript\r\nconst mongoose = require('mongoose');\r\nconst userSchema = new mongoose.Schema({ username: String });\r\nuserSchema.index({ username: 1 }, { unique: true });\r\nconst User = mongoose.model('User', userSchema);\r\n\r\nasync function run() {\r\n    await mongoose.connect('mongodb://localhost/test', {\r\n        useNewUrlParser: true, useCreateIndex: true, useUnifiedTopology: true });\r\n    await mongoose.connection.dropDatabase();\r\n    await User.init();\r\n    // await User.create({ username: 'a' });\r\n    // await User.create({ username: 'A' });\r\n    console.log(await User.listIndexes());\r\n}\r\nrun().then(async () => { await mongoose.disconnect(); });\r\n```\r\nThen run with changed index:\r\n```javascript\r\nconst mongoose = require('mongoose');\r\nconst userSchema = new mongoose.Schema({ username: String });\r\nuserSchema.index({ username: 1 }, { unique: true,\r\n    collation: {\r\n        locale: 'en',\r\n        strength: 2\r\n    }\r\n});\r\nconst User = mongoose.model('User', userSchema);\r\n\r\nasync function run() {\r\n    await mongoose.connect('mongodb://localhost/test', {\r\n        useNewUrlParser: true, useCreateIndex: true, useUnifiedTopology: true });\r\n    await User.init();\r\n    await User.syncIndexes();\r\n    console.log(await User.listIndexes());\r\n}\r\nrun().then(async () => { await mongoose.disconnect(); });\r\n```\r\nIndex remains unchanged\r\n\r\n**What is the expected behavior?**\r\nThe index should be recreated. \r\nAdding `'collation'` to `optionKeys` in `model.js` like #6820 seem to update the index when documents are valid under the constraint. \r\nHowever, the index seem to get dropped without error and is not recreated when there are clashing documents. I'm not sure whether that's the desired behaviour. \r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nNode: v13.6.0\r\nMongoose: 5.8.9\r\nMongoDB: 3.4.1"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\n- Report a bug or make sure it's designed like this\r\n\r\n**What is the current behavior?**\r\n\r\nI have the following document in a collection in my MongoDB database:\r\n\r\n```\r\n\"_id\":\"5e2088563824e72ea5ee7095\",\r\n\"image\":\"xxx\",\r\n\"questions\":[ \r\n    {\r\n       \"_id\":\"5e2088563824e72ea5ee70c3\",\r\n       \"text\":\"test test test\",\r\n    },\r\n    {\r\n       \"_id\":\"5e2088563824e72ea5ee70be\",\r\n       \"text\":\"what is your age 1?\",\r\n    },\r\n    {\r\n       \"_id\":\"5e2088563824e72ea5ee70b9\",\r\n       \"text\":\"what is your gender 1?\",\r\n    },\r\n    {\r\n       \"_id\":\"5e2088563824e72ea5ee70b4\",\r\n       \"text\":\"what is your blood type 1?\",\r\n    },\r\n    {\r\n       \"_id\":\"5e2088563824e72ea5ee70af\",\r\n       \"text\":\"what is your blood type 1?\",\r\n    }\r\n],\r\n\"__v\":0\r\n```\r\nWithout doing any type of sorting on the questions array, the document would always return like above which is the natural ascending order of the data entered.\r\n\r\nWhat is strange is that the generated IDs are in reversed order as you can see:\r\n\r\n```\r\nkey 0 => 5e2088563824e72ea5ee70c3\r\nkey 1 => 5e2088563824e72ea5ee70be\r\nkey 2 => 5e2088563824e72ea5ee70b9\r\nkey 3 => 5e2088563824e72ea5ee70b4\r\nkey 4 => 5e2088563824e72ea5ee70af\r\n```\r\n\r\n**What is the expected behavior?**\r\n\r\nI expected the generated ID to match with the key of the array (ascending) so, it should be like:\r\n\r\n```\r\nkey 0 => 5e2088563824e72ea5ee7096\r\nkey 1 => 5e2088563824e72ea5ee709b\r\nkey 2 => 5e2088563824e72ea5ee70a0\r\nkey 3 => 5e2088563824e72ea5ee70a5\r\nkey 4 => 5e2088563824e72ea5ee70aa\r\n```\r\n\r\nWhy does Mongoose give the first element in the array the highest ObjectID and the last element the lowest ObjectID?\r\n\r\nHowever, behaviour of the generated document IDs is normal like the auto-increment of MySQL (ascending). It's just the nested arrays that have the reversed order.\r\n\r\nIs this a bug or is it the normal behavior? Why is it designed like this if this is normal?"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBug (breaking change)\r\n\r\n**What is the current behavior?**\r\n\r\nWhen using the `default` schema path option to create an array with a single subdoc, using `parent()` and `ownerDocument()` in the child schema's middleware seems to behave incorrectly. Encountered this issue when upgrading from mongoose 5.2.18 (where it was working as expected) to 5.8.7. I believe the changes that caused this change in behaviour happened in 5.3.x and 5.4.x.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n\r\n```js\r\nconst assert = require('chai').assert\r\nconst mongoose = require('mongoose')\r\nconst Schema = mongoose.Schema\r\n\r\nit('parent() and ownerDocument() should work when subdoc array is initialized using `default` schema path option', async () => {\r\n   // Setup our schemas + model\r\n\r\n   const locationSchema = new Schema({\r\n      name: String,\r\n      city: String\r\n   })\r\n\r\n   // Middleware to set a default location name derived from the parent organization doc\r\n   locationSchema.pre('validate', function (next) {\r\n      const location = this\r\n      console.log('Parent Doc', location.parent())\r\n      console.log('Owner Doc', location.ownerDocument())\r\n      if (location.isNew && !location.get('name') && location.ownerDocument().get('name')) {\r\n         location.set('name', `${location.ownerDocument().get('name')} Office`)\r\n      }\r\n\r\n      next()\r\n   })\r\n\r\n   // Here is a schema that exemplifies the issue\r\n   const buggyOrganizationSchema = new Schema({\r\n      name: String,\r\n      // Having a default doc this way causes issues\r\n      locations: { type: [locationSchema], default: [{}] }\r\n   })\r\n\r\n   // Here is a similar schema, but where a default location is added using middleware\r\n   const workingOrganizationSchema  = new Schema({\r\n      name: String,\r\n      locations: [locationSchema]\r\n   })\r\n\r\n   workingOrganizationSchema.pre('validate', function (next) {\r\n      if (this.locations.length === 0) {\r\n         this.locations.push({})\r\n      }\r\n\r\n      next()\r\n   })\r\n\r\n   // Models\r\n   const WorkingOrganization = mongoose.model('working-org', workingOrganizationSchema)\r\n   const BuggyOrganization = mongoose.model('buggy-org', buggyOrganizationSchema)\r\n\r\n   // Create new Org doc using the working schema\r\n   console.log('Test with default location being set via middleware')\r\n   const abcCorp = new WorkingOrganization()\r\n   abcCorp.set('name', 'ABC Corp')\r\n   await abcCorp.save()\r\n   assert(abcCorp.locations[0].name === 'ABC Corp Office')\r\n\r\n   // Create new Org doc using the buggy schema - this will fail\r\n   console.log('\\nTest with default location being set via default schema option')\r\n   const defCorp = new BuggyOrganization()\r\n   defCorp.set('name', 'DEF Corp')\r\n   await defCorp.save()\r\n   assert(defCorp.locations[0].name === 'DEF Corp Office')\r\n})\r\n```\r\n\r\nThe console output is:\r\n\r\n```\r\nTest with default location being set via middleware\r\nParent Doc { _id: 5e1f89b40d3bb32dfe699b03,\r\n  locations: [ { _id: 5e1f89b40d3bb32dfe699b04 } ],\r\n  name: 'ABC Corp' }\r\nOwner Doc { _id: 5e1f89b40d3bb32dfe699b03,\r\n  locations: [ { _id: 5e1f89b40d3bb32dfe699b04 } ],\r\n  name: 'ABC Corp' }\r\n\r\nTest with default location being set via default schema option\r\nParent Doc null\r\nOwner Doc { _id: 5e1f89b40d3bb32dfe699b06 }\r\n```\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nnode 8.15.0\r\nmongoose 5.8.7 (was working as expected in 5.2.18)\r\nMongoDB 3.6.10\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nI have updated from mongoose mongoose@4.13.20 to mongoose@5.8.7, using mongo 3.4.20\r\nI have noticed in version 5 when setting a value as undefined, it is saved as null.\r\nIn version 4 this would not have been set but ignored.\r\nThis happens when the minimize flag is set to false.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\n```javascript\r\n#!/usr/bin/env node\r\n'use strict';\r\n\r\nvar mongoose = require('mongoose');\r\n\r\nmongoose.connect('mongodb://localhost/mongoose5');\r\nconst minimize = false\r\nvar dummySchema = new mongoose.Schema({\r\n  alpha: { type: String },\r\n  beta: { type: String },\r\n  betaIsNull: { type: Boolean },\r\n  betaIsUndefined: { type: Boolean },\r\n  isMinimize: { type: Boolean }\r\n},\r\n{\r\n  toObject: {virtuals: true, minimize: minimize},\r\n  toJSON: {virtuals: true, minimize: minimize}\r\n}\r\n);\r\nmongoose.model('Dummy', dummySchema);\r\n\r\nvar dummy1 = new mongoose.models.Dummy({ alpha: 'blabla', beta: null, betaIsNull: true, isMinimize: minimize });\r\nvar dummy2 = new mongoose.models.Dummy({ alpha: 'blabla', beta: undefined, betaIsUndefined: true , isMinimize: minimize });\r\n\r\ndummy1.save(async (error, saved) => {\r\n  dummy2.save(async (error, saved) => {\r\n    var res = await mongoose.models.Dummy.find({})\r\n    console.log(res)\r\n    return mongoose.connection.close();\r\n  })\r\n});\r\n\r\n```\r\n\r\nOutput without minimize\r\n\r\n```\r\n[ { _id: 5e1ca7638d47a72f3a086116,\r\n    alpha: 'blabla',\r\n    beta: null,\r\n    betaIsNull: true,\r\n    isMinimize: false,\r\n    __v: 0,\r\n    id: '5e1ca7638d47a72f3a086116' },\r\n  { _id: 5e1ca7638d47a72f3a086117,\r\n    alpha: 'blabla',\r\n    beta: null,\r\n    betaIsUndefined: true,\r\n    isMinimize: false,\r\n    __v: 0,\r\n    id: '5e1ca7638d47a72f3a086117' } ]\r\n```\r\n\r\nOutput with minimize\r\n\r\n```\r\n[ { _id: 5e1ca7e42da4fa302e51ee8e,\r\n    alpha: 'blabla',\r\n    beta: null,\r\n    betaIsNull: true,\r\n    isMinimize: true,\r\n    __v: 0,\r\n    id: '5e1ca7e42da4fa302e51ee8e' },\r\n  { _id: 5e1ca7e42da4fa302e51ee8f,\r\n    alpha: 'blabla',\r\n    betaIsUndefined: true,\r\n    isMinimize: true,\r\n    __v: 0,\r\n    id: '5e1ca7e42da4fa302e51ee8f' } ]\r\n```\r\n\r\n**What is the expected behavior?**\r\nI expected the behavior to be the same in version 4 when using 5, in that undefined values are ignored, with or without the minimize flag. \r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\n- mongoose@4.13.20 \r\n- mongoose@5.8.7\r\n- mongo 3.4.20\r\n\r\n**comments**\r\nIn order to stop this, in mongoose 5 I have to set the minimize flag to true. Without this I end up saving documents with a load of null values, which will affect queries when using '$exists' operator.\r\n\r\nWhy has this changed? I can bypass it by setting minimize to true, but I'm unaware of the consequences.\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\nrelated to https://github.com/Automattic/mongoose/issues/8452\r\n\r\n**What is the current behavior?**\r\nlist data populated in wrong order and missing some data that should be populated\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```js\r\nconst mongoose = require('mongoose');\r\nconst { Schema, ObjectId, model } = mongoose;\r\n\r\nmongoose.connect(\r\n  'mongodb://localhost:27017',\r\n  {\r\n    keepAlive: true,\r\n    dbName: 'localTest',\r\n    useNewUrlParser: true,\r\n    useFindAndModify: false,\r\n    useCreateIndex: true,\r\n    autoIndex: true,\r\n  },\r\n);\r\nmongoose.set('debug', true);\r\n\r\n(async () => {\r\n  const ImageSchema = new mongoose.Schema({\r\n    imageName: {\r\n      type: String,\r\n      required: true\r\n    }\r\n  });\r\n  const Image = mongoose.model('Image', ImageSchema);\r\n\r\n  const TextSchema = new mongoose.Schema({\r\n    textName: {\r\n      type: String,\r\n      required: true\r\n    }\r\n  });\r\n  const Text = mongoose.model('Text', TextSchema);\r\n\r\n  const ItemSchema = new Schema({\r\n    objectType: {\r\n      type: String,\r\n    },\r\n  }, {\r\n    discriminatorKey: 'objectType',\r\n    _id: false,\r\n  });\r\n\r\n  const InternalItemSchemaGen = () => new Schema({\r\n    data: {\r\n      type: ObjectId,\r\n      refPath: 'list.objectType',\r\n    },\r\n  }, {\r\n    _id: false,\r\n  });\r\n\r\n  const ExternalItemSchemaGen = () => new Schema({\r\n    data: {\r\n      sourceId: {\r\n        type: Number,\r\n        required: true,\r\n      },\r\n    },\r\n  }, {\r\n    _id: false,\r\n  });\r\n\r\n  const ExampleSchema = new Schema({\r\n    test: {\r\n      type: String,\r\n    },\r\n    list: [{\r\n      type: ItemSchema,\r\n      required: false\r\n    }],\r\n  });\r\n\r\n  // Unrelated to this issue, not sure is it an expected behavior:\r\n  // If I pass the same schema object to different discriminators, \r\n  // the later discriminator will override the previous one,\r\n  // instead of sharing the same structure with different discriminator name.\r\n  ExampleSchema.path('list').discriminator('Image', InternalItemSchemaGen());\r\n  ExampleSchema.path('list').discriminator('Text', InternalItemSchemaGen());\r\n  ExampleSchema.path('list').discriminator('ExternalSourceA', ExternalItemSchemaGen());\r\n  ExampleSchema.path('list').discriminator('ExternalSourceB', ExternalItemSchemaGen());\r\n  const Example = model('Example', ExampleSchema);\r\n\r\n  const image1 = await Image.create({\r\n    imageName: '01image',\r\n  });\r\n  const image2 = await Image.create({\r\n    imageName: '02image',\r\n  });\r\n  const text1 = await Text.create({\r\n    textName: '01text',\r\n  });\r\n  const text2 = await Text.create({\r\n    textName: '02text',\r\n  });\r\n\r\n  const example = await Example.create({\r\n    test: 'example',\r\n    list: [\r\n      {\r\n        data: image1._id,\r\n        objectType: 'Image',\r\n      },\r\n      {\r\n        data: text2._id,\r\n        objectType: 'Text',\r\n      },\r\n      {\r\n        data: {\r\n          sourceId: 123\r\n        },\r\n        objectType: 'ExternalSourceA',\r\n      },\r\n      {\r\n        data: image2._id,\r\n        objectType: 'Image',\r\n      },\r\n      {\r\n        data: {\r\n          sourceId: 456\r\n        },\r\n        objectType: 'ExternalSourceB',\r\n      },\r\n      {\r\n        data: text1._id,\r\n        objectType: 'Text',\r\n      },\r\n    ],\r\n  });\r\n  const query = Example\r\n    .findById(example._id)\r\n    .populate({\r\n      path: 'list.data',\r\n    })\r\n    .lean()\r\n\r\n  const result = await query.exec();\r\n\r\n  // Issue occurs here, explain in the next part\r\n  return result;\r\n})().then(\r\n  async result => {\r\n    await mongoose.disconnect();\r\n    process.exit(0);\r\n  },\r\n  async _ => {\r\n    console.log(_);\r\n    await mongoose.disconnect();\r\n    process.exit(1);\r\n  }\r\n)\r\n```\r\n\r\n**What is the expected behavior?**\r\nWhat I received was\r\n```js\r\n{\r\n  \"_id\": \"5e17fadda260df3a0093e2f8\",\r\n  \"test\": \"example\",\r\n  \"list\": [\r\n    // This item is ok\r\n    {\r\n      \"objectType\": \"Image\",\r\n      \"data\": {\r\n        \"_id\": \"5e17fadda260df3a0093e2f4\",\r\n        \"imageName\": \"01image\",\r\n        \"__v\": 0\r\n      }\r\n    },\r\n    // This item is ok\r\n    {\r\n      \"objectType\": \"Text\",\r\n      \"data\": {\r\n        \"_id\": \"5e17fadda260df3a0093e2f7\",\r\n        \"textName\": \"02text\",\r\n        \"__v\": 0\r\n      }\r\n    },\r\n    // This item is wrong, data should be { sourceId: 123 }\r\n    {\r\n      \"objectType\": \"ExternalSourceA\",\r\n      \"data\": {\r\n        \"_id\": \"5e17fadda260df3a0093e2f5\",\r\n        \"imageName\": \"02image\",\r\n        \"__v\": 0\r\n      }\r\n    },\r\n     // This item is wrong, data should be image data\r\n    {\r\n      \"objectType\": \"Image\",\r\n      \"data\": {\r\n        \"_id\": \"5e17fadda260df3a0093e2f6\",\r\n        \"textName\": \"01text\",\r\n        \"__v\": 0\r\n      }\r\n    },\r\n    // This item is ok\r\n    {\r\n      \"objectType\": \"ExternalSourceB\",\r\n      \"data\": {\r\n        \"sourceId\": 456\r\n      }\r\n    },\r\n    // This should be populated but not\r\n    {\r\n      \"objectType\": \"Text\",\r\n      \"data\": \"5e17fadda260df3a0093e2f6\"\r\n    }\r\n  ],\r\n  \"__v\": 0\r\n}\r\n```\r\n\r\nWhat I expected is:\r\n```js\r\n{\r\n  \"_id\": \"5e17fadda260df3a0093e2f8\",\r\n  \"test\": \"example\",\r\n  \"list\": [\r\n    {\r\n      \"objectType\": \"Image\",\r\n      \"data\": {\r\n        \"_id\": \"5e17fadda260df3a0093e2f4\",\r\n        \"imageName\": \"01image\",\r\n        \"__v\": 0\r\n      }\r\n    },\r\n    {\r\n      \"objectType\": \"Text\",\r\n      \"data\": {\r\n        \"_id\": \"5e17fadda260df3a0093e2f7\",\r\n        \"textName\": \"02text\",\r\n        \"__v\": 0\r\n      }\r\n    },\r\n    {\r\n      \"objectType\": \"ExternalSourceA\",\r\n      \"data\": {\r\n        \"sourceId\": 123\r\n      }\r\n    },\r\n    {\r\n      \"objectType\": \"Image\",\r\n      \"data\": {\r\n        \"_id\": \"some mongo id\",\r\n        \"imageName\": \"02image\",\r\n        \"__v\": 0\r\n      }\r\n    },\r\n    {\r\n      \"objectType\": \"ExternalSourceB\",\r\n      \"data\": {\r\n        \"sourceId\": 456\r\n      }\r\n    },\r\n    {\r\n      \"objectType\": \"Text\",\r\n      \"data\": {\r\n        \"_id\": \"5e17fadda260df3a0093e2f6\",\r\n        \"textName\": \"01text\",\r\n        \"__v\": 0\r\n      }\r\n    }\r\n  ],\r\n  \"__v\": 0\r\n}\r\n```\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nnode: v10.17.0\r\nmongoDB: 4.2.1\r\nmongoose: 5.8.6\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\nHappens in 5.8.5, but not in 5.8.3\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBUG\r\n\r\n**What is the current behavior?**\r\nModifying several nested paths within arrays and calling the root-document's save method results in an validation error: \"Can't validate() the same doc multiple times in parallel.\"\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nNot really sure tbh, it is consistent, but I don't have the time to create a sample that exhibits the behavior.  Please note, we are only calling save once with an await and are not calling validate ourselves.\r\n\r\n**What is the expected behavior?**\r\n\r\nThe object should be saved successfully as it was in 5.8.3.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nNode: v8.15.0\r\nMongoDB: 4.2.2\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n\r\nFULL EXCEPTION DUMP:\r\n\r\nUnhandled Rejection at [object Promise]:  { ValidationError: prospect validation failed: quotes.1.versions.21.terms.0.usageSummary: Can't validate() the same doc multiple times in parallel. Document: 5e14bef17bdb101633602aa6, quotes.1.versions.21.terms.1.usageSummary: Can't validate() the same doc multiple times in parallel. Document: 5e14bef17bdb101633602acc, quotes.1.versions.21.terms.3.usageSummary: Can't validate() the same doc multiple times in parallel. Document: 5e14bef27bdb101633602afe, quotes.1.versions.21.terms.2.usageSummary: Can't validate() the same doc multiple times in parallel. Document: 5e14bef27bdb101633602b3c, quotes.1.versions.21.usageSummary: Can't validate() the same doc multiple times in parallel. Document: 5e14bef27bdb101633602b70\r\n    at ValidationError.inspect (/.../node_modules/mongoose/lib/error/validation.js:61:24)\r\n    at formatValue (util.js:399:38)\r\n    at inspect (util.js:293:10)\r\n    at Object.format (util.js:160:12)\r\n    at Object.inspect (/.../node_modules/log4js/lib/layouts.js:36:66)\r\n    at formatValue (util.js:399:38)\r\n    at inspect (util.js:293:10)\r\n    at Object.format (util.js:222:18)\r\n    at formatLogData (/.../node_modules/log4js/lib/layouts.js:55:22)\r\n    at colouredLayout (/.../node_modules/log4js/lib/layouts.js:130:7)\r\n    at /.../node_modules/log4js/lib/appenders/stdout.js:5:29\r\n    at appenders.forEach (/.../node_modules/log4js/lib/log4js.js:142:5)\r\n    at Array.forEach (<anonymous>)\r\n    at Logger.sendLogEventToAppender [as dispatch] (/.../node_modules/log4js/lib/log4js.js:141:13)\r\n    at Logger._log (/.../node_modules/log4js/lib/logger.js:95:12)\r\n    at Logger.(anonymous function) [as error] (/.../node_modules/log4js/lib/logger.js:127:14)\r\n    at process.Application.process.on (/.../Application.js:61:35)\r\n    at emitTwo (events.js:126:13)\r\n    at process.emit (events.js:214:7)\r\n    at methodName (/.../node_modules/bluebird/js/release/debuggability.js:186:33)\r\n    at activeFireEvent (/.../node_modules/bluebird/js/release/debuggability.js:229:44)\r\n    at fireRejectionEvent (/.../node_modules/bluebird/js/release/debuggability.js:614:14)\r\n    at Promise._notifyUnhandledRejection (/.../node_modules/bluebird/js/release/debuggability.js:61:9)\r\n    at Async._drainQueue (/.../node_modules/bluebird/js/release/async.js:138:12)\r\n    at Async._drainQueues (/.../node_modules/bluebird/js/release/async.js:146:10)\r\n    at Immediate.Async.drainQueues (/.../node_modules/bluebird/js/release/async.js:17:14)\r\n    at runCallback (timers.js:810:20)\r\n    at tryOnImmediate (timers.js:768:5)\r\n  errors: \r\n   { 'quotes.1.versions.21.terms.0.usageSummary': \r\n      { ParallelValidateError: Can't validate() the same doc multiple times in parallel. Document: 5e14bef17bdb101633602aa6\r\n    at ParallelValidateError.MongooseError [as constructor] (/.../node_modules/mongoose/lib/error/mongooseError.js:10:11)\r\n    at new ParallelValidateError (/.../node_modules/mongoose/lib/error/parallelValidate.js:18:17)\r\n    at SingleNested.Document.validate (/.../node_modules/mongoose/lib/document.js:2033:24)\r\n    at /.../node_modules/mongoose/lib/schema/SingleNestedPath.js:252:11\r\n    at SingleNestedPath.SchemaType.doValidate (/.../node_modules/mongoose/lib/schematype.js:1046:12)\r\n    at SingleNestedPath.doValidate (/.../node_modules/mongoose/lib/schema/SingleNestedPath.js:244:35)\r\n    at /.../node_modules/mongoose/lib/document.js:2323:9\r\n    at _combinedTickCallback (internal/process/next_tick.js:132:7)\r\n    at process._tickCallback (internal/process/next_tick.js:181:9)\r\n        message: 'Can\\'t validate() the same doc multiple times in parallel. Document: 5e14bef17bdb101633602aa6',\r\n        name: 'ParallelValidateError' },\r\n     'quotes.1.versions.21.terms.1.usageSummary': \r\n      { ParallelValidateError: Can't validate() the same doc multiple times in parallel. Document: 5e14bef17bdb101633602acc\r\n    at ParallelValidateError.MongooseError [as constructor] (/.../node_modules/mongoose/lib/error/mongooseError.js:10:11)\r\n    at new ParallelValidateError (/.../node_modules/mongoose/lib/error/parallelValidate.js:18:17)\r\n    at SingleNested.Document.validate (/.../node_modules/mongoose/lib/document.js:2033:24)\r\n    at /.../node_modules/mongoose/lib/schema/SingleNestedPath.js:252:11\r\n    at SingleNestedPath.SchemaType.doValidate (/.../node_modules/mongoose/lib/schematype.js:1046:12)\r\n    at SingleNestedPath.doValidate (/.../node_modules/mongoose/lib/schema/SingleNestedPath.js:244:35)\r\n    at /.../node_modules/mongoose/lib/document.js:2323:9\r\n    at _combinedTickCallback (internal/process/next_tick.js:132:7)\r\n    at process._tickCallback (internal/process/next_tick.js:181:9)\r\n        message: 'Can\\'t validate() the same doc multiple times in parallel. Document: 5e14bef17bdb101633602acc',\r\n        name: 'ParallelValidateError' },\r\n     'quotes.1.versions.21.terms.3.usageSummary': \r\n      { ParallelValidateError: Can't validate() the same doc multiple times in parallel. Document: 5e14bef27bdb101633602afe\r\n    at ParallelValidateError.MongooseError [as constructor] (/.../node_modules/mongoose/lib/error/mongooseError.js:10:11)\r\n    at new ParallelValidateError (/.../node_modules/mongoose/lib/error/parallelValidate.js:18:17)\r\n    at SingleNested.Document.validate (/.../node_modules/mongoose/lib/document.js:2033:24)\r\n    at /.../node_modules/mongoose/lib/schema/SingleNestedPath.js:252:11\r\n    at SingleNestedPath.SchemaType.doValidate (/.../node_modules/mongoose/lib/schematype.js:1046:12)\r\n    at SingleNestedPath.doValidate (/.../node_modules/mongoose/lib/schema/SingleNestedPath.js:244:35)\r\n    at /.../node_modules/mongoose/lib/document.js:2323:9\r\n    at _combinedTickCallback (internal/process/next_tick.js:132:7)\r\n    at process._tickCallback (internal/process/next_tick.js:181:9)\r\n        message: 'Can\\'t validate() the same doc multiple times in parallel. Document: 5e14bef27bdb101633602afe',\r\n        name: 'ParallelValidateError' },\r\n     'quotes.1.versions.21.terms.2.usageSummary': \r\n      { ParallelValidateError: Can't validate() the same doc multiple times in parallel. Document: 5e14bef27bdb101633602b3c\r\n    at ParallelValidateError.MongooseError [as constructor] (/.../node_modules/mongoose/lib/error/mongooseError.js:10:11)\r\n    at new ParallelValidateError (/.../node_modules/mongoose/lib/error/parallelValidate.js:18:17)\r\n    at SingleNested.Document.validate (/.../node_modules/mongoose/lib/document.js:2033:24)\r\n    at /.../node_modules/mongoose/lib/schema/SingleNestedPath.js:252:11\r\n    at SingleNestedPath.SchemaType.doValidate (/.../node_modules/mongoose/lib/schematype.js:1046:12)\r\n    at SingleNestedPath.doValidate (/.../node_modules/mongoose/lib/schema/SingleNestedPath.js:244:35)\r\n    at /.../node_modules/mongoose/lib/document.js:2323:9\r\n    at _combinedTickCallback (internal/process/next_tick.js:132:7)\r\n    at process._tickCallback (internal/process/next_tick.js:181:9)\r\n        message: 'Can\\'t validate() the same doc multiple times in parallel. Document: 5e14bef27bdb101633602b3c',\r\n        name: 'ParallelValidateError' },\r\n     'quotes.1.versions.21.usageSummary': \r\n      { ParallelValidateError: Can't validate() the same doc multiple times in parallel. Document: 5e14bef27bdb101633602b70\r\n    at ParallelValidateError.MongooseError [as constructor] (/.../node_modules/mongoose/lib/error/mongooseError.js:10:11)\r\n    at new ParallelValidateError (/.../node_modules/mongoose/lib/error/parallelValidate.js:18:17)\r\n    at SingleNested.Document.validate (/.../node_modules/mongoose/lib/document.js:2033:24)\r\n    at /.../node_modules/mongoose/lib/schema/SingleNestedPath.js:252:11\r\n    at SingleNestedPath.SchemaType.doValidate (/.../node_modules/mongoose/lib/schematype.js:1046:12)\r\n    at SingleNestedPath.doValidate (/.../node_modules/mongoose/lib/schema/SingleNestedPath.js:244:35)\r\n    at /.../node_modules/mongoose/lib/document.js:2323:9\r\n    at _combinedTickCallback (internal/process/next_tick.js:132:7)\r\n    at process._tickCallback (internal/process/next_tick.js:181:9)\r\n        message: 'Can\\'t validate() the same doc multiple times in parallel. Document: 5e14bef27bdb101633602b70',\r\n        name: 'ParallelValidateError' } },\r\n  _message: 'prospect validation failed',\r\n  name: 'ValidationError' }"},{"labels":["bug"],"text":"Hi,\r\n\r\nI find that the result of function ownerDocument() is wrong after replaced sub document array by sub document array from another document. The output result is still the original parent document, not the updated one.\r\n\r\nBelow is the test code to reproduce the problem:\r\n```javascript\r\nvar chai = require(\"chai\");\r\nvar expect = chai.expect;\r\n\r\nconst mongoose = require('mongoose');\r\nconst Schema = mongoose.Schema;\r\nconst Model = mongoose.model;\r\n\r\nconst nestedArraySchema = new Schema({\r\n  name: String,\r\n  subDocArray: [new Schema({\r\n    name: String,\r\n  })],\r\n});\r\n\r\nconst nestedArrayModel = Model('NestedArray', nestedArraySchema);\r\n\r\ndescribe('Issue: ownerDocument of subDocument array do not update', () => {\r\n  it('Replace subDoc array by subDoc array of another document', () => {\r\n    const doc1 = new nestedArrayModel({\r\n      name: 'doc1',\r\n      subDocArray: [{\r\n        name: 'subDoc',\r\n      }],\r\n    });\r\n    const doc2 = new nestedArrayModel({\r\n      name: 'doc2',\r\n      subDocArray: [{\r\n        name: 'subDoc',\r\n      }],\r\n    });\r\n\r\n    // replace subDoc array by subDoc array of doc2\r\n    doc1.subDocArray = doc2.subDocArray;\r\n\r\n    // the subDoc of doc1 array still points to doc2\r\n    expect(doc1.subDocArray[0].ownerDocument().id).to.equal(doc1.id);\r\n    expect(doc1.subDocArray[0].ownerDocument().name).to.equal(doc1.name);\r\n  });\r\n});\r\n```\r\n\r\nAnd the test result is:\r\n```\r\n$ mocha index.js\r\n\r\n\r\n  Issue: ownerDocument of subDocument array do not update\r\n    1) Replace subDoc array by subDoc array of another document\r\n\r\n\r\n  0 passing (16ms)\r\n  1 failing\r\n\r\n  1) Issue: ownerDocument of subDocument array do not update\r\n       Replace subDoc array by subDoc array of another document:\r\n\r\n      AssertionError: expected '5e129c929574b8fd4f50a6c1' to equal '5e129c929574b8fd4f50a6bf'\r\n      + expected - actual\r\n\r\n      -5e129c929574b8fd4f50a6c1\r\n      +5e129c929574b8fd4f50a6bf\r\n      \r\n      at Context.it (index.js:60:55)\r\n```\r\n\r\n------------------------------\r\nnodejs: 10.17.0\r\nmongoose: 5.8.4\r\nchai: 4.2.0\r\nmocha: 7.0.0"},{"labels":["bug"],"text":"I could be missing that this is expected behavior, but can't find anything in the documentation about this. `remove` has deprecation warnings so we are moving to `deleteMany`, however when using discriminators, the behavior is different. Using `remove` on a model, only those documents that match the model will be removed. When using `deleteMany`, all documents from the base model (shared in the collection by the discriminator) are deleted.\r\n\r\nHere is what I did to test\r\n```\r\nconst PeopleSchema = new mongoose.Schema({\r\n  job: {type: String},\r\n  name: {type: String}\r\n}, {discriminatorKey: 'job'});\r\n\r\nlet People = mongoose.model('People', PeopleSchema);\r\n\r\nconst DesignerSchema = new mongoose.Schema({\r\n  badge: {type: String}\r\n});\r\n\r\nlet Designer = People.discriminator('Designer', DesignerSchema);\r\n\r\nconst DeveloperSchema = new mongoose.Schema({\r\n  coffeeAmount: {type: Number}\r\n});\r\n\r\nlet Developer = People.discriminator('Developer', DeveloperSchema);\r\n\r\nlet runTest = async function() {\r\n  await Designer.create([\r\n    {name: 'Bob', badge: '1234'},\r\n    {name: 'Jeff', badge: '1234'},\r\n    {name: 'Josh', badge: '1234'},\r\n    {name: 'Billy', badge: '1234'},\r\n    {name: 'Sam', badge: '1234'}\r\n  ]);\r\n\r\n  await Developer.create([\r\n    {name: 'Ryan', coffeeAmount: 2},\r\n    {name: 'Rob', coffeeAmount: 2},\r\n    {name: 'Ben', coffeeAmount: 2}\r\n  ]);\r\n\r\n  let startCount = await People.countDocuments({});\r\n  console.log(`there are ${startCount} in the db`);\r\n\r\n// await Developer.remove();\r\n  await Developer.deleteMany();\r\n\r\n  let newCount = await People.countDocuments({});\r\n  console.log(`now there are ${newCount} in the db`);\r\n}\r\n\r\nrunTest();\r\n```\r\n\r\nIn the test, if I use `remove` there are 5 documents left. When I run with `deleteMany` there are 0 left.\r\n\r\nI also don't see that `remove` is being deprecated [here](https://mongoosejs.com/docs/api/model.html#model_Model-remove) or [here](https://mongoosejs.com/docs/api/model.html#model_Model.remove), but I do get logged warnings when using it, which is why the switch to `deleteMany`."},{"labels":["bug"],"text":"If the model.validate() function is called, then the model.save() function is called, the save() function apparently does not validate the data, and proceeds to write the data to the database, even if it would not pass validation.\r\n\r\nFull description with example code:\r\nhttps://stackoverflow.com/questions/59547793/mongoose-saves-invalid-data-without-throwing-validation-errors-if-model-validate\r\n\r\nThis issue seems to be mitigated by calling the validateSync() function, but even so, it should NEVER write data failing to pass validation to the database."},{"labels":["bug"],"text":"Slightly related to https://github.com/Automattic/mongoose/issues/8342, when I follow the advice and set 'setDefaultsOnInsert' to true, a new object always gets the default value - even when the update object passed in has a non-default override\r\n\r\n```javascript\r\nconst _opts = { upsert: true, setDefaultsOnInsert: true };\r\nconst _fields = {\r\n  name: String,\r\n  age: { type: Number, default: 25, immutable: true }\r\n}\r\nmodel.findOneAndUpdate( { name : \"John\" }, { name : \"John\", age: 20 }, _opts );\r\n```\r\nWhen no match is found this results in age=25, as opposed to age=20 as expected. When I set 'immutable' to false, it becomes 20.\r\nThe semantics of 'immutable' in combination with default values are inconsistent: There is no double assignment here, the default should only be used if no value is provided"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?** *bug*\r\n\r\n**What is the current behavior?**\r\n\r\nIf a pre validate hook in a sub schema throw an error whose name is `ValidationError` it's swallowed.\r\nThis is the case for instance when throwing a validation error from [joi](https://github.com/hapijs/joi).\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n\r\n```js\r\nconst Mongoose = require('mongoose');\r\n\r\nconst childSchema = Mongoose.Schema({\r\n\tname: String\r\n});\r\n\r\nchildSchema.pre('validate', function () {\r\n\tif (this.name === 'Invalid') {\r\n\t\tconst error = new Error('invalid name');\r\n\t\terror.name = 'ValidationError'; // withouth this the error is not swallowed\r\n\t\tthrow error;\r\n\t}\r\n});\r\n\r\nconst fatherSchema = Mongoose.Schema({\r\n\tchildren: [\r\n\t\tchildSchema\r\n\t]\r\n});\r\n\r\nconst Father = Mongoose.model('person', fatherSchema);\r\n\r\nnew Father({\r\n\tchildren: [\r\n\t\t{\r\n\t\t\tname: 'Valid'\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: 'Invalid'\r\n\t\t}\r\n\t]\r\n\r\n}).validate((err) => {\r\n\t// err is null\r\n\tconsole.log(err);\r\n})\r\n```\r\n\r\n**What is the expected behavior?**\r\n\r\n`err` should be the error throw in the pre validate hook.\r\n\r\nThe faulty  check is at https://github.com/Automattic/mongoose/blob/master/lib/schema/documentarray.js#L231\r\n\r\nI saw a few more places in the code you check for `error.name === \"ValidationError\"` and a few places you check for `err[validatorErrorSymbol]` in addition to `name`.\r\nI guess it you should always check for `err[validatorErrorSymbol]`?\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\n```\r\nnodejs v12.13.0\r\nmongoose 5.8.3\r\nmongodb 3.4.1\r\n```\r\n\r\n\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n*bug*\r\n\r\n**What is the current behavior?**\r\nI just upgraded my mongoose from version `5.7.11` to `5.8.3` and on my models that have an undefined array, using `populate` on that field is returning `undefined` instead of `[]` like it previously did.\r\n\r\nI'm not sure if this change was intentional or not, I couldn't seem to track it down in the issues over the past handful of releases.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n```\r\nvar TestSchema = new Schema({\r\n  thingIds: { type: [Schema.Types.ObjectId] },\r\n});\r\n\r\nTestSchema.virtual('things', {\r\n  ref: 'Thing',\r\n  localField: 'thingIds',\r\n  foreignField: '_id',\r\n  justOne: false,\r\n})\r\n```\r\nThen when `thingIds` is undefined in the database, I get the following:\r\n```\r\nvar testModel = await Test.findById('<some ID'>).populate('things');\r\nconsole.log(testModel.things) // undefined\r\n```\r\n\r\n**What is the expected behavior?**\r\nA blank array should still be returned.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nNode: 10.16.0\r\nMongoose: 5.8.3\r\nMongoDb: 4.0.6\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nbug\r\n\r\n**What is the current behavior?**\r\npopulate an item that should not populate by discriminator setting\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n```js\r\nconst mongoose = require('mongoose');\r\nconst { Schema, ObjectId, model } = mongoose;\r\n\r\nmongoose.connect(\r\n  'mongodb://localhost:27017',\r\n  {\r\n    keepAlive: true,\r\n    dbName: 'localTest',\r\n    useNewUrlParser: true,\r\n    useFindAndModify: false,\r\n    useCreateIndex: true,\r\n    autoIndex: true,\r\n  },\r\n);\r\nmongoose.set('debug', true);\r\n\r\n(async () => {\r\n  const ImageSchema = new mongoose.Schema({\r\n    imageName: {\r\n      type: String,\r\n      required: true\r\n    }\r\n  });\r\n  const Image = mongoose.model('Image', ImageSchema);\r\n\r\n  const TextSchema = new mongoose.Schema({\r\n    textName: {\r\n      type: String,\r\n      required: true\r\n    }\r\n  });\r\n  const Text = mongoose.model('Text', TextSchema);\r\n\r\n  const ItemSchema = new Schema({\r\n    objectType: {\r\n      type: String,\r\n    },\r\n  }, {\r\n    _id: false,\r\n  });\r\n\r\n  const ItemSchemaA = new Schema({\r\n    data: {\r\n      type: ObjectId,\r\n      refPath: 'list.objectType',\r\n    },\r\n    objectType: {\r\n      type: String,\r\n      enum: ['Image', 'Text'],\r\n    },\r\n  }, {\r\n    _id: false,\r\n  });\r\n\r\n  const ItemSchemaB = new Schema({\r\n    data: {\r\n      sourceId: {\r\n        type: Number,\r\n        required: true,\r\n      },\r\n    },\r\n    objectType: {\r\n      type: String,\r\n      enum: ['ExternalSourceA', 'ExternalSourceB'],\r\n    },\r\n  }, {\r\n    _id: false,\r\n  });\r\n\r\n  const ExampleSchema = new Schema({\r\n    test: {\r\n      type: String,\r\n    },\r\n    list: [{\r\n      type: ItemSchema,\r\n      required: false\r\n    }],\r\n  });\r\n  ExampleSchema.path('list').discriminator('ExtendA', ItemSchemaA);\r\n  ExampleSchema.path('list').discriminator('ExtendB', ItemSchemaB);\r\n  const Example = model('Example', ExampleSchema);\r\n\r\n  const image = await Image.create({\r\n    imageName: '00image',\r\n  });\r\n  const text = await Text.create({\r\n    textName: '00text',\r\n  });\r\n\r\n  await Example.create({\r\n    test: '02',\r\n    list: [\r\n      {\r\n        __t: 'ExtendA',\r\n        message: 'i01',\r\n        data: image._id,\r\n        objectType: 'Image',\r\n      },\r\n      {\r\n        __t: 'ExtendA',\r\n        message: 't01',\r\n        data: text._id,\r\n        objectType: 'Text',\r\n      },\r\n      {\r\n        __t: 'ExtendB',\r\n        message: 'm02',\r\n        data: {\r\n          sourceId: 123\r\n        },\r\n        objectType: 'ExternalSourceA',\r\n      }],\r\n  });\r\n  const query = Example\r\n    .find()\r\n    .populate({\r\n      path: 'list.data',\r\n    })\r\n    .lean()\r\n\r\n  // Error occurs here and the message as shown below:\r\n  // \"Schema hasn't been registered for model \"ExternalSourceA\".\r\n  // Use mongoose.model(name, schema)\"\r\n  const results = await query.exec();\r\n  return results;\r\n})().then(\r\n  async result => {\r\n    await mongoose.disconnect();\r\n    process.exit(0);\r\n  },\r\n  async _ => {\r\n    console.log(_);\r\n    await mongoose.disconnect();\r\n    process.exit(1);\r\n  }\r\n)\r\n```\r\n\r\n**What is the expected behavior?**\r\nDo not try to populate items of ItemSchemaB and return the original data\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nnode: v10.17.0\r\nmongoDB: 4.2.1\r\nmongoose: 5.7.13\r\n"},{"labels":["bug"],"text":"I tried to do this(type: Object), but found that the setter did not take effect, This is normal when I change type to Number or String\r\n```\r\njobCategory: {\r\n   type: Object,\r\n   set: v => {\r\n     console.log(v)\r\n     return {\r\n        name: 1,\r\n        value: 1\r\n      }\r\n   }\r\n},\r\n```\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nbug\r\n\r\n**What is the current behavior?**\r\nPopulating unset field which type is array of objects results in an array with one empty object (or object whose fields are all nulls).\r\n \r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\nhttps://github.com/alexeychikk/mongoose-populate-array-bug\r\nnpm install\r\nnpm start\r\n\r\nYou should notice `files: [ { \"uploadedBy\": null, \"id\": null } ]` in the populated rides. Issue is gone if you comment out `await Ride.updateMany({}, { $unset: { files: 1 } });`\r\n\r\n**What is the expected behavior?**\r\nField should be populated with default value or remain empty.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\nNode 10.14\r\nmongodb 3.4.0\r\nmongoose 5.8.1"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nSchema `Schema.prototype.add`  doesn't add field into the new schema.\r\nThe new object created from the corresponding models just remove the keys that were added from other model.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nStarting from the schema `add` method example of the documentation at \r\nhttps://mongoosejs.com/docs/api.html#schema_Schema-add\r\nFrom the two schemas,create two models and instaciate them.\r\n\r\n```js\r\nconst mongoose = require(\"mongoose\");\r\n\r\nconst ToySchema = new mongoose.Schema();\r\nToySchema.add({ name: \"string\", color: \"string\", price: \"number\" });\r\nconst toyModel = mongoose.model(\"toy\", ToySchema);\r\n\r\nconst TurboManSchema = new mongoose.Schema();\r\nTurboManSchema.add(ToySchema).add({ year: Number });\r\nconst TurboManModel = mongoose.model(\"turbo\", TurboManSchema);\r\n\r\nconst aToy = new toyModel({\r\n  name: \"MyToyName\",\r\n  color: \"red\",\r\n  price: 123,\r\n  year: 2009\r\n});\r\nconst aTurbo = new TurboManModel({\r\n  name: \"MyTurboName\",\r\n  color: \"red\",\r\n  price: 123,\r\n  year: 2009\r\n});\r\n\r\nconsole.log(aToy.toJSON()); // year is expectedly deleted\r\nconsole.log(aTurbo.toJSON()); //everything but year is deleted\r\n\r\n```\r\n\r\n**What is the expected behavior?**\r\nIt is expected that the second schema(TurboManSchema) has the properties specified in the first one (ToySchema ).\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nNode.js v13.1.0\r\nMongoose 5.8.1\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nFor `eachAsync`, if the 'parallel' option is set to a higher number than the number of records in the cursor, `eachAsync` will move on without waiting for functions to resolve. (For example, when the number of records in the cursor is 3 and the options are set to `{ parallel: 4 }`)\r\n\r\nThis does not appear to be resolved by the `eachAsync` fixes made in 5.7.14.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\nHere's a failing test to demonstrate- I just borrowed the setup from `test/es-next/asyncIterator.test.es6.js`:\r\n```\r\n'use strict';\r\n\r\nconst assert = require('assert');\r\nconst start = require('../common');\r\n\r\nconst mongoose = start.mongoose;\r\n\r\ndescribe('eachAsync', function() {\r\n  let db;\r\n  let Movie;\r\n\r\n  before(async function() {\r\n    db = await start();\r\n\r\n    const schema = new mongoose.Schema({ name: String });\r\n    Movie = db.model('gh6737_Movie', schema);\r\n\r\n    await Movie.create([\r\n      { name: 'Kickboxer' },\r\n      { name: 'Ip Man' },\r\n      { name: 'Enter the Dragon' }\r\n    ]);\r\n  });\r\n\r\n  after(function(done) {\r\n    db.close(done);\r\n  });\r\n\r\n  it('waits for all promises to resolve when the parallel setting surpasses the number of records in the cursor', async function() {\r\n    var a = false;\r\n\r\n    async function test() {\r\n      await new Promise((resolve) => setTimeout(resolve, 100));\r\n      a = true;\r\n    }\r\n\r\n    await Movie.find().cursor().eachAsync(test, { parallel: 4 })\r\n    assert.equal(a, true);\r\n  });\r\n```\r\n\r\nNote this test will pass when parallel is less than or equal to 3.\r\n\r\n**What is the expected behavior?**\r\n`eachAsync` will wait for all functions to resolve, regardless of number of records in the cursor and what the parallel count is set to.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nNode.js: 12.13.1\r\nMongoose: 5.7.14\r\nMongoDB: 4.2.1"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nSetting readPreference on the schema does not seem to affect `QueryCursor` options - regular find queries.\r\nWhen trying to use findOne, the `readPreference` is correctly set and affects the resulting command to the DB.\r\n\r\nIf findOne, it gets to [here](https://github.com/Automattic/mongoose/blob/ee892b91f6930ce26a3063b3a81a1a25e3baccb8/lib/query.js#L1631) but using regular `find` it doesnt get there and goes to some other place where it doesnt know about the scheme at all.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nCreate a schema and set the readPreference to \"secondary\".\r\nTry to send any `find` command and observe the database ops or Atlas metrics. Only the primary will get the command.\r\nTry to send a `findOne` command and it should actually be sent to the secondary node.\r\nMoreover, using `query.read('secondary')` does seem to affect since it affects the query object options directly.\r\n\r\n**What is the expected behavior?**\r\nSetting `read` option on the schema level should affect all query commands (both find and findOne)\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nNode 12\r\nMongoose 5.7.14\r\nMongoDB 4\r\n\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBug\r\nMight be related to #8312\r\n\r\n**What is the current behavior?**\r\n\r\nIn 5.7.12 (but also 5.7.7) calling `.map().splice()` on a `CoreDocumentArray` errors this out:\r\n```\r\n     TypeError: Cannot read property 'casterConstructor' of undefined\r\n      at CoreDocumentArray._cast (node_modules/mongoose/lib/types/documentarray.js:46:47)\r\n      at CoreDocumentArray.splice (node_modules/mongoose/lib/types/core_array.js:759:16)\r\n      at CoreDocumentArray.splice (node_modules/mongoose/lib/types/documentarray.js:234:30)\r\n```\r\n\r\nNotes:\r\n- Also happens in 5.6.13 - Seems to be CoreMongooseArray then\r\n- Looks fine in 5.5.15 - Still CoreMongooseArray\r\n- Looks fine in 5.0.18 - Is a a regular JS Array then though, so that makes sense.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n- make a collection with nested array\r\n- create a document with array values (no need to save)\r\n- run `.map().splice()` on the nested array\r\n\r\n(see script below https://github.com/Automattic/mongoose/issues/8399#issuecomment-561464630)\r\n\r\n**What is the expected behavior?**\r\nSplice like any array\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using?** \r\nMongoDB 3.6.12\r\nMongoose 5.7.12\r\nNode 8.11.1\r\n\r\n\r\ncc @vkarpov15"},{"labels":["bug"],"text":"Bug\r\n\r\nMy code was working fine until update 5.7.13\r\n\r\n```\r\n2019-12-01T17:34:06.345999168Z TypeError: Cannot read property 'activePaths' of undefined\r\n2019-12-01T17:34:06.346008167Z     at Object.Document.modifiedPaths (/home/node/app/ne-route-droker-api/node_modules/mongoose/lib/document.js:1674:52)\r\n2019-12-01T17:34:06.346017932Z     at Object.Document.isModified (/home/node/app/ne-route-droker-api/node_modules/mongoose/lib/document.js:1745:44)\r\n2019-12-01T17:34:06.346030897Z     at SingleNested.Subdocument.isModified (/home/node/app/ne-route-droker-api/node_modules/mongoose/lib/types/subdocument.js:128:29)\r\n2019-12-01T17:34:06.346042057Z     at _init (/home/node/app/ne-route-droker-api/node_modules/mongoose/lib/document.js:633:17)\r\n2019-12-01T17:34:06.346050904Z     at init (/home/node/app/ne-route-droker-api/node_modules/mongoose/lib/document.js:587:5)\r\n2019-12-01T17:34:06.346059520Z     at SingleNested.Document.$__init (/home/node/app/ne-route-droker-api/node_modules/mongoose/lib/document.js:517:3)\r\n2019-12-01T17:34:06.346068570Z     at SingleNested.syncWrapper [as $__init] (/home/node/app/ne-route-droker-api/node_modules/kareem/index.js:234:23)\r\n2019-12-01T17:34:06.346077293Z     at SingleNested.Document.init (/home/node/app/ne-route-droker-api/node_modules/mongoose/lib/document.js:485:8)\r\n2019-12-01T17:34:06.346086108Z     at SingleNestedPath.cast (/home/node/app/ne-route-droker-api/node_modules/mongoose/lib/schema/SingleNestedPath.js:170:12)\r\n2019-12-01T17:34:06.346094942Z     at SingleNestedPath.SchemaType.applySetters (/home/node/app/ne-route-droker-api/node_modules/mongoose/lib/schematype.js:969:12)\r\n2019-12-01T17:34:06.346103914Z     at SingleNestedPath.SchemaType.getDefault (/home/node/app/ne-route-droker-api/node_modules/mongoose/lib/schematype.js:916:25)\r\n2019-12-01T17:34:06.346112984Z     at /home/node/app/ne-route-droker-api/node_modules/mongoose/lib/helpers/setDefaultsOnInsert.js:84:33\r\n2019-12-01T17:34:06.346121593Z     at Schema.eachPath (/home/node/app/ne-route-droker-api/node_modules/mongoose/lib/schema.js:944:5)\r\n2019-12-01T17:34:06.346130137Z     at /home/node/app/ne-route-droker-api/node_modules/mongoose/lib/helpers/setDefaultsOnInsert.js:78:25\r\n2019-12-01T17:34:06.346138830Z     at Schema.eachPath (/home/node/app/ne-route-droker-api/node_modules/mongoose/lib/schema.js:944:5)\r\n2019-12-01T17:34:06.346149197Z     at module.exports (/home/node/app/ne-route-droker-api/node_modules/mongoose/lib/helpers/setDefaultsOnInsert.js:71:10)\r\n2019-12-01T17:34:06.346158249Z     at model.Query.Query._findAndModify (/home/node/app/ne-route-droker-api/node_modules/mongoose/lib/query.js:3450:22)\r\n2019-12-01T17:34:06.346167078Z     at model.Query.<anonymous> (/home/node/app/ne-route-droker-api/node_modules/mongoose/lib/query.js:3002:8)\r\n2019-12-01T17:34:06.346177040Z     at model.Query._wrappedThunk [as _findOneAndUpdate] (/home/node/app/ne-route-droker-api/node_modules/mongoose/lib/helpers/query/wrapThunk.js:16:8)\r\n2019-12-01T17:34:06.346188146Z     at /home/node/app/ne-route-droker-api/node_modules/kareem/index.js:278:20\r\n2019-12-01T17:34:06.346215611Z     at _next (/home/node/app/ne-route-droker-api/node_modules/kareem/index.js:102:16)\r\n2019-12-01T17:34:06.346225405Z     at process.nextTick (/home/node/app/ne-route-droker-api/node_modules/kareem/index.js:507:38)\r\n2019-12-01T17:34:06.346234009Z     at process._tickCallback (internal/process/next_tick.js:61:11)\r\n2019-12-01T17:34:06.377675206Z error Command failed with exit code 1.\r\n\r\n```\r\n\r\nI did not make any changes to my source code, just update package. It should work fine. I rolled back to package 5.7.1 and everything works.\r\n\r\nMongo 4.1\r\nNode 10 LTS\r\nMongoose version 5.7.13\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug or extension of current feature?\r\n\r\n**What is the current behavior?**\r\nUpdating a nested discriminator by dot notation drops any attributes not defined in base schema even if discriminator key is provided in the update.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```\r\nconst shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });\r\nconst schema = Schema({ shape: shapeSchema });\r\n\r\nschema.path('shape').discriminator('Circle', Schema({ radius: String, color: String }));\r\nschema.path('shape').discriminator('Square', Schema({ side: Number, color: String }));\r\n\r\nconst MyModel = mongoose.model('ShapeTest', schema);\r\n\r\ndoc = await MyModel.create({\r\n  shape: {\r\n    kind: 'Circle',\r\n    name: 'circle test',\r\n    radius: 5,\r\n    color: 'red'\r\n  }\r\n});\r\n \r\nconst updatedDoc = await MyModel.findByIdAndUpdate(\r\n  doc._id,\r\n  {\r\n      $set: {\r\n         'shape.kind': 'Circle',\r\n         'shape.name': 'updated name',\r\n         'shape.radius': 10\r\n      }\r\n   }\r\n);\r\n\r\nupdatedDoc.shape.name; // updated name\r\nupdatedDoc.shape.radius; // 5\r\n```\r\n\r\n**What is the expected behavior?**\r\nThe update will cast, (validate when `runValidators=true`) and update 'shape.kind' and 'shape.name' but drops 'shape.radius' which is defined in the discriminator schema. When updates use dot notation and path is a nested (or array) discriminator then should use discriminator key provided in the updates (or fallback to existing doc discriminatorKey value?) for correct casting. Currently the only way to set 'shape.radius' is to set `strict=false` (which defeats the purpose of defining a schema) or first retrieve the doc, apply the partial updates and .save(). Atomic operations are required.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nNode.js 10.16.3\r\nMongoose 5.7.12\r\nMongoDB 4.0.3\r\n"},{"labels":["bug"],"text":"please ignore the contradiction of code logic. after the following code is executed, there is no data in mongodb. who can tell me why? according to my understanding, execute  ```document.save()```can insert data, but now there is no data. it's strange.\r\n\r\n```\r\n\r\nlet acl = await Acl.findOneAndRemove({name: \"nodejs\"});\r\nconsole.log(acl);\r\nconsole.log(acl instanceof mongoose.Document); // true\r\nlet newAcl = await acl.save();\r\nconsole.log(newAcl);\r\n\r\n```\r\nnodejsï¼š10.16.3    \r\nmongoose: 5.6.9"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n*bug*\r\n**What is the current behavior?**\r\n`SchemaType.validate` does not allow a function to be sent as a message if a custom type is not defined\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\nSo if I have the following for a custom schema type:\r\n```\r\nfunction Email (path, options) {\r\n  mongoose.SchemaTypes.String.call(this, path, options)\r\n  this.validate(val => validateEmail(val), (error) => `${error.path} is invalid`)\r\n}\r\n```\r\nAn error message won't be returned when validation fails.\r\nNow If I define a custom type:\r\n```\r\nfunction Email (path, options) {\r\n  mongoose.SchemaTypes.String.call(this, path, options)\r\n  this.validate(val => validateEmail(val), (error) => `${error.path} is invalid`, 'email')\r\n```\r\nit works as expected.\r\n\r\nI believe the error is caused at https://github.com/Automattic/mongoose/blob/master/lib/schematype.js#L679 (`if (message instanceof Object && !type) `) because apparently `<function> instanceof Object` is true. I would imagine `typeof message === 'object'` would do in its place\r\n\r\n**What is the expected behavior?**\r\nThe function should be called either way, not just if there is a custom type\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nNode: 10.16.0\r\nMongoose: 5.7.11\r\nMongoDB: 4.0.6\r\n"},{"labels":["bug"],"text":"\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nwhen using eachAsync with parallel option set to 10 and having a populate on the query, mongoose returns even before all awaits are finished.\r\n\r\nsee test script, output:\r\n```\r\na\r\na\r\na\r\na\r\nb\r\nDONE <-- this sohuld be defintily after all 'b's.. \r\nb\r\nb\r\nb\r\nb\r\nb\r\nb\r\nb\r\nb\r\nb\r\n```\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```js\r\n(async () => {\r\n\tconst jobsRes = await DBJobModel.find({})\r\n\t\t.populate('_location _field _type _company', '-searchQueries') // <-- need to populate some stuff, it works when uncommenting this line.\r\n\t\t.lean()\r\n\t\t.limit(10)\r\n\t\t.cursor();\r\n\r\n\tawait jobsRes.eachAsync(\r\n\t\tasync jobOrg => {\r\n\t\t\tconsole.log('a');\r\n\t\t\tawait new Promise((resolve) => setTimeout(resolve, 1000));\r\n\t\t\tconsole.log('b');\r\n\t\t}\r\n\t, { parallel: 10 });\r\n\r\n\tconsole.log('DONE');\r\n})();\r\n```\r\n\r\n**What is the expected behavior?**\r\neachAsync needs to wait for all promises\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nmongoose 5.7.11\r\nnode v12.13.0\r\nmongodb 4.2.1\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n*bug*\r\n\r\n**What is the current behavior?**\r\nWhen using .find().populate() it fails on a virtual field.\r\nThis is caused due to the .find() being executed on a discriminated model for which the registered value is different then the ModelName.\r\n\r\nfail:\r\nconst items = await main.find().populate('virtualField').exec();\r\n--> items.virtualField is not correct.\r\n\r\nsuccess:\r\nconst items = await main.find().exec();\r\nawait main.populate('virtualField').execPopulate();\r\n--> items.virtualField is correct.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nThe following (simplified code) fails with a MongooseError due to model \"discriminatedValue\" not being registered on the following line:\r\n[https://github.com/Automattic/mongoose/blob/master/lib/helpers/populate/getModelsMapForPopulate.js#L305](url)\r\n```\r\nlet mainSchema = new Schema(\r\n  {\r\n    title: { type: String },\r\n  },\r\n  {\r\n    discriminatorKey: 'type',\r\n  }\r\n);\r\n\r\nmainSchema.virtual('virtualField', {\r\n  ref: 'AnotherModel',\r\n  localField: '_id',\r\n  foreignField: 'main',\r\n});\r\n\r\nlet discriminatedSchema = new Schema({\r\n  {\r\n    description: { type: String },\r\n  }\r\n});\r\n\r\nlet main = connection.model('Main', mainSchema, 'main');\r\nlet discriminated = this.main.discriminator('Discriminated', discriminatedSchema, 'discriminatedValue');\r\n\r\nconst items = await main.find().populate('virtualField').exec();\r\n```\r\n\r\nThe code works after changing the code to the following (where the discriminator is retrieved by going from the value to the model).\r\n\r\n```\r\nmodelForFindSchema = utils.getValue(discriminatorKey, doc);\r\nif (modelForFindSchema) {\r\n  const discriminatorByValue = getDiscriminatorByValue(model, modelForFindSchema);\r\n  if (discriminatorByValue !== null) {\r\n    modelForCurrentDoc = discriminatorByValue;\r\n  } else {\r\n    try {\r\n      modelForCurrentDoc = model.db.model(modelForFindSchema);\r\n    } catch (error) {\r\n      return error;\r\n    }\r\n  }\r\n  \r\n  ...\r\n```\r\n\r\n**What is the expected behavior?**\r\nThat the populate works by correctly identifying the associated model within the .find\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nNode.js: v12.11.1\r\nMongoDB: v3.4.10\r\nMongoose: v5.7.9\r\n\r\n"},{"labels":["bug"],"text":"I opened [this ](https://github.com/Automattic/mongoose/issues/8239 )ticket for an issue I had been facing for a while now, but it had been closed without a fix. I attached a reproduce script to this ticket, where issue can be easily recreated.\r\n\r\n\r\n\r\nReproduce script:\r\nhttps://drive.google.com/open?id=1rN0nBTOwkEnLzPMCpR3pyhLd19fQB64i\r\n\r\n```\r\nconst mongoose = require('mongoose');\r\nconst dbUrl = 'mongodb+srv://myuser:mypass@myapp.mongodb.net/mydb?retryWrites=true&w=majority'; // TODO: add a valid mongodb cluster\r\n\r\nmongoose.connect(dbUrl, {useNewUrlParser: true, useUnifiedTopology: false}, error => {\r\n    if (error) {\r\n        console.log('Error occurred when connecting to database. ' + error);\r\n    }\r\n});\r\n\r\nfunction testStartSession() {\r\n    const startSessionTimeout = setTimeout(() => {\r\n        console.log('Start session timeout exceeded. quitting.');\r\n        process.exit(0);\r\n    }, 60000);\r\n\r\n    const time = Date.now();\r\n    mongoose.startSession()\r\n        .then(mongoSession => {\r\n            console.log('start session successful. took ' + (Date.now() - time));\r\n            clearTimeout(startSessionTimeout);\r\n            mongoSession.endSession();\r\n            setTimeout(() => testStartSession(), 1000);\r\n        })\r\n        .catch(reason => {\r\n            console.log('start session failed. took ' + (Date.now() - time) + '. reason: ' + reason);\r\n            clearTimeout(startSessionTimeout);\r\n            setTimeout(() => testStartSession(), 1000);\r\n        });\r\n}\r\n\r\nmongoose.connection.once('open', () => {\r\n    console.log('Connected to database');\r\n    testStartSession();\r\n});\r\n```\r\nIn above code, whenever the primary instance of the mongodb replica set is stopped, `mongoose.startSession()` neither succeeds, nor fails. It just hangs.\r\n\r\nI tested with both `useUnifiedTopology` enabled and disabled, and the issue exists in both cases.\r\n\r\nI tested with a DB query operation instead of ` mongoose.startSession()`, and when a primary failover occurs, the immediate next read operation fails (doesn't hang like startSession), and consequent read operations succeed, which is acceptable."},{"labels":["bug"],"text":"Hello, this seems similar to #3889.\r\n\r\nI am using node 8.10.0, mongodb 3.2.11 and mongoose 5.7.9\r\n\r\nI have the following code:\r\n\r\n```\r\nvar forms = this.getFormalization();\r\nvar form = forms.find(f => f._id == id);\r\n  if (typeof form.lastIndependentDate === 'undefined' || this.lastUpdate > \r\n      form.lastIndependentDate) {\r\n    forms = forms.slice()\r\n    forms.splice(forms.indexOf(form), 1)\r\n```\r\n\r\nThe last line throws the error:\r\n\r\nTypeError: Cannot read property '$__' of undefined\r\n    at _updateParentPopulated (/home/shaolin/Documents/software/normative-gui/node_modules/mongoose/lib/types/documentarray.js:323:14)\r\n    at CoreDocumentArray.splice (/home/shaolin/Documents/software/normative-gui/node_modules/mongoose/lib/types/documentarray.js:228:5)\r\n    at model.theorySchema.methods.isIndependent (/home/shaolin/Documents/software/normative-gui/models/theory.js:145:11)\r\n    at /home/shaolin/Documents/software/normative-gui/controllers/theoryController.js:202:14\r\n    at /home/shaolin/Documents/software/normative-gui/node_modules/mongoose/lib/model.js:4604:16\r\n    at /home/shaolin/Documents/software/normative-gui/node_modules/mongoose/lib/query.js:4351:12\r\n    at process.nextTick (/home/shaolin/Documents/software/normative-gui/node_modules/mongoose/lib/query.js:2849:28)\r\n    at _combinedTickCallback (internal/process/next_tick.js:131:7)\r\n    at process._tickCallback (internal/process/next_tick.js:180:9)\r\n\r\nThe model is\r\n```\r\nvar theorySchema = new Schema({\r\n    lastUpdate        : Date,\r\n    name \t\t          : String,\r\n    description       : String,\r\n    content           : String, // annotated XML\r\n    comment           : String,\r\n    vocabulary        : [{symbol: String, original: String, full: String}],\r\n    autoVocabulary    : [{symbol: String, original: String, full: String}],\r\n    formalization     : [{original: String, json: Object, formula: String, active: Boolean, lastIndependent: Boolean, lastIndependentDate: Date}],\r\n    autoFormalization : [{original: String, json: Object, formula: String, active: Boolean, lastIndependent: Boolean, lastIndependentDate: Date}],\r\n\t\tuser \t\t\t\t\t\t\t: { type: Schema.Types.ObjectId, ref: 'User' },\r\n    clonedForm        : { type: Schema.Types.ObjectId, ref: 'Theory' },\r\n    lastConsistency   : Boolean,\r\n    lastConsistencyDate: Date,\r\n    writeProtected    : Boolean\r\n});\r\n\r\n\r\ntheorySchema.methods.getFormalization = function() {\r\n  return this.formalization.concat(this.autoFormalization)\r\n}\r\n```\r\nDowngrading to 4.4.3 also fixes it in my case.\r\n\r\nThank you.\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nReport a bug.\r\n**What is the current behavior?**\r\nSee comments on two last lines of code - getter is skipped when calling toJSON on parent, despite having \"getters: true\" on all schemas.\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n```\r\nvar { model, Schema } = require('mongoose');\r\n\r\nvar childSchema = new Schema({}, {\r\n\ttoJSON: { getters: true }\r\n});\r\n\r\nchildSchema.virtual('field')\r\n\t.get(function(){\r\n\t\treturn this._field;\r\n\t})\r\n\t.set(function(v){\r\n\t\treturn this._field = v;\r\n\t});\r\n\r\nvar Child = model('Child', childSchema);\r\n\r\nvar parentSchema = new Schema({\r\n\tchild: { type: Schema.Types.ObjectId, ref: 'Child', get: childGetter }\r\n}, {\r\n\ttoJSON: { getters: true }\r\n});\r\n\r\nfunction childGetter(child){\r\n\tchild.field = true;\r\n\treturn child;\r\n}\r\n\r\nvar Parent = model('Parent', parentSchema);\r\n\r\n//=====================\r\nvar child = new Child();\r\nvar parent = new Parent({ child });\r\n\r\nconsole.log(parent.toJSON().child.field); //prints 'undefined'\r\nconsole.log(parent.child.toJSON().field); //prints 'true'\r\n```\r\n**What is the expected behavior?**\r\nTo have \"true\" as output of both ``console.log``s.\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nNode.js 8.9.3\r\nMongoose 5.6.0\r\nMongoDB irrelevant - MWE does not connect to DB at all\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBug\r\n\r\n**What is the current behavior?**\r\n\r\nManually populated as described in the docs doesn't work for discriminators.\r\n\r\nRepro script (sorry a bit long):\r\n\r\n```js\r\n// Modules\r\nconst Promise = require('bluebird');\r\nconst mongoose = require('mongoose');\r\nmongoose.Promise = Promise;\r\nconst Schema = mongoose.Schema;\r\n\r\nconsole.log(mongoose.version);\r\n\r\n// DB\r\nlet connect = mongoose.connect('mongodb://localhost:27018/test');\r\n\r\n// Models\r\nconst AddonSchema = new Schema({\r\n  title: String,\r\n});\r\nconst Addon = mongoose.model('Addon', AddonSchema);\r\nconst AddonItemSchema = new Schema({\r\n  addon: { type: Schema.Types.ObjectId, ref: 'Addon' },\r\n  quantity: Number,\r\n});\r\n\r\nconst ProductSchema = new Schema({\r\n  title: String,\r\n});\r\nconst Product = mongoose.model('Product', ProductSchema);\r\nconst ProductItemSchema = new Schema({\r\n  product: { type: Schema.Types.ObjectId, ref: 'Product' },\r\n});\r\n\r\nconst OrderItemSchema = new mongoose.Schema({\r\n  quantity: Number,\r\n}, {discriminatorKey: '__t'});\r\nconst OrderItem = mongoose.model('OrderItem', OrderItemSchema);\r\n\r\n\r\nconst OrderSchema = new Schema({\r\n  product: { type: Schema.Types.ObjectId, ref: 'Product' },\r\n  noDiscriminator: {\r\n    type: [{\r\n      product: { type: Schema.Types.ObjectId, ref: 'Product' },\r\n    }],\r\n    default: [],\r\n  },\r\n  discriminatorNoArray: {\r\n    type: OrderItemSchema,\r\n  },\r\n  items: {\r\n    type: [OrderItemSchema],\r\n    default: [],\r\n  },\r\n});\r\n\r\nconst docArray = OrderSchema.path('items');\r\n\r\nconst ProductItem = docArray\r\n  .discriminator('ProductItem', ProductItemSchema);\r\nconst AddonItem = docArray\r\n  .discriminator('AddonItem', AddonItemSchema);\r\n\r\nOrderSchema.path('discriminatorNoArray').discriminator('ProductItem', ProductItemSchema);\r\nOrderSchema.path('discriminatorNoArray').discriminator('AddonItem', AddonItemSchema);\r\n\r\nconst Order = mongoose.model('Order', OrderSchema);\r\n\r\n// Create test data\r\nconnect.then(async () => {\r\n  mongoose.connection.db.dropDatabase();\r\n\r\n  const addon = await Addon({title: 'Addon title'}).save();\r\n  const product = await Product({title: 'Product title'}).save();\r\n\r\n  // Create order with embedded items\r\n  const unsaved = new Order({\r\n    product,\r\n    noDiscriminator: [\r\n      {\r\n        product,\r\n      }\r\n    ],\r\n    discriminatorNoArray: {\r\n      product,\r\n      quantity: 42,\r\n      __t: 'ProductItem',\r\n    },\r\n    items: [\r\n      {\r\n        addon,\r\n        quantity: 42,\r\n        __t: 'AddonItem',\r\n      },\r\n      {\r\n        product,\r\n        quantity: 42,\r\n        __t: 'ProductItem',\r\n      }\r\n    ]\r\n  });\r\n\r\n  // Doesn't show manually populated in items\r\n  console.log(unsaved);\r\n\r\n  await unsaved.save();\r\n\r\n  // Find order, populate addon of items\r\n  const order = await Order.findOne({}).exec();\r\n\r\n  order.product = product;\r\n  order.noDiscriminator[0].product = product;\r\n  order.discriminatorNoArray.product = product;\r\n  order.items[0].addon = addon;\r\n  order.items[0].addon = addon;\r\n\r\n  // Doesn't show manually populated in items\r\n  console.log(order);\r\n});\r\n```\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using?**\r\n\r\nNode.js v8.11.0\r\nMongoose v5.7.6"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nbug\r\n\r\n**What is the current behavior?**\r\nusing the following snippet:\r\n```javascript\r\nconst mongoose = require('mongoose');\r\n\r\nconst opts = {\r\n    useNewUrlParser: true,\r\n    useUnifiedTopology: true\r\n};\r\n\r\nconst connection = mongoose.createConnection('mongodb://localhost:27017/test', opts);\r\n\r\nconst userSchema = new mongoose.Schema({\r\n    name: String\r\n}, {\r\n    collection: 'users',\r\n    versionKey: false\r\n});\r\n\r\nconst testModel = connection.model('User', userSchema);\r\n\r\nlet testId = null;\r\n\r\nasync function insertTest () {\r\n    testId = (await (new testModel({name: 'tom'})).save())._id;\r\n}\r\n\r\nasync function findTest () {\r\n    const result = await testModel.findOne(testId).lean().exec();\r\n    console.log(result);\r\n    //in 5.7.4 it prints the inserted test user\r\n    //in 5.7.5 it prints null because of the BSON fix\r\n}\r\n\r\nasync function run() {\r\n    await insertTest();\r\n    await findTest();\r\n}\r\n\r\nrun();\r\n```\r\n\r\nWhen using `mongoose 5.7.4` it works fine and returns the inserted user.\r\nWhen using `mongoose 5.7.5` it returns null.\r\nThis is due the a BSON vulnerability fix done in \r\nhttps://github.com/Automattic/mongoose/issues/8222\r\nhttps://github.com/Automattic/mongoose/commit/f3eca5b94d822225c04e96cbeed9f095afb3c31c\r\n\r\n**What is the expected behavior?**\r\nIf it's a vulnerability, it must be fixed. But if it's a breaking change, it needs to be documented in the release notes and probably change the version to major.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nNode.js - 10\r\nMongoose: 5.7.4, 5.7.5, 5.7.6\r\nMongoDB - 4.0"},{"labels":["bug"],"text":"BUG\r\n\r\n`{\r\n    \"name\": \"TypeError\",\r\n    \"message\": \"Cannot read property 'split' of undefined\",\r\n    \"stack\": \"TypeError: Cannot read property 'split' of undefined\\n    at SingleNested.Subdocument.isModified (/home/node/app/ne-route-droker-api/node_modules/mongoose/lib/types/subdocument.js:120:51)\\n    at SingleNested.<anonymous> (/home/node/app/ne-route-droker-api/node_modules/mongoose/lib/schema.js:1113:60)\\n    at callMiddlewareFunction (/home/node/app/ne-route-droker-api/node_modules/kareem/index.js:482:23)\\n    at SingleNested.next (/home/node/app/ne-route-droker-api/node_modules/kareem/index.js:58:7)\\n    at _next (/home/node/app/ne-route-droker-api/node_modules/kareem/index.js:106:10)\\n    at process.nextTick (/home/node/app/ne-route-droker-api/node_modules/kareem/index.js:507:38)\\n    at process._tickCallback (internal/process/next_tick.js:61:11)\"\r\n  }`\r\n\r\nMy code was working like a charm and I update from 5.7.1 to 5.7.5 and suddenly this error start happening. I did not write any change in my code. I revert to version 5.7.1 and everything works again.\r\n\r\nI built a Docker Image over Ubuntu 16.04. \r\n\r\nMongo 4.1\r\nNode 10 LTS\r\nMongoose version 5.7.5\r\n"},{"labels":["bug"],"text":"**What is the current behavior?**\r\n\r\nA model containing an array of another schema, which itself has a reference to another model.  When calling `.populated('nested.reference')` the result doesn't appear to match the length of the array if you have pushed new items into the array.\r\n\r\nhttps://gist.github.com/dave-continuum-media/09848138ae86508d891c65bddc537b20\r\n\r\n**What is the expected behavior?**\r\n\r\n`.populated('nested.reference')` should return `undefined` if none of the items are populated but an array of equal length to the sub-schema array if some or all are.\r\n\r\nCurrently it takes extra effort to tell if a document subschema array has been fully populated:\r\n\r\n```\r\nconst populated = doc.populated('nested.reference');\r\nif (populated === undefined || populated.length < doc.nested.length) {\r\n    await doc.populate('nested.reference');\r\n}\r\n```\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nbug\r\n\r\n**What is the current behavior?**\r\nSince the last update of mongoose I experience a lot of \"Cursor already in use\" in long running queries where a cursor is used in combination with eachAsync().\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nRun a long runnign query and use eachASync to iterate over it. It's not 100% reproducable, but it happens significantely often.\r\n\r\n**What is the expected behavior?**\r\nNo cursor already in use error.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n* tested with v12.6.0 and v10.16.3 (LTS).\r\n* mongoose: v5.7.3\r\n* mongodb: 4.0.10\r\n\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nCould be interpreted both ways but I'd label it as a bug.\r\n\r\n**What is the current behavior?**\r\nWhen creating a virtual field referencing an array of other documents, the population of the field works inconsistently. The resulting values will vary between an array filled with users, an empty array and undefined. This is inconsistent and will cause issues and/or unnecessary type checks.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nAs an example we will attempt to populate all children of a user document which are user documents themselves. The schema will be complemented with an array called `childIds` containing all children ids and a virtual called `children` which references the user schema.\r\n\r\n```javascript\r\nconst mongoose = require(\"mongoose\");\r\n\r\nmongoose.connect(\"mongodb://localhost:32768/population\");\r\n\r\n/**\r\n * Define the user schema\r\n */\r\nconst userSchema = new mongoose.Schema(\r\n  {\r\n    name: { type: String },\r\n    childIds: [\r\n      {\r\n        type: mongoose.Schema.Types.ObjectId,\r\n        ref: \"User\",\r\n        required: true\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    toObject: { virtuals: true },\r\n    toJSON: { virtuals: true }\r\n  }\r\n);\r\n\r\nuserSchema.virtual(\"children\", {\r\n  ref: \"User\",\r\n  localField: \"childIds\",\r\n  foreignField: \"_id\",\r\n  justOne: false\r\n});\r\n\r\nconst userModel = mongoose.model(\"User\", userSchema);\r\n\r\n```\r\n\r\nAfterwards we will define a scenario where Joe has two children called John and Jane. When we find and populate all users we will receive three user objects with two of them containing an empty array at the `children` field and one containing an array with the two previous users. When we find and populate the two users without children however, we will receive those two users without the `children` field since it is left empty.\r\n\r\n```javascript\r\n/**\r\n * Play out the scenario\r\n */\r\nasync function scenario() {\r\n  // create users\r\n  const children = [\r\n    await userModel.create({ name: \"John\", childIds: [] }),\r\n    await userModel.create({ name: \"Jane\", childIds: [] })\r\n  ];\r\n\r\n  await userModel.create({ name: \"Joe\", childIds: children.map(c => c._id) });\r\n\r\n  // output all users (populated)\r\n  const all = await userModel\r\n    .find({})\r\n    .populate(\"children\")\r\n    .exec();\r\n\r\n  console.log(all);\r\n\r\n  /*\r\n  [\r\n    {\r\n        childIds: [],\r\n        _id: 5d9db29c4066eb4baac97f58,\r\n        name: 'John',\r\n        __v: 0,\r\n        children: [],\r\n        id: '5d9db29c4066eb4baac97f58'\r\n    },\r\n    {\r\n        childIds: [],\r\n        _id: 5d9db29c4066eb4baac97f59,\r\n        name: 'Jane',\r\n        __v: 0,\r\n        children: [],\r\n        id: '5d9db29c4066eb4baac97f59'\r\n    },\r\n    {\r\n        childIds: [ 5d9db29c4066eb4baac97f58, 5d9db29c4066eb4baac97f59 ],\r\n        _id: 5d9db29c4066eb4baac97f5a,\r\n        name: 'Joe',\r\n        __v: 0,\r\n        children: [ [Object], [Object] ],\r\n        id: '5d9db29c4066eb4baac97f5a'\r\n    }\r\n  ]\r\n  */\r\n\r\n  // output all users without children (populated)\r\n  const withoutChildren = await userModel\r\n    .find({ childIds: [] })\r\n    .populate(\"children\")\r\n    .exec();\r\n\r\n  console.log(withoutChildren);\r\n\r\n  /*\r\n  [\r\n    {\r\n      childIds: [],\r\n      _id: 5d9db29c4066eb4baac97f58,\r\n      name: 'John',\r\n      __v: 0,\r\n      id: '5d9db29c4066eb4baac97f58'\r\n    },\r\n    {\r\n      childIds: [],\r\n      _id: 5d9db29c4066eb4baac97f59,\r\n      name: 'Jane',\r\n      __v: 0,\r\n      id: '5d9db29c4066eb4baac97f59'\r\n    }\r\n  ]\r\n  */\r\n}\r\n\r\nscenario();\r\n\r\n```\r\n\r\n**What is the expected behavior?**\r\nI expect that, since I define it to be an array, the virtual field is always filled as an array when populated even when empty.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nNode.js: v12.10.0\r\nMongoDB: v4.2.0\r\nMongoose: v5.7.3\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nbug\r\n\r\n**What is the current behavior?**\r\nWith a schema like so:\r\n```\r\nconst secondLevelSchema = new Schema({\r\n  id: Number,\r\n  text: String\r\n})\r\n\r\nconst topLevelSchema = new Schema({\r\n  secondLevel: {\r\n    type: secondLevelSchema\r\n  }\r\n}\r\n```\r\nIf you create a new topLevelItem and set one of the properties of secondLevel but not the other,\r\nfor instance:\r\n`new TopLevelModel({ secondLevel: { text: 'example' } })`\r\n\r\nthen you will have the following strange behavior for the other property:\r\n```\r\ntopLevelItem.isModified('secondLevel.id') //true\r\ntopLevelItem.secondLevel.isModified('id')) //false\r\n```\r\n\r\n**What is the expected behavior?**\r\nboth values should be false, since the id has not been modified\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nVulnerability\r\n\r\n**What is the current behavior?**\r\nWith this vulnerability, an attacker might steal sensitive data/bypass authentication in nodejs applications that use mongoose as front end.\r\n\r\nWhen injecting \"_bsontype\" attribute to a query object (e.g., id in find(id)), Mongoose will directly ignore the query object. This can be abused since most nodejs applications treat user input as an object. For example, an attacker can force the query filter condition to be null by adding another attribute (_bsontype) to the user-input data. By doing this, an attacker can log into other users' accounts or bypass the token verification logics during password reset[1]. Even though Mongoose checks the query object according to the scheme when querying in the form of findOne(id:id_object), the vulnerability can still be exploited if developers do queries like findOne(id).\r\n\r\nSimilar issues are also found it Mongodb, and we have reported it.  However, just to be safe, my suggestion is that mongoose should also filter _bsontype before invoking mongodb since _bsontype is an internal attribute used by mongodb.\r\n\r\n[1] https://github.com/Jerenaux/phaserquest/blob/a7ea970c7ef965adcdde29907a872c104b9f8508/js/server/GameServer.js#L278\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nProof of Concept\r\n\r\n```\r\nconst mongoose = require('mongoose');\r\nmongoose.connect('mongodb://localhost/bsontype', {useNewUrlParser: true});\r\n\r\nconst Schema = mongoose.Schema;\r\nconst ObjectId = Schema.ObjectId;\r\n\r\nconst userSchema = new Schema({\r\n\t  author: ObjectId,\r\n\t  username: String,\r\n\t  password: String,\r\n\t  token: String\r\n},);\r\n\r\nconst users = mongoose.model('users', userSchema);\r\ntoken = {\"t\":\"wrongToken\",\"_bsontype\":\"a\"};\r\nusers.findOne(token, function (err, res) {\r\n\tconsole.log(res);\r\n});\r\n\r\n```\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nMongoose 5.7.3\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nI think this a bug.\r\nIf it is by design, I would be very curious as to why, as it seem misleading to me.\r\n\r\n**What is the current behavior?**\r\n\r\nif I create a schema like this\r\n```\r\nmongoose.Schema({name : {type : String, required : undefined}});\r\n```\r\nthen the \"name\" field is required\r\n\r\nalso, if I set it like so \r\n```\r\nmongoose.Schema({name : {type : String, required : null}})\r\n```\r\nthen the schema Throw with the error \"Cannot read property 'message' of null\r\n\r\n\r\n**What is the expected behavior?**\r\nI would expect both a field marked with \"required : undefined\" or \"required : null\" to simply not be required, as their are falsy value and by default, if \"required\" is not set, it is \"false\".\r\nthis cause a subtle bug where if I have different biaviour depending if I have an object without the property \"required\" or if I have it but with value \"undefined\".\r\n\r\nAt most, I would expect that if we don't want for null and undefined value to be concidered as \"falsy\", we could throw a meaningfull message.\r\n\r\n\r\nFor null, the error is there because at `schematype.js:791`, there is the line `if(typeof required === 'object')`, letting pass the \"null\" value as it was an object.\r\n\r\nFor undefined, the error is because at `schematype.js:797`, there is the line `if(required === false)`, not permitting undefined nor null.\r\n\r\ndo note, I don't know what to do if the value send is a string or number. Common sens would be probably to let normal javascript rules for coercion (so changing line 797 for `if(!!required === false)`, and let a non-empty string or non-zero number be true, and an empty string or 0 be false.\r\n\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nI use mongoose 5.7.2 and Node 11.7.0\r\n\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBUG\r\n\r\n**What is the current behavior?**\r\n\r\nCoreMongooseArray incorrectly/incompletely implements \"includes\" method since version 5.6.0.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\nhttps://gist.github.com/hellivan/0d3ce7722d6add10eab83bbfbca52cc5\r\n\r\n**What is the expected behavior?**\r\nShould print:\r\n```\r\nArray.includes:  false\r\nCoreMongooseArray.includes:  false\r\n```\r\n\"includes\" should return false, since 'foo' is not included in friends array after index 1.\r\n\r\nBut instead following content is logged:\r\n```\r\nArray.includes:  false\r\nCoreMongooseArray.includes:  true\r\n```\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nMongoose: 5.6.0, 5.6.9, 5.7.2\r\nNode: 8.16.0 12.3.1\r\n\r\nThe bug was possibly introduced by commit 97c46661c60f78d20f66d59bf4b8dad2a287c8ff which introduced `lib/types/core_array.js`.\r\nSince CoreMongooseArray extends Array type and Array.prototype.includes accepts a second parameter `fromIndex` according to the [specs](https://www.ecma-international.org/ecma-262/7.0/#sec-array.prototype.includes)  , implementation was incomplete from the beginning.\r\n\r\n\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nCalling `.set` on the parent model with the `merge` option set to true, does not merge subdocuments.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nSample Schema:\r\n```js\r\nvar AddressSchema = new mongoose.Schema(\r\n  {\r\n    street: { type: String, required: true },\r\n    city: { type: String, required: true },\r\n    country: { type: String, required: true },\r\n  }\r\n);\r\n\r\nvar PersonSchema = new mongoose.Schema(\r\n  {\r\n    name: { type: String, required: true },\r\n    address: { Type: AddressSchema, required: true },\r\n  }\r\n);\r\n\r\nvar Person = mongoose.model('Person', PersonSchema);\r\n```\r\nWith a Person already stored as:\r\n```js\r\n{\r\n  _id: '5d8d2525c1631200550cea41',\r\n  name: 'John Bastion',\r\n  address: {\r\n    _id: '5d7f9ab3f1a6120607784451',\r\n    street: 'Real Street',\r\n    city: 'Vancouver',\r\n    country: 'Canada',\r\n  }\r\n}\r\n```\r\n\r\n\r\nAnd if I call something like the following:\r\n```js\r\n// person is a document\r\nperson.set({ name: 'John Bastien', address: { street: 'Fake Street' } }, undefined, { merge: true });\r\nawait person.save();\r\n```\r\nAddress is set to simply `{ street: 'Fake Street' }` and is not merged.\r\nIt might be worth noting too that `person.address.isNew` is still false however\r\n\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\n**What is the expected behavior?**\r\nThe person object should be updated to:\r\n```js\r\n{\r\n  _id: '5d8d2525c1631200550cea41',\r\n  name: 'John Bastien',\r\n  address: {\r\n    _id: '5d7f9ab3f1a6120607784451',\r\n    street: 'Fake Street',\r\n    city: 'Vancouver',\r\n    country: 'Canada',\r\n  }\r\n}\r\n```\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nMongoose: 5.7.1\r\nMongodb: 4.0.6\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nA previously reported bug was fixed in version 5.1.3 of mongoose. Starting with version 5.2.5, the bug has been reintroduced.\r\n\r\nPreviously fixed bug: https://github.com/Automattic/mongoose/issues/6488\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\nSee the reproduction script in the link above under the section: \r\n\r\n_Virtual Population NOT WORKING When Virtual Field Is Nested Within Embedded Object Schema_\r\n\r\n**What is the expected behavior?**\r\nI expected the issue to be resolved in all versions after 5.1.3\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nmongoose: 5.7.1\r\nnode: 10.14.1\r\nmongo: 3.6.4\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":" I have a collection documents with a document that looks like this:\r\n```javascript\r\n{\r\n    \"_id\" : ObjectId(\"5d7ddedf92264a43ceee9f48\"),\r\n    \"name\" : \"test123\",\r\n    \"predictedEntityValues\" : [ \r\n        {\r\n            \"status\" : \"DONE\",\r\n            \"values\" : [ \r\n                {\r\n                    \"text\" : \"123\"\r\n                }\r\n            ]\r\n        }\r\n    ]\r\n}\r\n```\r\nI have the following query where documentIds = [ ObjectId(\"5d7ddedf92264a43ceee9f48\") ]\r\n```javascript\r\nawait models.documents\r\n    .updateMany(\r\n      { _id: { $in: documentIds } },\r\n      {\r\n        $pull: {\r\n          predictedEntityValues: { 'values.0.coords': { $exists: false } },\r\n        },\r\n      }\r\n    )\r\n```\r\n\r\nThe above query should should remove the value in the array 'predictedEntityValues', but it doesn't.\r\nMy query is correct because when I execute it into the mongo shell, it works.\r\n\r\nI turned on debug mode, and I saw that the library parsed my query to this query:\r\n```javascript\r\nMongoose: documents.updateMany({ _id: { '$in': [ ObjectId(\"5d7ddedf92264a43ceee9f48\") ] } }, { '$setOnInsert': { createdAt: new Date(\"Sun, 15 Sep 2019 06:42:51 GMT\") }, '$set': { updatedAt: new Date(\"Sun, 15 Sep 2019 06:42:51 GMT\") }, \r\n'$pull': {  predictedEntityValues: { 'values.0.coords': {} } } }, {})\r\n```\r\n\r\nAs you can see, it removes the $exists false in the parsed query: ```{  predictedEntityValues: { 'values.0.coords': {} } } }```\r\n\r\n"},{"labels":["bug"],"text":"`Query.prototype.sort()` accepts array of arrays. When I add .toConstructor() it crashes saying\r\n ```\r\nInvalid sort() argument, must be array of arrays\r\n    at Query.sort (/xxx/node_modules/mquery/lib/mquery.js:1256:15)\r\n    at Query.sort (/xxx/node_modules/mongoose/lib/query.js:2536:26)\r\n    at Query.setOptions (/xxx/node_modules/mquery/lib/mquery.js:187:20)\r\n    at Query.setOptions (/xxx/node_modules/mongoose/lib/query.js:1367:32)\r\n    at model.Query.toConstructor (/xxx/node_modules/mongoose/lib/query.js:191:5)\r\n```\r\n\r\nNodeJS: v12.6.0\r\nMongoose: 5.7.0\r\nMongoDB: irrelevant\r\n"},{"labels":["bug"],"text":"When calling Model.populate() on a document or an array of documents, Mongoose returns the populated path as an Array.\r\n\r\nThe expected behaviour would be that if the path's value is a single ObjectId, String or Object (_using the skipInvalidIds property_) it should return a single Document, and if the value is an array then to return an Array of documents.\r\n\r\n\r\n**Schema**\r\n```javascript\r\nvar PhotoSchema = new Schema({\r\n    title: {\r\n        type: String,\r\n    },\r\n    data: {\r\n        type: Schema.Types.Mixed,\r\n    },\r\n});\r\n\r\nvar Photo = mongoose.model('photo', PhotoSchema);\r\n\r\n```\r\n\r\n**Example Document**\r\n```json\r\n{\r\n  \"title\":\"Example\",\r\n  \"data\":{\r\n     \"photographer\":{\r\n           \"_id\":\"5a9390c84028396d2a374432\",\r\n           \"title\":\"John Smith\",\r\n     }\r\n  }\r\n}\r\n```\r\n\r\n**Code to Populate**\r\n```javascript\r\n\r\nvar items; //Array of documents containing the example document above\r\n\r\nreturn Photo.populate(items, {\r\n          path:\"data.photograpger\",\r\n          select: controller.basicFields,\r\n          skipInvalidIds: true, \r\n}, done);                        \r\n```\r\n\r\n\r\n**Current Output**\r\n```json\r\n{\r\n  \"title\":\"Example\",\r\n  \"data\":{\r\n     \"photographer\":[\r\n     {\r\n           \"_id\":\"5a9390c84028396d2a374432\",\r\n           \"title\":\"John Smith\",\r\n     }\r\n     ]\r\n  }\r\n}       \r\n```\r\n\r\n\r\n**Expected Output**\r\n```json\r\n{\r\n  \"title\":\"Example\",\r\n  \"data\":{\r\n     \"photographer\":{\r\n           \"_id\":\"5a9390c84028396d2a374432\",\r\n           \"title\":\"John Smith\",\r\n     }\r\n  }\r\n}       \r\n```\r\n\r\n\r\n\r\nThis is really in relation to the skipInvalidIds feature, as if the objects are depopulated when saved to the database everything works as expected, It's just for when there are objects in the database that aren't plain ObjectIds but are objects with an _id that cause the issue.\r\n\r\nMy understanding was that  when using the 'skipInvalidIds' feature the data would stay the same as it originally was before calling populate(), It's seems like it's a bit smarter than that and is actually populating the object picking up the _id property. Which is nice, it just needs to understand whether it's a single ID or an array of multiple IDs when it returns\r\n\r\n"},{"labels":["bug"],"text":"**What is the current behavior?**\r\nWhen using instance of Number in filter mongo recieves an empty object instead of the number.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\n```\r\nconst mySchema = new Schema({\r\n  id: {\r\n    type: Number,\r\n    set: value => {\r\n      return new Number(value.valueOf());\r\n    }\r\n  }\r\n});\r\n\r\nconst MyModel = mongoose.model('MyModel', mySchema);\r\n\r\nMyModel.findOne({ id: 12345 });\r\n```\r\n\r\n```\r\ncommand: find { find: \"mymodel\", filter: { id: {} }, projection: {}, limit: 1, singleBatch: true, batchSize: 1, returnKey: false, showRecordId: false, lsid: { id: UUID(\"blahblahblah\") }, $db: \"mydb\" }\r\n```\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nNode: 12\r\nMongo: 4.2\r\nMongoose: 5.7.0\r\n"},{"labels":["bug"],"text":"**before**\r\n```\r\nschema.createIndex({ a: 1, b: 1 });\r\n```\r\n**after**\r\n```\r\nschema.createIndex({ b:1, a: 1 });\r\nModel.syncIndexes();\r\n```\r\n\r\nIt dose not drop index `{a: 1, b: 1}`"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug.\r\n\r\n**What is the current behavior?**\r\nThis is a follow-up for https://github.com/Automattic/mongoose/issues/8067\r\n\r\nScenario: Validator is used on an object property. With 5.6.9 the validator gets called **several** times, with 5.6.11 it gets **not** called at all.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```\r\nconst mongoose = require('mongoose'); // no mongoose.version when using import?!\r\n\r\n(async () => {\r\n  const Model = mongoose.model('model', new mongoose.Schema({\r\n    name: { type: String },\r\n    level1: {\r\n      level2: {\r\n        type: Object,\r\n        validate: {\r\n          validator: (v: any) => {\r\n            console.log('called validator with', v);\r\n            return true;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }));\r\n\r\n  const doc = new Model({ name: 'bob' });\r\n  console.log(mongoose.version);\r\n  doc.level1 = { level2: { a: 'one', b: 'two', c: 'three' } };\r\n  await doc.validate();\r\n  console.log('done');\r\n})().catch(err => console.error(err));\r\n```\r\n\r\nRunning with Mongoose 5.6.9 I see:\r\n```\r\n$ ./node_modules/.bin/ts-node ./src/mongoose-8067.ts \r\n5.6.9\r\ncalled validator with { a: 'one', b: 'two', c: 'three' }\r\ncalled validator with one\r\ncalled validator with two\r\ncalled validator with three\r\ndone\r\n```\r\n\r\nRunning with Mongoose 5.6.11 I see:\r\n```\r\n$ ./node_modules/.bin/ts-node ./src/mongoose-8067.ts \r\n5.6.11\r\ndone\r\n```\r\n\r\nI admittedly didn't try the version in between :-P\r\n\r\n**What is the expected behavior?**\r\nThe validator should execute once with `{ a: 'one', b: 'two', c: 'three' }`\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nBy cloning a schema the SchemaType loose the reference of the default requiredValidator method.\r\n\r\nThe error is related to this commit https://github.com/Automattic/mongoose/commit/a0f6ac1970de5bf243e640413c3d82daf03bd44d\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```\r\nconst mongoose = require('mongoose');\r\n\r\nclass Distance extends mongoose.SchemaType {\r\n  //...\r\n}\r\n\r\nmongoose.Schema.Types.Distance = Distance;\r\n\r\n(async () => {\r\n\r\n  const schema = new mongoose.Schema({\r\n    field: {type: Distance, required: true}\r\n  });\r\n\r\n  // Test KO\r\n\r\n  const TestKo = mongoose.model('TestKo', schema.clone()); //>> cloned\r\n\r\n  const testKo = new TestKo();\r\n\r\n  await testKo.validate(); //>> KO, not throwing the ValidationError \"Path `field` is required\r\n\r\n  console.error('should not exec bottom');\r\n\r\n  // Test Ok\r\n\r\n  const TestOk = mongoose.model('TestOk', schema); //>> not cloned\r\n\r\n  const testOk = new TestOk();\r\n\r\n  await testOk.validate();\r\n\r\n})();\r\n\r\n```\r\n\r\n**What is the expected behavior?**\r\nI expect the required validator to be executed after being cloned\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nnode v12.8.1\r\nMongoose v5.6.11\r\n\r\n"},{"labels":["bug"],"text":"https://github.com/Automattic/mongoose/pull/7492#issuecomment-522659317"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nIt's not a bug or a feature, I just want an example for discriminators. Sorry about this post but I'm really stuck and the documentation didn't help me.\r\n\r\n**What is the current behavior?**\r\n\r\nIt's not a behavior but more a request to understand how could I update a document contains 2 properties whichs are array of discriminators ? I didn't find any sample about that.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\n**What is the expected behavior?**\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nNode : 10.16.1\r\nMongoDB: 3.6.3\r\nMongoose: 5.6.9\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n\r\n> const mongoose = require('mongoose');\r\n> const carSchema = require('./car');\r\n> const continentalWheelSchema = require('./wheel/continental');\r\n> const michelinWheelSchema = require('./wheel/michelin');\r\n> \r\n> const CarSchema = new mongoose.Schema({}, { discriminatorKey: 'type', _id: false } );\r\n> const WheelSchema = new mongoose.Schema({}, { discriminatorKey: 'type', _id: false } );\r\n> \r\n> const ClientParkSchema = new mongoose.Schema({\r\n>     customer: { type: String, required: true },\r\n>     created_at: { type: Date, default: Date.now },\r\n>     updated_at: { type: Date, default: Date.now },\r\n>     cars: [CarSchema],\r\n>     wheels: [WheelSchema]\r\n> });\r\n> \r\n> ClientParkSchema.path('cars').discriminator('break', carSchema);\r\n> ClientParkSchema.path('wheels').discriminator('continental', continentalWheelSchema);\r\n> ClientParkSchema.path('wheels').discriminator('michelin', michelinWheelSchema);\r\n> \r\n> module.exports = {\r\n>     ClientPark: mongoose.model('client_park', ClientParkSchema, 'client_park')\r\n> };\r\n> \r\n> /////////////////////// CAR SCHEMA ////////////////////////\r\n> \r\n> const mongoose = require('mongoose');\r\n> \r\n> const CarSchema = new mongoose.Schema({\r\n>     brand: { type: String, required: true },\r\n>     model: { type: String, required: true },\r\n> }, { _id: false } );\r\n> \r\n> module.exports = CarSchema;\r\n> \r\n> /////////////////////// CONTINENTAL WHEEL SCHEMA ////////////////////////\r\n> \r\n> const mongoose = require('mongoose');\r\n> \r\n> const ContinentalWheelSchema = new mongoose.Schema({\r\n>     model: { type: String, required: true }\r\n> }, { _id: false } );\r\n> \r\n> module.exports = ContinentalWheelSchema;\r\n> \r\n> /////////////////////// MICHELIN WHEEL SCHEMA ////////////////////////\r\n> \r\n> const mongoose = require('mongoose');\r\n> \r\n> const MichelinWheelSchema = new mongoose.Schema({\r\n>     price: { type: number, required: true},\r\n>     model: { type: String, required: true },\r\n>     season: { type: String, required: true }\r\n> }, { _id: false } );\r\n> \r\n> module.exports = MichelinWheelSchema;\r\n> \r\n\r\nmy mongoose query :\r\n\r\n>  clientParkModels.ClientPark.updateOne(\r\n>                     {\r\n>                         '_id': '5d39a19e2376c7089ec7707b', 'car.type': 'break', 'wheel.type': 'continental'\r\n>                     }, \r\n>                     {\r\n>                         $set: {\r\n>                             'cars.$.brand': 'Ford',\r\n>                             'wheels.$.model': 'X5485622',\r\n>                             'wheels.$.price': 10000,\r\n>                             'wheels.$.season': 'summer'\r\n>                         }\r\n>                     }\r\n>                 ).exec();\r\n\r\nMy document is not updated. So, I would like if I can update 2 differents discriminator in the same query ? \r\nCould you provide an example ? \r\n\r\nThank you very much"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nThis is a bug report\r\n\r\n**What is the current behavior?**\r\n\r\nWhen I use `schema.path('sub.propA')`, I get `undefined`, if `sub` is a sub-document array.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\nSee current behavior.\r\n\r\n**What is the expected behavior?**\r\n\r\nWhen using `schema.path` on paths that go inside a sub-document array, the SchemaType is returned instead of `undefined`.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nNode.js 8.11.2\r\nMongoose 5.6.9\r\nMongoDB 4.0.3\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"We recently upgrade to mongoose 5.6.7\r\n\r\nIn earlier versions of mongoose we were using the stream() method for large collections like this,\r\n\r\n```javascript\r\n\r\nvar streamArray = [];\r\nvar stream = Model.find().batchSize(1000).stream();\r\n\r\n    stream.on('data', (doc) => {\r\n        streamArray.push(doc);\r\n    });\r\n\r\n    stream.on('end', () => {\r\n       var collection = streamArray.length;\r\n//Collection is our mongo documents\r\n\r\n    });\r\n\r\n```\r\n\r\nIn the updated documentation, it says instead to use .cursor()\r\n```javascript\r\nvar stream = Model.find().batchSize(1000).cursor({ batchSize: 1000 })\r\n```\r\n\r\nThis is much much slower and seems to only stream a single document at a time, (iterating through thousands of documents takes minutes) changing batchSize as above doesn't seem to make a difference, and the documentation implies that it is a replacement for the stream() method. In a blog post elsewhere it was suggested that we instead should manually load batches of documents at a time, but this puts so much stress on the database and blocks the event loop if the query is complex.\r\n\r\nIs cursor() supposed to allow for batchSize? Or should we stick with using .stream()\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"},{"labels":["bug"],"text":"mongoose: 5.6.7\r\nnodejs: 12.7.0\r\n\r\n---\r\n\r\nmongoose.Types.ObjectId.name returns `ObjectID` and mongoose at\r\nhttps://github.com/Automattic/mongoose/blob/1ceeb2bad1a56511f3802c19e62b38efd6c6ce03/lib/schema.js#L831\r\nwants `ObjectId`\r\n\r\n---\r\n\r\ni am a maintainer of typegoose, where we need `Type.name` (Type can be anything like ObjectId, Array, Mixed, String, etc), and because of that `Types.ObjectId[]` dosnt work, we implement a fix, but wanted to know if this is expect behavior\r\n\r\nthe Error: \r\n```\r\nTypeError: Invalid schema configuration: `ObjectID` is not a valid type within the array `docs`.See http://bit.ly/mongoose-schematypes for a list of valid schema types.\r\n```"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nWhen orFail(new Error()) is chained on a findOneAndReplace() query, no error is thrown when no document is found. Instead the query result is null as if orFail() was not used.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\nawait Model.findOneAndReplace({ foo: 'bar' }, { name: 'test' }).\r\n  orFail(() => Error('Not found'));\r\n\r\nseems like findOneAndReplace() (and maybe other operations) are not listed in this switch statement: https://github.com/Automattic/mongoose/blob/master/lib/query.js\r\n\r\n**What is the expected behavior?**\r\nAn error should be thrown if the no document was found in a findOneAndReplace().orFail(new Error()) scenario\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nNode: 10.15.0\r\nMongoDB: 4.0.6\r\nMongoose: 5.6.5\r\n\r\nsee also: https://github.com/Automattic/mongoose/issues/7280\r\n\r\n"},{"labels":["bug"],"text":"Hi, I wanted to point out this error I am getting that I think is sort of a bug, since technically we are just executing READ commands on the document(s), and the content changes so that the validation fails.\r\n\r\n**What is the current behavior?**\r\nWhen trying to save a document, after it has been populated on a required key, and the populated key is null because the reference object was not found anymore, trying to save it fails due to a validation error in the populated key being null after the populate.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```javascript\r\nconst mongoose = require('mongoose');\r\nmongoose.set('debug', true);\r\n\r\nconst GITHUB_ISSUE = `gh8018`;\r\nconst connectionString = `mongodb://localhost:27017/${GITHUB_ISSUE}`;\r\n\r\nrun().then(() => console.log('done')).catch(error => console.error(error.stack));\r\n\r\nasync function run() {\r\n    const db = await mongoose.connect(connectionString);\r\n    await mongoose.connection.dropDatabase();\r\n\r\n    const schema = mongoose.Schema({\r\n        placeHolderKey: {\r\n            type: String,\r\n            default: \"TEST\"\r\n        }\r\n    });\r\n\r\n    const schema2 = mongoose.Schema({\r\n        keyToPopulate: {\r\n            type: mongoose.Schema.Types.ObjectId,\r\n            ref: \"SecondaryModel\",\r\n            required: true\r\n        }\r\n    });\r\n\r\n\r\n    const secondaryModelThatIsPopulatedOnTheMainModel = db.model('SecondaryModel', schema);\r\n    const mainModelThatFailsValidation = db.model('MainModelThatFailsRequiredValidation', schema2);\r\n\r\n    let secondaryModelObject = await secondaryModelThatIsPopulatedOnTheMainModel.create({placeHolderKey: \"TEST\"});\r\n    let mainModelObject = await mainModelThatFailsValidation.create({keyToPopulate: secondaryModelObject._id});\r\n    await secondaryModelObject.remove();\r\n\r\n    const doc = await mainModelThatFailsValidation.find({_id: mainModelObject._id})\r\n        .populate(\"keyToPopulate\")\r\n        .exec();\r\n\r\n    doc[0].save(); //This one normally throws the error\r\n\r\n    console.log(doc[0].toObject()); //Removing the `await secondaryModelObject.remove();` will throw no errors\r\n}\r\n```\r\n\r\n**What is the expected behavior?**\r\nI think that `populate` shouldn't affect the actual content to the point of making it different from the previous one, since we didn't change anything at all.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nMongoose: 5.5.2\r\nNode: 8.12.0\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nI guess it's a bug\r\n**What is the current behavior?**\r\naggregate's pre hook not support changing the pipline; but when using the aggregate's cursor, then it is OK.\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\nschema.pre('aggregate', function(next) {\r\n    this.append({ $lookup: options });\r\n    next();\r\n  });\r\nI guess it's the lib/aggregate.js#L959, the pipeline passing to collection.aggregate cannot be changed. But the lib/cursor/AggregationCursor.js#L58 use the _pipline directly\r\n**What is the expected behavior?**\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"On version 5.6.5, I'm experiencing `bulkWrite` to not respect the schema `timestamps: false` option when it's being used with `updateOne`. The `updateMany` alternative doesn't seem to be facing this issue.\r\n\r\nHere is a repro script (unsure whether it's the minimal repro script but it shows the issue properly):\r\n\r\n```js\r\nconst assert = require('assert');\r\nconst start = require('./common');\r\n\r\nconst mongoose = start.mongoose;\r\nconst Schema = mongoose.Schema;\r\n\r\nit('bulkWrite must respect timestamps: false in subdocument (gh-8007)', async function() {\r\n  const db = start();\r\n\r\n  const subSchema = new Schema(\r\n    {\r\n      subObjId: {\r\n        type: Schema.Types.ObjectId,\r\n        required: false\r\n      }\r\n    },\r\n    {\r\n      timestamps: false,\r\n      _id: false\r\n    }\r\n  );\r\n\r\n  const ASchema = new Schema({\r\n    data: {\r\n      type: subSchema,\r\n      required: false\r\n    }\r\n  });\r\n\r\n  const A = db.model('gh-8007', ASchema);\r\n\r\n  const res = await A.create({\r\n    data: {}\r\n  });\r\n\r\n  await A.bulkWrite([\r\n    {\r\n      updateOne: {\r\n        filter: {\r\n          _id: res._id\r\n        },\r\n        update: {\r\n          'data.subObjId': new mongoose.Types.ObjectId()\r\n        }\r\n      }\r\n    }\r\n  ]);\r\n\r\n  const data = await A.findOne({}).lean();\r\n  assert.deepEqual(Object.keys(data.data), ['subObjId']);\r\n});\r\n```"},{"labels":["bug"],"text":"I have \"once\" field in my model doc. Which is conflicting while updating the existing doc, But while saving fresh doc am not getting.\r\n\r\nCode:\r\n```javascript\r\nvar mongoose = require('mongoose')\r\n\r\nvar options = {discriminatorKey: 'kind'};\r\n\r\nvar eventSchema = new mongoose.Schema({once: {\r\n    booleanField: {type: String}\r\n  }}, options)\r\n\r\n\r\n\r\nvar Event = mongoose.model('Event', eventSchema);\r\n\r\n// ClickedLinkEvent is a special type of Event that has\r\n// a URL.\r\nvar ClickedLinkEvent = Event.discriminator('ClickedLink',\r\n  new mongoose.Schema({lookups: {\r\n    type: [\r\n      {\r\n        hi: { type: String }\r\n      }\r\n    ]},url: String}, options));\r\n\r\nvar clickedEvent =\r\n  new ClickedLinkEvent({\r\n    once: {booleanField: true},\r\n    lookups: [\r\n    {\r\n      hi: 'address1',\r\n      name: 'address2',\r\n    }], url: 'google.com'});\r\n\r\nconsole.log(clickedEvent)\r\n```\r\nWhile updating existing doc am getting below error:\r\n```javascript\r\nUncaught TypeError: this.once is not a function\r\n      at model.Document (/node_modules/mongoose/lib/document.js:127:10)\r\n      at model.Model (/node_modules/mongoose/lib/model.js:93:12)\r\n      at new model (/node_modules/mongoose/lib/model.js:4542:13)\r\n      at Object.createModel (/node_modules/mongoose/lib/queryhelpers.js:130:10)\r\n      at completeOne (/node_modules/mongoose/lib/query.js:2663:26)\r\n      at model.Query.Query._completeOne (/node_modules/mongoose/lib/query.js:1951:7)\r\n      at Immediate.Query.base.findOne.call (node_modules/mongoose/lib/query.js:1993:10)\r\n      at Immediate.<anonymous> (/node_modules/mquery/lib/utils.j\r\n```\r\n\r\nCan anybody suggest how can resolve this issue. \r\n"},{"labels":["bug"],"text":"Nesting schemas with `select: false` causes parent `select:false` to be ignored if the parent is not a top level field.\r\n\r\nRelated: #1333 - which only checks if there is a top-level parent\r\n\r\nCurrent Behavior\r\n- `['a', 'a.b.c']` => `['a']` (correctly covered by #1333)\r\n- `['a.b', 'a.b.c']` => `['a.b', 'a.b.c']` (not covered)\r\n\r\nExpected Behavior\r\n- `['a.b', 'a.b.c']` => `['a.b']`\r\n\r\nOffending Code:\r\n\r\n[lib/query.js#L526](https://github.com/Automattic/mongoose/blob/a4e83c4f93d0916a9acd31152ec58d5c1dbbabfb/lib/query.js#L526)\r\n\r\n```js\r\n// check for parent exclusions\r\nvar root = path.split('.')[0];\r\nif (~excluded.indexOf(root)) return;\r\n```\r\n\r\nSomething like this checks if path starts with any parent path:\r\n\r\n```js\r\nif (excluded.some(parent => path.startsWith(parent + '.')) {\r\n  return;\r\n}\r\n```\r\n\r\nHere's the current spec [schema.select.test.js#L276](https://github.com/Automattic/mongoose/blob/c027681e67d23951d401ceebf5272fa54d6f43cb/test/schema.select.test.js#L276) adjusted to cause a failing case. I just made the first `select: false` one level deep. (note: sorry I haven't tested this spec)\r\n\r\n```js\r\ndescribe('exclusion in root schema should override child schema', () => {\r\n  it('works', (done) => {\r\n    const m = new mongoose.Mongoose();\r\n    const child = new Schema({\r\n      name1: {type: String, select: false},\r\n      name2: {type: String, select: true}\r\n    });\r\n    const selected = new Schema({\r\n      // I just nested docs, so it's not top-level\r\n      parent: {\r\n        docs: {type: [child], select: false}\r\n      }\r\n    });\r\n    const M = m.model('deselect', selected);\r\n\r\n    const query = M.findOne();\r\n    query._applyPaths();\r\n    assert.equal(Object.keys(query._fields).length, 1);\r\n    assert.equal(query._fields['parent.docs.name1'], undefined);\r\n    assert.equal(query._fields['parent.docs.name2'], undefined);\r\n    assert.equal(query._fields.parent.docs, 0);\r\n    done();\r\n  });\r\n});\r\n```\r\n\r\n"},{"labels":["bug"],"text":"**What is the current behavior?**\r\nIf you use projection to exclude a property and that property has a defined getter on the schema, and at the same time your schema has specified `{ toObject : { getters: true } }`, then the projection seems to be ignored and the property is included in the response even though it should be excluded according to the projection.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```javascript\r\nconst mongoose = require('mongoose');\r\nmongoose.set('debug', true);\r\n\r\nconst GITHUB_ISSUE = `gh7940`;\r\nconst connectionString = `mongodb://localhost:27017/${ GITHUB_ISSUE }`;\r\nconst { Schema } = mongoose;\r\n\r\nrun().then(() => console.log('done')).catch(error => console.error(error.stack));\r\n\r\nasync function run() {\r\n  await mongoose.connect(connectionString);\r\n  await mongoose.connection.dropDatabase();\r\n\r\n  const schema = new Schema({\r\n    foo: String,\r\n    bar: { type: String, get: () => 'getter value' }\r\n  }, \r\n  {\r\n    toObject : { getters: true }\r\n  });\r\n\r\n  const Model = mongoose.model('Test', schema);\r\n\r\n  await Model.create({ foo: 'test', bar: 'baz' });\r\n\r\n  const doc = await Model.findOne({ foo: 'test' }, 'foo');\r\n  console.log(doc);\r\n}\r\n```\r\n\r\n**What is the expected behavior?**\r\nThe property excluded by the projection is actually excluded from the response, even if it has a getter defined. \r\n\r\nNot sure if this is the expected behavior when you set `{ getters: true }` but I would have expected the getter to be applied only when you actually want to get the value of the property.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nNode: 10.16\r\nMongoose: 5.6.1\r\nMongoDB: 4.0.0"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n*bug*\r\n\r\n**What is the current behavior?**\r\n```\r\n~/node_modules/mongoose/lib/document.js:981\r\ncur = cur[parts[i]];\r\n^\r\n\r\nTypeError: Cannot read property 'list' of undefined\r\nat SingleNested.$set (~/node_modules/mongoose/lib/document.js:981:14)\r\nat SingleNested.$set (~/node_modules/mongoose/lib/document.js:815:16)\r\nat SingleNested._handleIndex (~/node_modules/mongoose/lib/document.js:856:12)\r\nat SingleNested.$set (~/node_modules/mongoose/lib/document.js:821:22)\r\nat SingleNested._handleIndex (~/node_modules/mongoose/lib/document.js:856:12)\r\nat SingleNested.$set (~/node_modules/mongoose/lib/document.js:821:22)\r\nat SingleNested._handleIndex (~/node_modules/mongoose/lib/document.js:856:12)\r\nat SingleNested.$set (~/node_modules/mongoose/lib/document.js:821:22)\r\nat SingleNested.Document (~/node_modules/mongoose/lib/document.js:124:12)\r\nat SingleNested.Subdocument (~/node_modules/mongoose/lib/types/subdocument.js:34:12)\r\nat new SingleNested (~/node_modules/mongoose/lib/schema/embedded.js:61:17)\r\nat Embedded.cast (~/node_modules/mongoose/lib/schema/embedded.js:174:12)\r\nat Embedded.SchemaType.getDefault (~/node_modules/mongoose/lib/schematype.js:895:25)\r\nat $__applyDefaults (~/node_modules/mongoose/lib/document.js:359:22)\r\nat model.Document (~/node_modules/mongoose/lib/document.js:111:5)\r\nat model.Model (~/node_modules/mongoose/lib/model.js:97:12)\r\n```\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\n```javascript\r\nconst mongoose = require('mongoose');\r\n\r\nconst subdoc = new mongoose.Schema({\r\n    list: {\r\n        type: [String],\r\n        default: ['a']\r\n    }\r\n}, { minimize: false });\r\n\r\nconst TestSchema = new mongoose.Schema({\r\n    lists: {\r\n        type: subdoc,\r\n        default: subdoc\r\n    }\r\n});\r\n\r\nconst Test = mongoose.model('test', TestSchema);\r\n\r\nmongoose.connect('mongodb://localhost/test')\r\n    .then(() => Test.create({}))\r\n    .then(() => Test.find({})) // <---- error rises here\r\n    .then(console.log)\r\n    .catch(console.log);\r\n```\r\n\r\n**What is the expected behavior?**\r\nno TypeError when finding documents\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nNode.js v10.16.0\r\nMongoose 5.6.1\r\nMongoDB v4.0.10\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n\r\nmongoose@5.5.2 - error reproduces starting this version"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBug\r\n\r\n**What is the current behavior?**\r\n\r\nWhen performing an `update*`, `$setOnInsert` is set to empty if the schema is using the `timestamps` option and the `createdAt` property is marked as `immutable: true`, even if the `update` query specifies `{ upsert: false }`.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\nThe model must include the appropriate timestamps and mark `createdAt` as `immutable`:\r\n\r\n```\r\n    createdAt: {\r\n        type: mongoose.Schema.Types.Date,\r\n        default: (new Date()).getTime(),\r\n        index: true,\r\n        immutable: true\r\n    },\r\n    updatedAt: {\r\n        type: mongoose.Schema.Types.Date,\r\n        default: (new Date()).getTime()\r\n    }\r\n}, {\r\n    timestamps: true\r\n})\r\n```\r\n\r\nUpon attempting `Model.update({ .. }, { upsert: false })`, the Mongo query will be of the form:\r\n\r\n`Model.update({ ... }, { '$setOnInsert': {}, '$set': { ... }, { upsert: false })`\r\n\r\nThis results in an error:\r\n\r\n`MongoError: '$setOnInsert' is empty. You must specify a field like so: {$setOnInsert: {<field>: ...}}`\r\n\r\n**What is the expected behavior?**\r\n\r\nMaking `createdAt` immutable is a desirable use case: http://thecodebarbarian.com/whats-new-in-mongoose-5-6-immutable-properties.html\r\n\r\nIt appears `immutable` properties are being exempted from `$setOnInsert`? At the very least it seems when specifying `{ upsert: false }`, the `$setOnInsert` option can be skipped completely. Indeed if the `$setOnInsert` object is empty, it probably shouldn't be included at all.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nNode.js: 12.4.0\r\nMongoose: 5.6.0\r\nMongoDB: 3.6.8\r\n\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\n\r\nReport a bug\r\n\r\n**What is the current behavior?**\r\n\r\nWhen using a schema with a field of type `Map`, attempting to do a `findOneAndUpdate` with both the `setDefaultsOnInsert` and `upsert` fields set to `true` causes a `DollarPrefixedFieldName` Mongo Error (code 52). This occurs even when both the `findOneAndUpdate` condition and update do not reference the `Map` field.\r\n\r\nSee [Codesandbox Demo.](https://codesandbox.io/s/happy-shtern-04ymv?fontsize=14&hidenavigation=1)\r\n\r\n**What is the expected behavior?**\r\n\r\nThe expected fields should be upserted into the DB and any defaults should be set. No error should occur.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nNode.js: v10.16.0\r\nMongoose: v5.6.0\r\nMongoDB: v4.0.10"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**Current behavior**\r\nProperties on objects that contain a value of type `Date` are not persisted to a document when passing an object into a model constructor, where the model is based off of a schema with the `strict: false` option set. This previously worked in version 5.5.1\r\n\r\n**Steps to reproduce.**\r\n```javascript\r\nconst mongoose = require('mongoose');\r\n\r\n// === Connect to MongoDB ===\r\nconst mongoURI = 'mongodb://localhost:27017';\r\nconst mongoOpts = {\r\n  dbName: 'mongooseBug',\r\n  useNewUrlParser: true,\r\n  useCreateIndex: true,\r\n}\r\nmongoose.connect(mongoURI, mongoOpts);\r\n\r\n// === Create Schema/Model\r\nconst schema = mongoose.Schema({}, { strict: false });\r\nconst SettingsModel = mongoose.model('Settings', schema);\r\n\r\n// === Create Document ===\r\nconst settingsObject = {\r\n  timestamp: new Date(),\r\n  subDoc: {\r\n    timestamp: new Date(),\r\n  },\r\n}\r\nconst settingsDocument = new SettingsModel(settingsObject);\r\n\r\n// === Output Actual & Expected Documents\r\nconsole.log('=== ACTUAL DOCUMENT ===')\r\nconsole.log(settingsDocument);\r\n\r\nconsole.log('\\n=== EXPECTED DOCUMENT ===')\r\nconsole.log({\r\n  _id: '<AUTO GENERATED>',\r\n  timestamp: settingsObject.timestamp,\r\n  subDoc: {\r\n    timestamp: settingsObject.subDoc.timestamp\r\n  },\r\n});\r\n\r\n// === Save Document & Close MongoDB Connection ===\r\nsettingsDocument.save((err) => {\r\n  mongoose.connection.close()\r\n});\r\n```\r\n\r\n**What is the expected behavior?**\r\nI expect the following to be logged out & saved to DB:\r\n```\r\n=== EXPECTED DOCUMENT ===\r\n{ _id: '<AUTO GENERATED>',\r\n  timestamp: 2019-06-17T23:02:07.711Z,\r\n  subDoc: { timestamp: 2019-06-17T23:02:07.711Z } }\r\n```\r\nInstead I get the following:\r\n```\r\n=== ACTUAL DOCUMENT ===\r\n{ _id: 5d081cb010dcaa21488d97d2 }\r\n```\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using?**\r\nNode: 10.7.0\r\nMongoose: 5.5.2 - 5.6.0. Version 5.5.1 provides the expected output\r\nMongoDB: 4.0 & 3.6\r\n\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nWhen using nested discriminators and a schema `clone()`, the method lookup doesn't work as expected (ie. calls the abstract version of the method).\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n```javascript\r\nconst mongoose = require('mongoose');\r\nconst { Schema } = mongoose;\r\n\r\nconst colorSchema = new Schema({}, { discriminatorKey: 'type' });\r\ncolorSchema.methods.isYellow = function () { return false; };\r\n\r\nconst yellowSchema = new Schema();\r\nyellowSchema.methods.isYellow = function () { return true; };\r\n\r\nconst fruitSchema = new Schema({}, { discriminatorKey: 'type' });\r\n\r\nconst bananaSchema = new Schema({ color: { type: colorSchema } });\r\nbananaSchema.path('color').discriminator('yellow', yellowSchema);\r\nbananaSchema.methods.isYellow = function () { return this.color.isYellow(); };\r\n\r\nconst schema = new Schema(\r\n  {\r\n    fruits: {\r\n      type: [fruitSchema],\r\n      default: [],\r\n    },\r\n  },\r\n);\r\n\r\n// Note the clone() here\r\nschema.path('fruits').discriminator('banana', bananaSchema.clone());\r\n\r\nconst Basket = mongoose.model('Basket', schema);\r\nconst b = new Basket({\r\n  fruits: [\r\n    {\r\n      type: 'banana',\r\n      color: { type: 'yellow' },\r\n    },\r\n  ],\r\n});\r\n\r\nconsole.log(b.fruits[0].isYellow()); // prints false\r\n```\r\n**What is the expected behavior?**\r\nThe correct specialized method should be called.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nNode v10.15.3\r\nMongoose v5.5.15\r\n\r\n**Remarks**\r\nIt's working if we remove the schema `clone()`. Problem is I need this `clone()` (this example doesn't).\r\n\r\nThe problem seems to have appeared with v5.4.15 (it's working with v5.4.14).\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"Re: https://github.com/Automattic/mongoose/issues/5602#issuecomment-496078461"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nbug report\r\n\r\n**What is the current behavior?**\r\nWhen using a schema static function with \"this.findById\" the application crashes with the error:\r\n\r\n`TypeError: Cannot read property 'paths' of undefined`\r\n\r\nThis same code is confirmed as working on <=5.5.7, but produces the above error on >=5.5.8\r\nI console.log'd the model.schema.paths directly before the calling line to this.findById and the paths were output.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n- create a schema+model\r\n- add a static method that calls this.findById\r\n- require the model from another point in the application and call the static function\r\n\r\n\r\n**What is the expected behavior?**\r\nExpect this to not error and return the query as before.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nNode.js: v9.2.1\r\nMongoose: 5.5.8\r\nMongoDB: 3.2.3\r\n\r\n**Full Error Stack (paths sanitized)**\r\n\r\n> TypeError: Cannot read property 'paths' of undefined\r\nat docReducer (/[PATH]/node_modules/mongoose/lib/document.js:2556:49)\r\nat /[PATH]/node_modules/mongoose/lib/document.js:2587:16\r\nat Array.reduce (<anonymous>)\r\nat docReducer (/[PATH]/node_modules/mongoose/lib/document.js:2586:31)\r\nat /[PATH]/node_modules/mongoose/lib/document.js:2595:12\r\nat Array.reduce (<anonymous>)\r\nat model.Document.$__getAllSubdocs (/[PATH]/node_modules/mongoose/lib/document.js:2594:42)\r\nat model.$session (/[PATH]/node_modules/mongoose/lib/document.js:712:26)\r\nat completeMany (/[PATH]/node_modules/mongoose/lib/helpers/query/completeMany.js:45:12)\r\nat cb (/[PATH]/node_modules/mongoose/lib/query.js:1827:9)\r\nat result (/[PATH]/node_modules/mongodb/lib/utils.js:410:17)\r\nat executeCallback (/[PATH]/node_modules/mongodb/lib/utils.js:402:9)\r\nat handleCallback (/[PATH]/node_modules/mongodb/lib/utils.js:128:55)\r\nat cursor.close (/[PATH]/node_modules/mongodb/lib/operations/cursor_ops.js:224:62)\r\nat handleCallback (/[PATH]/node_modules/mongodb/lib/utils.js:128:55)\r\nat completeClose (/[PATH]/node_modules/mongodb/lib/cursor.js:898:14)\r\nat Cursor.close (/[PATH]/node_modules/mongodb/lib/cursor.js:917:10)\r\nat cursor._next (/[PATH]/node_modules/mongodb/lib/operations/cursor_ops.js:224:23)\r\nat handleCallback (/[PATH]/node_modules/mongodb-core/lib/cursor.js:204:5)\r\nat _setCursorNotifiedImpl (/[PATH]/node_modules/mongodb-core/lib/cursor.js:426:38)\r\nat self._endSession (/[PATH]/node_modules/mongodb-core/lib/cursor.js:434:46)\r\nat Cursor._endSession (/[PATH]/node_modules/mongodb-core/lib/cursor.js:195:5)\r\nat Cursor._endSession (/[PATH]/node_modules/mongodb/lib/cursor.js:231:59)\r\nat _setCursorNotifiedImpl (/[PATH]/node_modules/mongodb-core/lib/cursor.js:434:17)\r\nat setCursorNotified (/[PATH]/node_modules/mongodb-core/lib/cursor.js:426:3)\r\nat setCursorDeadAndNotified (/[PATH]/node_modules/mongodb-core/lib/cursor.js:419:3)\r\nat nextFunction (/[PATH]/node_modules/mongodb-core/lib/cursor.js:547:5)\r\nat Cursor.next (/[PATH]/node_modules/mongodb-core/lib/cursor.js:766:3)\r\n"},{"labels":["bug"],"text":"I'm not sure if a bug or if i need to go about setting this up differently when constructing the document. \r\n\r\nI'm having a problem where discriminated subdocuments with different schemas are not being populated with default values when the document is saved. the only field being set when saving is the field which is discriminated on, `type`. is there a workaround for this problem?\r\n\r\n```js\r\nconst mongoose = require('mongoose');\r\nconst Schema = mongoose.Schema;\r\nconst Types = Schema.Types;\r\n\r\n//the type constants used for the subdocument schemas\r\nconst constants = {\r\n    TYPES:{\r\n        A:1,\r\n        B:2,\r\n        C:3,\r\n        D:4,\r\n        E:5\r\n    }\r\n};\r\n\r\n//create our types schema\r\nconst TypesSchema = new Schema({\r\n    type:{type:Number},\r\n},{discriminatorKey:'type',_id:false});\r\n\r\n//add types schema to main schema\r\nconst MainSchema = new Schema({\r\n    types:[TypesSchema],\r\n});\r\n\r\nfunction generateTypeSchema(type) {\r\n    const schema = {\r\n        description:{type:String,default:null},\r\n        foo:{type:Boolean,default:false},\r\n\t//assume more stuff is here based on the needs of each type\r\n    };\r\n    return schema;\r\n}\r\n\r\n// generate a schema for each type\r\nconst ASchema = generateTypeSchema('A');\r\nconst BSchema = generateTypeSchema('B');\r\nconst CSchema = generateTypeSchema('C');\r\nconst DSchema = generateTypeSchema('D');\r\nconst ESchema = generateTypeSchema('E');\r\n\r\n//setup discriminators for each type schema\r\nMainSchema.path('types').discriminator(constants.TYPES.A, new Schema(ASchema));\r\nMainSchema.path('types').discriminator(constants.TYPES.B, new Schema(BSchema));\r\nMainSchema.path('types').discriminator(constants.TYPES.C, new Schema(CSchema));\r\nMainSchema.path('types').discriminator(constants.TYPES.D, new Schema(DSchema));\r\nMainSchema.path('types').discriminator(constants.TYPES.E, new Schema(ESchema));\r\n\r\nconst Main = mongoose.model('Main',MainSchema);\r\n\r\nconst main = new Main({\r\n    types:[\r\n        {type:1},\r\n        {type:2},\r\n        {type:3}\r\n        {type:4}\r\n        {type:5}\r\n    ]\r\n});\r\n\r\nmain.save((err,doc)=>{\r\n    console.log(doc);//subdocuments in types have not been saved with default values. only saved value in each was the type field.\r\n});\r\n```\r\n\r\n**EDIT**: after switching the discriminatorKey's type from `Number` to `String` and changing to string constants, it is now working. this means mongoose is not compatible for discriminating on non string fields. please update your documentation to reflect this, i have wasted alot of time on this issue. PS: thanks for great library with awesome features"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nFeature\r\n\r\n**What is the current behavior?**\r\n\r\nThis piece of code works. I expected it to give a validation error since I've set key `kind` (which is also the discriminator key) to required.\r\n\r\n```javascript\r\nconst eventSchema = new mongoose.Schema(\r\n  { \r\n    title: String,\r\n    kind: { type: String, required: true }\r\n  },\r\n  { discriminatorKey: 'kind' }\r\n);\r\n\r\nconst Event = mongoose.model('Event', eventSchema);\r\nconst ClickedEvent = Event.discriminator(\r\n  'ClickedEvent',\r\n  new mongoose.Schema({ url: String })\r\n);\r\n\r\nawait Event.create(\r\n  {\r\n    title: 'Title1'\r\n  }\r\n)\r\n```\r\n\r\n**What is the expected behavior?**\r\nI expect it to fail validation, and that I need to set it like this:\r\n\r\n```javascript\r\nawait Event.create(\r\n  {\r\n    title: 'Title1',\r\n    kind: 'ClickedEvent'\r\n  }\r\n)\r\n```\r\n\r\nThe reasoning behind this is that I want a parent schema with some defaults, but I do not want to be able to create documents directly only validating against parent schema. If there is something wrong in this way of thinking I'm all ears.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nMoongose 5.5.2\r\nMongodb 3.6.3\r\nNode.js 10.13.0\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\n\r\nI believe this is a **bug**.\r\n\r\n**What is the current behavior?**\r\n\r\nAssuming the following model:\r\n\r\n```js\r\nconst coll = new mongoose.Schema(\r\n  { tags: [String] }\r\n);\r\n```\r\n\r\nand sample collection:\r\n\r\n```\r\n[\r\n  { \"tags\": [] },\r\n  { \"tags\": null },\r\n  { \"tags\": [null] },\r\n  { \"tags\": [\"\"] },\r\n  { \"tags\": [\"non-empty\"] }\r\n]\r\n```\r\n\r\nTo match all documents with â€œemptyâ€ tags, the following query can be used, and works well with both plain Mongo and Mongoose:\r\n\r\n```js\r\n// Mongo: works as expected\r\ndb.getCollection(\"colls\").find(\r\n  { tags: { $in: ['', null, []] } }\r\n);\r\n\r\n// Mongoose: works as expected\r\nColl.find(\r\n  { tags: { $in: ['', null, []] } }\r\n)\r\n```\r\n\r\nTo match all documents with â€œnon-emptyâ€ tags, the following query can be used, and works well with plain Mongo, but it **fails with Mongoose**:\r\n\r\n```js\r\n// Mongo: works as expected\r\ndb.getCollection(\"colls\").find(\r\n  { tags: { $nin: ['', null, []] } }\r\n);\r\n\r\n// Mongoose: MongooseError [CastError]: Cast to string failed for value \"[]\" at path \"tags\" for model \"Coll\"\r\nColl.find(\r\n  { tags: { $nin: ['', null, []] } }\r\n)\r\n```\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n\r\nA sample project triggering the error is available at this [repository](https://github.com/coox/mongoose-in-vs-nin-issue).\r\n\r\n**What is the expected behavior?**\r\n\r\nMongoose is expected to send a query with `{ $nin: [ [] ] }` to Mongoose, just like it does for the `$in` operator.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nI could reproduce this issue with all versions of Mongoose from 5.4.23 to the latest (currently 5.5.8). For these versions, Mongoose debug reports:\r\n\r\n```\r\nMongoose: colls.find({ tags: { '$in': [ '', null, [] ] } }, { projection: {} })\r\nCastError: Cast to string failed for value \"[]\" at path \"tags\" for model \"Coll\"\r\n```\r\n\r\nFor versions 5.4.22 and prior, Mongoose debug reports:\r\n\r\n```\r\nMongoose: colls.find({ tags: { '$in': [ '', null, [] ] } }, { projection: {} })\r\nMongoose: colls.find({ tags: { '$nin': [ '', null, '' ] } }, { projection: {} })\r\n```"},{"labels":["bug"],"text":"We are using nested schemas and we have a child schema that has a pre-save hook. After upgrading to latest mongoose the child schema pre save hooks stopped working. Seems that this started happening since mongoose 5.5.4. With mongoose 5.5.3 the hooks are still being called.\r\n\r\nCode that you can use to replicate the issue\r\n```const childSchema = new mongoose.Schema({ test: String });\r\n  childSchema.pre('save', function () {\r\n    console.log('HELLO WORLD')\r\n  });\r\n\r\n  const topSchema = new mongoose.Schema({\r\n    children: {\r\n      child1: childSchema,\r\n      child2: childSchema,\r\n    }\r\n  });\r\n\r\n  const Model = mongoose.model('Model', topSchema);\r\n\r\n  const m = await new Model({\r\n    children: {\r\n      child1: {},\r\n      child2: {},\r\n    }\r\n  }).save();\r\n```\r\nBefore when calling `save` for the model the child schema pre-save hooks would run but with version 5.5.4 or later they are not being called. "},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nthis context in hooks are not of type Query anymore\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\nquery hook:\r\n```\r\nmySchema.pre('findOneAndUpdate', async function setDefaultOptions(this: any) {\r\n  console.log(this instanceof Query) // false, used to be true up to mongoose 5.4.22\r\n})\r\n```\r\ncall findOneAndUpdate\r\n```\r\nawait model(message.messageType).findOneAndUpdate({_id: {$exists: false}}, newMessage, {upsert: true})\r\n````\r\n**What is the expected behavior?**\r\n\r\nbehaviour should not change between minor versions of mongoose\r\nquery hooks should be of type Query\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nmongoose 5.5.6 is broken (and earlier)\r\nmongoose 5.4.22 is the last tested working version\r\n\r\n```\r\n# mongod --version                       \r\ndb version v4.0.9\r\n```\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nThe property stays unpopulated\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nhttps://gist.github.com/sergei202/c59b4cafebbf16ec8bf49d8d93e1d964\r\n\r\nInstall 5.4.16 and run the script, you will see `parent.list[0].fill.child` populated.\r\nInstall a newer version (broken in 5.4.17) and you will only see the ObjectId.\r\n\r\n**What is the expected behavior?**\r\nIt should be populated regardless of property name.  Renaming the property from `fill` to something like `filling` works.  Just the word `fill` that causes it to break.  Interestingly, it only breaks when its a subdocument.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nNode: v10.15.3\r\nMongoDB: 4.0.5\r\nMongoose: 5.5.6\r\n"},{"labels":["bug"],"text":"This is actually extremely similar to #7707. I'm opening a new issue as requested by @vkarpov15 .\r\n\r\nSince 5.4.19 our build has been failing because it looks like nested properties are not being set correctly (or even set to undefined). \r\n\r\nIn our own case this is happening with Number fields that are set to undefined and then when mongoose tries to cast them to numbers, they become `NaN` (`Number(undefined) -> NaN`) https://travis-ci.org/HabitRPG/habitica/jobs/524634104\r\n\r\nI can followup with a different repro script if needed but this code posted in #7707 by @Msordet works in reproducing the issue\r\n\r\n```\r\nconst mongoose = require(\"mongoose\");\r\nconst Schema = mongoose.Schema;\r\n\r\n// Fix all deprecation warnings: https://mongoosejs.com/docs/deprecations.html\r\nmongoose.set(\"useNewUrlParser\", true);\r\nmongoose.set(\"useFindAndModify\", false);\r\nmongoose.set(\"useCreateIndex\", true);\r\n\r\nconst geojsonSchema = new Schema(\r\n  {\r\n    type: { type: String, default: \"Feature\" },\r\n    geometry: {\r\n      type: {\r\n        type: String,\r\n        enum: [\r\n          \"Point\",\r\n          \"MultiPoint\",\r\n          \"LineString\",\r\n          \"MultiLineString\",\r\n          \"Polygon\",\r\n          \"MultiPolygon\",\r\n          \"GeometryCollection\"\r\n        ],\r\n        required: true\r\n      },\r\n      coordinates: { type: [] }\r\n    },\r\n    properties: { type: Object }\r\n  },\r\n  {\r\n    _id: false,\r\n    timestamps: {\r\n      createdAt: true\r\n    }\r\n  }\r\n).index({ geometry: \"2dsphere\" });\r\n\r\nconst userSchema = new Schema({\r\n  position: geojsonSchema\r\n});\r\n\r\nconst GeoJson = mongoose.model(\"GeoJson\", geojsonSchema);\r\nconst User = mongoose.model(\"User\", userSchema);\r\n\r\nmongoose.connect(\"mongodb://localhost:27017/test-nested\").then(async () => {\r\n  const position = new GeoJson({\r\n    geometry: {\r\n      type: \"Point\",\r\n      coordinates: [1.11111, 2.22222]\r\n    },\r\n    properties: {\r\n      a: \"b\"\r\n    }\r\n  });\r\n\r\n  const newUser = new User({\r\n    position\r\n  });\r\n  try {\r\n    await newUser.save();\r\n  } catch (e) {\r\n    console.log(\"Fail at user creation\");\r\n    console.error(e);\r\n  }\r\n\r\n  const editUser = await User.findById(newUser._id);\r\n\r\n  editUser.position = position;\r\n\r\n  try {\r\n    await position.validate();\r\n    await editUser.validate();\r\n  } catch (e) {\r\n    console.log(\"Fail at user validation\");\r\n    console.error(e);\r\n  }\r\n});\r\n```"},{"labels":["bug"],"text":"In a Document of a Model with a Map field that has been populated, modifying that Map object and saving it doesn't get saved in the database.\r\n\r\n~~~ js\r\nconst assert = require(\"assert\")\r\nconst mongoose = require(\"mongoose\");\r\nmongoose.connect(\"mongodb://localhost:27017/test\", { useNewUrlParser: true });\r\n\r\nconsole.log(\"Mongoose \" + mongoose.version)\r\n\r\nconst Scene = mongoose.model('Scene', new mongoose.Schema({\r\n  name: String\r\n}))\r\n\r\nconst Event = mongoose.model('Event', new mongoose.Schema({\r\n  id: String,\r\n\r\n  scenes: {\r\n    type: Map,\r\n    default: {},\r\n    of: {\r\n      type: mongoose.Schema.Types.ObjectId,\r\n      ref: \"Scene\"\r\n    }\r\n  },\r\n}, {id: false}))\r\n\r\nasync function Test() {\r\n  await Event.deleteMany({})\r\n  await Scene.deleteMany({})\r\n\r\n  var bar_scene = await new Scene({name: \"bar\"}).save()\r\n  var event = await new Event({ id: \"my-event\", scenes: {foo: bar_scene} }).save()\r\n  \r\n  var event = await Event.findOne({id: \"my-event\"}).populate(\"scenes\")\r\n  var baz_scene = await new Scene({name: \"baz\"}).save()\r\n  event.scenes.set(\"bar\", baz_scene)\r\n  await event.save()\r\n\r\n  console.log(event.scenes.get(\"bar\")) // Scene\r\n\r\n  event = await Event.findOne({id: \"my-event\"}).populate(\"scenes\")\r\n  console.log(event.scenes.get(\"bar\")) // Should print a Scene\r\n\r\n  mongoose.disconnect()\r\n}\r\n\r\nTest();\r\n~~~"},{"labels":["bug"],"text":"I have dynamic json (Structure is not defined) which have to stored into db.\r\n\r\n```\r\nlet data = {\r\n    \"channelTaxonomyList\": [\r\n        { \"categoryId\": \"10187\", \"taxonomyName\": \"Website Taxonomy\" },\r\n        { \"categoryId\": \"10237\", \"taxonomyName\": \"Website Taxonomy\" },\r\n        { \"categoryId\": \"10025\", \"taxonomyName\": \"Website Taxonomy\" },\r\n        { \"categoryId\": \"10030\", \"taxonomyName\": \"Website Taxonomy\" },\r\n        { \"categoryId\": \"10157\", \"taxonomyName\": \"Website Taxonomy\" },\r\n        { \"categoryId\": \"10278\", \"taxonomyName\": \"Website Taxonomy\" },\r\n        { \"categoryId\": \"10055\", \"taxonomyName\": \"Website Taxonomy\" }\r\n    ]\r\n};\r\n\r\nlet newProduct = new product(data);\r\n\r\nnewProduct.save(function (err, savedProduct) {\r\n    if (err) {\r\n        console.log(\"err\", err)\r\n    } else {\r\n        console.log(\"savedProduct\", savedProduct)\r\n    }\r\n})\r\n```\r\n\r\n**Expectation:** \r\nsaved document should like this. **channelTaxonomyList** must be type **Array**\r\n```\r\n{ _id: 5cbefb9d663e872f07f79467,\r\n  channelTaxonomyList: \r\n   [ { categoryId: '10187', taxonomyName: 'Website Taxonomy' },\r\n     { categoryId: '10237', taxonomyName: 'Website Taxonomy' },\r\n     { categoryId: '10025', taxonomyName: 'Website Taxonomy' },\r\n     { categoryId: '10030', taxonomyName: 'Website Taxonomy' },\r\n     { categoryId: '10157', taxonomyName: 'Website Taxonomy' },\r\n     { categoryId: '10278', taxonomyName: 'Website Taxonomy' },\r\n     { categoryId: '10055', taxonomyName: 'Website Taxonomy' } ],\r\n  __v: 0 }\r\n```\r\n**Actual Result:**  channelTaxonomyList converted into Object (Map Type with key and value).\r\nArray index changes into key and array elements into values.\r\n\r\n```\r\n{ _id: 5cbefb85a09e6a1d4376ebec,\r\n  channelTaxonomyList:\r\n   { '0': { categoryId: '10187', taxonomyName: 'Website Taxonomy' },\r\n     '1': { categoryId: '10237', taxonomyName: 'Website Taxonomy' },\r\n     '2': { categoryId: '10025', taxonomyName: 'Website Taxonomy' },\r\n     '3': { categoryId: '10030', taxonomyName: 'Website Taxonomy' },\r\n     '4': { categoryId: '10157', taxonomyName: 'Website Taxonomy' },\r\n     '5': { categoryId: '10278', taxonomyName: 'Website Taxonomy' },\r\n     '6': { categoryId: '10055', taxonomyName: 'Website Taxonomy' } },\r\n  __v: 0 }\r\n```\r\n\r\nAs i describe above the json have no predefined structure, key may be change at run time, So in **schema** i'm using **{ strict: false }**.\r\n\r\nMy schema and model is :\r\n\r\n```\r\nimport * as mongoose from 'mongoose';\r\nconst ProductSchema = new mongoose.Schema({\r\n}, { strict: false });\r\n\r\nProductSchema.index({ '$**': 'text' });\r\nexport default mongoose.model('new_products', ProductSchema);\r\n```\r\n\r\n**Node Version:**  8.10.0\r\n**@types/mongoose:**  5.3.24\r\n**mongoose:**  5.4.20\r\n\r\n**Note:** Working fine in local machine (OS: Mac- High Sierra).\r\n               Bug is producible on AWS server (OS: Ubuntu: 18.04.2 LTS) \r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\n**What is the current behavior?**\r\n\r\nWhen populate array and it is empty array , populate will not execute query and get undefined on virtual count field.\r\n\r\n**What is the expected behavior?**\r\n\r\nvirtual count field should be 0 rather than undefined.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nmongoose: 5.4.6\r\nmongo: 3.6\r\nnode: 8.14\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n\r\n\r\nExample Schema:\r\n```js\r\nconst Group = new Schema({\r\n   roles: [{\r\n       createdAt: Date,\r\n       roleId: {type: String, ref: \"Role\"}\r\n   }]\r\n})\r\nGroup.virtual(\"rolesCount\", {\r\n  ref: \"Role\",\r\n  localField: \"roles.roleId\",\r\n  foreignField: \"_id\",\r\n  count: true\r\n})\r\n\r\nconst Role = new Schema({\r\n   _id: String\r\n})\r\n```\r\n\r\nExample document:\r\n```js\r\n{\r\n     _id: \"foobar\",\r\n     roles: []\r\n}\r\n```\r\n\r\nExample Query:\r\n```js\r\nGroup.findOne({_id: \"foobar\"}).populate([\r\n      {\r\n        path: \"rolesCount\"\r\n      }\r\n    ])\r\n    .orFail()\r\n```\r\n\r\nReturn of gorup.rolesCount will become `null` rather than `0` here."},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nUpdating a subdocument which subschema have the timestamps option set gives different results depending on how the query and the model is set up.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```js\r\nconst mongoose = require('mongoose');\r\n\r\n(async () => {\r\n  const dbUri = 'mongodb://localhost:27017/test';\r\n  const db = await mongoose.connect(dbUri, { useNewUrlParser: true });\r\n  const ChildSchema = new mongoose.Schema({ name: String }, { timestamps: true });\r\n\r\n  // model with child subdocument from child schema\r\n  const ChildObjectSchema = new mongoose.Schema({ docNr: Number, child: ChildSchema }, { timestamps: true });\r\n  const ChildObjectModel = db.model('ChildObject', ChildObjectSchema);\r\n\r\n  // model with child subdocument and children array subdocuments from child schema\r\n  const ChildObjectAndArraySchema = new mongoose.Schema({ docNr: Number, child: ChildSchema, children: [ChildSchema] }, { timestamps: true });\r\n  const ChildObjectAndArrayModel = db.model('childObjectAndArray', ChildObjectAndArraySchema);\r\n\r\n  await Promise.all([\r\n    ChildObjectModel.deleteMany({}),\r\n    ChildObjectAndArrayModel.deleteMany({}),\r\n  ]);\r\n\r\n  const [doc1, doc2, doc3, doc4] = await Promise.all([\r\n    ChildObjectModel.create({ docNr: 1, child: { name: 'foo' } }),\r\n    ChildObjectAndArrayModel.create({ docNr: 2, child: { name: 'foo' } }),\r\n    ChildObjectAndArrayModel.create({ docNr: 3, child: { name: 'foo' }, children: [{ name: 'foo' }] }),\r\n    ChildObjectAndArrayModel.create({ docNr: 4, child: { name: 'foo' }, children: [{ name: 'foo' }] }),\r\n  ]);\r\n\r\n  await new Promise((resolve) => setTimeout(resolve, 2000));\r\n\r\n  await Promise.all([\r\n    // does not update updatedAt for child subdocument\r\n    ChildObjectModel.findOneAndUpdate({ 'child._id': doc1.child._id }, { $set: { 'child.name': 'bar' } }),\r\n\r\n    // does not update updatedAt for child subdocument\r\n    ChildObjectAndArrayModel.findOneAndUpdate({ 'child._id': doc2.child._id }, { $set: { 'child.name': 'bar' } }),\r\n\r\n    // does not update updatedAt for child subdocument and children subdocuments\r\n    ChildObjectAndArrayModel.findOneAndUpdate({ 'children._id': doc3.children[0]._id }, { $set: { 'child.name': 'bar' }, 'children.$.name': 'bar' }),\r\n\r\n    // does not update updatedAt for child subdocument and removes timestamps in children subdocuments\r\n    ChildObjectAndArrayModel.findOneAndUpdate({ 'children._id': doc4.children[0]._id }, { $set: { 'child.name': 'bar' }, 'children.$': { name: 'bar' } }),\r\n  ]);\r\n\r\n  process.exit(0);\r\n})();\r\n```\r\n\r\n**What is the expected behavior?**\r\nUpdating a subdocument should only update the updatedAt property when the timestamps option is set in subschema.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nNode: v10.15.3\r\nMongoDB: v4.0.8\r\nMongoose\": v5.5.1\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nWe are currently using 5.4.19 because we were affected by this bug https://github.com/Automattic/mongoose/issues/7681 and https://github.com/Automattic/mongoose/issues/7660 so I'm not sure if it got introduced in 5.5.1 or in between the two versions but since upgrading to 5.5.1 we're seeing several test failures regarding casting errors inside embedded docs\r\n\r\n```\r\nUser validation failed: purchased.plan.consecutive.offset: Cast to Number failed for value \"NaN\" at path \"consecutive.offset\", purchased.plan.consecutive.gemCapExtra: Cast to Number failed for value \"NaN\" at path \"consecutive.gemCapExtra\", ... (other fields here...)\r\n```\r\nIn our schema `Purchased` is a subdoc of `User`\r\n\r\nand \r\n\r\n```\r\nCastError: Cast to embedded failed for value \"{ completed: false,\\n  text: \\'Checklist Item 1\\',\\n  id: \\'274db346-3baa-46c6-bff3-ea5cff557301\\' }\" at path \"undefined\"\r\n```\r\n\r\nIn this case it's also happening inside a subdoc (although an array of docs not a single one like `purchased`)\r\n\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nI've not been able to create a repro script yet but will look into it\r\n\r\n**What is the expected behavior?**\r\nNo errors\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nNode 10, mongo 3.4, mongoose 5.5.1\r\n"},{"labels":["bug"],"text":"After deploying our service, we had a lot of errors like in the headline.\r\n\r\n`\r\nTypeError: Cannot read property 'now' of undefined\r\nat Function._setTimestampsOnUpdate (/app/node_modules/mongoose/lib/schema.js:1059:33)\r\n`\r\n\r\nFor a quick fix we set the version of mongoose back to `5.4.22`\r\n\r\nOn a local machine with a fresh `npm install`, i did not get the errors.\r\nLocal node version: v10.9.0\r\nRemote node version: v10.15.3 "},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n**What is the current behavior?**\r\nWhen setting a default value for an array whose content is discriminated, the specified items do not hold their entire state.\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n```javascript\r\nconst mongoose = require('mongoose');\r\nconst { Schema } = mongoose;\r\n\r\nconst abstractSchema = new Schema({}, { discriminatorKey: 'kind', _id: false });\r\nconst concreteSchema = new Schema({ foo: { type: Number } });\r\nconst defaultValue = [{ kind: 'concrete', foo: 42 }];\r\n\r\nconst schema = new Schema({\r\n  items: {\r\n    type: [abstractSchema],\r\n    default: defaultValue,\r\n  },\r\n});\r\n\r\nschema.path('items').discriminator('concrete', concreteSchema);\r\n\r\nconst Thing = mongoose.model('Thing', schema);\r\nconsole.log(new Thing().items[0].foo); // prints 'undefined'\r\nconsole.log(new Thing().items[0].kind); // prints 'concrete' as expected\r\nconsole.log(new Thing({ items: defaultValue }).items[0].foo); // prints '42' as expected\r\n```\r\n**What is the expected behavior?**\r\nNo fields should be stripped when using default values.\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nNode v10.15.3\r\nMongoose 5.4.22\r\nMongoDB, tested on v3.4.6 and v4.0.7\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n*bug*\r\n\r\n**What is the current behavior?**\r\nWhen populating a nested object (that is we populate an object and then populate another object within the previously populated object), its `populated()` method returns undefined\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```javascript\r\nconst assert = require('assert');\r\nconst mongoose = require('mongoose');\r\nmongoose.set('debug', true);\r\n\r\nconst GITHUB_ISSUE = `gh7685`;\r\nconst connectionString = `mongodb://localhost:27017/${GITHUB_ISSUE}`;\r\nconst {Schema} = mongoose;\r\n\r\nrun().then(() => console.log('done')).catch(error => console.error(error.stack));\r\n\r\nasync function run() {\r\n    const db = await mongoose.connect(connectionString);\r\n    await mongoose.connection.dropDatabase();\r\n\r\n    const schema = mongoose.Schema({\r\n        a: {\r\n            type: String,\r\n            default: \"TEST\"\r\n        }\r\n    });\r\n\r\n    const schema2 = mongoose.Schema({\r\n        g: {\r\n            type: mongoose.Schema.Types.ObjectId,\r\n            ref: \"Test\",\r\n            required: true\r\n        },\r\n        h: {\r\n            type: String,\r\n            default: \"TEST2\"\r\n        }\r\n    }, {\r\n        toObject: {\r\n            virtuals: true\r\n        }\r\n    });\r\n\r\n    const schema3 = mongoose.Schema({\r\n        i: {\r\n            type: mongoose.Schema.Types.ObjectId,\r\n            ref: \"Test2\",\r\n            required: true\r\n        },\r\n        j: {\r\n            type: String,\r\n            default: \"TEST3\"\r\n        }\r\n    });\r\n\r\n    schema2.virtual(\"f\").get(function () {\r\n        if (this.populated(\"g\")) {\r\n            console.log(\"populated\");\r\n        } else {\r\n            console.log(\"not populated\");\r\n            console.log(this.g.a);\r\n        }\r\n    });\r\n\r\n    const M = db.model('Test', schema);\r\n    const N = db.model('Test2', schema2);\r\n    const O = db.model('Test3', schema3);\r\n\r\n    let m = await M.create({a: \"TEST\"});\r\n    let n = await N.create({g: m._id});\r\n    let o = await O.create({i: n._id});\r\n\r\n    const doc = await O.find({_id: o._id})\r\n        .populate(\"i\")\r\n        .exec();\r\n\r\n    const finalDoc = await doc[0].populate(\"i.g\").execPopulate();\r\n\r\n    console.log(finalDoc.toObject()); //even though we can clearly see that `g` was populated, checking with `this.populated(\"g\")` returns undefined\r\n}\r\n```\r\n\r\n**What is the expected behavior?**\r\n`this.populated(\"g\")` should not return undefined\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nMongoose: 5.4.21\r\nMongoDB: 3.6\r\nNodeJS: 8+"},{"labels":["bug",null],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBug\r\n**What is the current behavior?**\r\n\r\nIf you delete a mongoose Model from mongoose.models, mongoose.connections.models and mongoose.modelSchemas, the model remains in memory and the memory usage of the process grows uncontrollably\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n\r\nRun this gist:\r\nhttps://gist.github.com/MarcoCanalcar/a978e4acd8effb7910f71c734c890fa6\r\n**What is the expected behavior?**\r\n\r\nThe memory usage of the process should be stable\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nNode.js: v11.12.0\r\nMongoose: 5.4.21\r\nMongoDB: Not relevant, we are able to reproduce the bug without even connecting to mongodb\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n\r\n\r\nNote: We got the instructions for deleting a model from #2874"},{"labels":["bug"],"text":"Hi,\r\n\r\nI find that the result is wrong after modified the single nested subdocument of existing document.\r\n\r\nBelow is my test case:\r\n```javascript\r\nvar chai = require(\"chai\");\r\nvar expect = chai.expect;\r\n\r\nconst mongoose = require('mongoose');\r\nconst Schema = mongoose.Schema;\r\nmongoose.connect('mongodb://localhost:27017/test', { useNewUrlParser: true });\r\n\r\nconst singleNestedSchema = new Schema({\r\n  name: String,\r\n  value: Number,\r\n});\r\n\r\nconst testModel = mongoose.model('test', new Schema({\r\n  title: String,\r\n  data: singleNestedSchema,\r\n}));\r\n\r\nlet sampleDocumentId;\r\n\r\ndescribe('test', () => {\r\n  before('Clear collection and add sample document', () => {\r\n    return testModel.deleteMany({})\r\n      .then(() => {\r\n        const testDocument = new testModel({\r\n          title: 'test',\r\n          data: {\r\n            name: 'first',\r\n            value: 100,\r\n          }\r\n        });\r\n\r\n        return testDocument.save();\r\n      })\r\n      .then(result => {\r\n        sampleDocumentId = result._id;\r\n      });\r\n  });\r\n  after('DB disconnect', () => {\r\n    mongoose.disconnect();\r\n  });\r\n  it('Edit single nested subdocument', () => {\r\n    return testModel.findById(sampleDocumentId)\r\n      .then(result => {\r\n        result.data = {\r\n          name: 'second',\r\n          value: 200,\r\n        };\r\n\r\n        expect(result.data.value).to.equal(200);\r\n        expect(result.data.name).to.equal('second');\r\n      });\r\n  });\r\n});\r\n```\r\n\r\nAnd the test result is:\r\n```\r\n$ mocha index.js\r\n\r\n\r\n  test\r\n    1) Edit single nested subdocument\r\n\r\n\r\n  0 passing (63ms)\r\n  1 failing\r\n\r\n  1) test\r\n       Edit single nested subdocument:\r\n\r\n      AssertionError: expected 'first' to equal 'second'\r\n      + expected - actual\r\n\r\n      -first\r\n      +second\r\n      \r\n      at testModel.findById.then.result (index.js:50:37)\r\n      at process._tickCallback (internal/process/next_tick.js:68:7)\r\n```\r\nThe results show that field **result.data.value** can pass the test, but field **result.data.name** cannot.\r\n\r\n------------------------------\r\nnodejs: 10.12.0\r\nmongoose: 5.4.21\r\nmongodb: 3.6.5\r\nchai: 4.2.0\r\nmocha: 6.0.2"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug (?)\r\n\r\n**What is the current behavior?**\r\nWhen defining a schema with an array as the type, setters will not run on updates (`like findOneAndUpdate()`). I realize this used to be the case, then runSettersOnQuery() was introduced, then subsequently removed because it became the default. So it should work?\r\n\r\nI think this goes back to the same core issue that was closed in April 2018 [issue](https://github.com/Automattic/mongoose/issues/6277)\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nThe following script will check the contents of the genres array (strings) against the enum without setting the strings to lowercase. Other setters also do not work. This behavious works fine on saving a new document, but not when updating.\r\n\r\n```\r\nconst bookSchema = new Schema({\r\n    genres: {\r\n        type: [{\r\n            type: String,\r\n            lowercase: true,\r\n            enum: [\"romantic\", \"horror\", \"fantasy\"],\r\n        }]\r\n    }\r\n});\r\n```\r\n\r\nAs a very ugly workaround, it is possible to do this manually with a pre-hook, but it defeats the purpose of having the schema:\r\n\r\n```\r\nbookSchema.pre(\"findOneAndUpdate\", function() {    \r\n    this._update.genres = this._update.genres.map(genre => genre.toLowerCase());\r\n});\r\n```\r\n\r\n**What is the expected behavior?**\r\n\r\nThe setters should also run for the array contents on update.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nNode v10.13.0\r\nMongoose version 5.4.20\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBUG\r\n**What is the current behavior?**\r\nError: Cannot read property 'then' of undefined\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<https://gist.github.com/bangbang93/925fad7317c7f09ea4edae57da2d3a3e>\r\n\r\n`mongoose-callback.js` works fine, but `mongoose-promise.js` throws an error. According to <http://mongodb.github.io/node-mongodb-native/3.1/api/Collection.html#indexExists> there should be a promise.\r\n\r\n**What is the expected behavior?**\r\nreturn promise\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nmongoose@5.4.21\r\nnode@11.9.0\r\nmongod@4.0.3\r\n\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBug\r\n\r\n**What is the current behavior?**\r\n\r\nNot all values of an object which is set to a nested path are updated, if the nested value is defined as `Schema`.\r\n\r\n**What is the expected behavior?**\r\n\r\nAll values should be updated.\r\n\r\n**Code to reproduce**\r\n\r\n```\r\nconst { expect } = require('chai');\r\nconst { Schema, model } = require('mongoose');\r\n\r\nit('does not updated all nested values inside a nested schema', () => {\r\n  const schema = new Schema({\r\n    nested: new Schema(\r\n      {\r\n        foo: Number,\r\n        bar: Boolean,\r\n      },\r\n      {\r\n        _id: false,\r\n      }\r\n    ),\r\n  });\r\n  const Model = model('first', schema);\r\n\r\n  const entry = new Model({ nested: { foo: 666, bar: false } });\r\n\r\n  entry.set('nested', { foo: 42, bar: true });\r\n\r\n  // FAILS! foo == {foo: 666, bar: true}\r\n  expect(entry.toObject().nested).to.deep.equal({\r\n    foo: 42,\r\n    bar: true,\r\n  });\r\n});\r\n\r\nit('updates all nested values without a nested schema', () => {\r\n  const schema = new Schema({\r\n    nested: {\r\n      foo: Number,\r\n      bar: Boolean,\r\n    },\r\n  });\r\n  const Model = model('second', schema);\r\n\r\n  const entry = new Model({ nested: { foo: 123, bar: false } });\r\n\r\n  entry.set('nested', { foo: 666, bar: true });\r\n\r\n  // successes\r\n  expect(entry.toObject().nested).to.deep.equal({\r\n    foo: 666,\r\n    bar: true,\r\n  });\r\n});\r\n```\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nNode.js: 10.15.1\r\nMongoose: 5.4.20\r\nMongoDb: Not needed for that behavior"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBug\r\n\r\n**What is the current behavior?**\r\n\r\nTrying to overwrite (override) a field that contains a nested subdocument updates some nested fields but not another.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n\r\n```js\r\nmongoose = require('mongoose');\r\n\r\nMySchema = new mongoose.Schema({\r\n  innerValue1: new mongoose.Schema({\r\n    aaa: {\r\n      type: String,\r\n    },\r\n    zzz: {\r\n      type: String,\r\n    },\r\n    geometry: new mongoose.Schema({ // using a subdocument here makes geometry optional\r\n      title: {\r\n        type: String,\r\n      },\r\n      coordinates: {\r\n        type: [Number],\r\n      },\r\n    }, {\r\n      _id: false,\r\n      id: false,\r\n    }),\r\n  }, {\r\n    _id: false,\r\n    id: false,\r\n  }),\r\n});\r\n\r\nMySchemaModel = mongoose.model('MySchemaModel', MySchema);\r\n\r\ndoc = new MySchemaModel({\r\n  innerValue1: {\r\n    aaa: 'aaa1',\r\n    zzz: 'zzz1',\r\n    geometry: {\r\n      title: 'Point1',\r\n      coordinates: [1, 1]\r\n    }\r\n  },\r\n});\r\n\r\ndoc.innerValue1 = {\"zzz\":\"zzz2\",\"geometry\":{\"coordinates\":[2,2],\"title\":\"Point2\"},aaa:\"aaa2\"}\r\n```\r\n\r\n**What is the expected behavior?**\r\n\r\nThe expected value would be a document with `innerValue1` equals `{\"zzz\":\"zzz2\",\"geometry\":{\"coordinates\":[2,2],\"title\":\"Point2\"},aaa:\"aaa2\"}`.\r\nWhat I get is: \r\n```js\r\n// JSON.stringify(doc.innerValue1.toObject())\r\n'{\"zzz\":\"zzz1\",\"geometry\":{\"coordinates\":[1,1],\"title\":\"Point1\"},\"aaa\":\"aaa2\"}'\r\n```\r\n\r\nOnly one field (`aaa`) has changed.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\nNodeJS 10.14.1\r\nMongoose 5.4.20\r\nNo mongodb connection.\r\n\r\nI've tested the same code on mongoose 5.4.19 and it works as expected. This bug must have been introduced between 5.4.19 and 5.4.20. If this is a known side effect of other changes, it should be a major/minor version change, not a patch version change (19 to 20), because it is not backward compatible.\r\n\r\nThanks\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBug\r\n\r\n**What is the current behavior?**\r\n\r\nIf a model has an array of subdocs within an array of subdocs, then using `.set` that includes numerical array indexes to set a path does not seem to work.\r\neg. The following general code fails: \r\n```js\r\nparentDoc.set('parrentArray[rootArrayIndex].childArray[childArrayIndex]', 'whatever')\r\n```\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n\r\n```js\r\nconst assert = require('chai').assert\r\nconst mongoose = require('mongoose')\r\nconst Schema = mongoose.Schema\r\n\r\nit('Using `document.set` on deeply nested path does not work', () => {\r\n   // Setup our schemas + model\r\n   // Everything here works\r\n\r\n   const citySchema = new Schema({\r\n      name: String,\r\n      population: Number\r\n   })\r\n\r\n   const stateSchema = new Schema({\r\n      name: String,\r\n      cities: [citySchema]\r\n   })\r\n\r\n   const countrySchema = new Schema({\r\n      name: String,\r\n      states: [stateSchema]\r\n   })\r\n\r\n   const Country = mongoose.model('test-country', countrySchema)\r\n\r\n   // Create new Country doc\r\n   // Everything cool here too...\r\n\r\n   let usa = new Country({\r\n      name: 'United States of America',\r\n      states: [\r\n         {\r\n            name: 'Ilinois',\r\n            cities: [\r\n               {\r\n                  name: 'Chicago',\r\n                  population: 2.5\r\n               }\r\n            ]\r\n         }\r\n      ]\r\n   })\r\n\r\n   // This works fine\r\n   usa.set('states.0.name', 'Illinois') // Fix the spelling of Illinois\r\n   assert.equal(usa.states[0].name, 'Illinois') // Works!\r\n   assert.equal(usa.get('states.0.name'), 'Illinois') // Works!\r\n\r\n   // But this does not\r\n   usa.set('states.0.cities.0.population', 2.7) // Fix the population of Chicago\r\n   assert.equal(usa.states[0].cities[0].population, 2.7) // FAILS!\r\n   assert.equal(usa.get('states.0.cities.0.population'), 2.7) // FAILS!\r\n\r\n   // But setting it directly (without using `.set`) works fine\r\n   usa.states[0].cities[0].population = 2.7\r\n   assert.equal(usa.states[0].cities[0].population, 2.7) // Works!\r\n   assert.equal(usa.get('states.0.cities.0.population'), 2.7) // Works!\r\n})\r\n\r\nit('Using `document.set` on recursive path does not work', () => {\r\n   // Setup our schemas + model\r\n   // Everything here works\r\n\r\n   const pageElementSchema = new Schema({\r\n      type: { type: String, required: true }\r\n   }, { discriminatorKey: 'type' })\r\n\r\n   const textElementSchema = new Schema({\r\n      body: { type: String }\r\n   })\r\n\r\n   const blockElementSchema = new Schema({\r\n      elements: [pageElementSchema]\r\n   })\r\n\r\n   blockElementSchema.path('elements').discriminator('block', blockElementSchema)\r\n   blockElementSchema.path('elements').discriminator('text', textElementSchema)\r\n\r\n   const pageSchema = new Schema({\r\n      elements: [pageElementSchema]\r\n   })\r\n\r\n   pageSchema.path('elements').discriminator('block', blockElementSchema)\r\n   pageSchema.path('elements').discriminator('text', textElementSchema)\r\n\r\n   const Page = mongoose.model('test-page', pageSchema)\r\n\r\n   // Create new Page doc\r\n   // Everything cool here too...\r\n\r\n   let page = new Page({\r\n      elements: [\r\n         {\r\n            type: 'text',\r\n            body: 'Page Title'\r\n         }, {\r\n            type: 'block',\r\n            elements: [\r\n               {\r\n                  type: 'text',\r\n                  body: 'Page Content'\r\n               }\r\n            ]\r\n         }\r\n      ]\r\n   })\r\n\r\n   // This works fine\r\n   page.set('elements.0.body', 'Page Heading')\r\n   assert.equal(page.elements[0].body, 'Page Heading') // Works!\r\n   assert.equal(page.get('elements.0.body'), 'Page Heading') // Works!\r\n\r\n   // But this does not\r\n   page.set('elements.1.elements.0.body', 'Page Body')\r\n   assert.equal(page.elements[1].elements[0].body, 'Page Body') // FAILS!\r\n   assert.equal(page.get('elements.1.elements.0.body'), 'Page Body') // FAILS!\r\n\r\n   // But setting it directly (without using `.set`) works fine\r\n   page.elements[1].elements[0].body = 'Page Body'\r\n   assert.equal(page.elements[1].elements[0].body, 'Page Body') // Works!\r\n   assert.equal(page.get('elements.1.elements.0.body'), 'Page Body') // Works!\r\n})\r\n```\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n\r\n<!-- You can print `mongoose.version` to get your current version of Mongoose: https://mongoosejs.com/docs/api.html#mongoose_Mongoose-version -->\r\n\r\nnode 8.14.0\r\nmongoose 5.4.20\r\nMongoDB 3.6.10"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug. May be an enhancement, but a necessary one.\r\n\r\n**What is the current behavior?**\r\nValidator functions don't have access to the session being used in a transaction.\r\n\r\nIn my case I have a reference validator that checks that the references inserted actually exist in the DB. The problems is that if I insert a document inside a transaction and then use it in a reference field, the validator tries to find it, but fails because it needs to use the session in the query.\r\n\r\nCalling `this.$session()` inside the validator function returns `null`, so I can't use that.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nStandalone script:\r\n```\r\nconst mongoose = require('mongoose');\r\n\r\nmongoose.connection.on('error', err => {\r\n  console.log(`MongoDB connection error: ${err}`);\r\n  process.exit(-1);\r\n});\r\n\r\nmongoose.connect(\r\n  YOUR_MONGO_URI_HERE,\r\n  {\r\n    keepAlive: 1,\r\n    useNewUrlParser: true,\r\n    useCreateIndex: true\r\n  }\r\n);\r\n\r\n(async () => {\r\n  const someSchema = new mongoose.Schema(\r\n    {\r\n      name: String\r\n    },\r\n    { autoCreate: true }\r\n  );\r\n  const SomeModel = mongoose.model('SomeModel', someSchema);\r\n\r\n  const someOtherSchema = new mongoose.Schema(\r\n    {\r\n      fieldWithReference: {\r\n        type: mongoose.Schema.Types.ObjectId,\r\n        ref: 'SomeModel',\r\n        validate: {\r\n          isAsync: true,\r\n          validator(value, cb) {\r\n            // Need session here\r\n            // this.$session() returns null\r\n            console.log(`this.$session() value: ${this.$session()}`);\r\n\r\n            SomeModel.findOne({ _id: value })\r\n              .session(this.$session())\r\n              .exec((err, doc) => {\r\n                if (doc) {\r\n                  console.log('Success! Reference found!');\r\n                } else {\r\n                  console.error('Failed! No reference found!');\r\n                }\r\n\r\n                cb(doc);\r\n              });\r\n          }\r\n        }\r\n      }\r\n    },\r\n    { autoCreate: true }\r\n  );\r\n  const SomeOtherModel = mongoose.model('SomeOtherModel', someOtherSchema);\r\n  let session;\r\n\r\n  try {\r\n    session = await mongoose.startSession();\r\n    session.startTransaction();\r\n    const [insertedDocument] = await SomeModel.create([{ name: 'Potato' }], { session });\r\n    await SomeOtherModel.create([{ fieldWithReference: insertedDocument }], { session }); // Validator returns false because it can't find insertedDocument\r\n    session.commitTransaction();\r\n  } catch (err) {\r\n    if (session) {\r\n      session.abortTransaction();\r\n    }\r\n\r\n    console.error(err);\r\n  }\r\n})();\r\n```\r\n\r\n**What is the expected behavior?**\r\nEither the validator function should have access to the same session that was passed down to the `.create` method (probably as a third param), or `this.$session()` should return that same session.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nNode.js: 10.15.1\r\nMongoose: 5.4.9\r\nMongoDB: 4.0.4\r\n\r\nI'll get started on a PR this weekend if I can.\r\n\r\n**Edit**: Updated standalone script."},{"labels":["bug"],"text":"I have a mongoose model with following field. And I am not able to populate the 'recordings'.\r\n\r\n`\r\nrecordings: [[{\r\n    cueIn: Number,\r\n    file: {\r\n      type: Schema.ObjectId,\r\n      ref: 'asset',\r\n    }\r\n  }]]\r\n`"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nI have upgraded to the latest mongoose from 4.x to 5.x and now currently if I destructure the document described below, I run into an error `obj.toObject` is not a function. \r\n\r\nI will add that I have ran this same test against another schema and was not able to reproduce this error. Would appreciate the help identifying what in the profileSchema is causing this.\r\n\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nhttps://gist.github.com/uptownhr/048749c0d85264d502dd9df467dfb1d0\r\n\r\n**What is the expected behavior?**\r\nShould destructure properly and be able to output without error and be used.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\nNode: 8.12.0\r\nMongoose: 5.4.19\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?** Bug\r\n\r\n**What is the current behavior?**\r\n\r\nThe following TypeScript example (but the same applies to pure ES6 classes) shows that mongoose ignores `Nested.prop` in the `set()` call. => So the `nested`-property update gets lost in a following `save()` call.\r\n\r\n```TS\r\nclass Nested {\r\n    constructor(readonly prop: string) { }\r\n}\r\n\r\nconst ClassInstanceAsNestedInputModel = mongoose.model<{ nested: Nested } & Document>(\r\n    'ClassInstanceAsNestedInput', new Schema({\r\n            nested: { prop: { required: true, type: String } },\r\n        },\r\n        // { strict: \"throw\" },\r\n    ));\r\n\r\nlet doc = new ClassInstanceAsNestedInputModel({ nested: { prop: \"initial\" } });\r\n\r\nconst newNested = new Nested(\"new val\");\r\nconsole.log(newNested); // prints \"Nested { prop: 'new val' }\"\r\n\r\ndoc.set({ nested: newNested });\r\n//doc.set({ nested: { ...newNested } }); // Workaround via object spread\r\n\r\n// ISSUE: prints \"{ prop: 'initial' }\" instead of \"{ prop: 'new val' }\"\r\nconsole.log(doc.nested);\r\n\r\n// With 'strict: \"throw\"', set() throws \"ObjectExpectedError: Tried to set nested\r\n// object field `nested` to primitive value `[object Object]`\"\r\n```\r\n\r\nI would classify this as bug because if someone does not use `{ strict: \"throw\" }` (which isn't the default) these \"lost updates\" aren't detected (i.e. a following `save()` stores a stale version of `nested`).\r\n\r\n**What is the expected behavior?**\r\n`doc.nested.prop` is \"new val\" after the `set()` call, i.e. `save()` (and all the other operations which \"parse\" a document input) also respect class properties.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using?** \r\nMongoose 5.4.19, 5.4.20, Node 11.12\r\n"},{"labels":["bug"],"text":"Schema\r\n```js\r\nconst schema = new mongoose.Schema({\r\n    describe: {\r\n        type: Map,\r\n        of: Map,\r\n        default: {}\r\n    }\r\n});\r\n\r\nconst GoodsInfo = mongoose.model('GoodsInfo', schema);\r\n```\r\n\r\nAt v5.3.14\r\n```js\r\n(async function(){\r\n    try {\r\n        let goodsInfo = new GoodsInfo();\r\n        goodsInfo.describe = new Map();\r\n        goodsInfo.describe.set('brand', new Map([['en', 'Hermes']]));\r\n        \r\n        await goodsInfo.save();\r\n        const id = goodsInfo.id;\r\n        console.log(id);\r\n\r\n        goodsInfo = await GoodsInfo.findById(id);\r\n        console.log(goodsInfo.describe); // => Map(1)Â {\"brand\" => Map(1)}\r\n    } catch (err) {\r\n        console.error('ERROR :', err);\r\n    }\r\n})()\r\n```\r\nAs expected\r\n![3](https://user-images.githubusercontent.com/7956480/54795758-cd9b0100-4c90-11e9-9030-c22df3ebd0e6.jpg)\r\n\r\n\r\nAt v5.3.15+\r\n```js\r\n(async function(){\r\n    try {\r\n        let goodsInfo = new GoodsInfo();\r\n        goodsInfo.describe = new Map();\r\n        goodsInfo.describe.set('brand', new Map([['en', 'Hermes']]));\r\n        \r\n        await goodsInfo.save();\r\n        const id = goodsInfo.id;\r\n        console.log(id);\r\n\r\n        goodsInfo = await GoodsInfo.findById(id);\r\n        console.log(goodsInfo.describe); // => Map(0) {}\r\n    } catch (err) {\r\n        console.error('ERROR :', err);\r\n    }\r\n})()\r\n```\r\nI get one empty Map\r\n![1](https://user-images.githubusercontent.com/7956480/54795773-d8ee2c80-4c90-11e9-84c8-44f353fc48e4.jpg)\r\n\r\n\r\nAt v5.3.15+ modify Schema\r\n```js\r\nconst schema = new mongoose.Schema({\r\n    describe: {\r\n        type: Map,\r\n        of: Object, // Map change to Object\r\n        default: {}\r\n    }\r\n});\r\n```\r\nNon-nested Map schema for correct reading\r\n![2](https://user-images.githubusercontent.com/7956480/54795784-dbe91d00-4c90-11e9-82c6-343262406e33.jpg)\r\n\r\n\r\n\r\n"},{"labels":["bug"],"text":" https://github.com/vkarpov15/mongoose-lean-virtuals/issues/20"},{"labels":["bug"],"text":"Greetings!\r\n\r\nQuick forewarning, I am breaking a cardinal rule here (run the latest version), but I did find a similar issue from July 2016, so I'm willing to bet a high five that this has not been fixed in the last few releases.\r\n```\r\ndb version v3.2.22\r\ngit version: 105acca0d443f9a47c1a5bd608fd7133840a58dd\r\nOpenSSL version: OpenSSL 1.0.2g  1 Mar 2016\r\nallocator: tcmalloc\r\nmodules: none\r\nbuild environment:\r\n    distmod: ubuntu1604\r\n    distarch: x86_64\r\n    target_arch: x86_64\r\nNodeJS version 10.14.2\r\nNPM package \"mongoose\": \"^5.4.19\"\r\n```\r\n\r\nThis issue appears to be the same as discussed in #4304.\r\n\r\nGiven the following pseudo code...\r\n```\r\nmongoose = require(\"mongoose\");\r\nSchema = mongoose.Schema;\r\n\r\nnew Schema({\r\n  something: {\r\n    someField: {\r\n      type: String,\r\n      unique: false,\r\n      index: false\r\n    }\r\n  }\r\n})\r\n```\r\n\r\nWhen the collection is created, the \"something\" field will be indexed. Between tests, the collection was dropped, then created anew.\r\n\r\nJust as the other user from #4304 stated, I would expect that setting both index/unique to false would mean that the field would be neither indexed, or unique.\r\n\r\nNot a big deal, but I figured I'd let someone know.\r\n\r\nThanks for the great work you all have done with Mongoose!"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nbug\r\n\r\n**What is the current behavior?**\r\nValue of a field in the database is an array. Mongoose schema type for that field is string. Mongoose coerces value to string. This is bad and error prone.\r\n\r\n**What is the expected behavior?**\r\nMongoose should throw an error.\r\n\r\n**What are the versions of Node.js, Mongoose and MongoDB you are using? Note that \"latest\" is not a version.**\r\n`\"mongoose\": \"^5.4.14\",`\r\n`mongo: image: mongo:4.0`\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\n\r\nReport a possible bug \r\n\r\n**What is the current behavior?**\r\n\r\nWhen using `debug` and `pre` hooks I get different firing sequence if query is a `find()` or an `aggregate()`.\r\n\r\nIn both case (either `find()` or `aggregate()`), I get the following order:\r\n1. pre-hook\r\n2. debug\r\n3. post-hook\r\n\r\nBut the properties (eg. `options`) I add the query object in `pre`-hook are not available to `debug` when query is an `aggregate()` (but are with `find()`).\r\nSo it looks like, for `aggregate()`, `debug` gets fired in parallel of `pre`.\r\n\r\n```Js\r\nmongoose.set('debug', (collectionName, method, query, queryOptions) => {\r\n    console.log(`[${new Date().toISOString()}] debug-mongoose: query (${method}):`, query);\r\n    console.log(`[${new Date().toISOString()}] debug-mongoose: queryOptions:`, queryOptions);\r\n\r\n    if (\r\n        queryOptions.hasOwnProperty('profiler')\r\n        && queryOptions.profiler.hasOwnProperty('startTime')\r\n    ) {\r\n        console.log(`[${new Date().toISOString()}] debug-mongoose: query started at ${queryOptions.profiler.startTime.toISOString()}`);\r\n    }\r\n    if (\r\n        queryOptions.hasOwnProperty('profiler')\r\n        && queryOptions.profiler.hasOwnProperty('endTime')\r\n    ) {\r\n        console.log(`[${new Date().toISOString()}] debug-mongoose: query ended at ${queryOptions.profiler.endTime.toISOString()}`);\r\n    }\r\n});\r\n\r\nconst preHook = function() {\r\n    this.options.profiler = {\r\n        'startTime': new Date(),\r\n    };\r\n    console.log(`[${new Date().toISOString()}] pre-hook: query started at ${this.options.profiler.startTime.toISOString()}`);\r\n    console.log(`[${new Date().toISOString()}] pre-hook: this.options:`, this.options);\r\n};\r\nconst postHook = function(result) {\r\n    this.options.profiler.endTime = new Date();\r\n    console.log(`[${new Date().toISOString()}] post-hook: query ended at ${this.options.profiler.endTime.toISOString()}`);\r\n    console.log(`[${new Date().toISOString()}] post-hook: this.options:`, this.options);\r\n}\r\n```\r\n\r\nFind outputs (where `debug-mongoose: queryOptions` line shows `profiler` query option set by `pre` is available in `debug` hook):\r\n```\r\n[2019-03-14T10:27:55.411Z] pre-hook: query started at 2019-03-14T10:27:55.411Z\r\n[2019-03-14T10:27:55.411Z] pre-hook: this.options: { profiler: { startTime: 2019-03-14T10:27:55.411Z } }\r\n[2019-03-14T10:27:55.414Z] debug-mongoose: query (find): { foo: 42 }\r\n[2019-03-14T10:27:55.415Z] debug-mongoose: queryOptions: { profiler: { startTime: 2019-03-14T10:27:55.411Z },\r\n  projection: {} }\r\n[2019-03-14T10:27:55.415Z] debug-mongoose: query started at 2019-03-14T10:27:55.411Z\r\n[2019-03-14T10:27:55.424Z] post-hook: query ended at 2019-03-14T10:27:55.424Z\r\n[2019-03-14T10:27:55.424Z] post-hook: this.options: { profiler:\r\n   { startTime: 2019-03-14T10:27:55.411Z,\r\n     endTime: 2019-03-14T10:27:55.424Z } }\r\n```\r\n\r\nAggregate outputs (where `debug-mongoose: queryOptions` line shows `profiler` query option set by `pre` is not available in `debug` hook):\r\n```\r\n[2019-03-14T10:27:34.742Z] pre-hook: query started at 2019-03-14T10:27:34.742Z\r\n[2019-03-14T10:27:34.742Z] pre-hook: this.options: { profiler: { startTime: 2019-03-14T10:27:34.742Z } }\r\n[2019-03-14T10:27:34.747Z] debug-mongoose: query (aggregate): [ { '$project': { a: 1, b: 1 } }, { '$limit': 1 } ]\r\n[2019-03-14T10:27:34.748Z] debug-mongoose: queryOptions: {}\r\n[2019-03-14T10:27:34.763Z] post-hook: query ended at 2019-03-14T10:27:34.763Z\r\n[2019-03-14T10:27:34.763Z] post-hook: this.options: { profiler:\r\n   { startTime: 2019-03-14T10:27:34.742Z,\r\n     endTime: 2019-03-14T10:27:34.763Z } }\r\n```\r\n\r\nHere is a full gist to reproduce:\r\nhttps://gist.github.com/C-Duv/9d547f951f0ee94e12b8c36d6bd4bf24\r\n\r\n**What is the expected behavior?**\r\n\r\nConsistent behavior between `find()` and `aggregate()`.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\n\r\n* NodeJS: v10.15.3\r\n* Mongoose: v5.4.17\r\n* MongoDB: v4.0.3"},{"labels":["bug"],"text":"I am using Luxon for dates on the application level and in some cases, when a single-nested subdocument with date values gets updated as a whole via an object, upon document save the date values get stored in MongoDB as `double` instead of `date`.\r\n\r\nThis only happens under the following conditions:\r\n- the subdocument is updated **as a whole**, not property by property\r\n- the schema definition is using a **getter** for converting the `Date` from Mongoose into a `DateTime` for the application layer.\r\n\r\nIf the getter is deactivated (which of course makes no sense for the application), the problem strangely does not occur.\r\n\r\n\r\n```javascript\r\nconst DateTimeAsDate = (value) => value.toJSDate();\r\nconst DateAsDateTime = (value) => DateTime.fromJSDate(value);\r\n\r\nconst requiredDate =\r\n{\r\n    type: Date, required: true,\r\n    set: DateTimeAsDate, get: DateAsDateTime\r\n};\r\n\r\nconst msDateTimeSubDoc = new Schema(\r\n    {\r\n        start: requiredDate,\r\n        end: requiredDate,\r\n    }\r\n);\r\n\r\nconst testSchema = new Schema(\r\n    {\r\n    dateTimes: msDateTimeSubDoc\r\n    }\r\n);\r\n```\r\n\r\nThe problem **does not occur** for subdocuments structured exactly the same but using for example Decimal.js at the application layer and Decimal128 for Mongoose:\r\n\r\n```javascript\r\nconst Dec128AsDec = (value) => new Decimal(value.toString());\r\nconst DecAsDec128 = (value) => mongodb.Decimal128.fromString(value.valueOf());\r\n\r\nconst requiredDecimal =\r\n{\r\n    type: mongoose.SchemaTypes.Decimal128, required: true,\r\n    set: DecAsDec128, get: Dec128AsDec\r\n};\r\n\r\nconst msDecSubDoc = new Schema(\r\n    {\r\n        value1: requiredDecimal,\r\n        value2: requiredDecimal\r\n    }\r\n);\r\n```\r\n\r\nHere is a complete code example to reproduce the problem:\r\n\r\n```javascript\r\nconst mongoose = require(\"mongoose\");\r\nconst { Decimal } = require(\"decimal.js\");\r\nconst { DateTime } = require(\"luxon\");\r\nconst mongodb = require(\"mongodb\");\r\n\r\nasync function dbsetup() {\r\n    mongoose.set(\"useCreateIndex\", true);\r\n    const databaseName = \"testmongoosedatetime\";\r\n    const urlToMongoDB = `mongodb://localhost:27017/${databaseName}`;\r\n    await mongoose.connect(\r\n        urlToMongoDB,\r\n        { useNewUrlParser: true }\r\n    );\r\n}\r\n\r\nconst Dec128AsDec = (value) => new Decimal(value.toString());\r\nconst DecAsDec128 = (value) => mongodb.Decimal128.fromString(value.valueOf());\r\n\r\nconst DateTimeAsDate = (value) => value.toJSDate();\r\nconst DateAsDateTime = (value) => DateTime.fromJSDate(value);\r\n\r\nconst requiredDecimal =\r\n{\r\n    type: mongoose.SchemaTypes.Decimal128, required: true,\r\n    set: DecAsDec128, get: Dec128AsDec\r\n};\r\n\r\nconst requiredDate =\r\n{\r\n    type: Date, required: true,\r\n    set: DateTimeAsDate, get: DateAsDateTime\r\n};\r\n\r\nconst SubDocumentSchemaOptions = {\r\n    _id: false,\r\n    toObject: { getters: true }\r\n};\r\n\r\n\r\nconst Schema = mongoose.Schema;\r\n\r\n\r\nconst msDecSubDoc = new Schema(\r\n    {\r\n        value1: requiredDecimal,\r\n        value2: requiredDecimal\r\n    },\r\n    SubDocumentSchemaOptions);\r\n\r\nconst msDateTimeSubDoc = new Schema(\r\n    {\r\n        start: requiredDate,\r\n        end: requiredDate,\r\n    },\r\n    SubDocumentSchemaOptions\r\n);\r\n\r\nconst testSchema = new Schema({\r\n    dateTimes: msDateTimeSubDoc,\r\n    decimals: msDecSubDoc\r\n});\r\n\r\n\r\nconst dateTimes1 = {\r\n    start: DateTime.fromISO(\"2019-03-03\"),\r\n    end: DateTime.fromISO(\"2019-04-04\")\r\n};\r\n\r\nconst dateTimes2 = {\r\n    start: DateTime.fromISO(\"2019-05-05\"),\r\n    end: DateTime.fromISO(\"2019-06-06\")\r\n};\r\n\r\nconst decimals1 = {\r\n    value1: new Decimal(11.1),\r\n    value2: new Decimal(22.2)\r\n};\r\n\r\nconst decimals2 = {\r\n    value1: new Decimal(33.3),\r\n    value2: new Decimal(44.4)\r\n};\r\n\r\nasync function main() {\r\n    await dbsetup();\r\n\r\n    const TestModel = mongoose.model(\"Test\", testSchema);\r\n\r\n    const testDocument = await TestModel.create({\r\n        dateTimes: dateTimes1,\r\n        decimals: decimals1\r\n    });\r\n\r\n    // dates are getting stored as doubles in MongoDB\r\n    testDocument.dateTimes = dateTimes2;\r\n    // updating property by property does not cause the problem\r\n\r\n    // updating the subdocument with decimals is fine\r\n    testDocument.decimals = decimals2;\r\n\r\n    await testDocument.save();\r\n}\r\n\r\n\r\nmain(process)\r\n    .then(process.exit)\r\n    .catch(error => {\r\n        console.log(error);\r\n        process.exit(1);\r\n    });\r\n```\r\n\r\n\r\n\r\n**Setup:**\r\n\r\nMongoose 5.4.19\r\nMongoDB 4.0.5\r\n\r\nDecimal.js 10.1.1\r\nLuxon 1.11.4\r\n\r\nNode 10.15.2"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBug\r\n\r\n**What is the current behavior?**\r\n\r\nUsing `document.get` and `document.set` to access/set a nested path fails when the `alias` schema option is set on a field that contains embedded doc(s).\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n\r\n```js\r\nconst assert = require('chai').assert\r\nconst mongoose = require('mongoose')\r\nconst Schema = mongoose.Schema\r\n\r\nit('Using `document.get` or `document.set` on nested path does not work with an aliased field', async () => {\r\n   // Setup our schemas + model\r\n   // Everything works okay here\r\n\r\n   const photoSchema = new Schema({\r\n      filename: String,\r\n      position: String\r\n   })\r\n\r\n   const pageSchema = new Schema({\r\n      t: { type: String, alias: 'title' },\r\n\r\n      // NOTE: Tests still fail regardless of what the type is,\r\n      // even if it's a primitive array such as [String].\r\n      p: { type: [photoSchema], alias: 'photos' },\r\n\r\n      // NOTE: Also fails on single embedded schemas, like this one:\r\n      h: { type: photoSchema, alias: 'hero' }\r\n   })\r\n\r\n   const Page = mongoose.model('test-page', pageSchema)\r\n\r\n   // Create new Page doc\r\n   // Everything cool here too...\r\n\r\n   let page = new Page({\r\n      title: 'From Sea to Sky', // Using the alias\r\n      hero: { // Using the alias\r\n         filename: 'skyHero.jpg',\r\n         position: 'top'\r\n      },\r\n      p: [ // NOT using the alias, but doesn't really matter\r\n         {\r\n            filename: 'snowbird.jpg',\r\n            position: 'center'\r\n         }\r\n      ]\r\n   })\r\n\r\n   // await page.save() // Doesn't have any effect\r\n\r\n   // Getting title works fine\r\n   assert.equal(page.title, 'From Sea to Sky')\r\n   assert.equal(page.get('title'), 'From Sea to Sky')\r\n\r\n   // These assertions all work on `photos`\r\n   assert.equal(page.photos[0].filename, 'snowbird.jpg')\r\n   assert.equal(page.get('p.0.filename'), 'snowbird.jpg')\r\n   assert.equal(Array.isArray(page.get('photos')), true)\r\n\r\n   // ...And these assertions all work on `hero`\r\n   assert.equal(page.hero.filename, 'skyHero.jpg')\r\n   assert.equal(page.get('h.filename'), 'skyHero.jpg')\r\n   assert.equal(typeof page.get('hero'), 'object')\r\n\r\n   // ...But using the getters to access the nested fields don't work!\r\n   assert.equal(page.get('photos.0.filename'), 'snowbird.jpg') // <= ASSERTION FAILS HERE\r\n   assert.equal(page.get('hero.filename'), 'skyHero.jpg') // <= ASSERTION FAILS HERE\r\n\r\n   // Setting does not work either\r\n   page.set('photos.0.filename', 'seathing.png') // <= ERROR THROWN HERE\r\n   assert.equal(page.photos[0].filename, 'seathing.png')\r\n   assert.equal(page.get('p.0.filename'), 'seathing.png')\r\n   assert.equal(page.get('photos.0.filename'), 'seathing.png')\r\n})\r\n```\r\n\r\n**What is the expected behavior?**\r\n\r\nShould be able to use document getters and setters to get/set paths, where the string path can contain the alias.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\n\r\nnode 8.14.0\r\nmongoose 5.4.17\r\nMongoDB 3.6.10"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\n\r\n1. Modifying the object in setters behaves strangely\r\n2. Fields created in set functions are not added to the object\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n\r\n```js\r\n\r\nconst mongoose = require('mongoose')\r\nconst Schema = mongoose.Schema\r\nconst db = mongoose.createConnection()\r\n\r\nconst NameSchema = new Schema({\r\n\r\n    full: {\r\n        type: String,\r\n        set: function (v, x, y) {\r\n\r\n            // One way to set values\r\n            this.set('first', 'XXX')\r\n\r\n            // Another way\r\n            this.last = 'YYY';\r\n\r\n            // Something weird\r\n            this.weird = 'ZZZ'\r\n\r\n            // Log current value\r\n            console.log('Current value', this) // { first: 'XXX', last: 'YYY' } // Logs this on each occasion\r\n\r\n            return v + ' BBB';\r\n        }\r\n    },\r\n    first: String,\r\n    last: String,\r\n    \r\n}, { _id: false, strict: false })\r\n\r\nconst User = mongoose.model('user', new Schema({\r\n\r\n    name: {\r\n        type: NameSchema,\r\n        default: {},\r\n    }\r\n\r\n}, { _id: false, strict: false }))\r\n\r\ntest('(0) User set name', done => {\r\n\r\n    const s = new User()\r\n    s.name = { full: 'AAA', other: 'ZZZ' }\r\n    console.log(s) // { name: { full: 'AAA BBB', other: 'ZZZ' } }\r\n    done()\r\n})\r\n\r\ntest('(1) User set name', done => {\r\n    const s = new User({ name: { full: 'AAA', other: 'ZZZ' } })\r\n    console.log(s) // { first: 'XXX', last: 'YYY', full: 'AAA BBB', other } }\r\n    done()\r\n})\r\n\r\ntest('(2) User set name', done => {\r\n    const s = new User()\r\n    // s.name = {}\r\n    s.name.full = 'AAA'\r\n    s.name.other = 'ZZZ';\r\n    console.log(s) // { first: 'XXX', last: 'YYY', full: 'AAA BBB' } }\r\n    done()\r\n})\r\n```\r\n\r\nResult in a table: \r\n\r\n|        | name.full | name.first | name.last | name.weird | name.other |\r\n|--------|-----------|------------|-----------|------------|------------|\r\n| Test 0 | AAA BBB   | -          | -         | -          | ZZZ        |\r\n| Test 1 | AAA BBB   | ZZZ        | YYY       | -          | ZZZ        |\r\n| Test 2 | AAA BBB   | ZZZ        | YYY       | -          | -          |\r\n\r\n\r\n**What is the expected behavior?**\r\n\r\nFirstly I expect `test (0)` to produce the same result as `test (1)` and `test (2)`. Please note that everything works very differently if you comment out `default: {}` property (and uncomment `//s.name = {}`.\r\n\r\nSecondly I'd expect that on each of the tests the property `weird` to exist. \r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\n\r\nNode: 11.10.0\r\nMongoose: 5.4.17\r\nMongoDB: 3.6.9\r\n\r\n\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nbug\r\n\r\n**What is the current behavior?**\r\nI have a schema which uses a document array with discriminators. When querying and specifying properties to return using `select()`, it will return parts of the document array even though this was not specified in the select function.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```\r\nimport * as mongoose from 'mongoose';\r\n\r\n(async function () {\r\n\r\n  await mongoose.connect('mongodb://localhost:27017/test', { useNewUrlParser: true });\r\n\r\n  const sectionSchema = new mongoose.Schema({ title: String }, { discriminatorKey: 'type' });\r\n  const imageSectionSchema = new mongoose.Schema({ href: String });\r\n  const textSectionSchema = new mongoose.Schema({ text: String });\r\n\r\n  const documentSchema = new mongoose.Schema({\r\n    title: String,\r\n    sections: [ sectionSchema ]\r\n  });\r\n\r\n  const sectionsType = documentSchema.path('sections') as mongoose.Schema.Types.DocumentArray;\r\n  sectionsType.discriminator('image', imageSectionSchema);\r\n  sectionsType.discriminator('text', textSectionSchema);\r\n\r\n  const Model = mongoose.model<any>('model', documentSchema);\r\n  await Model.create({\r\n    title: 'example',\r\n    sections: [\r\n      { type: 'image', title: 'image', href: 'http://example.com/picture.png' },\r\n      { type: 'text', title: 'text', text: 'the quick brown fox jumps over the lazy dog' }\r\n    ]\r\n  });\r\n\r\n  const doc = await Model.findOne({ title: 'example' }).select('title').exec();\r\n  console.log(doc.sections); // CoreMongooseArray [ { type: 'image' }, { type: 'text' } ]\r\n\r\n})().then(() => mongoose.disconnect());\r\n```\r\n\r\n**What is the expected behavior?**\r\n`doc` should **not** contain `sections`, as `select` specified only to return `title`:\r\n\r\n```\r\n  const doc = await Model.findOne({ title: 'example' }).select('title').exec();\r\n  console.log(doc.sections); // undefined\r\n```\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\n\"mongoose\": \"^5.4.16\""},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBug\r\n\r\n**What is the current behavior?**\r\n\r\nVirtuals do not work on nested schemas if plugin was added globally to Mongoose. They are defined on the schema but the getters/setters are not actually added to the instance prototype.\r\n\r\nIf the plugin is added separately to each of the schemas, and it's added to the nested schema before the outer schema is defined, then everything works as intended.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\nhttps://gist.github.com/steerio/e7ac7d8b33549dea1a9242b657bc2341\r\n\r\n**What is the expected behavior?**\r\n\r\nThe virtual should work on the nested schema as well.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\n\r\n* NodeJS: v11.10.0\r\n* Mongoose: v5.4.16\r\n* MongoDB: irrelevant, but v4.0.4"},{"labels":["bug"],"text":"Current behaviour is a bug.\r\nSchema is defined like this, for example:\r\n```\r\nconst somethingSchema = new Schema(\r\n  {\r\nprice: {\r\n      type: mongoose.mongo.Decimal128, // mongoose.Schema.Types.Decimal128-the same error\r\n      required: [true, 'Ovo polje je obavezno.'],\r\n}\r\n});\r\n```\r\nWhen saving the document with:\r\n`const data = {\"price\": 222.464567} `\r\nthis works.\r\nBut when updating with:\r\n```\r\nconst data = {\"price\": 333.464567} \r\nSomething.findOneAndUpdate({ _id: somethingID }, data, { runValidators: true, new: true });\r\n```\r\nthe mongoose throws validation errors like this:\r\n```\r\n{\r\n  \"error\": {\r\n    \"status\": 422,\r\n    \"type\": \"ValidationError\",\r\n    \"message\": \"Validation failed: price._bsontype: Ovo polje je obavezno., price.bytes: Ovo polje je obavezno.\",\r\n    \"details\": [{\r\n      \"name\": \"price._bsontype\",\r\n      \"value\": \"Ovo polje je obavezno.\"\r\n    }, {\r\n      \"name\": \"price.bytes\",\r\n      \"value\": \"Ovo polje je obavezno.\"\r\n    }]\r\n  }\r\n}\r\n```\r\nExpected behavior: Updating the document with new value of Decimal128.\r\nVersions:       Nodejs v10.15.0      Mongoose ^5.4.15     MongoDB v4.0.5\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBug\r\n\r\n**What is the current behavior?**\r\n\r\nWe would like to perform multiple operations on an array of subdocs. These operations include creating new subdocs, updating them, and re-ordering them. However, it seems that a specific combination of subdoc operations causes validation logic to run incorrectly.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n\r\nIn the example below, we have setup the field `name_plural` in a subdoc schema that is `required`, and for good measure we automatically generate a value for that field in pre-validation middleware (if a value has not already been set).\r\n\r\nPlease forgive the contrived useless-ness of the script, as I tried to massively simplify it for the purpose of this issue:\r\n\r\n```js\r\nconst assert = require('chai').assert\r\nconst mongoose = require('mongoose')\r\nconst Schema = mongoose.Schema\r\n\r\n// const pluralize = require('pluralize')\r\nconst pluralize = val => `${val}s`\r\n\r\nit('Performing multiple operations on an array of subdocs causes validation issues', async () => {\r\n   // This will be an embedded schema\r\n   const assetSchema = new Schema({\r\n      name: { type: String, required: true },\r\n      name_plural: { type: String, required: isRequired }\r\n   })\r\n\r\n   // This just generates a default pluralized name, if one was not set\r\n   assetSchema.pre('validate', function (next) {\r\n      if (this.isNew && !this.name_plural) {\r\n         this.set('name_plural', pluralize(this.name))\r\n      }\r\n\r\n      console.log(`Pre-validate middleware, name=${this.name}, name_plural=${this.name_plural}`)\r\n      next()\r\n   })\r\n\r\n   // This is just for debugging\r\n   assetSchema.post('validate', function (doc) {\r\n      console.log(`Post-validate middleware, name=${doc.name}, name_plural=${doc.name_plural}`)\r\n   })\r\n\r\n   // We don't actually need this either, this is just to help\r\n   // understand the order of things\r\n   assetSchema.path('name_plural').validate(function() {\r\n      console.log(`Running Custom Validator function, name=${this.name}, name_plural=${this.name_plural}`)\r\n      return !!this.name_plural\r\n   })\r\n\r\n   // We don't actually need this either, this is just to help\r\n   // understand the order of things\r\n   function isRequired() {\r\n      console.log(`Running 'required' validation, name=${this.name}, name_plural=${this.name_plural}`)\r\n      return true\r\n   }\r\n\r\n   // Parent schema\r\n   const personSchema = new Schema({\r\n      name: String,\r\n      assets: { type: [assetSchema] }\r\n   })\r\n\r\n   // Create our model\r\n   const Person = mongoose.model('test-people', personSchema)\r\n\r\n   // Create a new person document, add some basic data\r\n   let person = new Person({ name: 'Jane Doe' })\r\n   person.assets.addToSet({ name: 'Car' })\r\n   await person.save()\r\n\r\n   // Ensure our automatic name pluralization worked\r\n   assert(person.assets[0].name_plural === 'Cars')\r\n\r\n   // Everything up until this point is okay. No issues.\r\n   // This log will help us visually separate the log statements\r\n   // before and after our setup.\r\n   console.log('==================================')\r\n\r\n   // Setup all complete, let's get started.\r\n   person = await Person.findOne({})\r\n\r\n   // Append a new asset, intention is to let name_plural be generated automatically\r\n   person.assets.push({ name: 'Home' })\r\n\r\n   // Update the first asset\r\n   const firstAsset = person.assets.id(person.assets[0].id)\r\n   firstAsset.set('name', 'Cash')\r\n   firstAsset.set('name_plural', 'Cash')\r\n\r\n   // Re-order the assets, such that the order of the 1st and 2nd assets are reversed\r\n   const newOrder = [person.assets[1].id, person.assets[0].id]\r\n   person.assets.sort((doc1, doc2) => {\r\n      const doc1Index = newOrder.indexOf(doc1.id)\r\n      const doc2Index = newOrder.indexOf(doc2.id)\r\n      return doc1Index - doc2Index\r\n   })\r\n\r\n   // Everything looks good, let's save!\r\n   console.log('\\n', 'Start .save()')\r\n   await person.save() // Fail :(\r\n})\r\n```\r\n\r\nConsole output:\r\n```\r\nPre-validate middleware, name=Car, name_plural=Cars\r\nRunning 'required' validation, name=Car, name_plural=Cars\r\nRunning Custom Validator function, name=Car, name_plural=Cars\r\nPost-validate middleware, name=Car, name_plural=Cars\r\n==================================\r\n\r\nStart .save()\r\nRunning 'required' validation, name=Cash, name_plural=Cash  <= This usually doesn't happen before pre-validate middleware, might be related\r\nPre-validate middleware, name=Home, name_plural=Homes\r\nPre-validate middleware, name=Cash, name_plural=Cash\r\nRunning 'required' validation, name=Home, name_plural=Homes\r\nRunning Custom Validator function, name=Home, name_plural=Homes\r\nRunning 'required' validation, name=Cash, name_plural=Cash    <= Called twice now\r\nRunning Custom Validator function, name=Cash, name_plural=Cash\r\nPost-validate middleware, name=Home, name_plural=Homes\r\nPost-validate middleware, name=Cash, name_plural=Cash\r\n```\r\n\r\nError thrown:\r\n```\r\ntest-people validation failed: assets.0.name_plural: Path `name_plural` is required.\r\n  ValidationError: assets.0.name_plural: Path `name_plural` is required.\r\n      at new ValidationError (node_modules/mongoose/lib/error/validation.js:30:11)\r\n      at model.Document.invalidate (node_modules/mongoose/lib/document.js:2080:32)\r\n      at p.doValidate.skipSchemaValidators (node_modules/mongoose/lib/document.js:1943:17)\r\n      at /Users/ajay/Projects/api/node_modules/mongoose/lib/schematype.js:929:9\r\n      at _combinedTickCallback (internal/process/next_tick.js:132:7)\r\n      at process._tickDomainCallback (internal/process/next_tick.js:219:9)\r\n```\r\n\r\nIf you comment out either of the updating or re-ordering of the subdocs, then the validation logic happens correctly, no error is thrown, and the doc is saved successfully. My guess is that the combination of these operations is throwing the change tracking out of whack.\r\n\r\n**What is the expected behavior?**\r\n\r\nThat, regardless of the operations being applied to subdocs, `pre` validation middleware precedes any other validation logic (such as `requires` or custom validators), and that reordering of subdoc array elements doesn't lose track of what has changed in such cases.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\n\r\nnode.js: 8.14.0\r\nmongoose: 5.4.14\r\nMongoDB: 3.6.10\r\n\r\nThanks for all the great work on this library."},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug I believe.\r\n**What is the current behavior?**\r\nI have a base model that I want to store in multiple collections. And that base model has several discriminated models. But the discriminated model uses the collection of the FIRST model registered (since collection name isn't part of the cache key).\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```JavaScript\r\n  const options = { discriminatorKey: \"kind\" };\r\n\r\n  // the base event...\r\n  const eventSchema = new mongoose.Schema({ time: Date }, options);\r\n  const eventModelUser1 = mongoose.model(\"Event\", eventSchema, \"user1_events\");\r\n  const eventModelUser2 = mongoose.model(\"Event\", eventSchema, \"user2_events\");\r\n\r\n  // outputs user1_events\r\n  console.log(eventModelUser1.collection.name);\r\n\r\n  // outputs user2_events\r\n  console.log(eventModelUser2.collection.name);\r\n\r\n  // Our ClickEvent for user1\r\n  const clickEventUser1 = eventModelUser1.discriminator(\r\n    \"ClickEvent\",\r\n    new mongoose.Schema({ url: String }, options),\r\n  );\r\n\r\n  // even though they are different model instances, the cached model\r\n  // internally is the same because collection isn't part of the key. So\r\n  // if we call model.discriminate again, it will throw.\r\n  const clickEventUser2 = eventModelUser2.discriminators[\"ClickEvent\"];\r\n\r\n  // outputs user1_events as expected\r\n  console.log(clickEventUser1.collection.name);\r\n\r\n  // outputs user1_events and not user2_events\r\n  console.log(clickEventUser2.collection.name);\r\n```\r\n**What is the expected behavior?**\r\nI would expect `clickEventUser2.collection.name` to be `user2_events` not the first model that was cached internally.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNodeJS: 10.15.1\r\nMongoose: 5.4.13\r\nMongoDB: 3.6 and 4.0"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nWe have a mongo database where some documents contain a field that does not match the Model Schema exactly because these documents were not created through mongoose. When we try to populate paths nested within this field, we get the error:\r\n\r\n```js\r\nevents.js:167\r\n      throw er; // Unhandled 'error' event\r\n      ^\r\n\r\nTypeError: Cannot create property 'nested' on boolean 'false'\r\n    at assignVals (/Users/mac/Documents/code/playground/mongoose-tests/node_modules/mongoose/lib/model.js:4035:23)\r\n    at _assign (/Users/mac/Documents/code/playground/mongoose-tests/node_modules/mongoose/lib/model.js:3947:5)\r\n    at next (/Users/mac/Documents/code/playground/mongoose-tests/node_modules/mongoose/lib/model.js:3858:5)\r\n    at /Users/mac/Documents/code/playground/mongoose-tests/node_modules/mongoose/lib/model.js:4698:16\r\n    at /Users/mac/Documents/code/playground/mongoose-tests/node_modules/mongoose/lib/utils.js:258:16\r\n    at _hooks.execPost (/Users/mac/Documents/code/playground/mongoose-tests/node_modules/mongoose/lib/query.js:4074:11)\r\n    at /Users/mac/Documents/code/playground/mongoose-tests/node_modules/kareem/index.js:135:16\r\n    at process._tickCallback (internal/process/next_tick.js:61:11)\r\nEmitted 'error' event at:\r\n    at /Users/mac/Documents/code/playground/mongoose-tests/node_modules/mongoose/lib/model.js:4700:13\r\n    at /Users/mac/Documents/code/playground/mongoose-tests/node_modules/mongoose/lib/utils.js:258:16\r\n    [... lines matching original stack trace ...]\r\n    at process._tickCallback (internal/process/next_tick.js:61:11)\r\n```\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\n```js\r\nconst mongoose = require('mongoose')\r\nmongoose.connect('mongodb://localhost:27017/mongoose-test', { useNewUrlParser: true })\r\n  .then(async () => {\r\n    const Schema = mongoose.Schema\r\n\r\n    // Create Person Model\r\n    const personSchema = new Schema({ _id: Number, name: String })\r\n    const PersonModel = mongoose.model('People', personSchema, 'people')\r\n\r\n    // Create Event Model\r\n    const teamSchema = new Schema({\r\n      nested: { members: [{ type: Number, ref: 'People' }] }, // Nested Members\r\n      membersAtRoot: [{ type: Number, ref: 'People' }] // Members At Root\r\n    })\r\n    const eventSchema = new Schema({\r\n      _id: Number,\r\n      title: String,\r\n      teams: [teamSchema]\r\n    })\r\n    const EventModel = mongoose.model('Events', eventSchema, 'events')\r\n\r\n    // Mock Data\r\n    const person = { _id: 1, name: 'John Doe' }\r\n    const event1 = {\r\n      _id: 2,\r\n      title: 'Event 1',\r\n      teams: false // Some documents contain the Boolean false instead of an array of teamSchema\r\n    }\r\n    const event2 = {\r\n      _id: 3,\r\n      title: 'Event 2',\r\n      teams: [\r\n        {\r\n          nested: { members: [1] }, // Nested Members\r\n          membersAtRoot: [1] // Members at Root\r\n        }\r\n      ]\r\n    }\r\n\r\n    // Empty database\r\n    await Promise.all([PersonModel.deleteMany({}), EventModel.deleteMany({})])\r\n\r\n    // Insert items\r\n    await Promise.all([\r\n      PersonModel.create(person),\r\n      // Using collection.insertMany to insert data without validating to emulate our scenario\r\n      mongoose.connection.collection('events').insertMany([event1, event2], () => Promise.resolve())\r\n    ])\r\n\r\n    // Populate Members At Root (Works correctly even when a record contains: \"teams: false\")\r\n    await EventModel.find({})\r\n      .populate('teams.membersAtRoot')\r\n      .lean()\r\n      .then(results => console.log(JSON.stringify(results, null, 2)))\r\n\r\n    /*\r\n    [\r\n      {\r\n        \"_id\": 2,\r\n        \"title\": \"Event 1\",\r\n        \"teams\": false\r\n      },\r\n      {\r\n        \"_id\": 3,\r\n        \"title\": \"Event 2\",\r\n        \"teams\": [\r\n          {\r\n            \"nested\": {\r\n              \"members\": [\r\n                1\r\n              ]\r\n            },\r\n            \"membersAtRoot\": [\r\n              {\r\n                \"_id\": 1,\r\n                \"name\": \"John Doe\",\r\n                \"__v\": 0\r\n              }\r\n            ]\r\n          }\r\n        ]\r\n      }\r\n    ]\r\n    */\r\n\r\n    // Populate Nested Members (errors out)\r\n    await EventModel.find({})\r\n      .populate('teams.nested.members')\r\n      .lean()\r\n      .then(results => console.log(JSON.stringify(results, null, 2)))\r\n\r\n    /**\r\n      events.js:167\r\n            throw er; // Unhandled 'error' event\r\n            ^\r\n\r\n      TypeError: Cannot create property 'nested' on boolean 'false'\r\n          at assignVals (/Users/mac/Documents/code/playground/mongoose-tests/node_modules/mongoose/lib/model.js:4035:23)\r\n          at _assign (/Users/mac/Documents/code/playground/mongoose-tests/node_modules/mongoose/lib/model.js:3947:5)\r\n          at next (/Users/mac/Documents/code/playground/mongoose-tests/node_modules/mongoose/lib/model.js:3858:5)\r\n          at /Users/mac/Documents/code/playground/mongoose-tests/node_modules/mongoose/lib/model.js:4698:16\r\n          at /Users/mac/Documents/code/playground/mongoose-tests/node_modules/mongoose/lib/utils.js:258:16\r\n          at _hooks.execPost (/Users/mac/Documents/code/playground/mongoose-tests/node_modules/mongoose/lib/query.js:4074:11)\r\n          at /Users/mac/Documents/code/playground/mongoose-tests/node_modules/kareem/index.js:135:16\r\n          at process._tickCallback (internal/process/next_tick.js:61:11)\r\n      Emitted 'error' event at:\r\n          at /Users/mac/Documents/code/playground/mongoose-tests/node_modules/mongoose/lib/model.js:4700:13\r\n          at /Users/mac/Documents/code/playground/mongoose-tests/node_modules/mongoose/lib/utils.js:258:16\r\n          [... lines matching original stack trace ...]\r\n          at process._tickCallback (internal/process/next_tick.js:61:11)\r\n    */\r\n  })\r\n\r\n```\r\n\r\n**What is the expected behavior?**\r\nExpected it to not error out when populating the nested members and return results similar to populating members at the root\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nnode v10.14.1\r\nmongoose 5.4.14\r\nmongo v3.6.4"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\n report a bug\r\n\r\n**What is the current behavior?**\r\nIssue with arrayFilters on update since 5.4.4\r\nI have downgraded to 5.4.3 and this functionality works\r\n\r\nI'm getting the following \r\n\r\n```\r\nTypeError: Cannot read property 'castForQueryWrapper' of undefined\r\n    at castFilterPath (lib\\helpers\\query\\castFilterPath.js:45:31)\r\n    at castArrayFilters (lib\\helpers\\update\\castArrayFilters.js:57:26)\r\n    at _castArrayFilters (lib\\query.js:1738:5)\r\n    at model.Query._updateThunk (lib\\query.js:3403:3)\r\n    at model.Query.<anonymous> (lib\\query.js:3484:23)\r\n    at model.Query._wrappedThunk [as _execUpdate] (lib\\helpers\\query\\wrapThunk.js:16:8)\r\n    at process.nextTick (kareem\\index.js:369:33)\r\n    at process._tickCallback (internal/process/next_tick.js:61:11)\r\n```\r\n\r\nI think it got something to do with this commit:\r\nhttps://github.com/Automattic/mongoose/commit/c53a52a50cabc87b1a292cf96f218458f58027d1#diff-9cc02494c1b881b48d722bf517323774\r\n\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nI have the following structure:\r\n\r\n```\r\n\t\"_id\": \"5c66b062f2b8a936b124218f\",\r\n\t\"doctorsAppointment\": {\r\n\t\t\"queries\": [{\r\n\t\t\t\t\"isValid\": true,\r\n\t\t\t\t\"isDeleted\": false,\r\n\t\t\t\t\"isNewUpdates\": false,\r\n\t\t\t\t\"key\": \"vyJu4NVf\",\r\n\t\t\t\t\"hmo\": \"Filler\",\r\n\t\t\t\t\"speciality\": \"Filler\",\r\n\t\t\t\t\"cities\": [\"Filler\"],\r\n\t\t\t\t\"currentAppointmentDate\": \"2019-03-27T00:00:00.000Z\",\r\n\t\t\t\t\"suggestedAppointment\": [{\r\n\t\t\t\t\t\t\"date\": \"2019-03-06T09:00:00.000Z\",\r\n\t\t\t\t\t\t\"doctorsName\": \"Filler\",\r\n\t\t\t\t\t\t\"city\": \"Filler\",\r\n\t\t\t\t\t\t\"isDeleted\": false,\r\n\t\t\t\t\t\t\"key\": \"9qSAb\"\r\n\t\t\t\t\t}\r\n\t\t\t\t]\r\n\t\t\t}\r\n\t\t],\r\n```\r\nAnd I'm doing the following\r\n\r\n```\r\n  const query = {\r\n    _id: req.payload._id\r\n  };\r\n\r\n  const updateQuery = {\r\n    $set: {\r\n      \"doctorsAppointment.queries.$[].suggestedAppointment.$[update].isDeleted\": true\r\n    }\r\n  };\r\n\r\n  const options = { arrayFilters: [{ \"update.key\": { $eq: req.body.key } }] };\r\n\r\n  User.update(query, updateQuery, options, err => {\r\n    if (err) {\r\n      res.status(404).end();\r\n    } else {\r\n      res.status(200).end();\r\n    }\r\n  });\r\n```\r\n\r\n**What is the expected behavior?**\r\n\r\nNot to throw an error\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\n\r\nMongoDB 4.0.6 Community\r\n\"mongoose\": \"^5.4.14\"\r\nnode.js v10.15.1"},{"labels":["bug"],"text":"**Environment**\r\nnodejs 10.8.0\r\nmongoose 5.4.13\r\nmongoDB 4.0.4\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nI can set any value for the \"item\" field.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```js\r\nconst rootSchema = new Schema({\r\n  ...\r\n}, { minimize: false, timestamps: true, strict: 'throw', useNestedStrict: true })\r\n\r\nconst childSchema = new Schema({\r\n  item: {\r\n    type: String,\r\n    enum: ['foo', 'bar'],\r\n    default: 'foo'\r\n  }\r\n})\r\n\r\nconst query = { id: 1 }\r\nconst update = {\r\n  $set: {\r\n    'parents.$[parent].children.$[child].item': 'anyValue'\r\n  }\r\n}\r\n\r\nconst options = {\r\n  new: true,\r\n  runValidators: true,\r\n  arrayFilters: [\r\n    { 'parent.id': 'parent_id' },\r\n    { 'child.id': 'child_id' }\r\n  ]\r\n}\r\n\r\nModel.findOneAndUpdate(query, update, options)\r\n```\r\n\r\n**What is the expected behavior?**\r\nI can set only \"foo/bar\" values because I use the \"enum\" validator. If I try to set something else then I will get an exception."},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nI have the following array of bulk ops (simplified):\r\n\r\n```\r\nconst bulkOps = [\r\n   {\r\n      \"updateOne\": {\r\n         \"filter\": {\r\n            \"foo\": \"bar\",\r\n         },\r\n         \"update\": {\r\n            \"$setOnInsert\": {\r\n               \"anObject\": {\r\n                  \"object value\": \"object value\",\r\n               },\r\n            },\r\n            \"$addToSet\": {\r\n               \"anArray\": {\r\n                  \"$each\": [\r\n                     {\r\n                        \"foo\": \"bar\",\r\n                     }\r\n                  ]\r\n               }\r\n            }\r\n         },\r\n         \"upsert\": true\r\n      }\r\n   }\r\n]\r\n```\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nDoing a `Model.bulkWrite(bulkOps, { ordered: false })` produces the following error\r\n\r\nTried to set nested object field `anObject` to primitive value `[object Object]` and strict mode is set to throw.\r\n\r\n**What is the expected behavior?**\r\nThat the bulk operation is executed.\r\n\r\n**This did not happen with mongoose 5.4.10.** \r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug.\r\n\r\n**What is the current behaviour?**\r\nSetting getter for createdAt timestamp leads to wrong updatedAt value on document creation.\r\n\r\n**If the current behaviour is a bug, please provide the steps to reproduce.**\r\nI want to use such code to get timestamps in unix format:\r\n```\r\nconst modelSchema = new Schema({\r\n  ...\r\n  createdAt: {\r\n    type: Date,\r\n    get: (date) => date && moment(date).unix(),\r\n  }\r\n  updatedAt: {\r\n    type: Date,\r\n    get: (date) => date && moment(date).unix(),\r\n  },\r\n}, {\r\n  timestamps: true,\r\n  toJSON: { getters: true, virtuals: true },\r\n});\r\n```\r\nBut it seems like mongoose uses createdAt getter for setting updatedAt when creating document. So, I get wrong updatedAt timestamp value: \r\n```\r\nMongoose: chats.insertOne({ _id: ObjectId(\"5c5c33fcb20d305e2e9c4d12\"), deleted: \r\nfalse, createdAt: new Date(\"Thu, 07 Feb 2019 13:34:52 GMT\"),\r\nupdatedAt: new Date(\"Sun, 18 Jan 1970 22:25:46 GMT\"), __v: 0 })\r\n```\r\n**What is the expected behaviour?**\r\nRemoving getter for createdAt leads to correct updatedAt timestamp (on insertion). But I expected correct updatedAt setter regardless what getters I use.\r\nActually, it becomes correct when updating a document after it was inserted.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nnode.js v. 8.10, mongoose v. 5.2.14, mongo v. 3.6.6"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n*bug*\r\n\r\n**What is the current behavior?**\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\nHard to describe this properly, but modifying a nested document doesn't seem to mark as modified the field that's the nested schema on the parent...  So validating skips it :'(.\r\n\r\nYeah, that was a mouthful.  A test in browser.test.js would illustrate it better ;)\r\n\r\n``` javascript\r\n    it('validates parent when child schema modified (gh-7493)', function(done) {\r\n      const childSchema = new Schema({\r\n        from: {\r\n          type: Number,\r\n          min: 0,\r\n          max: 100\r\n        },\r\n        to: {\r\n          type: Number,\r\n          min: 0,\r\n          max: 100\r\n        }\r\n      });\r\n      const parentSchema = new Schema({\r\n        payrate: {\r\n          type: childSchema,\r\n          default: {},\r\n          validate: [\r\n            {\r\n              isAsync: false,\r\n              validator: (payrate) => {\r\n                return !payrate.from || !payrate.to || payrate.from<payrate.to;\r\n              }\r\n            }\r\n          ]\r\n        }\r\n      });\r\n\r\n      const parentDoc = new Document({}, parentSchema);\r\n\r\n      parentDoc.payrate.from = 20;\r\n      parentDoc.payrate.to = 10;\r\n      console.log('before - fails to validate');\r\n      assert.ok(parentDoc.validateSync());\r\n\r\n      parentDoc.markModified('payrate');\r\n      console.log('after - works');\r\n      assert.ok(parentDoc.validateSync());\r\n\r\n      done();\r\n    });\r\n```\r\n\r\nThe test above fails, but if you comment out the first assert.ok() it passes.\r\n\r\n**What is the expected behavior?**\r\n\r\nNo need to manually mark modified.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\n\r\nnode 10, and mongo nothing ;) browser-side.\r\n\r\nTested this on master and it still fails.\r\n\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n*bug*\r\n\r\n**What is the current behavior?**\r\nActually identified more than one while using virtuals.\r\n1. Having a property defined in the schema like:\r\n```\r\na: {\r\n            b: {\r\n                type: Boolean,\r\n                default: false\r\n            },\r\n            c: Date,\r\n            d: {},\r\n            e: {\r\n                type: String,\r\n                enum: [\"a\", \"b\"]\r\n            }\r\n        },\r\n```\r\nor like\r\n```\r\na: {\r\n     type: {\r\n            b: {\r\n                type: Boolean,\r\n                default: false\r\n            },\r\n            c: Date,\r\n            d: {},\r\n            e: {\r\n                type: String,\r\n                enum: [\"a\", \"b\"]\r\n            }\r\n       }\r\n   },\r\n```\r\nDeclaring a nested virtual like so:\r\n```\r\nuserDataSchema.path(\"a\").schema.virtual(\"f\").get(function () {\r\n    return ...;\r\n});\r\n```\r\nthrows an: `TypeError: Cannot read property 'schema' of undefined` on startup of the project.\r\n\r\nHaving the property as an array like below doesn't throw the error:\r\n```\r\na: {\r\n     type: [{\r\n            b: {\r\n                type: Boolean,\r\n                default: false\r\n            },\r\n            c: Date, //not less than 24 hours from the current server time\r\n            d: {},\r\n            e: {\r\n                type: String,\r\n                enum: [\"a\", \"b\"]\r\n            }\r\n       }\r\n   }],\r\n```\r\nI put the full nested document just in case there is a problem with a certain field.\r\n\r\n2. Having a nested property declared like (and we can take the property `a` declaration as in the above first case):\r\n\r\n```\r\nuserDataSchema.virtual(\"a.f\").get(function () {\r\n     return true; //or whatever, it doesn't matter what the return value is but there must be a return value\r\n});\r\n```\r\nif we try to do a `find()` without including property `a` in the projection part, like\r\n`User.find({_id:id}, {_id: 1})`, \r\nwe get thrown an error:\r\n`TypeError: Cannot set property 'f' of undefined`\r\n\r\nmongoose: 5.4.5\r\nMongoDB: 3.4\r\nNode.js: 8.12.0"},{"labels":["bug"],"text":"Even though `strict` is set to `throw` for all schemas, it does not throw for inner `_id` properties. The following code fails on 5.4.9:\r\n\r\n```js\r\n#!/usr/bin/env node\r\n(async function () {\r\n  const mongoose = require('mongoose');\r\n\r\n  mongoose.plugin((schema) => {\r\n    schema.options.versionKey = false;\r\n    schema.options.minimize = false;\r\n    schema.options.strict = 'throw';\r\n    schema.options.strictQuery = 'throw';\r\n  });\r\n\r\n  mongoose.connect('mongodb://localhost:27017/test', {useNewUrlParser: true});\r\n\r\n  const schema = new mongoose.Schema({\r\n    inner: {\r\n      type: new mongoose.Schema({\r\n        _id: false, // _id is disabled here\r\n        something: {\r\n          type: Boolean,\r\n          required: true\r\n        }\r\n      }),\r\n      require: true\r\n    }\r\n  });\r\n  const Model = mongoose.model('test', schema);\r\n\r\n  const instance = new Model({\r\n    inner: {\r\n      _id: mongoose.Types.ObjectId(), // property not allowed but it will validate\r\n      something: true\r\n    }\r\n  });\r\n  await instance.save(); // should fail but does not\r\n\r\n  console.log('This message should not appear (but it will)');\r\n})();\r\n```"},{"labels":["bug"],"text":"The following code fails in 5.4.9:\r\n\r\n```js\r\n#!/usr/bin/env node\r\n(async function () {\r\n  const mongoose = require('mongoose');\r\n  mongoose.Schema.Types.Array.options.castNonArrays = false;\r\n  mongoose.Schema.Types.DocumentArray.options.castNonArrays = false;\r\n  mongoose.connect('mongodb://localhost:27017/test', {useNewUrlParser: true});\r\n\r\n  const schema = new mongoose.Schema({\r\n    parents: {\r\n      type: [mongoose.Schema.Types.ObjectId],\r\n      default: [],\r\n      required: true\r\n    },\r\n  });\r\n  const Model = mongoose.model('test', schema);\r\n\r\n  await Model.updateMany(\r\n    {_id: '507f1f77bcf86cd799439011'},\r\n    {$addToSet: {parents: mongoose.Types.ObjectId('507f1f77bcf86cd799439012')}}\r\n  );\r\n\r\n  console.log('This message will not appear');\r\n})();\r\n```\r\n\r\n```\r\nUnhandledPromiseRejectionWarning: CastError: Cast to Array failed for value \"507f1f77bcf86cd799439012\" at path \"parents\"\r\n```\r\n\r\nIt's possible to workaround the issue by using `$addToSet: {$each: [singleValueHere]}`.\r\n\r\nThe issue can also be reproduced by using `$push` to add a single document - it will throw a `Cast to DocumentArray failed` error."},{"labels":["bug"],"text":"**Bug**\r\n\r\n**What is the current behavior?**\r\n\r\nIf a subdocument array is assigned to itself, the update history before that point appears to be lost.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n\r\n* Perform operations on subdocument array\r\n* Assign the sub-array to itself\r\n* Perform another subdocument operation\r\n* Only last operation is applied on .save()\r\n\r\n```js\r\nconst mongoose = require('mongoose');\r\nmongoose.connect('mongodb://localhost/testing-db', {useNewUrlParser: true});\r\n\r\nconst Dog = mongoose.model('Dog', new mongoose.Schema({\r\n  name: String,\r\n  toys: [{\r\n    name: String\r\n  }]\r\n}));\r\n\r\n\r\nasync function main() {\r\n\r\n  const dog = new Dog({ name: 'Dash' });\r\n\r\n  dog.toys.push({ name: '1' });\r\n  dog.toys.push({ name: '2' });\r\n  dog.toys.push({ name: '3' });\r\n\r\n  console.log('added toys', dog.toys.map(({name}) => name));\r\n  // Emits  [ '1', '2', '3' ] on all versions\r\n\r\n  await dog.save();\r\n\r\n  // Removes element with name '1'\r\n  dog.toys = dog.toys.filter((toy) => {\r\n    return toy.name !== '1';\r\n  });\r\n\r\n  console.log('removed one toy', dog.toys.map(({name}) => name));\r\n  // Emits ['2', '3'] on all versions\r\n\r\n  ['4', '5', '6'].forEach((toyName) => {\r\n    let giveToy = !dog.toys.some((toy) => {\r\n      return toy.name === toyName;\r\n    });\r\n    if (giveToy) {\r\n      // Commenting out this assignment line fixes everything\r\n      dog.toys = dog.toys || [];\r\n      dog.toys.push({\r\n        name: toyName,\r\n        count: 1\r\n      });\r\n    }\r\n  });\r\n\r\n  console.log('memory', dog.toys.map(({name}) => name));\r\n  // Emits ['2', '3', '4', '5', '6' ] on all versions\r\n\r\n  await dog.save();\r\n\r\n  let foundDog = await Dog.findOne({_id: dog._id });\r\n  console.log('db version', foundDog.toys.map(({name}) => name));\r\n  // Emits [ '1', '2', '3', '6' ] on >=4.6\r\n  // Emits ['2', '3', '4', '5', '6' ] on <=4.5\r\n\r\n  mongoose.connection.close();\r\n}\r\n\r\nmain().catch((e) => {\r\n  console.log(e);\r\n});\r\n```\r\n\r\n**What is the expected behavior?**\r\n\r\nThere is one line in this example that breaks everything, specifically this line in our loop: \r\n```dog.toys = dog.toys || [];```\r\nIt looks innocent enough, but somehow the mongoose getter/setter logic here sees this as a reason to reset the modification history on that array.\r\n\r\nThis means as far as mongoose is concerned, no operations took place before that assignment happens, which means it does not attempt to make those modifications to the array in the db, and instead writes the only op it knows about, the last push which happens to be '6'. \r\n\r\nIt seems to me that assigning an object to itself should not delete it's update history, while that specific assignment statement isn't actually necessary here, it may catch some users by surprise. We found this when upgrading to 5.x and in our usage the subdocument array was added to the schema some time after the original model, so the developer had wanted to make sure the array existed before pushing elements to it. Since subdocument arrays should be initialized these days we don't need to do that, but it broke some things for a while and took a while to track down. Not sure if there's a clean way to detect this sort of assignment or not. Would it make sense to warn about this in some way?\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nnode 8, mongoose 5.4.8, mongo 3.0"},{"labels":["bug"],"text":"This is a followup of https://github.com/Automattic/mongoose/issues/7435. That repro script now works correctly, but this one still fails in 5.4.7:\r\n\r\n```js\r\n#!/usr/bin/env node\r\n(async function () {\r\n  const mongoose = require('mongoose');\r\n  mongoose.set('applyPluginsToDiscriminators', true);\r\n  mongoose.connect('mongodb://localhost:27017/test', {useNewUrlParser: true});\r\n\r\n  mongoose.plugin((schema) => {\r\n    schema.options.versionKey = false;\r\n    schema.options.minimize = false;\r\n  });\r\n\r\n  const schema = new mongoose.Schema({\r\n    type: {type: String},\r\n    something: {type: String}\r\n  }, {\r\n    discriminatorKey: 'type'\r\n  });\r\n  const Model = mongoose.model('Test', schema);\r\n\r\n  const subSchema = new mongoose.Schema({\r\n    somethingElse: {type: String}\r\n  });\r\n  const SubModel = Model.discriminator('TestSub', subSchema);\r\n\r\n  console.log('This message will not appear');\r\n})();\r\n```\r\n\r\n```\r\nError: Can't customize discriminator option minimize (can only modify toJSON, toObject, _id, id)\r\n```"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nIf middleware is included for custom function, the first argument of that custom function will be overwritten by a callback handler (your custom function doesn't get its arguments)\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nIf I write a custom function, I expect to be able to pass it arguments\r\n\r\nCheck out this script:\r\n```javascript\r\nconst mongoose = require(\"mongoose\")\r\n\r\nconst run = async () => {\r\n  try {\r\n    // connect to mongoose\r\n    mongoose.connection.on(\"error\", console.error.bind(console, \"connection error:\"))\r\n    mongoose.connection.once(\"open\", function () {\r\n      console.log(\"Connected to Mongo!\")\r\n    })\r\n    await mongoose.connect('mongodb://localhost:27017/myproject')\r\n\r\n    let schema = new mongoose.Schema({ html: String })\r\n    schema.methods.customSave = async function (options = {}) {\r\n      console.log(`got options type of ${typeof options}`) // output: got options type of function\r\n      return this.save()\r\n    }\r\n    schema.pre('customSave', async function () {\r\n      console.log('went through pre hook')\r\n      return\r\n    })\r\n    let Model = mongoose.model('Article', schema)\r\n\r\n    let instance = Model({ html: '<h1>I really want this to work</h1>' })\r\n\r\n    let article = await instance.customSave({ importantOption: 'key' })\r\n    console.log('article', article)\r\n    process.exit(0)\r\n  } catch (err) {\r\n    console.error(err)\r\n    process.exit(1)\r\n  }\r\n}\r\n\r\nrun()\r\n```\r\n\r\nEven though no callbacks are specified, and [mongoose docs specify that you can use promises in middleware](https://mongoosejs.com/docs/middleware.html#pre), the log in the `customSave` function logs that the `options` argument is a `function`. I've tried any number of combinations, using `async/await` as well as returning promises, and nothing has seemed to change this behavior.\r\n\r\nNote: if you log the actual `options` in the `customSave` function, then you receive a function from `kareem` called `_cb`.\r\n\r\n**What is the expected behavior?**\r\nI expect the log to produce: \"got options type of object\", and if I log the options, I'd see `{ importantOption: 'key' }`\r\n\r\n**Additional troubleshooting/suggested fix**\r\nAs part of my troubleshooting, I pulled the mongoose repo and found that if I changed part of the `applyHooks` helper, I could \"escape\" the overwriting by modifying this [this section of code](https://github.com/Automattic/mongoose/blob/master/lib/helpers/model/applyHooks.js#L101) to:\r\n\r\n```javascript\r\n  for (const method of customMethods) {\r\n    if (!middleware.hasHooks(method)) {\r\n      // Don't wrap if there are no hooks for the custom method to avoid\r\n      // surprises. Also, `createWrapper()` enforces consistent async,\r\n      // so wrapping a sync method would break it.\r\n      continue;\r\n    }\r\n    const originalMethod = objToDecorate[method];\r\n    objToDecorate[method] = function() {\r\n      const args = Array.prototype.slice.call(arguments);\r\n      // changed code\r\n      let cb = utils.last(args);\r\n      if (typeof cb !== 'function') {\r\n        cb = null\r\n      }\r\n      // end changes\r\n      const argsWithoutCallback = cb == null ? args :\r\n        args.slice(0, args.length - 1);\r\n      return utils.promiseOrCallback(cb, callback => {\r\n        this[`$__${method}`].apply(this,\r\n          argsWithoutCallback.concat([callback]));\r\n      }, model.events);\r\n    };\r\n    objToDecorate[`$__${method}`] = middleware.\r\n      createWrapper(method, originalMethod, null, customMethodOptions);\r\n  }\r\n```\r\n\r\nI suggest that there should be an option, when creating a schema, which allows me to select the use of promises, instead of callbacks, and that the callback would not be assigned here in `applyHooks` if that option was passed.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nnode: `v10.15.0`\r\nmongoose:` ^5.4.6`\r\nMongoDB: `v3.6.8`\r\n\r\n**Other relevant material**\r\n[Stack Overflow post](https://stackoverflow.com/questions/20525896/mongoose-passing-parameters-to-pre-save-does-not-work-in-update-save) where the user suggests hacking around the issue by using a virtual method and calling it within the custom method, instead of using hooks at all"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nFeature request\r\n\r\n**What is the current behavior?**\r\ndocument.save() does not save the document in the database if the transaction associated with the document is aborted( https://mongoosejs.com/docs/transactions.html#with-mongoose-documents-and-save- ) but document.remove() removes the document from the database when the transaction associated with the document is aborted\r\n\r\n**What is the expected behavior?**\r\nthat document.remove() do not remove the document from the database if the transaction associated with the document is aborted\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nnode v10.14.2, mongoose v5.4.6, mongodb v4.1.1"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBug\r\n\r\n**What is the current behavior?**\r\n\r\nStrings that should be ObjectIds are not casted for subdocuments. It may be relevant that these subdocuments are set with discriminators.\r\n\r\n```.js\r\nOrder.count({\r\n  'lines.sellerId': '5bc0afe0dd135e925b55e6ff',\r\n}),\r\n// -> Does not find anything\r\n\r\nOrder.count({\r\n  'lines.sellerId': new mongoose.Types.ObjectId('5bc0afe0dd135e925b55e6ff'),\r\n})\r\n// -> returns correct count\r\n```\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n\r\nThe schema: Order.js (the relevant parts):\r\n```.js\r\nconst mongoose = require('../../utils/mongoose');\r\nconst { Schema } = mongoose;\r\n\r\n// There are some other kinds besides this one\r\nconst ListingLineSchema = new Schema({\r\n    sellerId: Schema.Types.ObjectId,\r\n    // More props\r\n});\r\n\r\nconst OrderSchema = new Schema(\r\n    {\r\n        lines: [\r\n            new Schema(\r\n                {\r\n                    amount: Number,\r\n                },\r\n                {\r\n                    discriminatorKey: 'kind',\r\n                },\r\n            ),\r\n        ],\r\n        // More props\r\n    }\r\n);\r\n\r\nconst lineArray = OrderSchema.path('lines');\r\nlineArray.discriminator('listing', ListingLineSchema);\r\n\r\nmodule.exports = mongoose.model('Order', OrderSchema);\r\n```\r\n\r\nAn example document (filtered to relevant parts):\r\n```.js\r\n{\r\n    \"_id\" : ObjectId(\"5bf673faf66e9e007cac3a32\"),\r\n    \"lines\" : [\r\n        {\r\n            \"_id\" : ObjectId(\"5bf673faf66e9e007cac3a34\"),\r\n            \"kind\" : \"listing\",\r\n            \"sellerId\" : ObjectId(\"5bc0afe0dd135e925b55e6ff\"),\r\n            \"amount\" : 100\r\n        },\r\n    ],\r\n}\r\n```\r\n\r\nSee the queries above, both `count` and `find` display the same behaviour. Using `$elemMatch` also doesn't help.\r\n\r\n**What is the expected behavior?**\r\n\r\nMongoose should cast the query value to an objectId.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\n\r\nnode: 8.15\r\nmongoose: 5.3.3\r\nmongodb: 3.6.8"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nWith a given Schema with a Map property there is a difference in creating and updating a document:\r\n\r\n```\r\nconst Schema = new mongoose.Schema({\r\n    map: {\r\n        type: Map,\r\n        of: String,\r\n    },\r\n});\r\n\r\nconst json1 = {\r\n    map: {\r\n        \"foo\": \"bar\"\r\n    }\r\n}\r\n\r\nconst json2 = {\r\n    \"map.foo\": \"bar\"\r\n}\r\n```\r\n\r\nIf you create an Entity from json1 everything works fine. If you create an empty Entity and update it with json1 everything works fine (and both entities have the same object-structure).\r\n\r\nBut if you create an Entity from json2 the map-Field is ignored (==> it creates an empty entitiy), but updating an entity with json2 is working fine.\r\n\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```\r\nimport {Schema, connect, model} from 'mongoose';\r\n\r\n\r\nconnect('mongodb://localhost:27017/playground', {useNewUrlParser: true});\r\nconst Test = new Schema({\r\n    map: {\r\n        type: Map,\r\n        of: String,\r\n    }\r\n})\r\n\r\nconst TestModel = model(\"Test\", Test);\r\n\r\nasync function main(){\r\n    let entityA = await TestModel.create({\"map\": {\"foo\": \"bar\"}});\r\n    console.log(`Create with complete Map: \\t\\t${JSON.stringify(entityA)}`);\r\n    let entityB = await TestModel.create({\"map.foo\": \"bar\"});\r\n    console.log(`Create with single property of Map: \\t${JSON.stringify(entityB)}`);\r\n\r\n    console.log(\"_______________________________________________________________________________________________________\")\r\n\r\n    let entityC = await TestModel.create({});\r\n    console.log(`Empty Entity: \\t\\t\\t\\t${JSON.stringify(entityC)}`);\r\n    let entityD = await TestModel.create({});\r\n\r\n    let updatedEntityC = await TestModel.findOneAndUpdate({_id:entityC._id}, {\"map\": {\"foo\": \"bar\"}}, {new: true});\r\n    console.log(`Updated with complete Map: \\t\\t${JSON.stringify(updatedEntityC)}`);    \r\n    let updatedEntityD = await TestModel.findOneAndUpdate({_id:entityD._id}, {\"map.foo\": \"bar\"}, {new: true});\r\n    console.log(`Updated with single property Map: \\t${JSON.stringify(updatedEntityD)}`);\r\n}\r\n\r\nmain().then(() => {});\r\n```\r\n\r\n\r\nConsole-Output:\r\n```\r\nCreate with complete Map:               {\"_id\":\"5c499a4489b38a0e14c81659\",\"map\":{\"foo\":\"bar\"},\"__v\":0}\r\nCreate with single property of Map:     {\"_id\":\"5c499a4689b38a0e14c8165a\",\"__v\":0}\r\n_______________________________________________________________________________________________________\r\nEmpty Entity:                           {\"_id\":\"5c499a4689b38a0e14c8165b\",\"__v\":0}\r\nUpdated with complete Map:              {\"_id\":\"5c499a4689b38a0e14c8165b\",\"__v\":0,\"map\":{\"foo\":\"bar\"}}\r\nUpdated with single property Map:       {\"_id\":\"5c499a4689b38a0e14c8165c\",\"__v\":0,\"map\":{\"foo\":\"bar\"}}\r\n```\r\n\r\n**What is the expected behavior?**\r\nNo difference in between Updating and Creating (in regards of \"changes\" of the object).\r\n"},{"labels":["bug"],"text":"I am reporting a Bug, where getters are called even though getters flag is not set in the toObject function. when toObject is called with the getters flag as true, like below. getters function gets called twice.\r\n\r\n`document.toObject({getters: true})`\r\n\r\nThis behavior has started to appear from version greater than 5.3.4.\r\n\r\nMy node.js, mongoose and MongoDB version.\r\nnode: v10.14.0\r\nmongoose: 5.4.5\r\nmongodb: v4.0.0  "},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nCalling populated() returns undefined on a populated virtual field.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```javascript\r\nconst mongoose = require('mongoose');\r\nconst Promise = require('bluebird');\r\n\r\nmongoose.Promise = Promise;\r\n\r\nmongoose.connect('mongodb://localhost/minimal', {});\r\nmongoose.set('debug', true);\r\n\r\nconst teamSchema = mongoose.Schema({\r\n  name: {\r\n    type: String,\r\n    required: true\r\n  },\r\n  captain: {\r\n    type: mongoose.Schema.Types.ObjectId,\r\n    ref: 'Player'\r\n  }\r\n});\r\nconst Team = mongoose.model('Team', teamSchema);\r\n\r\nconst playerSchema = mongoose.Schema({\r\n  name: {\r\n    type: String,\r\n    required: true\r\n  }\r\n});\r\nplayerSchema.virtual('teams', {\r\n  ref: 'Team',\r\n  localField: '_id',\r\n  foreignField: 'captain'\r\n})\r\nconst Player = mongoose.model('Player', playerSchema);\r\n\r\nasync function run() {\r\n  await Team.deleteMany();\r\n  await Player.deleteMany();\r\n\r\n  const player = await Player.create({name: 'Derek Jeter'});\r\n  await Team.create({name: 'Yankees', captain: player._id});\r\n\r\n  await player.populate('teams').execPopulate();\r\n\r\n  // Should be the document with the name \"Yankees\", and is that.\r\n  console.log('Teams are', player.teams);\r\n\r\n  // Should be the ID of \"Yankees\", but is undefined.\r\n  console.log('#populated is', player.populated('teams'));\r\n}\r\n\r\nrun();\r\n```\r\n\r\nWhen I run the code above, I see this logged in my console:\r\n```\r\n> $ node index.js                                 â¬¡ 10.13.0 â staging [Â±master â—]\r\n(node:87371) DeprecationWarning: current URL string parser is deprecated, and will be removed in a future version. To use the new parser, pass option { useNewUrlParser: true } to MongoClient.connect.\r\nMongoose: teams.deleteMany({}, {})\r\nMongoose: players.deleteMany({}, {})\r\nMongoose: players.insertOne({ _id: ObjectId(\"5c47b7d9460941554c3c7932\"), name: 'Derek Jeter', __v: 0 })\r\nMongoose: teams.insertOne({ _id: ObjectId(\"5c47b7d9460941554c3c7933\"), name: 'Yankees', captain: ObjectId(\"5c47b7d9460941554c3c7932\"), __v: 0 })\r\nMongoose: teams.find({ captain: { '$in': [ ObjectId(\"5c47b7d9460941554c3c7932\") ] } }, { projection: {} })\r\nTeams are [ { _id: 5c47b7d9460941554c3c7933,\r\n    name: 'Yankees',\r\n    captain: 5c47b7d9460941554c3c7932,\r\n    __v: 0 } ]\r\n#populated is undefined\r\n```\r\n\r\n**What is the expected behavior?**\r\nI expect #populated to return an array whose sole element is the ID of the \"player\" document.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNodeJS 10.13.0\r\nMongoose 5.4.6\r\nMongoDB 3.4.14\r\n"},{"labels":["bug"],"text":"This code used to work in 5.4.0 but fails in 5.4.5:\r\n\r\n```js\r\n#!/usr/bin/env node\r\n(async function () {\r\n  const mongoose = require('mongoose');\r\n  mongoose.set('applyPluginsToDiscriminators', true);\r\n  mongoose.connect('mongodb://localhost:27017/test', {useNewUrlParser: true});\r\n\r\n  mongoose.plugin((schema) => {\r\n    schema.options.versionKey = false;\r\n    schema.options.minimize = false;\r\n  });\r\n  const eventSchema = new mongoose.Schema({\r\n    kind: {type: String}\r\n  }, {\r\n    discriminatorKey: 'kind'\r\n  });\r\n\r\n  const testEventSchema = new mongoose.Schema({\r\n    inner: {\r\n      type: new mongoose.Schema({\r\n        _id: false,\r\n        bool: {type: Boolean, required: true}\r\n      })\r\n    }\r\n  });\r\n\r\n  const schema = new mongoose.Schema({\r\n    events: {\r\n      type: [eventSchema]\r\n    }\r\n  });\r\n\r\n  schema.path('events').discriminator('test-event', testEventSchema);\r\n})();\r\n```\r\n\r\n```\r\nError: Can't customize discriminator option minimize (can only modify toJSON, toObject, _id, id)\r\n```\r\n\r\nI think it might be caused by the fix to https://github.com/Automattic/mongoose/issues/7370."},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n**What is the current behavior?**\r\nSuppose we have schema with field \r\n```javascript\r\nitemsInfo: {\r\n  allUsers: { all: Number },\r\n  individual: [{\r\n    userId: String,\r\n    all: Number,\r\n  }]\r\n}\r\n```\r\nWe want to update just fields itemsInfo.individual.all, where userId belongs to certains array. Accoring do [mongodb docs](https://docs.mongodb.com/manual/reference/operator/update/positional-filtered/) it is possible to do with specifying arrayFilters in update. Current latest version of mongoose (mongoose 5.4.5) it throws error:\r\nReferenceError: context is not defined\r\n    at castFilterPath (myProject/node_modules/mongoose/lib/helpers/query/castFilterPath.js:48:18)\r\n    at castArrayFilters myProject/node_modules/mongoose/lib/helpers/update/castArrayFilters.js:57:26)\r\n    at _castArrayFilters (myProject/node_modules/mongoose/lib/query.js:1739:5)\r\n    at model.Query._updateThunk (myProject/node_modules/mongoose/lib/query.js:3445:3)\r\n    at model.Query.<anonymous> (myProject/node_modules/mongoose/lib/query.js:3548:23)\r\n    at model.Query._wrappedThunk [as _updateOne] (myProject/node_modules/mongoose/lib/helpers/query/wrapThunk.js:16:8)\r\n    at process.nextTick (myProject/node_modules/kareem/index.js:369:33)\r\n    at process.internalTickCallback (internal/process/next_tick.js:70:11)\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n```javascript\r\nmyModel.updateOne(\r\n        { _id: container._id },\r\n        {\r\n          $inc: {\r\n            'itemsInfo.allUsers.all': 1,\r\n            'itemsInfo.individual.$[element].all': 1\r\n          }\r\n        },\r\n        { arrayFilters: [{ 'element.userId': { $in: item.users } }] }\r\n );\r\n```\r\n**What is the expected behavior?**\r\nWork not throwing error\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nnodejs: 11.1.0\r\nmongoose: 5.4.5\r\nmongodb: 4.0.5"},{"labels":["bug"],"text":"```javascript\r\nconst assert = require('assert');\r\nconst mongoose = require('mongoose');\r\nmongoose.set('debug', true);\r\n\r\nconst GITHUB_ISSUE = `X`;\r\nconst connectionString = `mongodb://localhost:27017/${ GITHUB_ISSUE }`;\r\nconst { Schema } = mongoose;\r\n\r\nrun().then(() => console.log('done')).catch(error => console.error(error.stack));\r\n\r\nasync function run() {\r\n  await mongoose.connect(connectionString);\r\n  await mongoose.connection.dropDatabase();\r\n\r\n  const schema = new Schema({ test: Number });\r\n  // RegExp syntax new in Mongoose 5.3\r\n  schema.post(/.*/, function(error, res, next) {\r\n    console.log('Error middleware:', error.message);\r\n    next();\r\n  });\r\n\r\n  const Test = mongoose.model('Test', schema);\r\n\r\n  await Test.updateOne({}, { test: 'bar' });\r\n}\r\n```"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBug, in code or in docs.\r\n\r\n**What is the current behavior?**\r\n\r\nRelated to https://github.com/Automattic/mongoose/issues/7280, according to the docs [`orFail()` throw an error if no documents match the given filter](https://mongoosejs.com/docs/api.html#query_Query-orFail). You can set what object to be thrown as an error or also set a function to generate it, but it doesn't specify what error object is thrown if none is specified. In that case, `orFail()` always resolve with an `undefined` value.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n\r\nReading the code it's thrown [whatever is on `err`](https://github.com/Automattic/mongoose/blob/4a4628718c2b9dbe87d7e136e4e21d59c6c9a600/lib/query.js#L3886), so it's throwing `undefined`, that's ok. Thing is that when callin `orFail()` it's being used `.map()` to add a new transform, and [when consuming `_transforms` in `_wrapThunkCallback()`](https://github.com/Automattic/mongoose/blob/4a4628718c2b9dbe87d7e136e4e21d59c6c9a600/lib/query.js#L3996), the thrown value is captured and set as error of the `cb()` callback... so being `undefined`, the callback thinks the operation was sucesful and resolved with the not provided `res` value, it's say, it resolve to `undefined`.\r\n\r\n**What is the expected behavior?**\r\n\r\nWhen `orFail()` don't have defined its `err` argument and no documents are found, it should reject to some value (maybe an empty `Error` object with no message or any other info?).\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\n\r\nNode.js: 11.6.0\r\nMongoDB: 3.6.4\r\nMongoose: 5.4.3"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n### Do you want to request a *feature* or report a *bug*?\r\nBug\r\n\r\n### What is the current behavior?\r\nWhen I use remove() on a Document, it returns 'query in command must target a single shard key', even though the schema knows about the shard key and all the documents have valid shard key value.\r\n\r\n### If the current behavior is a bug, please provide the steps to reproduce.\r\n**The following code _doesn't_ work:**\r\n```\r\nimport { Schema, model as Model } from \"mongoose\";\r\n\r\nlet schemaData = {\r\n    secret: {\r\n        type: String,\r\n        required: true,\r\n        trim: true,\r\n        unique: true,\r\n    },\r\n    user: {\r\n        type: Schema.Types.ObjectId,\r\n        required: true,\r\n        ref: \"user\",\r\n    },\r\n    used: {\r\n        type: Boolean,\r\n        required: true,\r\n        default: false\r\n    }\r\n};\r\n\r\nexport let schema = new Schema(schemaData, { shardKey: {user: 1} });\r\n\r\nexport let model = Model(\"token\", schema)\r\n\r\nmodel.find({})\r\n    .exec()\r\n    .then(r => r[0].remove())\r\n    .catch(e => console.error(e))\r\n```\r\n**The following code _does_ work:**\r\n```\r\n    model.find({}).exec().then(r => {\r\n        r.forEach(async row => {\r\n            await model.deleteOne({_id: row.id, user: row.user})\r\n                .catch(e => console.error(e))\r\n        })\r\n    })\r\n```\r\nThe shard key is `user`, and it doesn't work on `findById`, `findOne`, etc. Find methods work as expected, and all the documents in the collection are valid and have a valid `user` value.\r\n\r\n### What is the expected behavior?\r\nSend the shard key with the ID on `remove()`.\r\n\r\n### Please mention your node.js, mongoose and MongoDB version.\r\n**Node:** v11.3.0\r\n**Mongoose:** 5.3.15\r\n**MongoDB:** Azure CosmosDB (compatible with MongoDB version 3.2)"},{"labels":["bug"],"text":"**Please mention your node.js, mongoose and MongoDB version.**\r\nMongoDB: `v4.0.3`\r\nMongoose: `v5.4.0`\r\nNodeJS: `v10.1.0`\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nreport a bug\r\n\r\n**What is the expected behavior?**\r\nI expected the virtual `{ count: true }` field to be accessible via dot syntax on the populated document resolved by `populate().execPopulate()`.\r\n\r\n**What is the current behavior?**\r\npopulating a virtual count field with `count: true` returns `null` on the populated document unless it is first converted to JSON with `.toJSON()`. This behavior is unlike populating the related documents themselves which are accessible on the populated document without transformation.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n## Here is a test script that shows the discrepancy in behaviors:\r\n- requires a test database URI in `process.env.TEST_DB_URI`\r\n\r\nI have presented two simple models `Parent` and `Child`. \r\nParent has two virtual fields\r\n- `children` related children documents themselves\r\n- `childrenCount` a `count: true` virtual for the count of related children documents. \r\n\r\nParent has 4 methods to illustrate the discrepencies. All 4 methods begin with `this.populate().execPopulate()` and differ in how they attempt to return the value. I did this to ensure the issue was not caused by native JS:\r\n- `getChildren()`: returns the populated `children` field [Child]\r\n  - returns: `.then(populatedDoc => populatedDoc.children)`\r\n- `getCountThen()`: populates the `childrenCount` field and attempts to return its value in a `.then()`\r\n  - returns: `.then(populatedDoc => populatedDoc.childrenCount)`\r\n- `getCountAsync()`: populates the `childrenCount` field using `async/await` and attempts to return its field value on the awaited document\r\n  - returns: `populatedDoc.childrenCount`\r\n- `getCountAfterJSON()`: populates the `childrenCount` field and returns its value after converting the populated document using `.toJSON()`\r\n  - returns: `populatedDoc.toJSON().childrenCount`\r\n```js\r\nrequire('dotenv').config();\r\nconst mongoose = require('mongoose');\r\n\r\nconst parentSchema = new mongoose.Schema({\r\n  name: String,\r\n});\r\n\r\nparentSchema.virtual('children', {\r\n  ref: 'children',\r\n  localField: '_id',\r\n  foreignField: 'parent',\r\n});\r\n\r\nparentSchema.virtual('childrenCount', {\r\n  ref: 'children',\r\n  localField: '_id',\r\n  foreignField: 'parent',\r\n  count: true,\r\n});\r\n\r\nparentSchema.methods.getChildren = function getChildren() {\r\n  return this.populate('children').execPopulate()\r\n    .then(populatedDoc => populatedDoc.children);\r\n}\r\n\r\nparentSchema.methods.getCountThen = function getCountThen() {\r\n  return this.populate('childrenCount').execPopulate()\r\n    .then(populatedDoc => populatedDoc.childrenCount);\r\n}\r\n\r\nparentSchema.methods.getCountAsync = async function getCountAsync() {\r\n  const populatedDoc = await this.populate('childrenCount').execPopulate();\r\n  return populatedDoc.childrenCount;\r\n}\r\n\r\nparentSchema.methods.getCountAfterJSON = async function getCountAfterJSON() {\r\n  const populatedDoc = await this.populate('childrenCount').execPopulate();\r\n  return populatedDoc.toJSON().childrenCount;\r\n}\r\n\r\nconst Parent = mongoose.model('parents', parentSchema);\r\n\r\nconst childSchema = new mongoose.Schema({\r\n  parent: { type: mongoose.SchemaTypes.ObjectId, ref: 'parents' },\r\n});\r\nconst Child = mongoose.model('children', childSchema);\r\n\r\ndescribe('virtual field population unexpected behavior', () => {\r\n  let parent;\r\n  let childrenCount;\r\n  let thenResult;\r\n  let asyncResult;\r\n  let jsonResult;\r\n  let childrenResult;\r\n  beforeAll(async () => {\r\n    mongoose.connect(process.env.TEST_DB_URI, { useNewUrlParser: true });\r\n    \r\n    parent = await Parent.create({ name: 'hubert' });\r\n    \r\n    childrenCount = 3;\r\n    await Promise.all(\r\n      Array(childrenCount)\r\n        .fill(null)\r\n        .map(() => Child.create({ parent })),\r\n    );\r\n\r\n    thenResult = await parent.getCountThen();\r\n    asyncResult = await parent.getCountAsync();\r\n    jsonResult = await parent.getCountAfterJSON();\r\n    childrenResult = await parent.getChildren();\r\n  });\r\n\r\n  afterAll(() => mongoose.connection.close());\r\n\r\n  describe('virtual count field { count: true }', () => {\r\n    test(\r\n      `getCountThen(): returns the number of children documents [${childrenCount}]`,\r\n      () => expect(thenResult).toBe(childrenCount),\r\n    );\r\n  \r\n    test(\r\n      `getCountAsync(): returns the number of children documents [${childrenCount}]`,\r\n      () => expect(asyncResult).toBe(childrenCount),\r\n    );\r\n  \r\n    test(\r\n      `getCountAfterJSON(): returns the number of children documents [${childrenCount}]`,\r\n      () => expect(jsonResult).toBe(childrenCount),\r\n    );\r\n  });\r\n\r\n  describe('virtual documents field { count: undefined }', () => {\r\n    test('getChildren(): returns an Array of Child documents', () => {\r\n      expect(childrenResult.length).toBe(childrenCount);\r\n    });\r\n  });\r\n});\r\n```\r\n\r\n## Jest Output:\r\n```sh\r\nFAIL  ./sample.test.js\r\n  virtual field population unexpected behavior\r\n    virtual count field { count: true }\r\n      âœ• getCountThen(): returns the number of children documents [3] (10ms)\r\n      âœ• getCountAsync(): returns the number of children documents [3] (1ms)\r\n      âœ“ getCountAfterJSON(): returns the number of children documents [3]\r\n    virtual documents field { count: undefined }\r\n      âœ“ getChildren(): returns an Array of Child documents\r\n\r\n  â— virtual field population unexpected behavior â€º virtual count field { count: true } â€º getCountThen(): returns the number of children documents [3]\r\n\r\n    expect(received).toBe(expected) // Object.is equality\r\n\r\n    Expected: 3\r\n    Received: null\r\n\r\n    Difference:\r\n\r\n      Comparing two different types of values. Expected number but received null.\r\n\r\n      75 |     test(\r\n      76 |       `getCountThen(): returns the number of children documents [${childrenCount}]`,\r\n    > 77 |       () => expect(thenResult).toBe(childrenCount),\r\n         |                                ^\r\n      78 |     );\r\n      79 |\r\n      80 |     test(\r\n\r\n      at Object.toBe (sample.test.js:77:32)\r\n\r\n  â— virtual field population unexpected behavior â€º virtual count field { count: true } â€º getCountAsync(): returns the number of children documents [3]\r\n\r\n    expect(received).toBe(expected) // Object.is equality\r\n\r\n    Expected: 3\r\n    Received: null\r\n\r\n    Difference:\r\n\r\n      Comparing two different types of values. Expected number but received null.\r\n\r\n      80 |     test(\r\n      81 |       `getCountAsync(): returns the number of children documents [${childrenCount}]`,\r\n    > 82 |       () => expect(asyncResult).toBe(childrenCount),\r\n         |                                 ^\r\n      83 |     );\r\n      84 |\r\n      85 |     test(\r\n\r\n      at Object.toBe (sample.test.js:82:33)\r\n\r\nTest Suites: 1 failed, 1 total\r\nTests:       2 failed, 2 passed, 4 total\r\nSnapshots:   0 total\r\nTime:        1.02s, estimated 2s\r\nRan all test suites matching /sample.test.js/i.\r\n```"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n**What is the current behavior?**\r\nI've several Schemas stored in a Object, also lots of Schema Types in my custom mongoose, I was using discriminators to define other models related to de \"User\" Model. it stopped working since 5.3.1 so I stayed in that versiÃ³n, later I saw I could clone a Schema or even use it as a base for other models, so I started trying.\r\n\r\nIf I use `let Other = new db.Schema(User);` I've got this error:\r\n\r\n**TypeError: Cannot read property 'clone' of undefined**\r\n\r\nIf I use `let Other = User.clone()` and latter add a custom Type I get this error:\r\n\r\n**TypeError: Invalid schema configuration: `Rut` is not a valid type at path `rut`. See http://bit.ly/mongoose-schematypes for a list of valid schema types.**\r\n\r\nThis are the Keys in User.base.Schema.Types:\r\n\r\n```\r\n[ 'String',\r\n  'Number',\r\n  'Boolean',\r\n  'DocumentArray',\r\n  'Embedded',\r\n  'Array',\r\n  'Buffer',\r\n  'Date',\r\n  'ObjectId',\r\n  'Mixed',\r\n  'Decimal',\r\n  'Decimal128',\r\n  'Map',\r\n  'Oid',\r\n  'Object',\r\n  'Bool',\r\n  'TimeFrame',\r\n  'Email',\r\n  'Url',\r\n  'Password',\r\n  'File',\r\n  'User',\r\n  'Range',\r\n  'Html',\r\n  'Rut',\r\n  'Currency',\r\n  'Percentage',\r\n  'TextArea',\r\n  'Address',\r\n  'Inversionista' ]\r\n```\r\nThis are from \"Other\" Schema:\r\n\r\n```\r\n[ 'String',\r\n  'Number',\r\n  'Boolean',\r\n  'DocumentArray',\r\n  'Embedded',\r\n  'Array',\r\n  'Buffer',\r\n  'Date',\r\n  'ObjectId',\r\n  'Mixed',\r\n  'Decimal',\r\n  'Decimal128',\r\n  'Map',\r\n  'Oid',\r\n  'Object',\r\n  'Bool' ]\r\n```\r\nIf I use lodash cloneDeep seems to work but I still need to do lots of tests.\r\n\r\nI can't reproduce the problem in a simple way, at first I think I was losing context, but as You can see is when I clone when I lose the **base** so your MongooseTypes is defined as the mongoose.Schema.Types and not as my custom mongoose.\r\n\r\nI'm trying this:\r\n\r\n```\r\nlet Other = User.clone();\r\nOther.base = User.base;\r\n```\r\n\r\nAnd it seems to work too.\r\n\r\nPlease let me know if this tweak can produce some side effect.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\n**What is the expected behavior?**\r\nHope to be able to reuse all the AAA definitions in User in other schemas.\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nmongoose 5.4.1\r\nmongodb 4.0.4\r\nnode 10.13.0"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nVirtual populate returns an array with only one document, even though the query returns more documents.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\n```\r\n//Song Schema\r\nlet songSchema= Schema({\r\n    title: { type: String },\r\n    folksong: {\r\n        _id: false,\r\n        identifiers: [{\r\n            _id: false,\r\n            composers: [{\r\n                _id: false,\r\n                artist: { type: ObjectId, ref: 'Artist' },\r\n            }],\r\n        }]\r\n    }\r\n},\r\n {\r\n        id: false,\r\n        timestamps: false,\r\n        toObject: { virtuals: true, minimize: true },\r\n        toJSON: { virtuals: true, minimize: true },\r\n});\r\n```\r\n\r\n```\r\n//Artist Schema\r\nartistSchema.virtual('folksongs', {\r\n\tref: 'Song',\r\n\tlocalField: '_id',\r\n\tforeignField: 'folksong.identifiers.composers.artist',\r\n\tjustOne: false\r\n});\r\n```\r\n\r\n```\r\n//Query\r\nconst testId = '5acc307dd734b019b8737d38';\r\nlet test = await ArtistModel.findById(testId).populate([{\r\n    path: 'folksongs'\r\n}]);\r\nconsole.log(test.folksongs.length); // returns 1\r\n```\r\n\r\n```\r\n//mongoose debug output\r\nMongoose: songs.find({ 'folksong.identifiers.composers.artist': { '$in': [ ObjectId(\"5acc307dd734b019b8737d38\") ] } }, { projection: {} })\r\n```\r\n\r\n**What is the expected behavior?**\r\nVirtual populate with the correct number of documents.\r\n\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nMongoose 5.4.1\r\nNode.js 8.9.1"},{"labels":["bug"],"text":"It looks like `strict: 'throw'` doesn't work with nested discriminators, see the repro script below that fails on mongoose 5.4.0:\r\n\r\n```js\r\n#!/usr/bin/env node\r\n(async function () {\r\n  const mongoose = require('mongoose');\r\n  mongoose.connect('mongodb://localhost:27017/test', {useNewUrlParser: true});\r\n\r\n  mongoose.plugin((schema) => {\r\n    schema.options.strict = 'throw';\r\n    schema.options.strictQuery = 'throw';\r\n  });\r\n\r\n  const eventSchema = new mongoose.Schema({\r\n    kind: {type: String}\r\n  }, {\r\n    discriminatorKey: 'kind'\r\n  });\r\n\r\n  const testEventSchema = new mongoose.Schema({\r\n    inner: {\r\n      type: new mongoose.Schema({\r\n        _id: false,\r\n        bool: {type: Boolean, required: true}\r\n      })\r\n    }\r\n  });\r\n\r\n  const schema = new mongoose.Schema({\r\n    events: {\r\n      type: [eventSchema]\r\n    }\r\n  });\r\n\r\n  schema.path('events').discriminator('test-event', testEventSchema);\r\n\r\n  const Model = mongoose.model('test', schema);\r\n\r\n  const doc = new Model();\r\n  doc.events.push({\r\n    _id: mongoose.Types.ObjectId(),\r\n    kind: 'test-event',\r\n    inner: {\r\n      bool: true\r\n    }\r\n  });\r\n\r\n  console.log('before:' + await doc.validate()); // OK - validates correctly\r\n  doc.events[0].inner = {\r\n    bool: true,\r\n    somethingExtra: 123 // `strict` is set to 'throw', should fail\r\n  };\r\n  console.log('after:' + await doc.validate()); // NOT OK - should fail but it doesn't\r\n})();\r\n```\r\n\r\nI'm not actually sure whether it's caused by the plugin not applying the `strict` option or just the `strict` option not working correctly, but there's clearly a bug here. If I move the `inner` declaration from `testEventSchema` to `eventSchema` second call to `doc.validate()` fails correctly."},{"labels":["bug"],"text":"Something has changed in behavior, unsure if it is a documentation bug or a driver bug.\r\nI get following error: errorz.updateOne(...).exec is not a function\r\n\r\nThe code behindt this is something like following:\r\n`myDocument.updateOne({$inc: {counter: 1}}).exec();`\r\n\r\nI first fetch a document, and increase a counter on it afterwards, this worked before, but since updating mongoose to the latest version I get this error. Accoridng to the docs, this should return a \"Query\", and therefore exec() should work?"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBUG\r\n\r\n**What is the current behavior?**\r\nquery.where() Cast to ObjectId failed\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\n\r\n```js\r\n// OK\r\nawait User.find({ _id: '5c1c7aa71154070fb6acea73' });\r\n// OK\r\nawait User.find({ _id: new ObjectId('5c1c7aa71154070fb6acea73') });\r\n// OK\r\nawait User.find().where({ _id: new ObjectId('5c1c7aa71154070fb6acea73') });\r\n// OK\r\nawait User.find({ _id: new ObjectId('5c1c7aa71154070fb6acea73') }).where({ _id: '5c1c7aa71154070fb6acea73' });\r\n// ERROR: Cast to ObjectId failed for value \"{ _bsontype: 'ObjectID',  id: <Buffer 5c 1c 7a a7 11 54 07 0f b6 ac ea 73> }\" at path \"_id\" for model \"User\"\r\nawait User.find({ _id: '5c1c7aa71154070fb6acea73' }).where({ _id: new ObjectId('5c1c7aa71154070fb6acea73') });\r\n\r\n```\r\n\r\n**What is the expected behavior?**\r\n\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNodejs v10.14.1\r\nmongoose 5.4.0"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?** \r\nI want to report a bug\r\n\r\n**What is the current behavior?** \r\nI am getting an error ''TypeError: Cannot read property 'listeners' of undefined\" while updating an object through custom method defined using schema.methods\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```js\r\nconst mongoose = require('mongoose');\r\nmongoose.Promise = global.Promise;\r\n\r\nmongoose.connect('mongodb://localhost:27017', { dbName: 'test-db', useNewUrlParser: true }, function (error) {\r\n  if (error) {\r\n    console.log('Error in mongo connection', error);\r\n  } else {\r\n    console.log('Mongo connection established');\r\n  }\r\n});\r\nmongoose.set('debug', true);\r\n\r\nlet catalogSchema = new mongoose.Schema({\r\n  name: {\r\n    type: String,\r\n    required: true,\r\n  },\r\n  image: {\r\n    type: new mongoose.Schema({\r\n      mediaUrl: String,\r\n      mediaType: String,\r\n      thumbURL: String\r\n    }),\r\n    default: null  //TODO : Make this 'required'\r\n  }\r\n\r\n}, { runSettersOnQuery: true });\r\n\r\ncatalogSchema.methods.update = function (data) {\r\n  for (let key in data) {\r\n    this[key] = data[key];\r\n  }\r\n  return this.save();\r\n};\r\n\r\nlet modelCatalog = mongoose.model('catalogue', catalogSchema);\r\n\r\nlet item = new modelCatalog({\r\n  'name': 'Bikes',\r\n});\r\nitem.save()\r\n  .then((result) => {\r\n    result.update({ name: 'Cars' });\r\n  }).catch((error) => {\r\n    console.log(error);\r\n  });\r\n```\r\n\r\n**What is the expected behavior?**\r\nIt should have successfully updated the object.\r\n\r\nHere is the stack trace that I am getting:\r\n\r\n>/home/abhishek/Desktop/Test-project/node_modules/mongoose/lib/utils.js:264\r\n        if (ee.listeners('error').length > 0 && !error[emittedSymbol]) {\r\n               ^\r\nTypeError: Cannot read property 'listeners' of undefined\r\n    at /home/abhishek/Desktop/Test-project/node_modules/mongoose/lib/utils.js:264:16\r\n    at /home/abhishek/Desktop/Test-project/node_modules/kareem/index.js:246:48\r\n    at /home/abhishek/Desktop/Test-project/node_modules/kareem/index.js:135:16\r\n    at _combinedTickCallback (internal/process/next_tick.js:131:7)\r\n    at process._tickCallback (internal/process/next_tick.js:180:9)\r\n\r\nThat's not all. If I go back a version(5.3.16), I am getting a different error. Here is the stack trace for that:\r\n\r\n>(node:30663) UnhandledPromiseRejectionWarning: TypeError: Cannot read property 'now' of undefined\r\n    at model._setTimestampsOnUpdate (/home/abhishek/Desktop/Test-project/node_modules/mongoose/lib/schema.js:925:33)\r\n    at callMiddlewareFunction (/home/abhishek/Desktop/Test-project/node_modules/kareem/index.js:474:23)\r\n    at next (/home/abhishek/Desktop/Test-project/node_modules/kareem/index.js:58:7)\r\n    at Kareem.execPre (/home/abhishek/Desktop/Test-project/node_modules/kareem/index.js:86:8)\r\n    at Kareem.wrap (/home/abhishek/Desktop/Test-project/node_modules/kareem/index.js:265:8)\r\n    at model.$__update (/home/abhishek/Desktop/Test-project/node_modules/kareem/index.js:375:11)\r\n    at utils.promiseOrCallback.callback (/home/abhishek/Desktop/Test-project/node_modules/mongoose/lib/helpers/model/applyHooks.js:99:30)\r\n    at Promise (/home/abhishek/Desktop/Test-project/node_modules/mongoose/lib/utils.js:250:5)\r\n    at new Promise (<anonymous>)\r\n    at Object.promiseOrCallback (/home/abhishek/Desktop/Test-project/node_modules/mongoose/lib/utils.js:249:10)\r\n    at model.objToDecorate.(anonymous function) [as update] (/home/abhishek/Desktop/Test-project/node_modules/mongoose/lib/helpers/model/applyHooks.js:98:20)\r\n    at item.save.then (/home/abhishek/Desktop/Test-project/index.js:77:12)\r\n    at <anonymous>\r\n    at process._tickCallback (internal/process/next_tick.js:188:7)\r\n\r\n\r\nThe latest verion that I am able to get it working with is v5.3.8\r\nHowever, updating the object through mongoose standard update function seems to work just fine.\r\nLike: \r\n\r\n```js\r\nitem.save()\r\n  .then((result) => {\r\n    modelCatalog.update({ _id: result._id }, { name: 'cars' })\r\n      .then((updatedResult) => {\r\n        console.log(updatedResult)\r\n      })\r\n      .catch((error) => {\r\n        console.log(error);\r\n      })\r\n  }).catch((error) => {\r\n    console.log(error);\r\n  });\r\n```\r\n\r\nAlso, both these errors exist only when I am using that child schema in image field. removing it solves both the bugs in their respective version.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNode version: 8.10\r\nMongoDB version: 4.0.4\r\nMongoose version: 5.4.0"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nReporting a bug.\r\n\r\n**What is the current behavior?**\r\nSubdocuments created via default are no longer having their `_id` field automatically generated.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```javascript\r\nconst accountSchema = new mongoose.Schema({\r\n  roles: {\r\n    type: [{\r\n      otherProperties: {\r\n        example: Boolean,\r\n      },\r\n      name: String,\r\n    }],\r\n    default: [\r\n      {\r\n        otherProperties: { example: true },\r\n        name: 'First',\r\n      },\r\n      {\r\n        otherProperties: { example: false },\r\n        name: 'Second',\r\n      }\r\n    ]\r\n  },\r\n});\r\nconst Account = mongoose.model('Account', accountSchema);\r\nconst account = db.models.Account.create({});\r\n// check `account.roles` and notice that the subdocuments do not contain `_id`\r\n```\r\n\r\n**What is the expected behavior?**\r\nSubdocuments should have `_id` applied unless the opposite is explicitly specified in the schema settings.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nUsing node v10.14.1. \r\n\r\nThis bug was introduced at v5.3.12 and hasn't been resolved as of v5.3.14."},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBug\r\n\r\n**What is the current behavior?**\r\n\r\nValues are not updated for subdocument in Map if changed after loading it from db.\r\n\r\nE.g in the example below, changing children.one.name results in the following query\r\n```javascript\r\nparents.updateOne({ _id: ObjectId(\"5c0f8b1b5aae0d62ab285cc2\") }, { '$unset': { 'children.$*.name': 1 } })\r\n```\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```javascript\r\n'use strict';\r\n\r\nconst mongoose = require('mongoose');\r\nmongoose.set('debug', true);\r\nmongoose.connect('mongodb://localhost:27017/dredition-test');\r\n\r\nconst childSchema = new mongoose.Schema({\r\n\tname: {type: String}\r\n});\r\n\r\nconst parentSchema = new mongoose.Schema({\r\n\tchildren: {\r\n\t\ttype: Map,\r\n\t\tof: childSchema\r\n\t}\r\n});\r\n\r\nconst Parent = mongoose.model('Parent', parentSchema);\r\n\r\n(async function go() {\r\n\tconst first = await new Parent({\r\n\t\tchildren: {\r\n\t\t\t'one': {name: 'foo'}\r\n\t\t}\r\n\t}).save();\r\n\r\n\tconst loaded = await Parent.findById(first.id);\r\n\tloaded.children.get('one').set('name', 'bar');\r\n\tawait loaded.save();\r\n})();\r\n\r\n```\r\n\r\n**What is the expected behavior?**\r\n\r\n`children.one.name` property should be set to `bar` in the database.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\n\r\nMongoose: 5.3.15\r\nNodeJS: v10.10.0\r\nMongodb: 3.4.1"},{"labels":["bug"],"text":"Hello,\r\n\r\nThanks for mongoose !\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nbug\r\n\r\n**What is the current behavior?**\r\n\r\n`RangeError: Maximum call stack size exceeded` when using `save()`, i.e : \r\n\r\n```\r\nRangeError: Maximum call stack size exceeded\r\n      at Document.get (...\\node_modules\\mongoose\\lib\\helpers\\document\\compile.js:120:20)\r\n      ...\r\n      at docReducer (...\\node_modules\\mongoose\\lib\\document.js:2342:27)\r\n      at ...\\node_modules\\mongoose\\lib\\document.js:2372:18\r\n      at Array.reduce (<anonymous>)\r\n      at docReducer (...\\node_modules\\mongoose\\lib\\document.js:2371:33)\r\n      at ...\\node_modules\\mongoose\\lib\\document.js:2381:12\r\n      at Array.reduce (<anonymous>)\r\n      at model.Document.$__getAllSubdocs (...\\node_modules\\mongoose\\lib\\document.js:2380:42)\r\n      at model.$session (...\\node_modules\\mongoose\\lib\\document.js:654:26)\r\n      at _init (...\\node_modules\\mongoose\\lib\\query.js:2578:12)\r\n      at model.Document.init (...\\node_modules\\mongoose\\lib\\document.js:435:5)\r\n      at completeOne (...\\node_modules\\mongoose\\lib\\query.js:2568:12)\r\n      at model.Query.Query._completeOne (...\\node_modules\\mongoose\\lib\\query.js:1901:7)\r\n      at Immediate.Query.base.findOne.call (...\\node_modules\\mongoose\\lib\\query.js:1943:10)\r\n      at Immediate._onImmediate (...\\node_modules\\mquery\\lib\\utils.js:116:16)\r\n      at runCallback (timers.js:785:20)\r\n      at tryOnImmediate (timers.js:747:5)\r\n      at processImmediate [as _immediateCallback] (timers.js:718:5)\r\n```\r\n\r\n```js\r\nconst schema = new mongoose.Schema({\r\n  http: {\r\n    get: {\r\n      type: Number,\r\n      required: true,\r\n    },\r\n  },\r\n});\r\n```\r\n\r\n**What is the expected behavior?**\r\n\r\nTo have an error when booting to warn me about the reserved key I'm using.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNode 8.8.1\r\nmongoose 5.3.13\r\nMongoDB 3.4.9"},{"labels":["bug"],"text":"```\r\ndiff --git a/test/types.map.test.js b/test/types.map.test.js\r\nindex 86ca8ce6a..8145ecc0c 100644\r\n--- a/test/types.map.test.js\r\n+++ b/test/types.map.test.js\r\n@@ -84,7 +84,7 @@ describe('Map', function() {\r\n   it('deep set', function(done) {\r\n     const userSchema = new mongoose.Schema({\r\n       socialMediaHandles: {\r\n-        type: Map,\r\n+        type: Schema.Types.Map,\r\n         of: String\r\n       }\r\n     });\r\n\r\n```\r\ngoes to\r\n```\r\n     TypeError: Undefined type `SchemaMap` at `socialMediaHandles`\r\n  Did you try nesting Schemas? You can only nest using refs or arrays.\r\n\r\n```"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nProbably a bug.\r\n\r\n**What is the current behavior?**\r\nIn the latest version of mongoose 4.x,`document#populate` behaves differently with `query#populate`\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nWhen using the `query#populate`, the document's populated field can be modified normally:\r\n```\r\nlet potter = await Book.findOne({ name: 'Potter' }).populate('owner').exec()\r\nconsole.log('before potter = ', potter)\r\npotter.owner = {}\r\nconsole.log('after potter = ', potter)\r\n``` \r\nand the result is this\r\n```\r\nbefore potter =  { _id: 5c08b95a0590e665915a46d1,\r\n  name: 'Potter',\r\n  owner: \r\n   { _id: 5c08b95a0590e665915a46cf,\r\n     name: 'Peter',\r\n     age: '12',\r\n     __v: 0 },\r\n  __v: 0 }\r\nafter potter =  { _id: 5c08b95a0590e665915a46d1,\r\n  name: 'Potter',\r\n  owner: { _id: 5c08cd6227b7516865831774 },\r\n  __v: 0 }\r\n```\r\n\r\nHowever, when using `document#populate`, the owner field will become unchangeable unless the new value is a mongoose document or null\r\n\r\n```\r\nlet potter = await Book.findOne({ name: 'Potter' }).exec()\r\nawait potter.populate('owner').execPopulate()\r\nconsole.log('before potter = ', potter)\r\npotter.owner = {}\r\nconsole.log('after potter = ', potter)\r\n``` \r\nand the result is this\r\n```\r\nbefore potter =  { _id: 5c08b95a0590e665915a46d1,\r\n  name: 'Potter',\r\n  owner: \r\n   { _id: 5c08b95a0590e665915a46cf,\r\n     name: 'Peter',\r\n     age: '12',\r\n     __v: 0 },\r\n  __v: 0 }\r\nafter potter =  { _id: 5c08b95a0590e665915a46d1,\r\n  name: 'Potter',\r\n  owner: \r\n   { _id: 5c08b95a0590e665915a46cf,\r\n     name: 'Peter',\r\n     age: '12',\r\n     __v: 0 },\r\n  __v: 0 }\r\n```\r\n\r\nThis problem isn't appear when I was still using mongoose 4.7.8, it just appear when I try to push the mongoose version to latest 4.x. For mongoose 5.x, this problem don't appear too.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNode 8.12.0\r\nMongoose 4.13.17\r\nMongoDB 3.2.21"},{"labels":["bug",null],"text":"When using `await` approach, request context variables returns `undefined` in `pre` `find*` hooks\r\n\r\nI have noticed that it is accessible inside \r\n`pre` `save`\r\n\r\non related note, if using callback approach, the context variables are not accessible inside the callback function. \r\nThis may or may not be related to mongoose code, but with combination of original issue it creates bigger problem since neither approach works perfectly when having to access the context variable both in `pre` hook and with the result.\r\n\r\nI did find a closed ticket maked `cannot reproduce` but I was able to modify the given sample code to reproduce the issue:\r\n\r\nThanks!\r\n\r\n```js\r\nconst assert = require(\"assert\");\r\nconst mongoose = require(\"mongoose\");\r\nmongoose.set(\"debug\", true);\r\n\r\nconst httpContext = require(\"express-http-context\");\r\nconst superagent = require(\"superagent\");\r\nconst express = require(\"express\");\r\n\r\nconst GITHUB_ISSUE = `gh7292`;\r\nconst connectionString = `mongodb://localhost:27017/${GITHUB_ISSUE}`;\r\nconst { Schema } = mongoose;\r\n\r\nrun()\r\n\t.then(() => console.log(\"done\"))\r\n\t.catch(error => console.error(error.stack));\r\n\r\nasync function run() {\r\n\tawait mongoose.connect(connectionString);\r\n\tawait mongoose.connection.dropDatabase();\r\n\r\n\tconst app = express();\r\n\r\n\tapp.use(httpContext.middleware);\r\n\r\n\tconst userSchema = new Schema({ name: String });\r\n\r\n\tuserSchema.pre(\"find\", function(next) {\r\n\t\tconsole.log(httpContext.get(\"test\"));\r\n\t\tnext();\r\n\t});\r\n\r\n\tconst User = mongoose.model(\"User\", userSchema);\r\n\r\n\tapp.get(\"/\", async (req, res) => {\r\n\t\thttpContext.set(\"test\", \"42\");\r\n\t\tconst user = await User.find({});\r\n\t\tres.json({ ok: 1 });\r\n\t});\r\n\r\n\tawait app.listen(3003);\r\n\r\n\tawait superagent.get(\"http://localhost:3003/\");\r\n\r\n\tconsole.log(\"done\");\r\n\tprocess.exit(0);\r\n}\r\n```\r\n\r\n`express@4.16.4` `express-http-context@1.2.0` `mongoose@5.3.12`\r\n\r\n_Originally posted by @mtbnunu in https://github.com/Automattic/mongoose/issues/7001#issuecomment-442677512_"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nReport a bug\r\n\r\n**What is the current behavior?**\r\nWhen an object having a very large `length` property and, `__proto__` or `constructor` property is passed, an out of memory error is thrown. This can be used to trigger a denial in service on apis that use unsanatized inputs in mongo queries.\r\n\r\n```\r\n[...]\r\n==== JS stack trace =========================================\r\n\r\nSecurity context: 0x3551a6b25e91 <JSObject>\r\n    1: push(this=0x35512c541261 <JSArray[75209227]>)\r\n    2: cast(aka cast) [/Users/immanuelpelzer/Development/tmp/mongoose-fic/node_modules/mongoose/lib/cast.js:~25] [pc=0x3c834931891c](this=0x3551b6a82311 <undefined>,schema=0x35512c541351 <Schema map = 0x3551b6221891>,obj=0x35512c541319 <Object map = 0x3551d534c081>,options=0x35512c5412e9 <Object map = 0x3551b6222339>,context=0x35512c541281 <JS...\r\n\r\nFATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory\r\n[...]\r\n\r\n```\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```\r\nconst mongoose = require('mongoose')\r\nmongoose.connect('mongodb://localhost/test')\r\n    .then(console.log('connected'))\r\n\r\nconst TestSchema = new mongoose.Schema({\r\n    test: String\r\n})\r\n\r\nconst TestModel = mongoose.model('Test', TestSchema)\r\n\r\n// Both cause the error\r\nTestModel.findOne({\r\n    test: {\r\n        length:1e10,\r\n        __proto__: []\r\n    }\r\n}).then(res => console.log)\r\n\r\n// Both cause the error\r\nTestModel.findOne({\r\n    test: {\r\n        length:1e10,\r\n        constructor: { name:\"Array\" }\r\n    }\r\n}).then(res => console.log)\r\n```\r\n\r\n**What is the expected behavior?**\r\nPropper handling of these kind of requests.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNode: v8.8.1\r\nMongoose: 5.3.14\r\nMongoDB: 3.4\r\n\r\n**Investigation**\r\nThe issue lies here: https://github.com/Automattic/mongoose/blob/d3cfdcb93279d319a9795fb5cfed8316fa07b384/lib/cast.js#L295-L302"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n*bug*\r\n**What is the current behavior?**\r\n\r\nMongoose schema doesn't allow to set `collection` as field. However, by using `strict: false`, one can create using `new Model` or `Model.create` a document with an overrided `collection`.\r\n\r\nIn most common scenario, this would cause a process crash (`uncaughtException`).\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n\r\nhttps://gist.github.com/dbellavista/08abb3e912e61e829a87b4fb5729ac64\r\n\r\n**What is the expected behavior?**\r\n\r\nThe creation should fail by rejecting the promise and/or invoking the callback with an error\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\n\r\nNode 10, mongoose 5.3.13, mongoDB 3.6\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nReport a bug\r\n\r\n**What is the current behavior?**\r\nWhen populating **an array of an array** of documents using dynamic references (using refPath), population gets done but at the end _item_ equals `null` in returned document.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nYou need an array of objects that have another array of elements you need to populate, using a field inside for the ObjectId and another field to indicate the model we will use to populate.\r\n\r\nConflictive part of the schema used:\r\n```javascript\r\n  equips: [\r\n    {\r\n      item: { type: Schema.Types.ObjectId, ref: 'equips' }, // <-- ignore this \r\n      assistents: [\r\n        {\r\n          item: { type: Schema.Types.ObjectId, refPath: 'equips.assistents.col' }, // <-- THIS is the populate that fails\r\n          rol: String,\r\n          col: String, // <-- here we can find the model to populate with\r\n          convocat: Boolean,\r\n          confirmat: Boolean,\r\n          validat: Boolean\r\n        }\r\n      ]\r\n    }\r\n  ],\r\n```\r\nAnd now part of the logic that invokes the populate:\r\n```javascript\r\nfor (var i = 0; i < doc.equips.length; i++) {\r\n  for (var j = 0; j < doc.equips[i].assistents.length; j++) {\r\n    doc.populate({ path: 'equips.' + i + '.assistents.' + j + '.item', populate: { path: 'idUsuaria', select: 'desc' } });\r\n  }\r\n}\r\n```\r\nAnd later I execute the `execPopulate()` on the document instance.\r\n\r\n**What is the expected behavior?**\r\nGetting the document with the indicated paths populated\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nmongodb version v3.6.6\r\nmongoose version 5.3.13\r\nnodejs v8.10\r\n\r\n\r\n#### Investigation\r\nAfter a little bit of debugging I realized that the `modelsMap` that returns the function `getModelsMapForPopulate` it's not correct.  In my case, that we can find ~13 paths populated using 2 different models, the modelsMap gets filled with only one of the 13 IDs and (but repeated 13 times) and using the wrong model (although it is divided in two different arrays, as there are two models):\r\n\r\n```\r\n[\r\n  [\"5bb47cd4724c8263c770cabe\",\"5bb47cd4724c8263c770cabe\",\"5bb47cd4724c8263c770cabe\",\"5bb47cd4724c8263c770cabe\",\"5bb47cd4724c8263c770cabe\",\"5bb47cd4724c8263c770cabe\",\"5bb47cd4724c8263c770cabe\",\"5bb47cd4724c8263c770cabe\",\"5bb47cd4724c8263c770cabe\",\"5bb47cd4724c8263c770cabe\",\"5bb47cd4724c8263c770cabe\",\"5bb47cd4724c8263c770cabe\",\"5bb47cd4724c8263c770cabe\"],\r\n  [\"5bb47cd4724c8263c770cabe\",\"5bb47cd4724c8263c770cabe\",\"5bb47cd4724c8263c770cabe\"]\r\n]\r\n```\r\nand I could even find another strange behaviour in the `getModelsMapForPopulate()`, in the following piece of code:\r\n```javascript\r\ntry {\r\n  Model = originalModel && originalModel[modelSymbol] ?\r\n  originalModel :\r\n  modelName[modelSymbol] ? modelName : model.db.model(modelName);\r\n} catch (error) {\r\n  return error;\r\n}\r\n```\r\ngiven that we have `k`, that iterates through the modelNames **starting from the top**, and that we have `modelName = modelNames[k]` that equals the model that corresponds to the last path being populated, which is not the current one;  after executing the `Model` assignation, tie condition falls to `model.db.model(modelName)` which equals **the incorrect model** (the last one in the array), because in the first condition `originalModel[modelSymbol]` equals `undefined`.\r\n\r\nIt then continues the iteration filling the map with all the same Id but with the models not being applied correctly."},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nConsider having 2 schemas (Parent and Child).\r\nThe Parent has a Map of ChildSchema.\r\n\r\nThe ChildSchema setters' context `this` is always an instance of _Document_, even when a model.find() was done. It is never an instance of _Query_ (unlike) the ParentSchema.\r\n\r\nAs far as I can tell this only happens when the ChildSchema is being used as a Map. When the ChildSchema is used directly as a Subdocument or an array of Subdocuments (not a Map), this context is correct (this might be false, I'm not 100% sure but in my tests it seemed to be ok).\r\n\r\nhttps://mongoosejs.com/docs/api.html#schematype_SchemaType-set refers to this at the end of the section (starting with _You can also use setters to modify other properties on the document..._)\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```js\r\nexport const ParentSchema: mongoose.Schema = new mongoose.Schema(\r\n  {\r\n   name: String,\r\n   children: {\r\n      type: Map,\r\n      of: ChildSchema,\r\n    }\r\n  }\r\n);\r\n\r\nexport const ChildSchema: mongoose.Schema = new mongoose.Schema(\r\n  {\r\n   age: {\r\n      type: Number,\r\n      set: setName,\r\n    },\r\n   yearBorn: Number,\r\n   name: String\r\n  }\r\n);\r\n\r\nfunction setAge(age: Number) {\r\n  // Never a Query\r\n  if (this instanceof mongoose.Query) {\r\n     return age;\r\n  }\r\n\r\n  // Always a Document\r\n  if (this instanceof mongoose.Document) {\r\n      this.yearBorn = 2018;\r\n      return age;\r\n  }\r\n}\r\n```\r\n**What is the expected behavior?**\r\n`this` is _always_ an instance of Document, causing the logic inside to be run on model.find() (in this case, setting yearBorn to 2018. Just like the parent Schema, this should be an instance of Query in that case.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNode: v8.11.4\r\nmongoose: v5.3.13\r\nMongoDB v4.0.3"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nRegression\r\n\r\nSample code:\r\n\r\n```js\r\nconst mongoose = require('mongoose');\r\nconst {Schema} = mongoose;\r\n\r\nconst ActivityBareSchema = new Schema({\r\n  _id: {\r\n    type: Schema.Types.ObjectId,\r\n    ref: 'Activity',\r\n  },\r\n  name: String,\r\n});\r\n\r\nconst EventSchema = new Schema({\r\n  activity: ActivityBareSchema,\r\n  name: String,\r\n});\r\n\r\nconst data = {\r\n  _id: '5bf606f6471b6056b3f2bfc8',\r\n  name: 'Test',\r\n  activity: {\r\n    _id: '5bf606f6471b6056b3f2bfc9',\r\n    name: 'Activity name',\r\n  },\r\n};\r\n\r\nconst Event = mongoose.model('Event', EventSchema);\r\nconst event = new Event(data, null);\r\n\r\nconsole.log(event);\r\n```\r\n\r\n**What is the current behavior?**\r\nIn 5.3.13, sample script outputs `{ _id: 5bf606f6471b6056b3f2bfc8, name: 'Test' }` with the nested activity document missing.\r\n\r\n**What is the expected behavior?**\r\nIn 5.3.4, the output included the activity subdocument:\r\n\r\n`{ _id: 5bf606f6471b6056b3f2bfc8,\r\n  name: 'Test',\r\n  activity: { _id: 5bf606f6471b6056b3f2bfc9, name: 'Activity name' } }`\r\n\r\n**More details**\r\nWe are passing `null` as the second parameter if we don't want to apply any data projection.\r\nThis is useful when we're using the aggregation framework to load documents, and then convert the results to models using `new` instantiation, like so:\r\n\r\n```js\r\nconst events = result.events.map(data => new Event(data, projection));\r\n```\r\n\r\nThe projection that we pass in depends on what the user is querying, and if we want all fields the value for projection is `null`. \r\n\r\nThis was working fine up until 5.3.4, but after updating to 5.3.13 this no longer works. In effect, this is a breaking change?\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNode 8.12.0, MongoDB 4.x."},{"labels":["bug"],"text":"**Bug**\r\nWhen updating a subdocument either with static or instance method timestamps are not set.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n\r\n```\r\n#!/usr/bin/env node\r\n\r\nassert = require('assert');\r\nmongoose = require('mongoose');\r\nSchema = mongoose.Schema;\r\n\r\nmongoose.connect('mongodb://localhost/test', \r\n\t{ \r\n\t\tuseNewUrlParser: true \r\n\t}\r\n);\r\n\r\nconst childSchema = new Schema(\r\n\t\r\n\t{\r\n\t\tname: String,\r\n\t\tcreated: Date,\r\n\t\tupdate: Date\r\n\t},\r\n\t\r\n\t{\r\n\t\ttimestamps: {\r\n\t\t\tcreatedAt: 'created',\r\n\t\t\tupdatedAt: 'updated'\r\n\t\t}\r\n\t}\r\n);\r\n\r\nconst parentSchema = new Schema(\r\n\t{\r\n\t\tname: String,\r\n\t\tchild: childSchema,\r\n\t\tcreated: Date,\r\n\t\tupdate: Date\r\n\t}, \r\n\t{\r\n\t\ttimestamps: {\r\n\t\t\tcreatedAt: 'created',\r\n\t\t\tupdatedAt: 'updated'\r\n\t\t}\r\n\t}\r\n);\r\n\r\nconst Parent = mongoose.model('Parent', parentSchema);\r\n\r\n( async () => {\r\n\r\n\tlet parent = new Parent(\r\n\t\t{\r\n\t\t\tname: \"Darth Vader\",\r\n\t\t}\r\n\t);\r\n\t\r\n\tlet doc = await parent.save();\r\n\t\r\n\tlet update = await doc.updateOne( \r\n\t\t{\r\n\t\t\tchild:{\r\n\t\t\t\tname: \"Luke Skywalker\"\r\n\t\t\t}\r\n\t\t}\r\n\t);\r\n\t// await Parent.updateOne( {_id: doc._id}, { 'child.name': \"Luke Skywalker\" } )\r\n\t\r\n\tassert.equal(update.n, 1, 'Parent should have a child');\r\n\t\r\n\treturn await Parent.findById(doc._id);\r\n\t\r\n})()\r\n\r\n.then( (result) => {\r\n\t// console.log(result);\r\n\r\n\tassert.ok(result.child.name, 'Child should have a name.');\r\n\tassert.ok(result.child.updated, 'Child should have updated date.');\r\n\tassert.ok(result.child.created, 'Child should have created date.');\r\n\r\n\tprocess.exit();\r\n})\r\n\r\n.catch( (e) => {\r\n\tconsole.log(e);\r\n\tprocess.exit();\r\n});\r\n\r\n```\r\n\r\n**What is the expected behavior?**\r\n`child.updated` and `child.created` should exist.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\n- Node: v8.12.0\r\n- MongoDB: 3.6.8\r\n- Mongoose: v5.3.12\r\n"},{"labels":["bug"],"text":"Pretty low priority, but ran into a problem that confused me for awhile and thought it would be worth mentioning here.\r\n\r\n**What is the current behavior?**\r\nCurrently, the 'ref' schema option only accepts string values (<a href=\"https://github.com/Automattic/mongoose/blob/master/lib/helpers/populate/validateRef.js\" target=\"_blank\">and functions</a> I guess?). In the case where a defined model isn't imported anywhere in application code but is still required to be a registered model for use as references in other models, mongoose will throw a MissingSchemaError (as it should).\r\n\r\nFor example:\r\n\r\n```javascript\r\n// src/models/User.js\r\n// This file isn't imported anywhere, so the model never gets registered\r\nimport mongoose from 'mongoose'\r\n\r\nconst userSchema = new mongoose.Schema({\r\n  name: String,\r\n})\r\n\r\nexport default mongoose.model('User', userSchema)\r\n```\r\n\r\n```javascript\r\n// src/models/Post.js\r\n// This file is imported in application code, so this model is registered\r\n// When the model is used, however, mongoose throws a MissingSchemaError because\r\n// the 'User' model isn't registered\r\nimport mongoose from 'mongoose'\r\n\r\nconst postSchema = new mongoose.Schema({\r\n  user: {\r\n    type: mongoose.Schema.Types.ObjectId,\r\n    required: true,\r\n    ref: 'User',\r\n  },\r\n})\r\n\r\nexport default mongoose.model('Post', postSchema)\r\n```\r\n\r\nThe workaround solution to this is, of course, to make sure all models are imported in the application code at some point before they are used. However, I think a cleaner method would be to allow passing models as the value for the ref; this would allow/encourage models to express dependency on one another declaratively via import/require statements. Here's what I mean:\r\n\r\n```javascript\r\n// src/models/Post.js\r\nimport mongoose from 'mongoose'\r\nimport User from './User'\r\n\r\nconst postSchema = new mongoose.Schema({\r\n  user: {\r\n    type: mongoose.Schema.Types.ObjectId,\r\n    required: true,\r\n    ref: User,\r\n  },\r\n})\r\n\r\nexport default mongoose.model('Post', postSchema)\r\n```\r\n\r\nThe problem I ran into was that I was doing the above thinking it was standard syntax, and nothing was throwing an error (the <a href=\"https://github.com/Automattic/mongoose/blob/master/lib/helpers/populate/validateRef.js\" target=\"_blank\">validateRef</a> helper in the mongoose codebase accepts functions as valid values). But when I wanted to populate those reference fields on document instances, population would fail silently and the fields would stay ObjectIDs. Likewise, when setting those fields with model instance values, the model instance values would be typecast to ObjectIDs and the fields would not be model instances as I had expected.\r\n\r\nTo get the import-model-dependencies syntax I wanted while keeping population functionality, I've gotten into the habit of doing the following as a compromise, which is arguably just as simple as the above proposal:\r\n\r\n```javascript\r\n// src/models/Post.js\r\nimport mongoose from 'mongoose'\r\nimport User from './User'\r\n\r\nconst postSchema = new mongoose.Schema({\r\n  user: {\r\n    type: mongoose.Schema.Types.ObjectId,\r\n    required: true,\r\n    ref: User.modelName,\r\n  },\r\n})\r\n\r\nexport default mongoose.model('Post', postSchema)\r\n```\r\n\r\nmongoose version: 5.3.11\r\nnode version: 11.1.0\r\nmongodb version: 4.0.4"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n**What is the current behavior?**\r\nWhen setting a model property as required inside an array, the validation path goes out of sync when using splice (thus changing the index).\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```js\r\nconst mongoose = require('mongoose');\r\n\r\nconst childSchema = mongoose.Schema({\r\n  name: {\r\n    type: String,\r\n    required: [true, 'Child name is required'],\r\n  }\r\n});\r\n\r\nconst kittySchema = new mongoose.Schema({\r\n  name: String,\r\n  children: [childSchema],\r\n});\r\n\r\nconst Kitten = mongoose.model('Kitten', kittySchema);\r\n\r\nconst kitten = new Kitten({ name: 'Kitten 1', children: [\r\n  { name: 'Child 1'},\r\n  { name: 'Child 2'},\r\n]});\r\n\r\n// remember to change the username, pass and db\r\nmongoose.connect('mongodb://user:pass@localhost/db');\r\nconst db = mongoose.connection;\r\ndb.on('error', console.error.bind(console, 'connection error:'));\r\ndb.once('open', function() {\r\n  return kitten.save().then(() => {\r\n    return Kitten.findOne({ _id: kitten._id });\r\n  }).then((k) => {\r\n    // this will trigger the validation, if this line is commented the bug will not manifest\r\n    k.children[1].name = 'Child 3';\r\n    // this will screw up the validation\r\n    k.children.splice(0, 1);\r\n    k.markModified('children');\r\n    // uncomment the following lines and it will work\r\n    // const aux = k.children;\r\n    // k.children = [];\r\n    // k.children = aux;\r\n    return k.save();\r\n  }).then(() => {\r\n    console.log('success');\r\n  }).catch((err) => {\r\n    console.log(JSON.stringify(err));\r\n  //   {\r\n  //     \"errors\": {\r\n  //         \"children.1.name\": {\r\n  //             \"message\": \"Child name is required\",\r\n  //             \"name\": \"ValidatorError\",\r\n  //             \"properties\": {\r\n  //                 \"message\": \"Child name is required\",\r\n  //                 \"type\": \"required\",\r\n  //                 \"path\": \"name\"\r\n  //             },\r\n  //             \"kind\": \"required\",\r\n  //             \"path\": \"name\"\r\n  //         }\r\n  //     },\r\n  //     \"_message\": \"Kitten validation failed\",\r\n  //     \"message\": \"Kitten validation failed: children.1.name: Child name is required\",\r\n  //     \"name\": \"ValidationError\"\r\n  // }\r\n  });\r\n});\r\n```\r\n\r\n**What is the expected behavior?**\r\nThe validation path should be updated when splice is called over an array. I think the problem is that the document calculates the validation paths and do not update those path when splice is called.\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nnode: v10.6.0\r\nmongoose: 5.3.12\r\nmongodb: 3.4.13"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nbug\r\n\r\n**What is the current behavior?**\r\nUpon creating a new model instance (and likely when modifying one), passing `false` (and some other alternatives) to a field that requires an array of sub-documents (schemas), causes a fatal ObjectParameterError.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\nThe following program can be used to reproduce this:\r\n```javascript\r\nconst mongoose = require('mongoose');\r\nmongoose.connect('mongodb://localhost/temp', { useNewUrlParser: true });\r\nconst Child = new mongoose.Schema({});\r\nconst Parent = new mongoose.Schema({\r\n\tchildren: {\r\n\t\ttype: [Child] // only happens for arrays of schemas\r\n\t}\r\n});\r\nconst ParentModel = mongoose.model('TestParent', Parent);\r\nconst model = new ParentModel({\r\n\tchildren: false // also happens for: [false], 0, [0] and [false, 0], but NOT for e.g. [false, 0, true]\r\n});\r\n// error after calling save()\r\nmodel.save(err => {\r\n\tconsole.log(err.errors.children.message); // should instead give validation error message as such\r\n});\r\n```\r\nThis is the exception that gets thrown:\r\n```\r\n    throw new ObjectParameterError(obj, 'obj', 'Document');\r\n    ^\r\nObjectParameterError: Parameter \"obj\" to Document() must be an object, got false\r\n    at new ObjectParameterError (path\\to\\project\\node_modules\\mongoose\\lib\\error\\objectParameter.js:25:11)\r\n    at EmbeddedDocument.Document (path\\to\\project\\node_modules\\mongoose\\lib\\document.js:68:11)\r\n    at EmbeddedDocument [as constructor] (path\\to\\project\\node_modules\\mongoose\\lib\\types\\embedded.js:39:12)\r\n    at new EmbeddedDocument (path\\to\\project\\node_modules\\mongoose\\lib\\schema\\documentarray.js:75:17)\r\n    at path\\to\\project\\node_modules\\mongoose\\lib\\schema\\documentarray.js:187:26\r\n    at DocumentArray.SchemaType.doValidate (path\\to\\project\\node_modules\\mongoose\\lib\\schematype.js:829:12)\r\n    at DocumentArray.doValidate (path\\to\\project\\node_modules\\mongoose\\lib\\schema\\documentarray.js:143:35)\r\n    at path\\to\\project\\node_modules\\mongoose\\lib\\document.js:1904:9\r\n    at _combinedTickCallback (internal/process/next_tick.js:131:7)\r\n    at process._tickCallback (internal/process/next_tick.js:180:9)\r\n    at Function.Module.runMain (module.js:695:11)\r\n    at startup (bootstrap_node.js:191:16)\r\n    at bootstrap_node.js:612:3\r\n```\r\n\r\n**What is the expected behavior?**\r\nInstead of a fatal error being thrown, a validation error should be passed to the save callback. This is already the case for inputs such as `true`, which simply give a message along the lines of `Cast to Array failed for value \"true\" at path \"children\"`.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNode: 8.11.3, Mongoose: 5.3.12"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nbug\r\n\r\n**What is the current behavior?**\r\nWhen a subSchema has a field with a default array isModified fails.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n```js\r\n'use strict';\r\n\r\nconst mongoose = require('mongoose');\r\nmongoose.Promise = global.Promise;\r\n\r\nconst subSchema = new mongoose.Schema({\r\n    users: {\r\n        type: [{\r\n            name: { type: String }\r\n        }]\r\n      , default: [ { name: 'test' } ] // <- isModified fails if default is an array\r\n    }\r\n});\r\n\r\nconst schema = new mongoose.Schema({\r\n    sub: [subSchema]\r\n});\r\n\r\nconst Model = mongoose.model('Test', schema);\r\n\r\nconst doc = new Model({ name: 'test', sub: [{}] });\r\n\r\nconst main = async () => {\r\n    await mongoose.connect('mongodb://localhost/test');\r\n    await doc.save();\r\n    console.log(doc.isModified()); //false\r\n\r\n    const doc2 = await Model.findById(doc._id);\r\n\r\n    console.log(doc2.isModified()); //true\r\n};\r\n\r\nmain().catch(err => {\r\n    console.error(err);\r\n    process.exit(-1);\r\n});\r\n\r\n```\r\n**What is the expected behavior?**\r\nisModified should be false\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\n```\r\nnode@10.12.0\r\nmongoose@5.3.10 \r\nmongo@4.0.1\r\n```\r\n\r\n"},{"labels":["bug"],"text":"re: @YouriT 's [comment](https://github.com/Automattic/mongoose/issues/7074#issuecomment-434340255) on #7074 \r\n\r\n### 7202.js\r\n```js\r\n#!/usr/bin/env node\r\n'use strict';\r\n\r\nconst assert = require('assert');\r\nconst mongoose = require('mongoose');\r\nconst { Schema, connection} = mongoose;\r\n\r\nconst DB = '7202';\r\nconst URI = `mongodb://localhost:27017/${DB}`;\r\nconst OPTS = { family: 4, useNewUrlParser: true };\r\n\r\nconst subSchema = new Schema({}, { timestamps: false });\r\nconst schema = new Schema({ sub: subSchema }, { timestamps: false });\r\n\r\nconst Test = mongoose.model('test', schema);\r\nconst test = new Test({ sub: {} });\r\n\r\nfunction strictEqual(a, b, msg) {\r\n  try {\r\n    assert.strictEqual(a, b, msg);\r\n  } catch (e) {\r\n    console.error(e.message);\r\n  }\r\n}\r\n\r\nasync function run() {\r\n  assert.strictEqual(mongoose.version, '5.3.8');\r\n  await mongoose.connect(URI, OPTS);\r\n  await connection.dropDatabase();\r\n  const doc = await Test.create(test);\r\n  assert.ok(doc);\r\n  strictEqual(doc.updatedAt, undefined, 'parent has createdAt set.');\r\n  strictEqual(doc.createdAt, undefined, 'parent has updatedAt set.');\r\n  strictEqual(doc.sub.createdAt, undefined, 'child has createdAt set.');\r\n  strictEqual(doc.sub.updatedAt, undefined, 'child has updatedAt set.');\r\n  await connection.close();\r\n}\r\n\r\nrun();\r\n```\r\n### Output:\r\n```\r\nissues: ./7202.js\r\nparent has createdAt set.\r\nparent has updatedAt set.\r\nissues:\r\n```"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n*Bug*\r\n\r\n**What is the current behavior?**\r\nWhen setting a value to a single nested document field\r\n```javascript\r\nrootDoc.set('anything.subDoc.someField', 12);\r\n```\r\nThe set function is called twice\r\n```javascript\r\n{\r\n  ...\r\n  someField: {\r\n    set: function(value) {\r\n      return value;\r\n    }\r\n  }\r\n  ...\r\n}\r\n```\r\nThe first time with `this` as `rootDoc` and the second as `subDoc`.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n[RunKit Example](https://runkit.com/lucgranato/mongoose-issue-set)\r\n\r\n**What is the expected behavior?**\r\nCalling only one time.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nnode: 8.11.3\r\nmongoose: 5.3.7"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nbug\r\n\r\n**What is the current behavior?**\r\n\r\n```sh\r\nâžœ  tmp node nested-refer-on-mongoose-document/script.js\r\n{ mongoose_version: '5.3.7', node_version: 'v10.12.0' }\r\nstep 0, before\r\n{ user: { _id: 5bd6c736562e8ff9c9e0c150 },\r\n  card: { _id: 5bd6c736562e8ff9c9e0c151 } }\r\nstep 0, after\r\nstep 1, before\r\n{ user:\r\n   { _id: 5bd6c736562e8ff9c9e0c150,\r\n     card: { _id: 5bd6c736562e8ff9c9e0c151 } },\r\n  card: { _id: 5bd6c736562e8ff9c9e0c151 } }\r\nstep 1, after\r\nstep 2, before\r\n[Object: Inspection interrupted prematurely. Maximum call stack size exceeded.]\r\nstep 2, after\r\n```\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\n```js\r\nconst mongoose = require('mongoose');\r\nconsole.log({\r\n  mongoose_version: mongoose.version,\r\n  node_version: process.version,\r\n});\r\n\r\nmongoose.connect('mongodb://localhost/test');\r\n\r\nconst UserSchema = new mongoose.Schema({\r\n  name: { type: String },\r\n  card: { type: mongoose.Schema.Types.ObjectId, ref: 'Card' },\r\n});\r\n\r\nconst CardSchema = new mongoose.Schema({\r\n  name: { type: String },\r\n  user: { type: mongoose.Schema.Types.ObjectId },\r\n});\r\n\r\nconst User = mongoose.model('User', UserSchema);\r\nconst Card = mongoose.model('Card', CardSchema);\r\n\r\nconst run = async () => {\r\n  const user = new User();\r\n  const card = new Card();\r\n\r\n  const log = (step) => {\r\n    console.log(`step ${step}, before`);\r\n    console.log({ user, card });\r\n    console.log(`step ${step}, after`);\r\n  };\r\n\r\n  log(0);\r\n  user.card = card;\r\n\r\n  log(1);\r\n  card.user = user;\r\n\r\n  log(2);\r\n};\r\n\r\ntry {\r\n  run();\r\n} catch (e) {\r\n  console.log(e.message);\r\n  process.exit(1);\r\n} finally {\r\n  process.exit(0);\r\n}\r\n```\r\n\r\n**What is the expected behavior?**\r\n\r\n```sh\r\nâžœ  tmp node nested-refer-on-mongoose-document/script.js\r\n{ mongoose_version: '5.2.18', node_version: 'v10.12.0' }\r\nstep 0, before\r\n{ user: { _id: 5bd6c745da551df9f1e78d3d },\r\n  card: { _id: 5bd6c745da551df9f1e78d3e } }\r\nstep 0, after\r\nstep 1, before\r\n{ user:\r\n   { _id: 5bd6c745da551df9f1e78d3d,\r\n     card: { _id: 5bd6c745da551df9f1e78d3e } },\r\n  card: { _id: 5bd6c745da551df9f1e78d3e } }\r\nstep 1, after\r\nstep 2, before\r\n{ user:\r\n   { _id: 5bd6c745da551df9f1e78d3d,\r\n     card:\r\n      { _id: 5bd6c745da551df9f1e78d3e,\r\n        user: 5bd6c745da551df9f1e78d3d } },\r\n  card:\r\n   { _id: 5bd6c745da551df9f1e78d3e,\r\n     user: 5bd6c745da551df9f1e78d3d } }\r\nstep 2, after\r\n```\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\n\r\n{ mongoose_version: '5.3.7', node_version: 'v10.12.0' }"},{"labels":["bug"],"text":"The following code uses a subschema that produces errors during validate. If that same code is placed in the root document, it fails, but all subschemas does not prevent saving or validating.\r\n\r\nThe following code should have prevented saving, but succeeded:\r\n\r\n```javascript\r\nconst mongoose = require(\"mongoose\");\r\nconst Schema = mongoose.Schema;\r\n\r\nconst InnerSchema = new Schema(\r\n  {\r\n    name: {\r\n      type: String,\r\n    },\r\n  },\r\n  { strict: \"throw\", timestamps: true },\r\n);\r\n\r\nInnerSchema.pre('validate', async function () {\r\n  console.log('pre-failing')\r\n  throw new Error('I have failed you')\r\n  console.log('post-failing')\r\n})\r\n\r\nconst TestSchema = new Schema(\r\n  {\r\n    subdoc: [ InnerSchema ]\r\n  },\r\n  { strict: \"throw\", timestamps: true },\r\n);\r\n\r\nconst Test = mongoose.model(\"Test\", TestSchema);\r\n\r\nmongoose.connect(\"mongodb://localhost:27017/test\");\r\n\r\nconst data = {\r\n  subdoc: [{name: 'Hey'}]\r\n};\r\n\r\n// should throw an error\r\nasync function main() {\r\n  const res = await Test.create(data);\r\n  console.log(res);\r\n}\r\nmain()\r\n  .then(() => process.exit(0))\r\n  .catch((err) => {\r\n        console.log(err);\r\n        process.exit(1)\r\n});\r\n```\r\n\r\noutput:\r\n```\r\npre-failing\r\n{ _id: 5bd529a8cc5068b0aaf70cc5,\r\n  subdoc:\r\n   [ { _id: 5bd529a8cc5068b0aaf70cc6,\r\n       name: 'Hey',\r\n       createdAt: 2018-10-28T03:14:48.894Z,\r\n       updatedAt: 2018-10-28T03:14:48.894Z } ],\r\n  createdAt: 2018-10-28T03:14:48.895Z,\r\n  updatedAt: 2018-10-28T03:14:48.895Z,\r\n  __v: 0 }\r\n```"},{"labels":["bug"],"text":"PR #6119 for issue #3781 addressed an issue that caused the context object (`this`) provided to `default` function callback handlers to only have access to properties set in other default handlers, not the contents of the document itself. This works when creating a document, but it does not work when loading a document via a query. This causes problems where we are trying to do conditional defaultsâ€”based on another property, the default value should either be changed or removed entirely.\r\n\r\nAnother ticket was opened about this issue and closed because no code samples were provided (\r\n#6330). I'm pretty sure this is the same issue I'm having.\r\n\r\nThe code snippet below reproduces the current behavior, with assertions for what is expected to happen. The second assertion fails because `this.type` was `undefined` in the default callback function.\r\n\r\nTested using Node 8.11.3, mongoose 5.3.6, mongo 3.4.2.\r\n\r\n```js\r\nconst mongoose = require('mongoose');\r\nconst Schema = mongoose.Schema;\r\nconst schema = new Schema({ type: String, choices: String });\r\nschema.path('choices').default(function () {\r\n  return this.type === 'mc' ? 'ABCDE' : this.type === 'rubric' ? '12345' : 'ERROR';\r\n});\r\n\r\nconst Model = mongoose.model('Test', schema);\r\n\r\nasync function run() {\r\n  await mongoose.connect('mongodb://localhost:27017/test');\r\n  await mongoose.connection.dropDatabase();\r\n\r\n  const created = new Model({ type: 'mc', id: 1 });\r\n  await created.save();\r\n  assert.equal(created.choices, 'ABCDE'); // works\r\n\r\n  // clear it out to test what happens when a loaded document needs a default\r\n  await Model.collection.updateOne({_id: created._id}, {$set: {type: 'rubric'}, $unset: {choices: 1}});\r\n  const loaded = await Model.findById(created._id).exec();\r\n  assert.equal(loaded.choices, '12345'); // fails because `this` was an empty object in default handler\r\n}\r\n\r\nrun().catch(error => console.error(error.stack));\r\n```"},{"labels":["bug"],"text":"Hey!\r\nI am wondering why the script below throw a validation error.\r\nI set strictQuery to throw, but the filter in find is correct.\r\n\r\n**Solution found**  if a use a dot notation in the find filter, it works great.\r\nThere is a slice difference between `dot notation` and using an `object notation` in the filter (either it look for  exactly the same object, or only the key provided) but still we should be able to perform a find with the two syntax.\r\n```javascript\r\n\t// solution found\r\n\tawait Test.find({\"customer.persona\": \"whatever\"});\r\n```\r\n\r\n```javascript\r\nconst mongoose = require(\"mongoose\");\r\nconst Schema = mongoose.Schema;\r\n\r\nconst TestSchema = new Schema(\r\n  {\r\n    customer: {\r\n      persona: String,\r\n    },\r\n  },\r\n  { strictQuery: \"throw\", timestamps: true },\r\n);\r\n\r\nconst Test = mongoose.model(\"Test\", TestSchema);\r\n\r\nmongoose.connect(\"mongodb://localhost:27017/test\");\r\n\r\nasync function main() {\r\n  const res = await Test.find({\r\n    customer: {\r\n      persona: \"whatever\",\r\n    },\r\n  });\r\n  console.log(res);\r\n}\r\n\r\nmain()\r\n  .then(() => process.exit(0))\r\n  .catch((err) => {\r\n    console.log(err);\r\n    process.exit(1);\r\n  });\r\n\r\n```"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n\r\n**What is the current behavior?**\r\nI just import mongoose in a project that initialized by vue-cli 2.0,when I run the project ,an error thrown as the title said,can anyone explain why?thanks!! \r\nhere is the detail of error:\r\nUncaught TypeError: Cannot read property 'prototype' of undefined\r\n    at eval (webpack-internal:///./node_modules/mongoose/lib/types/buffer.js:184)\r\n    at Array.forEach (<anonymous>)\r\n    at Object.eval (webpack-internal:///./node_modules/mongoose/lib/types/buffer.js:183)\r\n    at eval (webpack-internal:///./node_modules/mongoose/lib/types/buffer.js:306)\r\n    at Object../node_modules/mongoose/lib/types/buffer.js (app.bundle.js:2554)\r\n    at __webpack_require__ (app.bundle.js:679)\r\n    at fn (app.bundle.js:89)\r\n    at Object.eval (webpack-internal:///./node_modules/mongoose/lib/schema/buffer.js:10)\r\n    at eval (webpack-internal:///./node_modules/mongoose/lib/schema/buffer.js:225)\r\n    at Object../node_modules/mongoose/lib/schema/buffer.js (app.bundle.js:2386)\r\n    at __webpack_require__ (app.bundle.js:679)\r\n    at fn (app.bundle.js:89)\r\n    at eval (webpack-internal:///./node_modules/mongoose/lib/schema/array.js:19)\r\n    at Object../node_modules/mongoose/lib/schema/array.js (app.bundle.js:2370)\r\n    at __webpack_require__ (app.bundle.js:679)\r\n    at fn (app.bundle.js:89)\r\n\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNode.js 8.12\r\nmongoose 5.3.5\r\nMongoDB 4.0.3"},{"labels":["bug"],"text":"Hello everyone,\r\n\r\nI want to report a bug that randomly occured today, it worked completely fine yesterday and the only thing I did with the project was move the folder it was inside.\r\n\r\nI am using Mongoose inside of Electron.js for a desktop application and what happens when I try to run this app is this:\r\n\r\n![cef40660567fccc4a22c69380ea8787d](https://user-images.githubusercontent.com/39199931/47325513-6d158280-d664-11e8-87c6-ff3a6e88261a.png)\r\n\r\nThe app fails loading up and I get the error above. I am very, very sure that the source of the problem is the mongoose.Schema() method, since I don't get this error and the app loads up fine when I remove every call to mongoose.Schema() inside of my project. Obviously this can't be the solution since my whole app is based on MongoDB with mongoose and removing every Schema would also mean that I would probably have to completely switch over to another Database Service or somehow recode everything which I wouldn't want as of now. Here are my two schemas:\r\n\r\n![3c9119a74082f85532ee22a896c9c617](https://user-images.githubusercontent.com/39199931/47325652-33914700-d665-11e8-8da1-696f413b624a.png)\r\n\r\n![4f7c90b20278610a7a552e50811460a8](https://user-images.githubusercontent.com/39199931/47325733-94208400-d665-11e8-8c2c-291f098334e9.png)\r\n\r\nand like I said, the error only goes away when I remove both of the calls to mongoose.Schema() in both files. If I did anything wrong on my end with configuring mongoose.Schema correctly which is leading to that error, I apologize and would be thankful for improvements. Otherwise, any ideas on how to fix this? I am not sure about that but it seems to have stopped working since I have moved the project folder onto my second drive. It shouldn't be the node_modules though, since I deleted them, reinstalled them via npm install and checked that especially mongoose was fully up to date. I hope that this can be fixed as soon as possible since I really need to keep working on this project.\r\n\r\nThanks in advance! ðŸ‘ \r\n\r\n\r\n"},{"labels":["bug",null],"text":"regarding #2901, a comment by @SachinBhandari [here](https://github.com/Automattic/mongoose/issues/2901#issuecomment-431769767)\r\n\r\n### Repro Script (2901.js)\r\n```js\r\n#!/usr/bin/env node\r\n'use strict';\r\n\r\nconst assert = require('assert');\r\nconst mongoose = require('mongoose');\r\nconst { Schema, connection } = mongoose;\r\nconst DB = '2901';\r\nconst URI = `mongodb://localhost:27017/${DB}`;\r\nconst OPTS = { family: 4, useNewUrlParser: true };\r\n\r\nconst nestedSchema = new Schema({\r\n  to: Number\r\n});\r\n\r\nconst schema = new Schema({\r\n  name: String,\r\n  nested: nestedSchema\r\n});\r\n\r\nconst Test = mongoose.model('test', schema);\r\n\r\nconst test = new Test({ name: 'test1', nested: { to: 42 } });\r\n\r\nasync function run() {\r\n  assert.strictEqual(mongoose.version, '5.3.5');\r\n  await mongoose.connect(URI, OPTS);\r\n  await connection.dropDatabase();\r\n  const doc = await Test.create(test);\r\n  assert.ok(doc);\r\n\r\n  const cond = {\r\n    $or: [\r\n      { nested: { to: { $lt: 50 } } },\r\n      { name: /2$/ }\r\n    ]\r\n  };\r\n\r\n  const found = await Test.findOne(cond).catch(assert.ifError);\r\n  assert.ok(found);\r\n  assert.strictEqual(found.name, 'test1');\r\n  console.log('All Assertions Pass.');\r\n  await connection.close();\r\n}\r\n\r\nrun().catch(error);\r\n\r\nfunction error(e) {\r\n  console.error(e.message);\r\n  return connection.close();\r\n}\r\n\r\n```\r\n### Output:\r\n```\r\nissues: ./2901.js\r\nifError got unwanted exception: Cast to Number failed for value \"{ '$lt': 50 }\" at path \"to\" for model \"test\"\r\nissues:\r\n```"},{"labels":["bug"],"text":"BUG\r\n\r\n**What is the current behavior?**\r\n\r\nWe're migrating mongoose from `4.3.0` to `5.3.4` in our project and we hit a breaking change, which our system doesn't expect.\r\n\r\nIf you have a nested document with a property with default value, and in the DB the document doesn't have this property set - the default value is not populated when `find/findOne` the document from the DB with a `select` statement. If you don't use a `select` statement, it works as expected and the property is populated with the default value.\r\n\r\nThe case is for documents, which are stored already without the `default` values and the `default` value is added to the schema at a later stage.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n\r\nI've used as a base the `model.field.selection.test.js` file and changed it to isolate and reproduce the case:\r\n\r\n```\r\nbefore(function () {\r\n    const CalendarSchema = new Schema({\r\n      dateFormat: {\r\n        type: String,\r\n        default: 'dd/MM/yyyy'\r\n      },\r\n      culture: {\r\n        type: String,\r\n        default: 'en-gb'\r\n      }\r\n    }, {\r\n      _id: false,\r\n      minimize: false\r\n    });\r\n    modelName = 'CalendarSchema';\r\n\r\n    const SettingsSchema = new Schema({\r\n      calendar: {\r\n        type: CalendarSchema,\r\n        default: {}\r\n      }\r\n    }, {\r\n      _id: false,\r\n      minimize: false\r\n    });\r\n\r\n    modelName = 'SettingsSchema';\r\n    mongoose.model(modelName, SettingsSchema);\r\n\r\n    BlogPostB = new Schema({\r\n      title: String,\r\n      author: String,\r\n      settings: {\r\n        type: SettingsSchema,\r\n        default: {}\r\n      }\r\n    }, { minimize: false });\r\n\r\n    modelName = 'model.select.blogpost';\r\n    mongoose.model(modelName, BlogPostB);\r\n    collection = 'blogposts_' + random();\r\n    db = start();\r\n  });\r\n\r\n  after(function (done) {\r\n    db.close(done);\r\n  });\r\n\r\nit.only('excluded fields should be undefined', async function (done) {\r\n    const BlogPostB = db.model(modelName, collection);\r\n\r\n    const doc = {\r\n      title: 'subset 1',\r\n      author: 'me',\r\n      settings: {\r\n        calendar: {\r\n          dateFormat: '1234'\r\n        }\r\n      }\r\n    };\r\n\r\n    const query = {\r\n      author: 'me'\r\n    };\r\n    await BlogPostB.create(doc);\r\n\r\n    await BlogPostB.update(\r\n      query, {\r\n        $unset: {\r\n          'settings.calendar.culture': \"\"\r\n        }\r\n      }\r\n    );\r\n    const withoutSelect = await BlogPostB.findOne(query).exec();\r\n    const withSelect = await BlogPostB.findOne(query).select('settings title').exec();\r\n\r\n    assert.strictEqual('en-gb', withoutSelect.settings.calendar.culture);\r\n    assert.strictEqual('1234', withoutSelect.settings.calendar.dateFormat);\r\n    assert.strictEqual('1234', withSelect.settings.calendar.dateFormat);\r\n    assert.strictEqual('en-gb', withSelect.settings.calendar.culture);\r\n\r\n    done();\r\n  });\r\n```\r\n\r\nI am `unsetting` the `settings.calendar.culture` because when you save the document, the default value is persisted and I want to setup a Document which doesn't have the field set (like when you have existing documents saved and you add a new property with default value to the schema).\r\n\r\nWithout the `select` statement it works and is populated as expected, with the `select` statement it doesn't populate the default value.\r\n\r\n**What is the expected behavior?**\r\n\r\nIn both cases the `settings.calendar.culture` should be set the default value `en-gb`.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nnode.js: v8.9.3\r\nmongoose: tested in 5.3.5-pre and 5.3.4\r\nMongoDB: 3.4.10"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nbug\r\n**What is the current behavior?**\r\nSince 5.3.2 I can't use custom types, nor by class neither by function for my custom mongoose instance (fix(mongoose): isolate Schema.Types between custom Mongoose instances #6933)\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n\r\n\"use strict\";\r\nconst mongoose = require(\"mongoose\");\r\nconst assert = require(\"assert\");\r\nconst db = new mongoose.Mongoose();\r\nconst {Schema} = db;\r\ndb.connect(\"mongodb://localhost/test\").then(()=>{\r\n    function Int8(key, options) {\r\n        db.SchemaType.call(this, key, options, \"Int8\");\r\n    }\r\n    Int8.prototype = Object.create(db.SchemaType.prototype);\r\n\r\n    // `cast()` takes a parameter that can be anything. You need to\r\n    // validate the provided `val` and throw a `CastError` if you\r\n    // can't convert it.\r\n    Int8.prototype.cast = function(val) {\r\n        var _val = Number(val);\r\n        if (isNaN(_val)) {\r\n\t    throw new Error(\"Int8: \" + val + \" is not a number\");\r\n        }\r\n        _val = Math.round(_val);\r\n        if (_val < -0x80 || _val > 0x7F) {\r\n\t    throw new Error(\"Int8: \" + val +\r\n\t\t\" is outside of the range of valid 8-bit ints\");\r\n        }\r\n        return _val;\r\n    };\r\n\r\n    // Don't forget to add `Int8` to the type registry\r\n    db.Schema.Types.Int8 = Int8;\r\n\r\n    var testSchema = new Schema({ test: Int8 });\r\n    var Test = db.model(\"CustomTypeExample\", testSchema);\r\n\r\n    var t = new Test();\r\n    t.test = \"abc\";\r\n    console.log(t.validateSync());\r\n    assert.equal(1,1);\r\n    assert.ok(t.validateSync());\r\n    assert.equal(t.validateSync().errors[\"test\"].name, \"CastError\");\r\n    assert.equal(t.validateSync().errors[\"test\"].message,\r\n        \"Cast to Int8 failed for value \\\"abc\\\" at path \\\"test\\\"\");\r\n    assert.equal(t.validateSync().errors[\"test\"].reason.message,\r\n        \"Int8: abc is not a number\");\r\n});\r\n\r\n\r\n**What is the expected behavior?**\r\nIt does not work with \"Int8\" nor Int8 as type, my custom types are built around this example, so if this doesn't work neither my code.\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nnode 10.12.0\r\nMongoDB shell version v4.0.2\r\ngit version: fc1573ba18aee42f97a3bb13b67af7d837826b47\r\nOpenSSL version: OpenSSL 1.1.0f  25 May 2017\r\nallocator: tcmalloc\r\nmodules: none\r\nbuild environment:\r\n    distmod: debian92\r\n    distarch: x86_64\r\n    target_arch: x86_64\r\nmongoose since 5.3.2"},{"labels":["bug"],"text":"I'm using replaceOne() for the first time and timestamps are being stripped and not added to the document even though the Schema specifies the timestamps property:\r\n\r\n     await RestModel.replaceOne({_id: rest.id}, rest.toObject()).exec();\r\n\r\nI would expect Mongoose/MongoDB to respect this setting and properly update createdAt and updatedAt fields.\r\n\r\nUsing Mongoose 5.3.4, MongoDB 3.6.6, Typegoose 5.4.1, Typescript 3.1.1, and Node 10.11.0 on Mac OS X Mojave.\r\n"},{"labels":["bug"],"text":"I'll try to create a reproduction but in the meantime: while upgrading mongoose from version 5.1.x to 5.3.x one of our tests started to fail, I went through all the minor versions and found that it started to happen in 5.2.7\r\n\r\nThe test is the following:\r\n\r\n```\r\n  it('requires custom id to be a uuid', async () => {\r\n    body.id = 'not-a-uuid';\r\n\r\n    await expect(user.post('/user/webhook', body)).to.eventually.be.rejected.and.eql({\r\n      code: 400,\r\n      error: 'BadRequest',\r\n      message: 'User validation failed',\r\n    });\r\n  });\r\n```\r\n\r\nIt looks like that this custom validation isn't being run correctly:\r\n\r\n```\r\nexport let schema = new Schema({\r\n  id: {\r\n    type: String,\r\n    required: true,\r\n    validate: [validator.isUUID, shared.i18n.t('invalidWebhookId')],\r\n    default: uuid,\r\n  },\r\n...\r\n```\r\n\r\nThe document (a sub-document) is validated correctly and created with an `id` set to `not-a-uuid`"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBug\r\n\r\n**What is the current behavior?**\r\n\r\nExecuting replaceOne with a subdocument array of strings results in saving an array of null items instead.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nSteps to reproduce:\r\n\r\n```\r\nconst mongoose = require('mongoose');\r\nmongoose.connect('mongodb://localhost/bug-reports', {useNewUrlParser: true});\r\n\r\nconst key = 'A';\r\n\r\nconst Schema = new mongoose.Schema({\r\n    key: {\r\n        type: String\r\n    },\r\n    items: {\r\n        type: [String],\r\n        default: []\r\n    }\r\n}, {\r\n    collection: 'report-181016'\r\n});\r\n\r\nconst Record = mongoose.model('Record', Schema);\r\n\r\nconst record = {\r\n    key,\r\n    items: ['A', 'B', 'C']\r\n};\r\n\r\n(async () => {\r\n    try {\r\n        const result = await Record.replaceOne({key}, record, {upsert: true});\r\n        console.log('Replace one result', result);\r\n        const fetchedRecord = await Record.findOne({key}).exec();\r\n        console.log('Fetched record', fetchedRecord);\r\n        process.exit(0);\r\n    } catch (err) {\r\n        console.log('Err', err);\r\n        process.exit(1);\r\n    }\r\n})();\r\n```\r\n\r\nResult:\r\n```\r\nReplace one result { n: 1, nModified: 1, ok: 1 }\r\nFetched record { items: [ null, null, null ],\r\n  _id: 5bc637dbe6188e82a318ba00,\r\n  key: 'A' }\r\n```\r\n\r\n\r\n**What is the expected behavior?**\r\n\r\nreplaceOne should save the subdocument array of strings correctly.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\n\r\nnode: 8.9.4\r\nmongoose: 5.3.4\r\nmongodb: 3.6.8\r\n"},{"labels":["bug"],"text":"```javascript\r\nconst assert = require('assert');\r\nconst mongoose = require('mongoose');\r\n\r\nconsole.log(mongoose.version);\r\n\r\nconst GITHUB_ISSUE = `gh6984`;\r\nconst connectionString = `mongodb://localhost:27017/${ GITHUB_ISSUE }`;\r\nconst { Schema } = mongoose;\r\n\r\nrun().then(() => console.log('done')).catch(error => console.error(error.stack));\r\n\r\nasync function run() {\r\n  await mongoose.connect(connectionString);\r\n  await mongoose.connection.dropDatabase();\r\n\r\n  const schema = new Schema({ error: mongoose.Schema.Types.Mixed, name: { type: String, required: true } });\r\n\r\n  const Model = mongoose.model('Test', schema);\r\n\r\n  const doc = new Model();\r\n\r\n  const error = await doc.validate().catch(error => error);\r\n\r\n  doc.name = 'foo';\r\n  doc.error = error;\r\n\r\n  await doc.save();\r\n\r\n  console.log(await Model.findOne());\r\n}\r\n```\r\n\r\nThis throws \"Error: key $isValidatorError must not start with '$'\""},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBug.\r\n\r\n**What is the current behavior?**\r\n\r\n```js\r\nconst Account = new mongoose.Schema({\r\n  balance: Number,\r\n});\r\n\r\nconst Schema = new mongoose.Schema({\r\n  accounts: {type: Map, of: Account},\r\n});\r\n\r\nconst User = mongoose.model('User', Schema);\r\n\r\n(async () => {\r\n  await User.update(\r\n    {},\r\n    {accounts: {'USD': {balance: 100}}});\r\n})();\r\n```\r\n\r\n```js\r\nTypeError: Cannot read property 'selected' of undefined\r\n    at Embedded.cast (node_modules/mongoose/lib/schema/embedded.js:170:47)\r\n    at Embedded.SchemaType.applySetters (node_modules/mongoose/lib/schematype.js:757:12)\r\n    at Map.set (node_modules/mongoose/lib/types/map.js:60:11)\r\n    at Map.$__runDeferred (node_modules/mongoose/lib/types/map.js:104:12)\r\n    at new MongooseMap (node_modules/mongoose/lib/types/map.js:21:10)\r\n    at SchemaMap.cast (node_modules/mongoose/lib/schema/map.js:25:12)\r\n    at SchemaMap.SchemaType.applySetters (node_modules/mongoose/lib/schematype.js:757:12)\r\n    at SchemaMap.SchemaType._castForQuery (node_modules/mongoose/lib/schematype.js:1143:15)\r\n    at SchemaMap.SchemaType.castForQuery (node_modules/mongoose/lib/schematype.js:1133:15)\r\n    at SchemaMap.SchemaType.castForQueryWrapper (node_modules/mongoose/lib/schematype.js:1112:15)\r\n    at castUpdateVal (node_modules/mongoose/lib/helpers/query/castUpdate.js:411:19)\r\n    at walkUpdatePath (node_modules/mongoose/lib/helpers/query/castUpdate.js:180:22)\r\n    at castUpdate (node_modules/mongoose/lib/helpers/query/castUpdate.js:79:18)\r\n    at model.Query._castUpdate (node_modules/mongoose/lib/query.js:3852:10)\r\n    at castDoc (node_modules/mongoose/lib/query.js:3880:18)\r\n    at model.Query._updateThunk (node_modules/mongoose/lib/query.js:3235:17)\r\n    at model.Query.Query._execUpdate (node_modules/mongoose/lib/query.js:3296:23)\r\n    at process.nextTick (node_modules/kareem/index.js:369:33)\r\n```\r\n\r\n**What is the expected behavior?**\r\n\r\nLook like invalid number of arguments passed to `castUpdateVal()` in `lib/helpers/query/castUpdate.js`.\r\n```js\r\nobj[key] = castUpdateVal(schematype, val, op, context, prefix + key);\r\n...\r\nfunction castUpdateVal(schema, val, op, $conditional, context, path) {\r\n...\r\n```\r\n`context` is string instead of Query in result.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\n\r\n```\r\nnode v10.11.0\r\nmongoose@5.3.2\r\n```"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nReport a bug\r\n\r\n**What is the current behavior?**\r\nThe documentation for mongoose schema types [states that for mixed schema types](https://mongoosejs.com/docs/schematypes.html):\r\n\r\n> Mixed\r\n> An \"anything goes\" SchemaType, its flexibility comes at a trade-off of it being harder to maintain. Mixed is available either through Schema.Types.Mixed or by passing an empty object literal. The following are equivalent:\r\n> \r\n> var Any = new Schema({ any: {} });\r\n> var Any = new Schema({ any: Object });\r\n> var Any = new Schema({ any: Schema.Types.Mixed });\r\n\r\nI'm working with a document schemaType which goes like this,\r\n\r\n```\r\nconst myDocSchema = new mongoose.Schema(\r\n{\r\n   ...\r\n    'AField' : [ Object ],\r\n   ...\r\n})\r\n```\r\n\r\nWhen doing, after a `myDocSchema.findById(...)`\r\n\r\n```\r\nmyDocSchemaInstance.AField = ArrayOfValidThings\r\n```\r\n\r\nI get an error,\r\n\r\n```\r\n{ ValidationError: Student validation failed: AField: Cast to Array failed for value \"[ { field: 'value' } ]\" at path \"AField\"\r\n    at ValidationError.inspect (/home/daniel/Sandbox/student_api_mongodb/node_modules/mongoose/lib/error/validation.js:59:24)\r\n    at formatValue (util.js:400:38)\r\n    at inspect (util.js:294:10)\r\n    at format (util.js:161:12)\r\n    at Console.log (console.js:130:21)\r\n    at putStudentByID (/home/daniel/Sandbox/student_api_mongodb/routes/students.js:305:17)\r\n    at <anonymous>\r\n    at process._tickDomainCallback (internal/process/next_tick.js:228:7)\r\n  errors: \r\n   { AFiel: \r\n      { CastError: Cast to Array failed for value \"[ { field: 'value' } ]\" at path \"AField\"\r\n    at new CastError (/home/daniel/Sandbox/student_api_mongodb/node_modules/mongoose/lib/error/cast.js:29:11)\r\n    at model.$set (/home/daniel/Sandbox/student_api_mongodb/node_modules/mongoose/lib/document.js:931:7)\r\n    at model.set [as AField] (/home/daniel/Sandbox/student_api_mongodb/node_modules/mongoose/lib/helpers/document/compile.js:124:26)\r\n    at putStudentByID (/home/daniel/Sandbox/student_api_mongodb/routes/students.js:290:31)\r\n    at <anonymous>\r\n    at process._tickDomainCallback (internal/process/next_tick.js:228:7)\r\n        message: 'Cast to Array failed for value \"[ { field: \\'value\\' } ]\" at path \"AField\"',\r\n        name: 'CastError',\r\n        stringValue: '\"[ { field: \\'value\\' } ]\"',\r\n        kind: 'Array',\r\n        value: [Array],\r\n        path: 'AField',\r\n        reason: [Object] } \r\n```\r\n\r\n\r\n unless I change the schema to \r\n\r\n```\r\nconst myDocSchema = new mongoose.Schema(\r\n{\r\n   ...\r\n    'AField' : [ Schema.Types.Mixed ],\r\n   ...\r\n})\r\n```\r\nSo the operation\r\n```\r\nmyDocSchemaInstance.AField = ArrayOfValidThings\r\n```\r\nworks as expected, updating the underlying array of Objects\r\n\r\n**What is the expected behavior?**\r\nUpdate the underlying array of object\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\n* NodeJS 8.10 with NVM 0.33.11\r\n* mongoose 5.2.13\r\n* Mongo v3.6.5\r\n\r\nIs this a bug or I did something wrong?"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nRunning an update command against a double nested array when the parent schema uses timestamps throws an exception `TypeError: Cannot read property 'schema' of undefined` The bug appeared in version 5.3.0.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```\r\n      const subSub = new Schema({\r\n        x: String\r\n      });\r\n\r\n      const sub = new Schema({\r\n        name: String,\r\n        subArr: [subSub]\r\n      });\r\n\r\n      const schema = new Schema({\r\n        name: String,\r\n        arr: [sub]\r\n      }, { timestamps: true });\r\n\r\n      const Test = db.model('gh6532', schema);\r\n\r\n      const test = {\r\n        name: 'Xyz',\r\n        arr: [{\r\n          name: 'abc',\r\n          subArr: [{ x: 'a' }]\r\n        }]\r\n      };\r\n\r\n      const cond = { name: 'Xyz', arr: { $elemMatch: { name: 'abc' } } };\r\n      const set = { $set: { 'arr.$.subArr': [{ x: 'b' }] } };\r\n\r\n      Test.create(test).\r\n        then(function() {\r\n          return Test.updateOne(cond, set);\r\n        }).\r\n        then(function() {\r\n          return Test.collection.findOne({});\r\n        }).\r\n        then(function(found) {\r\n          assert.ok(Array.isArray(found.arr));\r\n          assert.strictEqual(found.arr[0].subArr[0].x, 'b');\r\n          done();\r\n        }).\r\n        catch(done);\r\n```\r\n\r\n**What is the expected behavior?**\r\nThe update doesn't throw an exception\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNode 10.11.0, Mongoose 5.3.2, MongoDB 4.0.2\r\n"},{"labels":["bug"],"text":"I just updated from 5.2.17 to 5.3.1 and the `strict: 'throw'` schema option stopped working.\r\n\r\nRepro script:\r\n\r\n```js\r\n#!/usr/bin/env node\r\n(async function () {\r\n  const mongoose = require('mongoose');\r\n  mongoose.connect('mongodb://localhost:27017/test', {useNewUrlParser: true});\r\n\r\n  mongoose.plugin((schema) => {\r\n    schema.options.strict = 'throw';\r\n    schema.options.strictQuery = 'throw';\r\n  });\r\n\r\n  const schema = new mongoose.Schema({\r\n    nested: {\r\n      type: new mongoose.Schema({\r\n        _id: false,\r\n        someProp: {\r\n          type: Boolean,\r\n          default: false,\r\n          required: true\r\n        }\r\n      }),\r\n      default: null\r\n    }\r\n  });\r\n  const Model = mongoose.model('model', schema);\r\n\r\n  const doc1 = new Model();\r\n  doc1.nested = {\r\n    someProp: false\r\n  };\r\n  console.log(doc1.validateSync()); // no error\r\n\r\n  const doc2 = new Model();\r\n  doc2.nested = {\r\n    someProp: false,\r\n    somethingExtra: false\r\n  };\r\n  console.log(doc2.validateSync()); // no error, but it should FAIL\r\n})();\r\n```\r\n\r\nOn mongoose 5.2.17 it correctly produces validation error for `doc2`.\r\nOn mongoose 5.3.1 validation succeeds in both scenarios."},{"labels":["bug"],"text":"Mongodb: **3.6.5**, Mongoose: **5.3.1**, Node Driver: **3.1.6**\r\n\r\nAs per the docs `onFail()` helper function should throw when nothing is found (or done in the case of update/delete) but if it matches on a document should return it right? It seems that just adding it to a working query with a valid `_id` it would make the query output `undefined`:\r\n\r\nSchema:\r\n```\r\nconst mongoose = require('mongoose');\r\nconst Schema = mongoose.Schema;\r\n\r\nvar AuthorSchema = new Schema({\r\n  email: {\r\n    type: String,\r\n    lowercase: true,\r\n    required: true\r\n  })\r\nmodule.exports = mongoose.model('Author', AuthorSchema)\r\n```\r\n\r\nRunning this then:\r\n```\r\nvar mongoose = require('mongoose');\r\nvar A = require('./models/author');\r\n\r\nvar r = A.findOne({ _id: mongoose.Types.ObjectId(\"5bb5806083512515c9dd88af\")})\r\n   .then(x => console.log('result', x))\r\n```\r\n\r\nWould return the **expected model as x**. However:\r\n\r\n```\r\nvar r = A.findOne({ _id: mongoose.Types.ObjectId(\"5bb5806083512515c9dd88af\")})\r\n   .orFail()\r\n   .then(x => console.log('result', x))\r\n```\r\n\r\nWould output **undefined**. Same happens if we use `.exec()`."},{"labels":["bug"],"text":"BUG\r\n\r\n**What is the current behavior?**\r\nWhat I sent to mongoose:\r\n```\r\n[ { updateOne:{\r\n    \"filter\":{\"_id\":\"5bb76e2c1fd572394cfb31d4\"},\r\n     \"upsert\": false,\r\n     \"update\":{ \"weekProcessedData.3.0\":23.0000000001485}\r\n  },\r\n  { updateOne: {\r\n      \"filter\":{\"_id\":\"5bb76e2c1fd572394cfb31df\"},\r\n      \"upsert\":false,\r\n      \"update\":{\"weekProcessedData.3.0\":22.500000000145267}\r\n   },\r\n   {updateOne: {\r\n     \"filter\":{\"_id\":\"5bb76e2c1fd572394cfb31ec\"},\r\n     \"upsert\":false,\r\n     \"update\":{\"weekProcessedData.3.0\":22.500000000145267}\r\n   }\r\n]\r\n```\r\nWhat mongoose sent to MongoDB\r\n```\r\nMongoose: pointdatas.bulkWrite([ { updateOne: { filter: { _id: 5bb76e2c1fd572394cfb31d4 }, update: { '$set': { 'weekProcessedData.3.0': [ 23.0000000001485 ] } }, upsert: false } }, { updateOne: { filter: { _id: 5bb76e2c1fd572394cfb31df }, update: { '$set': { 'weekProcessedData.3.0': [ 22.500000000145267 ] } }, upsert: false } }, { updateOne: { filter: { _id: 5bb76e2c1fd572394cfb31ec }, update: { '$set': { 'weekProcessedData.3.0': [ 22.500000000145267 ] } }, upsert: false } } ], { ordered: false })\r\n```\r\n\r\nThe set value should be a number not an array containing the number.\r\nin the Schema weekProcessedData is an object with 7 fixed keys 1..7 and each key contains an array of 1440 positions.\r\n\r\nthe update should set a value for the specified position ( in this case the position 0 ). \r\nBut instead it converts the value to an array containing the value and save it. Tested in the mongo shell works perfectly.\r\n\r\n\r\n**What is the expected behavior?**\r\nIt's expected to send to the mongoDB whatever I put in the value and no to convert it to an array on it's own.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNode.js v6.9.5\r\nmongoose: 5.3.1\r\nMongoDB 3.6"},{"labels":["bug"],"text":"Mongodb: 4.0.0, Mongoose: 5.3.0.\r\nThe $set part never udpates anything in my docs when I use updateMany (or simple update) with arrayFields and $[<identifier>].\r\nSchema:\r\n```\r\nexport const TableBookingSchema = new Schema({\r\ntables: {\r\n        type: [\r\n            {\r\n                tableID: String,\r\n                numberOfChairs: Number,\r\n                reserved: Boolean,\r\n                location: String,\r\n                inDoors: Boolean,\r\n                reservedDuring: [\r\n                    {\r\n                        reservedFrom: Date,\r\n                        reservedTo: Date,\r\n                        reservedFor: {\r\n                            type: mongoose.Schema.Types.ObjectId,\r\n                            ref: 'Consumer'\r\n                        }\r\n                    }\r\n                ]\r\n            }\r\n        ],\r\n        required: false\r\n    },\r\n});\r\n\r\ninterface ITableBooking extends mongoose.Document {\r\ntables: any[];\r\n}\r\n\r\nexport const TableBooking = mongoose.model<ITableBooking>('TableBooking', TableBookingSchema);\r\n\r\n```\r\nupdate function:\r\n`TableBooking.updateMany({}, {\r\n    '$set': {\r\n        'tables.$[].reservedDuring.$[arr].reservedFrom': Date.now()\r\n    }\r\n}, { arrayFilters: [{\r\n        'arr.reservedFrom': { $gte: Date.now() }\r\n    }],\r\n    multi: true\r\n}, ).then(function (doc)){}`\r\n\r\n**The result is: {\"n\":2,\"nModified\":0,\"ok\":1}.** For some reason no matter which array element I want to update (reservedFrom, reservedTo, reservedFor), nothing ever changes, even tough I have 2 docs that meet the conditions in the arrayFilters section. \r\nSorry in advance if I missed something."},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\n\r\nA bug, I guess.\r\n\r\n**What is the current behavior?**\r\n\r\n`doc.modifiedPaths()` returns that paths have been modified (even if they didn't) on models that have nested schemas. What is also interesting: it works completely fine when i don't do `type: ChildSchema` and just embed the schema inline.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```js\r\nconst BarSchema = new Schema(\r\n  {\r\n    bar: {\r\n      type: String\r\n    }\r\n  },\r\n  { _id: false }\r\n);\r\n\r\nconst FooNestedSchema = new Schema({\r\n  foo: {\r\n    type: BarSchema\r\n  }\r\n});\r\n\r\nconst FooSchema = new Schema({\r\n  foo: {\r\n    bar: {\r\n      type: String\r\n    }\r\n  }\r\n});\r\n\r\nconst FooNested = mongoose.model('fooNested', FooNestedSchema);\r\nconst fooNested = new FooNested({ foo: { bar: 'value' } });\r\n\r\nconst Foo = mongoose.model('foo', FooSchema);\r\nconst foo = new Foo({ foo: { bar: 'value' } });\r\n\r\n(async () => {\r\n  await fooNested.save();\r\n  await foo.save();\r\n\r\n  fooNested.set({ foo: { bar: 'value' } });\r\n  foo.set({ foo: { bar: 'value' } });\r\n\r\n  fooNested.modifiedPaths(); // WRONG: [ 'foo', 'foo.bar' ]\r\n  foo.modifiedPaths(); // CORRECT: []\r\n})();\r\n```\r\n\r\n**What is the expected behavior?**\r\n\r\nIt would be a lot less confusing if both examples would behave the same.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\n\r\n- Node.js: 10.9.0\r\n- Mongoose: 5.2.17\r\n\r\n**Additional info**\r\n\r\nIs there any workaround for this issue? Can I somehow manually check for equality on a saved document? `schema.pre('validate', () => {})` gives me only access to the already changed document, which is already a bummer. Any ideas?"},{"labels":["bug"],"text":"Hey there. I am submitting a supposed **BUG** report.\r\n\r\n**BEHAVIOR**\r\nIt looks like the fix for #6980 introduced a bug when updating documents with timestamps. This is a stack trace of the issue:\r\n\r\n```\r\nTypeError: Cannot read property '$set' of undefined\r\nat applyTimestampsToUpdate (/usr/src/app/node_modules/mongoose/lib/helpers/update/applyTimestampsToUpdate.js:41)\r\nat model.Query._setTimestampsOnUpdate (schema.js:873)\r\nat callMiddlewareFunction (/usr/src/app/node_modules/kareem/index.js:427)\r\nat next (/usr/src/app/node_modules/kareem/index.js:58)\r\nat Kareem.execPre (/usr/src/app/node_modules/kareem/index.js:86)\r\nat Kareem.wrap (/usr/src/app/node_modules/kareem/index.js:265)\r\nat model.Query._findOneAndUpdate (index.js:339)\r\nat model.Query.Query.findOneAndUpdate (query.js:2658)\r\nat utils.promiseOrCallback (query.js:3652)\r\nat Promise (/usr/src/app/node_modules/mongoose/lib/utils.js:246)\r\nat Promise (<anonymous>)\r\nat Object.promiseOrCallback (/usr/src/app/node_modules/mongoose/lib/utils.js:245)\r\nat model.Query.exec (query.js:3646)\r\nat model.Query.Query.then (query.js:3673)\r\n```\r\nI had limited time to test, but it appears that it's happening when calling \r\n\r\n```js\r\nModel.findOneAndUpdate({\r\n        _id: 'someId' // <-- normal, correct query\r\n    }, \r\n    undefined,\r\n    {new: true}\r\n});\r\n```\r\n\r\nNotice that the update object is `undefined`. We've corrected our code for that, but it might catch other people off guard.\r\n\r\n**EXPECTED BEHAVIOR**\r\nMongoose doesn't throw an error if no update object is passed.\r\n\r\n**MONGOOSE VERSION(S)**\r\nCan reproduce in mongoose 5.2.16 and 5.2.17. Cannot reproduce it in 5.2.15."},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBug\r\n\r\n**What is the current behavior?**\r\n\r\nWhen using findByIdAndUpdate() or findOneAndUpdate() with the `upsert` option, a `__v` key, and `$unset`, the following error is thrown:\r\n```\r\nMongoError: Updating the path '__v' would create a conflict at '__v'\r\n    at ~/mongoose-test/node_modules/mongodb-core/lib/connection/pool.js:581:63\r\n```\r\nThis bug appears similar to #5973 which is supposed to have been fixed. As far as I can tell, the difference here is that in this case the `$unset` key is being used.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n\r\n```javascript\r\nconst mongoose = require('mongoose');\r\nmongoose.Promise = global.Promise;\r\n\r\nconst GITHUB_ISSUE = `gh-7003`;\r\nconst connectionString = `mongodb://localhost:27017/${ GITHUB_ISSUE }`;\r\n\r\nrun().catch(error => console.error(error.stack));\r\n\r\nasync function run() {\r\n  await mongoose.connect(connectionString);\r\n  const schema = new mongoose.Schema({ name: String, description: String });\r\n  const Model = mongoose.model('Model', schema);\r\n  const doc = await Model.create({ name: 'test', description: 'we want to unset this description later' });\r\n  await Model.findByIdAndUpdate(doc._id, {\r\n    '$unset': { description: '' },\r\n    __v: 0,\r\n    name: 'update'\r\n  }, { upsert: true });\r\n  console.log('updated __v');\r\n}\r\n```\r\nWhen running this script, an error is thrown before the console.log.\r\n\r\n**What is the expected behavior?**\r\n\r\nThe record should update without at error. Remove either `__v`, `$unset`, or the `upsert` option from the example and it works as expected.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\n\r\nNode.js: v10.9.0\r\nMongoose: v5.2.14\r\nMongoDB: v3.6.3 (with setFeatureCompatibilityVersion: 3.6)"},{"labels":["bug"],"text":"**Current Behavior:** Mongoose fails creating a new document with an array of maps. `CastError: Cast to [undefined] failed for value \"[{\"a\":\"1\"}]\" at path \"val\"`. Not sure if expected behavior?\r\n\r\n**Repro Script:**\r\n\r\n```javascript\r\nconst mongoose = require('mongoose');\r\nmongoose.Promise = Promise;\r\nmongoose.connect('mongodb://localhost:27017/test', { useNewUrlParser: true });\r\nconst { Schema } = mongoose;\r\n\r\nconst ArrMapSchema = new Schema({\r\n    val: [Map],\r\n});\r\n\r\nmongoose.model('ArrMap', ArrMapSchema);\r\n\r\nconst ArrMap = mongoose.model('ArrMap');\r\n\r\nArrMap.create({\r\n    val: [{'a': '1'}],\r\n}).catch(error => console.log(error.errors.val.reason));\r\n```\r\n\r\n**Expected Behavior**\r\n\r\nDocument should create successfully and look like\r\n```\r\n{\r\n  val: [{'a': '1'}]\r\n}\r\n```\r\n\r\n**Versions**\r\n```\r\nnode --version         v8.11.3\r\nmongoose@5.2.13\r\ndb.version()            3.6.5\r\n```\r\n\r\nFull Error Trace:\r\n\r\n```\r\n{ CastError: Cast to [undefined] failed for value \"[{\"a\":\"1\"}]\" at path \"val\"\r\n    at new CastError (/Users/michaelshi/Projects/caster-array-repro/node_modules/mongoose/lib/error/cast.js:29:11)\r\n    at SchemaArray.cast (/Users/michaelshi/Projects/caster-array-repro/node_modules/mongoose/lib/schema/array.js:207:15)\r\n    at SchemaArray.SchemaType.applySetters (/Users/michaelshi/Projects/caster-array-repro/node_modules/mongoose/lib/schematype.js:755:12)\r\n    at model.$set (/Users/michaelshi/Projects/caster-array-repro/node_modules/mongoose/lib/document.js:922:18)\r\n    at model._handleIndex (/Users/michaelshi/Projects/caster-array-repro/node_modules/mongoose/lib/document.js:740:14)\r\n    at model.$set (/Users/michaelshi/Projects/caster-array-repro/node_modules/mongoose/lib/document.js:697:22)\r\n    at model.Document (/Users/michaelshi/Projects/caster-array-repro/node_modules/mongoose/lib/document.js:114:12)\r\n    at model.Model (/Users/michaelshi/Projects/caster-array-repro/node_modules/mongoose/lib/model.js:72:12)\r\n    at new model (/Users/michaelshi/Projects/caster-array-repro/node_modules/mongoose/lib/model.js:4294:13)\r\n    at toExecute.push.callback (/Users/michaelshi/Projects/caster-array-repro/node_modules/mongoose/lib/model.js:2501:22)\r\n    at /Users/michaelshi/Projects/caster-array-repro/node_modules/async/internal/parallel.js:31:39\r\n    at eachOfArrayLike (/Users/michaelshi/Projects/caster-array-repro/node_modules/async/eachOf.js:65:9)\r\n    at exports.default (/Users/michaelshi/Projects/caster-array-repro/node_modules/async/eachOf.js:9:5)\r\n    at _parallel (/Users/michaelshi/Projects/caster-array-repro/node_modules/async/internal/parallel.js:30:5)\r\n    at parallelLimit (/Users/michaelshi/Projects/caster-array-repro/node_modules/async/parallel.js:88:26)\r\n    at utils.promiseOrCallback.cb (/Users/michaelshi/Projects/caster-array-repro/node_modules/mongoose/lib/model.js:2511:5)\r\n  message: 'Cast to [undefined] failed for value \"[{\"a\":\"1\"}]\" at path \"val\"',\r\n  name: 'CastError',\r\n  stringValue: '\"[{\"a\":\"1\"}]\"',\r\n  kind: '[undefined]',\r\n  value: '[{\"a\":\"1\"}]',\r\n  path: 'val',\r\n  reason: TypeError: this.caster.cast is not a function\r\n    at SchemaArray.cast (/Users/michaelshi/Projects/caster-array-repro/node_modules/mongoose/lib/schema/array.js:203:34)\r\n    at SchemaArray.SchemaType.applySetters (/Users/michaelshi/Projects/caster-array-repro/node_modules/mongoose/lib/schematype.js:755:12)\r\n    at model.$set (/Users/michaelshi/Projects/caster-array-repro/node_modules/mongoose/lib/document.js:922:18)\r\n    at model._handleIndex (/Users/michaelshi/Projects/caster-array-repro/node_modules/mongoose/lib/document.js:740:14)\r\n    at model.$set (/Users/michaelshi/Projects/caster-array-repro/node_modules/mongoose/lib/document.js:697:22)\r\n    at model.Document (/Users/michaelshi/Projects/caster-array-repro/node_modules/mongoose/lib/document.js:114:12)\r\n    at model.Model (/Users/michaelshi/Projects/caster-array-repro/node_modules/mongoose/lib/model.js:72:12)\r\n    at new model (/Users/michaelshi/Projects/caster-array-repro/node_modules/mongoose/lib/model.js:4294:13)\r\n    at toExecute.push.callback (/Users/michaelshi/Projects/caster-array-repro/node_modules/mongoose/lib/model.js:2501:22)\r\n    at /Users/michaelshi/Projects/caster-array-repro/node_modules/async/internal/parallel.js:31:39\r\n    at eachOfArrayLike (/Users/michaelshi/Projects/caster-array-repro/node_modules/async/eachOf.js:65:9)\r\n    at exports.default (/Users/michaelshi/Projects/caster-array-repro/node_modules/async/eachOf.js:9:5)\r\n    at _parallel (/Users/michaelshi/Projects/caster-array-repro/node_modules/async/internal/parallel.js:30:5)\r\n    at parallelLimit (/Users/michaelshi/Projects/caster-array-repro/node_modules/async/parallel.js:88:26)\r\n    at utils.promiseOrCallback.cb (/Users/michaelshi/Projects/caster-array-repro/node_modules/mongoose/lib/model.js:2511:5)\r\n    at Promise (/Users/michaelshi/Projects/caster-array-repro/node_modules/mongoose/lib/utils.js:246:5) }\r\n```"},{"labels":["bug"],"text":"Hello.\r\n\r\nI defined my Schema and set a virtual to it's properties without specify the JustOne Option.\r\n\r\n```js\r\nmySchema = mongoose.Schema({fieldOne, fieldTwo})\r\n\r\nmySchema = .virtual('fieldVirtual', {\r\n  ref: 'AnotherModel',\r\n  localField: 'fieldTwo',\r\n  foreignField: '_id'\r\n})\r\n```\r\n\r\nAccording to the documentation default value for JustOne is *false* therefore we expect the\r\nresult of my Virtual field to be an Array, but it's returning an Object.\r\n\r\nMy conclusion is that this line overwrites the default expected behavior of the justOne Option.\r\nhttps://github.com/Automattic/mongoose/blob/master/lib/model.js#L3827. Look the **false** condition is being forced.\r\n\r\n\r\nLibraries version:\r\nMongoose: 5.2.13\r\nMongodb: 3.1.4\r\nNodeJS: v8.9.0"},{"labels":["bug"],"text":"Critical Bug (for us at least)\r\n\r\nWe've been using version mongoose 5.0.16 with no issues, We just upgraded to 5.2.13 and all hell has broken loose, not sure what the change is (i'm still looking through the diffs)\r\n\r\nIf we have a document like this and we call Model.populate on it\r\n```\r\n\r\n//Example document\r\nvar myDocument = {\r\n\t\"title\":\"something\",\r\n\t\"articles\":[\r\n\t\t\"5b6a2ab047b5883e44b27814\",\r\n\t\t\"5b6a2ab047b5883e44b27813\",\r\n\t\t\"5b6a2ab047b5883e44b27813\",\r\n\t\t\"5b6a2ab047b5883e44b27813\",\r\n\t\t\"5b6a2ab047b5883e44b27813\",\r\n\t\t]\r\n}\r\n\r\n\r\n//Populate the articles\r\nNode.populate(myDocument, {\r\n\tselect:'title',\r\n\tpath:'articles',\r\n\toptions:{\r\n\t\tlean:true\r\n\t}\r\n}, function(err, populated) {\r\n\r\n              \r\n});\r\n\r\n\r\n//myDocument now looks like this (it's converted an array into an object)\r\nvar myDocument = {\r\n\t\"title\":\"something\",\r\n\t\"articles\":{\r\n\t\t\"_id\":\"5b6a2ab047b5883e44b27814\",\r\n\t\t\"title\":\"title\",\r\n\t}\r\n}\r\n\r\n```\r\n\r\nExpected behaviour is this\r\n```\r\nvar myDocument = {\r\n\t\"title\":\"something\",\r\n\t\"articles\":[\r\n\t\t {\r\n\t\t\t\"_id\":\"5b6a2ab047b5883e44b27814\",\r\n\t\t\t\"title\":\"title\",\r\n\t\t},\r\n\t\t{\r\n\t\t\t\"_id\":\"5b6a2ab047b5883e44b27814\",\r\n\t\t\t\"title\":\"title\",\r\n\t\t},\r\n\t\t...\r\n\t]\r\n}\r\n```\r\n"},{"labels":["bug"],"text":"**What is the current behavior?**\r\nWhen once populates an array (eg: `comments`) and then populates a field within the array (eg: `comments.author`), populated field (`comments[x].author`) is an array.\r\n\r\n**Steps to reproduce.**\r\nFull code is in the repo: [mongoose-populate-5213-issue](https://github.com/amelon/mongoose-populate-5213-issue)\r\n\r\n**What is the expected behavior?**\r\nWhen you populate an array (eg: `comments`) and then populate a field of the array (eg: `comments.author`), populated field (`comments[x].author`) should be an object.\r\n\r\n````\r\n...\r\nasync function findPopulatedComments() {\r\n  const posts = await PostMod.find()\r\n  await PostMod.populate(posts, { path: 'comments', model: 'Comment' })\r\n  await PostMod.populate(posts, { path: 'comments.author', model: 'User' })\r\n\r\n  assert(Array.isArray(posts[0].comments[0].author) === false)\r\n}\r\n...\r\n````\r\n\r\nIt works as expected on mongoose 5.2.10.\r\n\r\n**Versions**\r\nnode: v8.9.1\r\nmongodb: v3.4.9\r\nmongoose: v5.2.13, v5.2.12, v5.2.11\r\n\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nbug\r\n\r\n**What is the current behavior?**\r\nIf we have a document with an array property and we are trying to push a new object that also contains array property using $push operator the bug will show up. \r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\nSuppose we have a document in database\r\n```\r\n{ array1 : [ ... ] }\r\n```\r\nand we want to push into array1 a new object like this:\r\n```\r\nvar toBePushedObj = { array2 : [] }\r\n```\r\nusing $push operator like this:\r\n```\r\nmodel.findByIdAndUpdate(id,{ $push: {array1:toBePushedObj}})\r\n```\r\nThe update will fail with an error message \"Cannot read property 'caster' of undefined\"\r\n\r\nHere is stack trace:\r\n```\r\n    at walkUpdatePath (/node_modules/mongoose/lib/helpers/query/castUpdate.js:264:26)\r\n    at walkUpdatePath (/node_modules/mongoose/lib/helpers/query/castUpdate.js:209:20)\r\n    at castUpdate (/node_modules/mongoose/lib/helpers/query/castUpdate.js:79:18)\r\n    at model.Query._castUpdate (/node_modules/mongoose/lib/query.js:3688:10)\r\n    at castDoc (/node_modules/mongoose/lib/query.js:3715:18)\r\n    at model.Query.Query._findAndModify (/node_modules/mongoose/lib/query.js:2941:19)\r\n    at model.Query.Query._findOneAndUpdate (/node_modules/mongoose/lib/query.js:2650:8)\r\n```\r\nI tried to somehow dig into this, I found that the local variable schematype for the array path is undefined even though the code is trying to get it from schema._getSchema(...) and getEmbeddedDiscriminatorPath(...)\r\n\r\n**What is the expected behavior?**\r\nNo bug, it should push the object into the array property\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNode: 8.11.1\r\nmongoose: 5.2.9\r\nMongoDB: 3.6.5"},{"labels":["bug"],"text":"I've found a *bug*.\r\n\r\n**Current behavior**\r\n\r\nWhen I do a POST query to my entity I am trying to trigger a mongoose hook for my subschema like this:\r\n\r\n```\r\nexport const TypeConsultationSchema: Schema = new Schema({\r\n  days: {\r\n    type: Map,\r\n    of: MySchema\r\n  },\r\n});\r\n\r\nexport const MySchema: Schema = new Schema({\r\n  updatedAt: Number,\r\n  updatedBy: Number,\r\n  field: String,\r\n});\r\n\r\nMySchema.pre('save', function(next: HookNextFunction) {\r\n   // it doesn't work\r\n});\r\n```\r\n\r\n.. it doesn't work. But if I change type in parent schema from Map to simple subschema it actually works:\r\n\r\n```\r\nexport const TypeConsultationSchema: Schema = new Schema({\r\n  days: MySchema,\r\n});\r\n\r\nexport const MySchema: Schema = new Schema({\r\n  updatedAt: Number,\r\n  updatedBy: Number,\r\n  field: String,\r\n});\r\n\r\nMySchema.pre('save', function(next: HookNextFunction) {\r\n   // it works\r\n});\r\n```\r\n\r\n\r\n**Expected behavior**\r\n\r\nWhen I do a POST query Iâ€™ll be able to do something in _pre save hook_ callback:\r\n\r\n```\r\nexport const TypeConsultationSchema: Schema = new Schema({\r\n  days: {\r\n    type: Map,\r\n    of: MySchema\r\n  },\r\n});\r\n\r\nexport const MySchema: Schema = new Schema({\r\n  updatedAt: Number,\r\n  updatedBy: Number,\r\n  field: String,\r\n});\r\n\r\nMySchema.pre('save', function(next: HookNextFunction) {\r\n   // it works\r\n});\r\n```\r\n\r\n\r\n**Versions**\r\n\r\n- Mongoose: 5.2.3\r\n- MongoDB: 4.0.1\r\n- Node.js: 10.8.0\r\n"},{"labels":["bug"],"text":"* If you set a field in a document to a valid ObjectId and then set it to an empty string, it will **not validate**\r\n* If you set a field in a subdocument to a valid ObjectId and then set it to an empty string, it'll ignore the empty string assignment, keep the old ObjectId and it will **validate**\r\n\r\nSee the repro script:\r\n\r\n```js\r\n#!/usr/bin/env node\r\n(async function () {\r\n  const mongoose = require('mongoose');\r\n  mongoose.connect('mongodb://localhost:27017/test', {useNewUrlParser: true});\r\n\r\n  const innerSchema = new mongoose.Schema({\r\n    innerField: {\r\n      type: mongoose.Schema.Types.ObjectId,\r\n      required: true\r\n    }\r\n  });\r\n\r\n  const schema = new mongoose.Schema({\r\n    field: {\r\n      type: mongoose.Schema.Types.ObjectId,\r\n      required: true\r\n    },\r\n\r\n    inner: {\r\n      type: [innerSchema]\r\n    }\r\n  });\r\n\r\n  const Model = mongoose.model('test', schema);\r\n\r\n  // This part demonstrates the normal, expected behavior\r\n  const doc1 = new Model();\r\n  doc1.field = mongoose.Types.ObjectId(); // set it to something valid first\r\n  doc1.field = ''; // now try to overwrite it\r\n  console.log('doc1: ' + doc1.validateSync()); // OK: prints a validation error\r\n\r\n  // This part will break\r\n  const doc2 = new Model();\r\n  doc2.field = mongoose.Types.ObjectId();\r\n  doc2.inner.push({\r\n    innerField: mongoose.Types.ObjectId() // set it to something valid first\r\n  });\r\n  doc2.inner[0].innerField = ''; // now try to overwrite it (value won't change)\r\n  console.log('doc2: ' + doc2.inner[0].validateSync()); // NOT OK: validates correctly\r\n})();\r\n```"},{"labels":["bug"],"text":"I've run into it accidentally, looks like a bug:\r\n\r\n```js\r\n#!/usr/bin/env node\r\n(async function () {\r\n  const mongoose = require('mongoose');\r\n  mongoose.connect('mongodb://localhost:27017/test', {useNewUrlParser: true});\r\n\r\n  const innerSchema = new mongoose.Schema({\r\n    innerField: {\r\n      type: mongoose.Schema.Types.ObjectId,\r\n      required: true\r\n    }\r\n  });\r\n\r\n  const schema = new mongoose.Schema({\r\n    inner: {\r\n      type: [innerSchema]\r\n    }\r\n  });\r\n\r\n  const Model = mongoose.model('test', schema);\r\n\r\n  const doc = new Model();\r\n  doc.inner.push({});\r\n  doc.inner[0].innerField = '';\r\n  console.log(doc.inner[0].validateSync());\r\n})();\r\n```\r\n\r\nValidation error includes the error twice and one is for an invalid path:\r\n\r\n> ValidationError: test validation failed: inner.0.innerField: Cast to ObjectID failed for value \"\" at path \"innerField\", **inner.0.inner.0.innerField**: Cast to ObjectID failed for value \"\" at path \"innerField\"\r\n\r\n(Note the invalid `inner.0.inner.0.innerField`)"},{"labels":["bug"],"text":"Any advice on trying to handle the validation on invalid query operator?\r\n\r\n``` javascript\r\n// The `amount` below is set as Number  \r\n\r\nTransaction\r\n  .find({ amount: { '$x': 42 } }) // note the intended invalid query operator here\r\n  .then(() => {\r\n    // ...\r\n  })\r\n  .catch((err) => {\r\n    console.log(err); // log below\r\n    if (err instanceof CastError) {\r\n      // handle if cast error\r\n    }\r\n\r\n    return next(err);\r\n  });\r\n```\r\nThe log is:\r\n\r\n> Error: Can't use $x with Number.\r\n> at SchemaNumber.castForQuery (/.../node_modules/mongoose/lib/schema/number.js:278:13)\r\n\r\nThe err is not an instance of CastError so I don't know how to specifically check the error above on mongoose. Currently, I set it as error 500 but I want it to change to something more specific error. Thanks!\r\n\r\nMongoose: v5.0.3\r\nNodejs: v8.9.3\r\nMongodb: v3.6.3"},{"labels":["bug"],"text":"https://gist.github.com/lineus/55daec8a5aab2217facae501286acb9c"},{"labels":["bug"],"text":"refPath items are not populated correctly in nested arrays.\r\n\r\n```js\r\n'use strict';\r\n\r\nconst mongoose = require('mongoose');\r\nmongoose.Promise = Promise\r\nconst Schema = mongoose.Schema;\r\n\r\nmongoose.connect('mongodb://localhost/test');\r\n\r\nconst UserSchema = new Schema({\r\n  name: String\r\n});\r\n\r\nconst PostSchema = new Schema({\r\n  comments: [{\r\n    references: [{\r\n      item: {\r\n        type: Schema.Types.ObjectId,\r\n        refPath: 'comments.references.kind'\r\n      },\r\n      kind: String\r\n    }]\r\n  }]\r\n});\r\n\r\nconst Post = mongoose.model('Post', PostSchema);\r\nconst User = mongoose.model('User', UserSchema);\r\n\r\nconst user = {\r\n  _id: mongoose.Types.ObjectId(),\r\n  name: 'Arnold',\r\n};\r\n\r\nconst post = {\r\n  _id: mongoose.Types.ObjectId(),\r\n  comments: [{}, { // Removing the first empty Object will populate the reference correctly\r\n    references: [{\r\n      item: user._id,\r\n      kind: 'User'\r\n    }]\r\n  }]\r\n};\r\n\r\nrun();\r\n\r\nasync function run() {\r\n  await User.remove();\r\n  await Post.remove();\r\n\r\n  await User.create(user);\r\n  await Post.create(post);\r\n\r\n  const dbPost = await Post\r\n    .findOne({\r\n      _id: post._id\r\n    })\r\n    .populate([{\r\n      path: 'comments.references.item',\r\n      select: 'name'\r\n    }])\r\n    .lean();\r\n\r\n  console.log('reference', dbPost.comments[1].references[0]);\r\n}\r\n```\r\n\r\nNode: v8.11.3\r\nMongoose: 5.2.9\r\nMongoDB: v3.6.6"},{"labels":["bug"],"text":"It appears to be a pretty serious issue, it took me a while to isolate it and come up with a repro script. It looks like calling `save()` on a document that was retrieved with `.select()` somehow affects further calls to `Model.create`.\r\n\r\n```js\r\n#!/usr/bin/env node\r\n(async function () {\r\n  try {\r\n    const mongoose = require('mongoose');\r\n    mongoose.connect('mongodb://localhost:27017/test', { useNewUrlParser: true });\r\n\r\n    // We start by creating a model that has a field that defaults to null. We also\r\n    // add a validator that will fail when that field is undefined, meaning that the\r\n    // default value didn't kick in\r\n    const schema = new mongoose.Schema({\r\n      field: {\r\n        type: String,\r\n        default: null,\r\n        required: [\r\n          function () { return this && this.field === undefined; },\r\n          'some err'\r\n        ]\r\n      }\r\n    });\r\n    const Model = mongoose.model('test', schema);\r\n\r\n    // This part is fine, it's here just to demonstrate that it works. First model\r\n    // instance will be created successfully, and if you inspect the call to `field`\r\n    // validator you'll see that it received a {_id: something, field: null} object as\r\n    // `this` so that default value was correctly applied. This is the expected behavior.\r\n    console.log('Creating instance1');\r\n    const instance1 = await Model.create({});\r\n    console.log('Instance1 created');\r\n\r\n    // This is the strange part. After doing this, the above snippet will no longer work.\r\n    // Note the call to `select()` - if you remove it, the bug isn't triggered.\r\n    console.log('Saving something');\r\n    const instance1Retrieved = await Model.findById(instance1._id).select({_id: 1});\r\n    await instance1Retrieved.save();\r\n    console.log('Something saved');\r\n\r\n    // So let's try creating a document again. This time it's going to fail,\r\n    // ValidationError will be thrown. If you inspect the call to `field` validator\r\n    // you'll notice that this time it received just a {_id: something} object,\r\n    // defaults were ignored.\r\n    console.log('Creating instance2');\r\n    const instance2 = await Model.create({});\r\n    console.log('Instance2 created');\r\n\r\n    console.log('This message won\\'t appear');\r\n  } catch (err) {\r\n    console.log(err);\r\n    process.exit(0);\r\n  }\r\n})();\r\n```"},{"labels":["bug"],"text":"I'm not sure if it's a bug or just a very surprising behavior, but here we go:\r\n\r\n```js\r\nnew mongoose.Schema({\r\n  arrayOfDocuments: {\r\n    type: [{\r\n      ...\r\n    }],\r\n    validate: {\r\n      validator: v => _.uniqBy(_.map(v, '_id'), id => id.toString()).length === v.length,\r\n      message: 'Ids have to be unique.'\r\n     }\r\n  }\r\n})\r\n```\r\n\r\nNow let's run an update query on this model:\r\n\r\n```js\r\n// validators are set to run on update\r\nawait SomeModel.findOneAndUpdate(\r\n  {_id: 'some object id'},\r\n  {$pull: {arrayOfDocuments: {_id: 'another object id'}}}\r\n);\r\n```\r\n\r\nThe above validator will be run with `{_id: 'another object id'}` as an argument - which isn't an array. I don't think this is valid, it's trying to validate a subset of document properties by passing it to an array validator."},{"labels":["bug"],"text":"Hey there!\r\n\r\nThe problem: Dynamic ref (``refPath``) is not working when I have mixed content. \r\n\r\nExample: \r\n\r\nI have a model Test with an _id as Number and a model Lesson with an _id as a String.\r\nThen, I have a Study Plan with an array of Parts and these parts have an array of Contents. \r\n\r\n```javascript\r\nconst mongoose = require('mongoose');\r\nconst db = mongoose.createConnection('mongodb://localhost:27017/dynamicRef');\r\n\r\nconst TestSchema = new mongoose.Schema({\r\n    _id: Number,\r\n    exercises: [String],\r\n  });\r\nconst LessonSchema = new mongoose.Schema({\r\n    _id: String,\r\n    url: String,\r\n  });\r\nconst StudyPlanSchema = new mongoose.Schema({\r\n    parts: [\r\n      {\r\n        title: String,\r\n        contents: [\r\n          {\r\n            item: {\r\n              type: mongoose.Schema.Types.Mixed,\r\n              refPath: 'parts.contents.kind',\r\n            },\r\n            kind: String,\r\n          },\r\n        ],\r\n      },\r\n    ],\r\n  });\r\nconst StudyPlan = db.model('StudyPlan', StudyPlanSchema);\r\nconst Test = db.model('Test', TestSchema);\r\nconst Lesson = db.model('Lesson', LessonSchema);\r\n\r\nconst test = new Test({ _id: 123, exercises: ['t1', 't2'] });\r\nconst lesson = new Lesson({ _id: 'lesson', url: 'https://youtube.com' });\r\nawait Promise.all([test.save(), lesson.save()]);\r\nconst studyPlan = new StudyPlan({\r\n    parts: [\r\n      {\r\n        title: 'Study Plan 01',\r\n        contents: [\r\n          // THIS CODE WORKS IF U COMMENT ONE OF THESE OBJECTS... IF I HAVE ONLY A TEST OR A LESSON, THE POPULATE WORKS FINE.\r\n          {\r\n            item: test._id,\r\n            kind: 'Test',\r\n          },\r\n          {\r\n            item: lesson._id,\r\n            kind: 'Lesson',\r\n          },\r\n        ],\r\n      },\r\n    ],\r\n  });\r\n\r\n  await studyPlan.save();\r\n```\r\nWhen I have a Study Plan with a TEST and a LESSON in the array, the following populate command fails.\r\n```javascript \r\nawait StudyPlan.findOne({}).populate('parts.contents.item');\r\n```\r\n`` CastError: Cast to number failed for value \"lesson\" at path \"_id\" for model \"Test\" ``\r\n\r\nPs.: This code works if you change the _id type of Test and Lesson to ``ObjectId``\r\n\r\nVersions:\r\n* mongoose 5.2.8\r\n* mongodb 4.0.1\r\n* node.js 10.6.0"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBug\r\n\r\n**What is the current behavior?**\r\n\r\n* The bug occurs when using the Populate Virtuals feature. \r\n* If the virtual field have the `justOne: true` option set, but the virtual field returns the same first item in the output result. \r\n* If i set `justOne: false` it works correctly. But it returns an array instead of single object.\r\n\r\nSummary: the `detailItem` in the second item of array have `_id` does not same with `idItem`. Data output looks like:\r\n\r\n```json\r\n\"items\":[\r\n      {\r\n         \"value\":\"1\",\r\n         \"idItem\":\"b3d379d5-8eb2-4c52-a098-7021bdc66eb6\",\r\n         \"idItemParent\":\"38d801d5-20f7-49df-b394-5afdfba6807d\",\r\n         \"_id\":\"0a65878c-d2b5-4c47-8de0-61cf65b64057\",\r\n         \"id\":\"0a65878c-d2b5-4c47-8de0-61cf65b64057\",\r\n         \"itemDetail\":{\r\n            \"_id\":\"b3d379d5-8eb2-4c52-a098-7021bdc66eb6\",\r\n            \"name\":\"DV\",\r\n            \"ghi_chu\":\"Chi phÃ­ dá»‹ch vá»¥\",\r\n            \"idItemParent\":\"38d801d5-20f7-49df-b394-5afdfba6807d\",\r\n            \"createdAt\":\"2018-08-14T17:22:48.415Z\",\r\n            \"updatedAt\":\"2018-08-14T17:22:48.415Z\",\r\n            \"id\":\"b3d379d5-8eb2-4c52-a098-7021bdc66eb6\"\r\n         }\r\n      },\r\n      {\r\n         \"value\":\"2\",\r\n         \"idItem\":\"fabbb077-5d59-4576-9fd9-97d47f2db12e\",\r\n         \"idItemParent\":\"38d801d5-20f7-49df-b394-5afdfba6807d\",\r\n         \"_id\":\"e2402c16-7d1a-4f11-95fe-76e060c36967\",\r\n         \"id\":\"e2402c16-7d1a-4f11-95fe-76e060c36967\",\r\n         \"itemDetail\":{ // here is the problem, output is same with the first item\r\n            \"_id\":\"b3d379d5-8eb2-4c52-a098-7021bdc66eb6\",  // not same `idItem`\r\n            \"code\":\"\",\r\n            \"name\":\"DV\",\r\n            \"ghi_chu\":\"Chi phÃ­ dá»‹ch vá»¥\",\r\n            \"idItemParent\":\"38d801d5-20f7-49df-b394-5afdfba6807d\",\r\n            \"createdAt\":\"2018-08-14T17:22:48.415Z\",\r\n            \"updatedAt\":\"2018-08-14T17:22:48.415Z\",\r\n            \"id\":\"b3d379d5-8eb2-4c52-a098-7021bdc66eb6\"\r\n         }\r\n      }\r\n   ],\r\n```\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\nHere are the steps:\r\n\r\n1. Define mongoose model\r\n\r\n```js\r\nvar uuid = require(\"uuid\");\r\nvar mongoose = require('mongoose');\r\n\r\nvar Schema = mongoose.Schema;\r\n\r\nvar ReportItemSchema = new Schema({\r\n    _id: {\r\n        type: String,\r\n        default: uuid.v4\r\n    },\r\n    idItem: {\r\n        type: String,\r\n        ref: 'Item'\r\n    },\r\n    idItemParent: {\r\n        type: String,\r\n        ref: 'Item'\r\n    },\r\n    value: String,\r\n    mediaType: String\r\n}, {\r\n    timestamps: true,\r\n    toJSON: {\r\n        virtuals: true\r\n    },\r\n    toObject: {\r\n        virtuals: true\r\n    }\r\n});\r\n\r\nvar ReportSchema = new Schema({\r\n    _id: {\r\n        type: String,\r\n        default: uuid.v4\r\n    },\r\n    items: [ReportItemSchema],\r\n    status: {\r\n        type: Number,\r\n        default: 0\r\n    }\r\n}, {\r\n    id: true,\r\n    timestamps: true,\r\n    toJSON: {\r\n        virtuals: true\r\n    },\r\n    toObject: {\r\n        virtuals: true\r\n    }\r\n});\r\n\r\n/**\r\n * Virtual fields definition\r\n */\r\n\r\nReportItemSchema.virtual('itemDetail', {\r\n    ref: 'Item',\r\n    localField: 'idItem',\r\n    foreignField: '_id',\r\n    justOne: true  // here is the problem\r\n});\r\n\r\nReportItemSchema.virtual('itemParent', {\r\n    ref: 'Item',\r\n    localField: 'idItemParent',\r\n    foreignField: '_id',\r\n    justOne: true\r\n});\r\n```\r\n\r\n```js\r\n// Model Item definition\r\nvar ItemSchema = new Schema({\r\n    _id: {\r\n        type: String,\r\n        default: uuid.v4\r\n    },\r\n    code: String,\r\n    name: String,\r\n    ghi_chu: String,\r\n    idItemParent: String\r\n}, {\r\n    id: true,\r\n    timestamps: true,\r\n    toJSON: {\r\n        virtuals: true\r\n    },\r\n    toObject: {\r\n        virtuals: true\r\n    }\r\n});\r\n\r\n/**\r\n * Virtual fields definition\r\n */\r\nItemSchema.virtual(\"parent\", {\r\n    ref: 'Item',\r\n    localField: 'idItemParent',\r\n    foreignField: '_id',\r\n    justOne: true\r\n}).set(function (value) {\r\n    if (value) {\r\n        this.idItemParent = value._id;\r\n    }\r\n});\r\n\r\n/**\r\n * Model definition\r\n */\r\n\r\nvar ItemModel = mongoose.model(\"Item\", ItemSchema);\r\nvar ReportModel = mongoose.model(\"Report\", ReportSchema);\r\n```\r\n\r\n2. Query data by `findOne`\r\n\r\n```js\r\n    read(req, res) {\r\n        var id = req.param('id');\r\n\r\n        this.ReportModel.findOne({\r\n                _id: id\r\n            })\r\n            .populate('items.itemDetail')\r\n            .populate('items.itemParent')\r\n            .then((doc) => {\r\n                res.ok(doc)\r\n            })\r\n            .catch((err) => {\r\n                res.error(err);\r\n            })\r\n    }\r\n```\r\n\r\n3. Data output have \r\n\r\n```json\r\n{\r\n   \"status\":0,\r\n   \"_id\":\"a6a14b80-8795-4864-9359-0b28b44fb6b9\",\r\n   \"items\":[\r\n      {\r\n         \"value\":\"1\",\r\n         \"idItem\":\"b3d379d5-8eb2-4c52-a098-7021bdc66eb6\",\r\n         \"idItemParent\":\"38d801d5-20f7-49df-b394-5afdfba6807d\",\r\n         \"_id\":\"0a65878c-d2b5-4c47-8de0-61cf65b64057\",\r\n         \"id\":\"0a65878c-d2b5-4c47-8de0-61cf65b64057\",\r\n         \"itemDetail\":{\r\n            \"_id\":\"b3d379d5-8eb2-4c52-a098-7021bdc66eb6\",\r\n            \"name\":\"DV\",\r\n            \"ghi_chu\":\"Chi phÃ­ dá»‹ch vá»¥\",\r\n            \"idItemParent\":\"38d801d5-20f7-49df-b394-5afdfba6807d\",\r\n            \"createdAt\":\"2018-08-14T17:22:48.415Z\",\r\n            \"updatedAt\":\"2018-08-14T17:22:48.415Z\",\r\n            \"__v\":0,\r\n            \"parent\":null,\r\n            \"id\":\"b3d379d5-8eb2-4c52-a098-7021bdc66eb6\"\r\n         },\r\n         \"itemParent\":{\r\n            \"_id\":\"38d801d5-20f7-49df-b394-5afdfba6807d\",\r\n            \"name\":\"Thá»‘ng kÃª chi phÃ­\",\r\n            \"ghi_chu\":\"\",\r\n            \"createdAt\":\"2018-08-14T10:26:23.878Z\",\r\n            \"updatedAt\":\"2018-08-14T10:26:23.878Z\",\r\n            \"__v\":0,\r\n            \"parent\":null,\r\n            \"id\":\"38d801d5-20f7-49df-b394-5afdfba6807d\"\r\n         }\r\n      },\r\n      {\r\n         \"value\":\"2\",\r\n         \"idItem\":\"fabbb077-5d59-4576-9fd9-97d47f2db12e\",\r\n         \"idItemParent\":\"38d801d5-20f7-49df-b394-5afdfba6807d\",\r\n         \"_id\":\"e2402c16-7d1a-4f11-95fe-76e060c36967\",\r\n         \"id\":\"e2402c16-7d1a-4f11-95fe-76e060c36967\",\r\n         \"itemDetail\":{ // here is the problem, output is same with the first item\r\n            \"_id\":\"b3d379d5-8eb2-4c52-a098-7021bdc66eb6\",\r\n            \"code\":\"\",\r\n            \"name\":\"DV\",\r\n            \"ghi_chu\":\"Chi phÃ­ dá»‹ch vá»¥\",\r\n            \"idItemParent\":\"38d801d5-20f7-49df-b394-5afdfba6807d\",\r\n            \"createdAt\":\"2018-08-14T17:22:48.415Z\",\r\n            \"updatedAt\":\"2018-08-14T17:22:48.415Z\",\r\n            \"__v\":0,\r\n            \"parent\":null,\r\n            \"id\":\"b3d379d5-8eb2-4c52-a098-7021bdc66eb6\"\r\n         },\r\n         \"itemParent\":{\r\n            \"_id\":\"38d801d5-20f7-49df-b394-5afdfba6807d\",\r\n            \"name\":\"Thá»‘ng kÃª chi phÃ­\",\r\n            \"ghi_chu\":\"\",\r\n            \"createdAt\":\"2018-08-14T10:26:23.878Z\",\r\n            \"updatedAt\":\"2018-08-14T10:26:23.878Z\",\r\n            \"__v\":0,\r\n            \"parent\":null,\r\n            \"id\":\"38d801d5-20f7-49df-b394-5afdfba6807d\"\r\n         }\r\n      }\r\n   ],\r\n   \"createdAt\":\"2018-08-14T19:19:31.170Z\",\r\n   \"updatedAt\":\"2018-08-15T07:28:47.823Z\",\r\n   \"__v\":0,\r\n   \"id\":\"a6a14b80-8795-4864-9359-0b28b44fb6b9\"\r\n}\r\n```\r\n\r\n**What is the expected behavior?**\r\n\r\nSince `justOne: true` is set for the virtual field **itemDetail**, the expected behavior is for **itemDetail** to contain a single object, and have its own value which references to **Item**.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\n\r\nnode.js: `v8.11.1`\r\nMongoDB: `v3.2.8`\r\nmongoose: `v5.2.8`\r\n"},{"labels":["bug"],"text":"@lineus, @trungtin and @vkarpov15,\r\n\r\nI'm opening this issue as an attempt to clarify things about #6618 and #6702 [and consequent #6726 and #6729]. Right now my app is stuck in  mongoose v5.2.2 and only today I had the time to try to understand what is breaking my code.\r\n\r\n#### Summarizing\r\nI came to the conclusion that #6618 **was not a `confirmed-bug`**. It's just a **different use case that does not fit in \"getters\" feature**. This misconception led us to #6702, which basically forced getters/populate to fit in that use case, at the cost of **breaking the expected reference system of `populate()`**.\r\n\r\n#### Arguing\r\nI've been using mongoose for a while, and AFAIK I would describe \"getters\" and \"populate\" as:\r\n- `populate`: it's mongoose's way to simulate SQL's `JOIN` (a document has a property that _references_ another document).\r\n- `getter`: it's a filter to be applied on the raw document value (fetched from the database) when someone accesses a model property.\r\n\r\nNow, considering `populate`/`JOIN`: we expect that a local value matches _exactly_ a foreign value, right? At least _we currently do not have the feature of specifying a custom matching rule for local/foreign values_.\r\n\r\nI'll show a use case of getters + populate that used to work before and it's now broken:\r\n\r\n```js\r\nconst stateSchema = new Schema({\r\n  _id: String,\r\n  name: String,\r\n});\r\n\r\nconst citySchema = new Schema({\r\n  _id: String,\r\n  name: String,\r\n  state: {\r\n    type: String,\r\n    get: value => `StateId:${value}`,\r\n    ref: 'State',\r\n  },\r\n});\r\n\r\n/*\r\nLet's assume we have these documents persisted in our database:\r\n\r\nCollection \"states\":\r\n{\"_id\": \"s1\", \"name\": \"California\"}\r\n\r\nCollection \"cities\":\r\n{\"_id\": \"c1\", \"name\": \"Los Angeles\", \"state\": \"s1\"}\r\n\r\nSeem's a fine relationship, right?\r\n*/\r\n\r\n\r\nconst losAngeles = await City.findById('c1');\r\nconsole.log(losAngeles.state);\r\n// prints \"StateId:s1\"\r\n// good, just filtering the fetched value from the document due to our defined getter for \"state\".\r\n\r\n\r\nconst losAngelesPopulatedState = await City.findById('c1').populate('state', 'name');\r\nconsole.log(losAngelesPopulatedState.state._id);\r\n// prints \"s1\"\r\n// we expect that this population did work\r\n```\r\n\r\nThe last `populate`/`JOIN` does not work after mongoose v5.2.2 :disappointed:\r\n\r\nThat's because we wrongly applied the getter on the value that we expect to match exactly with the foreign value.\r\n\r\nLooking forward on solving this issue. Thanks!"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\n**bug**\r\n\r\n**What is the current behavior?**\r\nWhen trying to set a default on an Array field, the default function doesn't give me access to the current object being created. I want to fill the array differently depending on the other values.\r\nI found a similar issue https://github.com/Automattic/mongoose/issues/6263\r\nBut it is recommended to access pre-hooks, which I can't do. I need to have access to the *default* field.\r\nIm using the latest version of mongoose (5.2.7).\r\n\r\nIm using the same example as in the mongoose doc http://mongoosejs.com/docs/defaults.html#default-functions-and-this\r\nI just added a field \"actors\" which is an array.\r\nIn releaseDate, I have access to **this** , but not in actors\r\n\r\n```\r\nconst mongoose = require(\"mongoose\");\r\nconst Schema = mongoose.Schema;\r\n\r\nconst schema = new Schema({\r\n\ttitle: String,\r\n\treleased: Boolean,\r\n\treleaseDate: {\r\n\t\ttype: Date,\r\n\t\tdefault: function() {\r\n\t\t\tconsole.log(\"releaseDate: \", this.released);\r\n\t\t\tif (this.released) {\r\n\t\t\t\treturn Date.now();\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t}\r\n\t},\r\n\tactors: {\r\n\t\ttype: [\r\n\t\t\t{\r\n\t\t\t\tname: String,\r\n\t\t\t\tage: Number\r\n\t\t\t}\r\n\t\t],\r\n\t\tdefault: function() {\r\n\t\t\tconsole.log(\"actors: \", this.released);\r\n\t\t\treturn [\r\n\t\t\t\t{\r\n\t\t\t\t\tname: \"Test\",\r\n\t\t\t\t\tage: 20\r\n\t\t\t\t}\r\n\t\t\t];\r\n\t\t}\r\n\t}\r\n});\r\n\r\nconst Movie = mongoose.model(\"Movie\", schema);\r\n\r\nconst movie1 = new Movie({ title: \"The Terminator\", released: true });\r\nconst movie2 = new Movie({ title: \"The Legend of Conan\", released: false });\r\n\r\nconsole.log(movie1);\r\n```"},{"labels":["bug"],"text":"Hi,\r\n\r\nWhen I test my validator in mocha, I find that the validators will be wrong if call save() function repeatedly.\r\n\r\nHere is my part of schema:\r\n```javascript\r\nconst ProjectSchema   = new Schema({\r\n    name: String\r\n    // ... \r\n    roles: {\r\n        type: [{\r\n            name: String, \r\n            folders: {\r\n                type: [{\r\n                    folderId: {\r\n                        type: Schema.Types.ObjectId,\r\n                        validate: {\r\n                            validator: MongoValidator.rolesFoldersFolderId\r\n                        },\r\n                    },\r\n                   // ...\r\n                }],\r\n                validate: {\r\n                    validator: MongoValidator.rolesFolders\r\n                }\r\n            }\r\n        }],\r\n        validate: {\r\n            validator: MongoValidator.roles\r\n        }\r\n    },\r\n    // ...\r\n    active: { type: Boolean, default: true, select: false},\r\n});\r\n```\r\n\r\nAnd here is my part of mocha code:\r\n```javascript\r\n// ...\r\nit('Edit folder id in role to a duplicate id', () => {\r\n       return expect(Project.findById('5b67ac70bdb7915e3041feab')\r\n            .then(projectDoc => {\r\n               // First save(): add a folder object\r\n               projectDoc.roles.find(role => role.name === 'role1').folders.push({ folderId: '5b67aadf3405b05e09304b83' });\r\n               return projectDoc.save();\r\n            })\r\n           .then(projectDoc => {\r\n               // Second save(): edit the folder id\r\n               projectDoc.roles.find(role => role.name === 'role1').folders.find(roleFolder => roleFolder.folderId.toString() === '5b67aadf3405b05e09304b83').folderId = '5b67aadf3405b05e09304b82';\r\n               return projectDoc.save();\r\n            }))\r\n            .be.rejected.then(error => {\r\n                  expect(error).to.have.property('name').equal('ValidationError');\r\n expect(error).to.have.property('errors').to.have.property('roles.1.folders').to.have.property('message').equal('Folder ID in role must be unique');\r\n             });\r\n});\r\n// ...\r\n```\r\nAfter I run the code with debugger, I find two problems happened in second save().\r\n___\r\n### Cannot Trigger the Validator\r\nI find that the validator 'rolesFolders' will not be triggered to validate the 'folders' array of 'role1' object, but can be triggered by other role objects ('Administrator' and 'role2').\r\n\r\nHere is the code of validator 'rolesFolders':\r\n```javascript\r\nfunction rolesFolders(folders) {\r\n  if ((this.isNew || this.isModified('folders')) && folders.find((folder, index) => folders.find((folderRef, indexRef) => folder.folderId.toString() === folderRef.folderId.toString() && index !== indexRef))) {\r\n    throw new Error('Folder ID in role must be unique');\r\n  } else {\r\n    return true;\r\n  }\r\n}\r\n```\r\n___\r\n### Wrong 'this' refer\r\nAlso, the 'this' of validator 'rolesFoldersFolderId' will refer to path 'roles' when validates the 'folderId' in 'folders' array of 'role1' object. I think the correct path should be 'roles.folders', the current level of 'folderId'.\r\n\r\nHere is the code of validator 'rolesFoldersFolderId':\r\n```javascript\r\nfunction rolesFoldersFolderId(folderId) {\r\n  if (this.isNew || this.isDirectModified('folderId')) {\r\n    return Folder.findById(folderId)\r\n      .then(folderDoc => {\r\n        if (folderDoc) {\r\n          return true;\r\n        } else {\r\n          throw new Error('Folder not exist');\r\n        }\r\n      });\r\n  } else {\r\n    return true;\r\n  }\r\n}\r\n```\r\n\r\n___\r\nHowever, if I find the document again before second save() call, every thing will become correct.\r\n\r\nJust like:\r\n```javascript\r\n// ...\r\nit('Edit folder id in role to a duplicate id', () => {\r\n       return expect(Project.findById('5b67ac70bdb7915e3041feab')\r\n            .then(projectDoc => {\r\n               // First save(): add a folder\r\n               projectDoc.roles.find(role => role.name === 'role1').folders.push({ folderId: '5b67aadf3405b05e09304b83' });\r\n               return projectDoc.save();\r\n            })\r\n           .then(projectDoc => Project.findById('5b67ac70bdb7915e3041feab')) // !!! <-- HERE: find the document again !!!\r\n           .then(projectDoc => {\r\n               // Second save(): edit the folder id\r\n               projectDoc.roles.find(role => role.name === 'role1').folders.find(roleFolder => roleFolder.folderId.toString() === '5b67aadf3405b05e09304b83').folderId = '5b67aadf3405b05e09304b82';\r\n               return projectDoc.save();\r\n            }))\r\n            .be.rejected.then(error => {\r\n                  expect(error).to.have.property('name').equal('ValidationError');\r\n expect(error).to.have.property('errors').to.have.property('roles.1.folders').to.have.property('message').equal('Folder ID in role must be unique');\r\n             });\r\n});\r\n// ...\r\n```\r\n\r\nSince the validators give different results with same update process, I suppose it may be a bug.\r\n\r\nmongoose version: 5.2.5\r\nmongodb version 3.6.5"},{"labels":["bug"],"text":"I am getting errors like the following:\r\n\r\n```\r\nObjectParameterError: Parameter \"obj\" to Document() must be an object, got 555bee3e4527879d33c7b33a\r\n    at new ObjectParameterError (node_modules/mongoose/lib/error/objectParameter.js:23:11)\r\n    at SingleNested.Document (node_modules/mongoose/lib/document.js:66:11)\r\n    at SingleNested.Subdocument (node_modules/mongoose/lib/types/subdocument.js:18:12)\r\n    at new SingleNested (node_modules/mongoose/lib/schema/embedded.js:57:17)\r\n    at Embedded.castForQuery (node_modules/mongoose/lib/schema/embedded.js:218:10)\r\n    at Embedded.SchemaType.castForQueryWrapper (node_modules/mongoose/lib/schematype.js:1082:15)\r\n    at cast (node_modules/mongoose/lib/cast.js:303:32)\r\n    at model.Query.Query.cast (node_modules/mongoose/lib/query.js:3751:12)\r\n    at model.Query.Query._castConditions (node_modules/mongoose/lib/query.js:1549:10)\r\n    at model.Query.Query._find (node_modules/mongoose/lib/query.js:1564:8)\r\n    at process.nextTick (node_modules/kareem/index.js:333:33)\r\n    at _combinedTickCallback (internal/process/next_tick.js:131:7)\r\n    at process._tickDomainCallback (internal/process/next_tick.js:218:9)\r\nFrom previous event:\r\n    at Object.promiseOrCallback (node_modules/mongoose/lib/utils.js:233:10)\r\n    at model.Query.exec (node_modules/mongoose/lib/query.js:3549:16)\r\n    at model.Query.Query.then (node_modules/mongoose/lib/query.js:3576:15)\r\n```\r\n\r\nEven with `Error.stackTraceLimit = Infinity;` we can't get more out of these errors or figure out what call they are originating from, because all stack trace lines refer to the mongoose library and not to our own app source code. This makes debugging our code very hard, especially since this error message is not very helpful. For example, I have no idea what Schema this relates to or what Model, or perhaps what sub schema, etc.\r\n\r\nIs it possible to clarify this a bit better or provide a full strack trace with these errors so we can pinpoint what calls triggered them?"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nWhen I have a single nested sub-document, required validations are called multiple times.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nGist with tests showing that `validate` custom validations are only called once, but `required` custom validations are called multiple times for single nested sub-documents:  https://gist.github.com/kprenger/c5c615dc2ff57e3b5d0e85ae425cd13b\r\n\r\n**What is the expected behavior?**\r\nI would expect the custom validation in the `required` attribute to behave the same as a custom validation in the `validate` attribute - in that it is only called one time.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nmongoose v5.2.6\r\nnode v8.11.3\r\nmongo v3.6.5"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nLet's say we have following models: Driver, Car and Producer (car producer). Driver contains array of references to Car model, car has reference (single reference, not an array!) to Producer. Both references are not required. \r\n\r\nIn first step we populate array of Cars in Drivers, array of references will correctly be substituted with Car objects. Then we again populate same list of Drivers, but this time we populate Producers in previously populated array of Cars. If car reference was defined, Car will now correctly contain Producer object, but if Car reference is missing (to be precise - producer property in Car object is undefined) it will be substituted with **empty array**. We expected that they would still be undefined after populated is executed.\r\n\r\nIt also seems that this happens only if at least one Car has reference to Producers. \r\n\r\nIn our case this can be problematic because in lot of our conditions instead of `cars[0].producer` being evaluated as false (since they were undefined), they are now evaluated as true (since they contain empty array). \r\n\r\nWe detected this bug yesterday after update to version 5.2.5. This bug also appears in 5.2.6. We found out that this bug was introduced with version 5.0.12. and assume that his happens because of following fix:\r\n\r\nhttps://github.com/Automattic/mongoose/issues/6245\r\nhttps://github.com/Automattic/mongoose/commit/9570a1b5f30ad09f7b62821ed185dba412aaa491\r\n\r\n(we confirmed that this bug doesn't appear in 5.0.11, but appears in 5.0.12 and above).\r\n\r\nEasiest way to reproduce and understand issue is script bellow. It is consistently reproducing issue with appropriate mongoose versions. \r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\n\r\n```\r\nconst mongoose = require('mongoose');\r\nmongoose.connect('mongodb://localhost:27017/issue_test');\r\n\r\nconst DriverSchema = new mongoose.Schema({\r\n  name: 'String',\r\n  cars: [{ type: 'ObjectId', required: false, ref: 'Car' }]\r\n})\r\n\r\nconst CarSchema = new mongoose.Schema({ \r\n  name: 'String',\r\n  producer: { type: 'ObjectId', required: false, ref: 'Producer'}\r\n});\r\n\r\nconst ProducerSchema = new mongoose.Schema({\r\n  name: 'String',\r\n})\r\n\r\nconst Driver = mongoose.model('Driver', DriverSchema);\r\nconst Car = mongoose.model('Car', CarSchema);\r\nconst Producer = mongoose.model('Producer', ProducerSchema);\r\n\r\nasync function execute() {\r\n  const oneProducer = new Producer({ name: 'Producer A '});\r\n  await oneProducer.save();\r\n\r\n  const oneCar = new Car({ name: 'My personal car', producer: oneProducer });\r\n  await oneCar.save();\r\n\r\n  const oneDriver = new Driver({ name: 'Driver 1', cars: [oneCar]})\r\n  await oneDriver.save();\r\n\r\n  const secondCar = new Car({ name: 'Work car' });\r\n  await secondCar.save();\r\n\r\n  const secondDriver = new Driver({ name: 'Driver 2', cars: [secondCar] });\r\n  await secondDriver.save();\r\n\r\n  const drivers = await Driver.find().populate('cars');\r\n\r\n  const _drivers = await Driver.populate(drivers, {\r\n    path: 'cars.producer',\r\n    model: 'Producer',\r\n  })\r\n\r\n  console.log(_drivers[1].cars[0].producer);\r\n  // Mongoose version 5.0.11 will print 'undefined'\r\n  // Mongoose versions >= 5.0.12 will print '[]' (empty array)\r\n}\r\n\r\nexecute();\r\n```\r\n\r\n\r\nPackage.json just for easier running:\r\n\r\n\r\n```\r\n{\r\n  \"name\": \"reproduce\",\r\n  \"version\": \"0.0.1\",\r\n  \"description\": \"Reproducer mongo bug\",\r\n  \"main\": \"index.js\",\r\n  \"scripts\": {\r\n    \"start\": \"node index.js\"\r\n  },\r\n  \"dependencies\": {\r\n    \"mongoose\": \"5.2.6\"\r\n  }\r\n}\r\n```\r\n\r\n\r\n**What is the expected behavior?**\r\n\r\nIn above scenario - populating missing property should still result in that field being undefined after populate.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\n\r\nNode: 8.10.0\r\nMongoose: 5.2.6\r\nMongodDB: v3.4, but we've also seen this behavior on v3.2\r\n"},{"labels":["bug"],"text":"Popped up when investigating #6637 \r\n\r\n```\r\nconst mongoose = require('mongoose');\r\nmongoose.connect('mongodb://localhost:27017/gh6637', { useNewUrlParser: true });\r\nconst conn = mongoose.connection;\r\nconst Schema = mongoose.Schema;\r\n\r\nmongoose.set('debug', true);\r\n\r\nconst schema = new Schema({\r\n  nested: {\r\n    arr: [{ key: String }]\r\n  }\r\n});\r\n\r\nschema.path('nested.arr.0.key').get(v => 'foobar' + v);\r\n\r\nconst Test = mongoose.model('test', schema);\r\n\r\nconst test = new Test;\r\n\r\ntest.nested.arr.push({ key: 'value' });\r\ntest.nested.arr.push({ key: 'value2' });\r\n\r\nasync function run() {\r\n  await conn.dropDatabase();\r\n  await test.save();\r\n  let doc = await Test.findOne();\r\n  console.log(doc.get('nested.arr.0.key')); // \"foobarfoobarvalue\"\r\n}\r\n\r\nrun();\r\n```"},{"labels":["bug",null],"text":"Docs for `doc.$session()` only mention that it applies `save()`:\r\n\r\n<img width=\"871\" alt=\"screen shot 2018-07-22 at 16 35 52\" src=\"https://user-images.githubusercontent.com/5895458/43046724-612fd982-8dcd-11e8-98e8-114e3fb2c3bd.png\">\r\n\r\nDoes it mean that calling `doc.populate()` or `doc.execPopulate` will ignore the associated mongo session?"},{"labels":["bug",null],"text":"According to the docs `Model.aggregate()` doesn't accept any `options` object:\r\n\r\n<img width=\"528\" alt=\"screen shot 2018-07-22 at 16 10 47\" src=\"https://user-images.githubusercontent.com/5895458/43046496-d5bce000-8dc9-11e8-9ea3-a8ebea879f78.png\">\r\n\r\nIt also returns `Aggregate` instance which doesn't have a `session()` setter like `Query`.\r\n\r\nIs there a way to run an aggregation query within a transaction?\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nIt's a bug.\r\n\r\n**What is the current behavior?**\r\nModel.findOneAndUpdate() hangs when update has a reference model which has a Map as a field.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n\r\n```javascript\r\nconst User = mongoose.model('User', {\r\n      maps: { type: Map, of: String },\r\n});\r\n\r\nconst Post = mongoose.model('Post', {\r\n      user: { type: Schema.Types.ObjectId, ref: 'User' },\r\n});\r\n\r\nconst user = await User.create({});\r\nawait Post.findOneAndUpdate({user}, {user}, {upsert: true, new: true}); /// hangs here.\r\n\r\n```\r\n\r\nI took a quick investigation. In lib/helpers/common.js function modifiedPaths will recursive call itself when there's map, because there is a key **$__parent** generated when model has a Map.\r\n\r\n```javascript\r\nfunction modifiedPaths(update, path, result) {\r\n  var keys = Object.keys(update || {});\r\n  var numKeys = keys.length;\r\n  result = result || {};\r\n  path = path ? path + '.' : '';\r\n\r\n  for (var i = 0; i < numKeys; ++i) {\r\n    var key = keys[i];\r\n    var val = update[key];\r\n\r\n    if (key.startsWith('$')) continue;   // << Works if I added this line\r\n\r\n    result[path + key] = true;\r\n    if (utils.isMongooseObject(val) && !Buffer.isBuffer(val)) {\r\n      val = val.toObject({ transform: false, virtuals: false });\r\n    }\r\n    if (shouldFlatten(val)) {\r\n      modifiedPaths(val, path + key, result);\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n```\r\n\r\n**What is the expected behavior?**\r\nNo infinite loop.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nnode v10.5.0\r\nmongoose 5.2.4\r\nmongodb v3.6.4"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nbug\r\n\r\n**What is the current behavior?**\r\nValidation will not continue after one object of array has validation errors. Validation does continue when array contains primitives.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n[Tests showing current behavior with bug](https://gist.github.com/martypdx/2a169b71b0a8d81b49014d85e0aea9f5)\r\n\r\n**What is the expected behavior?**\r\nThird test passes, both failed objects of array reported in validation\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\n* mongoose 5.2.4\r\n* node 10.3.0"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nThe Aggregate constructor used to accept spreads. (#2716). This meant that the following was a valid pipeline.\r\n\r\n    SomeModel\r\n        .aggregate({ $match: { someField: 'xxxx' })\r\n        .then(docs => console.log(docs); // Documents matching criteria\r\n            \r\n\r\nSince 5.0.0-rc0, this was removed, and was reported as a breaking change. If you pass an object as the first parameter, it treats it as an empty pipeline. Outputting after an empty pipeline throws an error (Error: Aggregate has empty pipeline).\r\n\r\nHowever, if you chain another pipeline stage, the error will be swallowed, and the aggregation will go on as if the constructor was empty.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nThe following would return all documents in a collection, if it has the memory to sort it.\r\n\r\n    SomeModel\r\n        .aggregate({ $match: { someField: 'xxxx' } })\r\n        .sort({ timestamp: -1 })\r\n        .then(docs => console.log(docs); // All documents in collection!\r\n\r\n**What is the expected behavior?**\r\nI think passing an invalid argument to the constructor should throw an error, instead of treating it an an empty constructor.\r\n\r\nI am honestly unsure whether you can consider this a bug or not.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nnode: 10.6.0\r\n\r\nmongoose: 5.2.3\r\n\r\nMongoDB: 3.6.5"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nA bug\r\n\r\n**What is the current behavior?**\r\nAs of `5.2.3`, _getters_ of schema types have inconsistent `this` context.\r\n\r\nBefore that release we used to assume that `this` would be the instance of `Model`. Now, when a path has a getter and is populated by a `ref`, at some point that getter is invoked with `this` being the plain object `doc`.\r\n\r\nI couldn't found in the documentation that the old behavior is a public API, but having two calling contexts for getters is a bit messy.\r\n\r\nUnfortunately my application depended on the old behavior. :disappointed:\r\n\r\nI've found that this issue was introduced here: https://github.com/Automattic/mongoose/pull/6702/files#diff-a140b60b6a99a8c69f4b5d0d1f1f2bfaR3947\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```js\r\nconst BarSchema = new mongoose.Schema({});\r\nconst Bar = mongoose.model('Bar', BarSchema);\r\n\r\nconst FooSchema = new mongoose.Schema({\r\n  bar: {\r\n    type: mongoose.Schema.Types.ObjectId,\r\n    ref: 'Bar',\r\n    get(value) {\r\n      console.log(this.constructor.name); // sometimes it prints `model`, sometimes `Object` \r\n      return value;\r\n    },\r\n  },\r\n});\r\nconst Foo = mongoose.model('Foo', FooSchema);\r\n\r\nconst bar = new Bar();\r\nawait bar.save();\r\n\r\nconst foo = new Foo({bar: bar});\r\nawait foo.save();\r\n\r\nconst fooWithPopulate = await Foo.find({_id: foo._id}).populate('bar');\r\nfooWithPopulate.bar;\r\n```\r\n\r\n**What is the expected behavior?**\r\n`this` in a getter function should always be the instance of `Model`.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nnode.js: v10.6.0\r\nmongoose: v5.2.3\r\nMongoDB: v3.6.1"},{"labels":["bug"],"text":"Re: https://github.com/Automattic/mongoose/issues/6663#issuecomment-403448647"},{"labels":["bug"],"text":"```js\r\n#!/usr/bin/env node\r\n'use strict';\r\n\r\nconst mongoose = require('mongoose');\r\n\r\nconst schema = new mongoose.Schema({\r\n  subdocument: new mongoose.Schema({\r\n    field: {\r\n      type: Number,\r\n      default: 123,\r\n      required: true\r\n    }\r\n  })\r\n}, {\r\n  minimize: false\r\n});\r\n\r\nconst Model = mongoose.model('test', schema);\r\nconst instance = new Model();\r\n\r\ninstance.subdocument = 123;\r\ninstance.validate().then(function () {\r\n  console.log('Huh? Subdocument is set to default instead of failing the validation.');\r\n});\r\n```\r\n\r\nI find this behavior very surprising, cast error is silently ignored. Is it by design? And is there a way to make it fail the validation?"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nAttempting to create an instance of a model using `new mongoose.model('myModel')(data)` results in an error.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```js\r\nconst mongoose = require('mongoose');\r\nmongoose.connect('mongodb://localhost:27017/testModelBug', { useNewUrlParser: true });\r\n\r\nconst Person = new mongoose.Schema({\r\n  name: {\r\n    given: {\r\n      type: String,\r\n      required: true\r\n    },\r\n    family: {\r\n      type: String,\r\n      required: true\r\n    }\r\n  }\r\n});\r\n\r\nmongoose.model('Person', Person);\r\n\r\ntry {\r\n  console.log('This will fail');\r\n  let x = new mongoose.model('Person')({\r\n    name: {\r\n      given: 'Test',\r\n      family: 'Fail'\r\n    }\r\n  });\r\n  console.log('Didn\\'t fail');\r\n} catch (e) {\r\n  console.log('Failed:', e);\r\n}\r\n\r\ntry {\r\n  console.log('This will not fail');\r\n  let Person = mongoose.model('Person');\r\n  let x = new Person({\r\n    name: {\r\n      given: 'Test',\r\n      family: 'Success'\r\n    }\r\n  });\r\n  console.log('Didn\\'t fail');\r\n} catch (e) {\r\n  console.log('You should not see this', e);\r\n}\r\n\r\nmongoose.modelProxy = function() {\r\n  return mongoose.model(arguments[0]);\r\n};\r\n\r\ntry {\r\n  console.log('This will also not fail');\r\n  let x = new mongoose.modelProxy('Person')({\r\n    name: {\r\n      given: 'Test',\r\n      family: 'Success'\r\n    }\r\n  });\r\n  console.log('Didn\\'t fail');\r\n} catch (e) {\r\n  console.log('You should not see this', e);\r\n}\r\n\r\nmongoose.connection.close();\r\n```\r\n\r\n**What is the expected behavior?**\r\nIt seems like mongoose.model is behaving differently depending on whether or not `new` is used. In reality it should just be returning the model here and not care.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nmongoose 5.2.1\r\nnode 8.9.1\r\nmongo 3.0.15"},{"labels":["bug"],"text":"### Bug\r\nCalling `findOneAndUpdate` with `$setOnInsert` and `setDefaultsOnInsert: true, upsert: true` on a nested subdocument with a default value for a field results in the error:\r\n```Updating the path 'nested.subdocument.default_field' would create a conflict at 'nested.subdocument'```\r\n\r\nMongoDB: 3.6.5\r\nMongoose v.5.2.1\r\nNode v.8.11.3\r\n\r\n### Reproduction code\r\n```js\r\nconst mongoose = require('mongoose');\r\nconst BugSchema = new mongoose.Schema({\r\n    nested: {\r\n        test: String,\r\n        default_field: {\r\n            type: Number,\r\n            default: 100,\r\n        },\r\n        subdocument: {\r\n            test: String,\r\n            default_field: {\r\n                type: Number,\r\n                default: 100,\r\n            },\r\n        },\r\n    },\r\n});\r\nconst BugModel = mongoose.model('BugSchema', BugSchema);\r\nmongoose\r\n    .connect('mongodb://localhost:27017')\r\n    .then(() => {\r\n        const failingUpdate = {\r\n            'nested.subdocument': {\r\n                test: 'Value',\r\n            },\r\n        };\r\n        const passingUpdate = {\r\n            'nested.subdocument': {\r\n                test: 'Value',\r\n                default_field: 100, // Note: Must set default_field value to prevent error.\r\n            }\r\n        };\r\n        const passingUpdate2 = {\r\n            'nested': {\r\n                test: 'Value', // Note: No default_field value set.\r\n            },\r\n        };\r\n        return bugModeQuery(failingUpdate)\r\n            .then(() => bugModeQuery(passingUpdate))\r\n            .then(() => bugModeQuery(passingUpdate2))\r\n            .then(() => {\r\n                mongoose.connection.close();\r\n                process.exit();\r\n            })\r\n    })\r\n    .catch(err => {\r\n        console.error(err);\r\n        mongoose.connection.close();\r\n        process.exit();\r\n    });\r\n\r\nfunction bugModeQuery(update) {\r\n    return BugModel.findOneAndUpdate(\r\n        {},\r\n        {$setOnInsert: update},\r\n        {\r\n            setDefaultsOnInsert: true,\r\n            upsert: true,\r\n        }\r\n    )\r\n        .then(res => {\r\n            console.log('Success');\r\n            console.log(res);\r\n            return;\r\n        })\r\n       .catch(err => {\r\n            console.error('ERROR');\r\n            console.error(err);\r\n            return Promise.resolve();\r\n        })\r\n}\r\n```"},{"labels":["bug"],"text":"5.2.0 took a too restrictive measure to fix #6605:\r\n- it makes sense not to create a duplicate index on _id\r\n- it does not make sense to prevent any index designating _id as part of a list of indexed fields, e.g.:\r\n    - { _categoryId: 1, _id: 1}\r\n    - { _userId: 1, _id: 1 }\r\n\r\nWith 5.2.0, any index containing _id: 1 raises an error because of https://github.com/Automattic/mongoose/blob/master/lib/model.js#L1208\r\n\r\n```\r\nif (index[0]._id != null) {\r\n```\r\nshould be replaced with something like\r\n\r\n```\r\nif (Object.keys(index[0]).length === 1 && index[0]._id != null) {\r\n```\r\n"},{"labels":["bug"],"text":"- Currently using the new Mongoose v5.2.0\r\n- Now must specify the localhost port that I am using, 27017 is no longer used by default.\r\nWill this be fixed in a patch release or will we now have to specify our port for development?\r\n\r\n// Add mongoose\r\nimport mongoose from 'mongoose';\r\n\r\n// Not Working\r\nmongoose.connect('mongodb://localhost/playground')\r\n    .then(() => console.log(`MongoDB Connected...`))\r\n    .catch(err => console.log(`Error ${err}`))\r\n//  Working\r\nmongoose.connect('mongodb://localhost:27017/playground')\r\n    .then(() => console.log(`MongoDB Connected...`))\r\n    .catch(err => console.log(`Error ${err}`))\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nWhen performing a virtual population of embedded discriminators, the correct result is returned the first time the query is run. Subsequent runs of the same query will not include results of the virtual population\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n```js\r\nconst mongoose = require('mongoose')\r\n\r\nmongoose.connect('mongodb://localhost/mongoosetest')\r\nmongoose.connection.once('open', () => {\r\n\r\n  const Schema = mongoose.Schema\r\n\r\n  // Generate Users Model\r\n  const userSchema = new Schema({ employeeId: Number, name: String })\r\n  const UserModel = mongoose.model('Users', userSchema, 'users')\r\n\r\n  // Generate Embedded Discriminators\r\n  const eventSchema = new Schema(\r\n    { message: String },\r\n    { discriminatorKey: 'kind'}\r\n  );\r\n\r\n  const batchSchema = new Schema({\r\n    events: [eventSchema]\r\n  });\r\n\r\n  const docArray = batchSchema.path('events'); \r\n\r\n  // First embedded discriminator schema\r\n  const clickedSchema = new Schema(\r\n    {\r\n      element: { type: String },\r\n      users: [{}]\r\n    },\r\n    {\r\n      toJSON: { virtuals: true},\r\n      toObject: { virtuals: true}\r\n    }\r\n  );\r\n\r\n  // Add virtual to first embedded discriminator schema for virtual population\r\n  clickedSchema.virtual('users_$', {\r\n    ref: 'Users',\r\n    localField: 'users',\r\n    foreignField: 'employeeId'\r\n  })\r\n  \r\n  const Clicked = docArray.discriminator('Clicked', clickedSchema);\r\n\r\n  // Second embedded discriminator\r\n  const Purchased = docArray.discriminator('Purchased', new Schema({\r\n    product: { type: String }\r\n  }));\r\n\r\n  const Batch = mongoose.model('EventBatch', batchSchema);\r\n\r\n  // Generate Items\r\n  const user = { employeeId: 1, name: 'Test name' }\r\n\r\n  const batch = {\r\n    events: [\r\n      {\r\n        kind: 'Clicked',\r\n        element: '#hero',\r\n        message: 'hello',\r\n        users: [\r\n          1\r\n        ]\r\n      },\r\n      { kind: 'Purchased', product: 'action-figure-1', message: 'world' }\r\n    ]\r\n  };\r\n\r\n  // Clearing out the collections before creating items\r\n  Promise.all([ UserModel.remove({}), Batch.remove({}) ])\r\n  .then(() => Promise.all([UserModel.create(user), Batch.create(batch)]))\r\n  .then(function(){\r\n    Batch.find({})\r\n      .populate('events.users_$') \r\n      .lean()\r\n      .then(results => {\r\n        // The events.users_$ IS populated\r\n        console.log('First Run:', JSON.stringify(results, null, 2))  \r\n      })\r\n      .then(() => {\r\n        Batch.find({})\r\n        .populate('events.users_$') \r\n        .lean()\r\n        .then(results => {\r\n          // The events.users_$ IS NOT populated\r\n          console.log('Second Run:', JSON.stringify(results, null, 2))\r\n        })\r\n      })\r\n  })\r\n})\r\n\r\n```\r\nResults (users_$ is not populated in the second run)\r\n\r\n```\r\nFirst Run: [\r\n  {\r\n    \"_id\": \"5b3a4dfde8bb8b28a8dd87d8\",\r\n    \"events\": [\r\n      {\r\n        \"users\": [\r\n          1\r\n        ],\r\n        \"_id\": \"5b3a4dfde8bb8b28a8dd87da\",\r\n        \"kind\": \"Clicked\",\r\n        \"element\": \"#hero\",\r\n        \"message\": \"hello\",\r\n        \"users_$\": [\r\n          {\r\n            \"_id\": \"5b3a4dfde8bb8b28a8dd87d7\",\r\n            \"employeeId\": 1,\r\n            \"name\": \"Test name\",\r\n            \"__v\": 0\r\n          }\r\n        ]\r\n      },\r\n      {\r\n        \"_id\": \"5b3a4dfde8bb8b28a8dd87d9\",\r\n        \"kind\": \"Purchased\",\r\n        \"product\": \"action-figure-1\",\r\n        \"message\": \"world\",\r\n        \"users_$\": []\r\n      }\r\n    ],\r\n    \"__v\": 0\r\n  }\r\n]\r\nSecond Run: [\r\n  {\r\n    \"_id\": \"5b3a4dfde8bb8b28a8dd87d8\",\r\n    \"events\": [\r\n      {\r\n        \"users\": [\r\n          1\r\n        ],\r\n        \"_id\": \"5b3a4dfde8bb8b28a8dd87da\",\r\n        \"kind\": \"Clicked\",\r\n        \"element\": \"#hero\",\r\n        \"message\": \"hello\"\r\n      },\r\n      {\r\n        \"_id\": \"5b3a4dfde8bb8b28a8dd87d9\",\r\n        \"kind\": \"Purchased\",\r\n        \"product\": \"action-figure-1\",\r\n        \"message\": \"world\"\r\n      }\r\n    ],\r\n    \"__v\": 0\r\n  }\r\n]\r\n```\r\n**What is the expected behavior?**\r\nExpected results for the same query to be the same\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nMongoose: 5.1.7\r\nNode: 8.11.1\r\nMongoDB: 3.6.4"},{"labels":["bug"],"text":"The enum error message seems like it wants to have variable substitution, but it isn't happening.\r\n**I'll see if I can sort this out in the AM**\r\n### 6621.js\r\n```js\r\n#!/usr/bin/env node\r\n'use strict';\r\n\r\nconst mongoose = require('mongoose');\r\nmongoose.connect('mongodb://localhost/test');\r\nconst conn = mongoose.connection;\r\nconst Schema = mongoose.Schema;\r\n\r\nconst schema = new Schema({\r\n  name: {\r\n    type: String,\r\n    enum: ['Billy', 'Bobby', 'Branford', 'Banksy']\r\n  }\r\n});\r\n\r\nconst Test = mongoose.model('test', schema);\r\n\r\nconst test = new Test({\r\n  name: 'Basquiat'\r\n});\r\n\r\nasync function run () {\r\n  await conn.dropDatabase();\r\n  await test.save()\r\n    .catch((err) => {\r\n      console.error(err.errors.name.properties.message);\r\n      return conn.close();\r\n    });\r\n}\r\n\r\nrun();\r\n```\r\n### Output:\r\n```\r\nissues: ./6621.js\r\n`{VALUE}` is not a valid enum value for path `{PATH}`.\r\nissues:\r\n```\r\n\r\n**Note to Self:** it looks like if I just `console.error(err);` it's there, if I try to access the full property path it doesn't work.\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nmongoose 5.1.6, node 8.11.1, mongodb 3.6.2"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nmaybe *bug*\r\n\r\n**What is the current behavior?**\r\nI'm migrating from parse-server to mongoose. Parser server save pointer in this shape `Model$_id`.  So in schema definition I have set a getter to transform `Model$xxxxx` => `xxxxx`.\r\nBut when using this field to populate, the getter does not run (so mongoose look for _id by `Model$xxxxx`, not `xxxxx`  as expected)\r\n\r\nI have tried to add a new virtual field as opose to using getter and use new virtual field to populate, it also not work.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\n**What is the expected behavior?**\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nmongoose@5.1.6"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nbug\r\n\r\n**What is the current behavior?**\r\nI get this error:\r\n```\r\n{ ParallelSaveError: Can't save() the same doc multiple times in parallel. Document: 5b2c9a3276254b3c471396c2\r\n    at ParallelSaveError.MongooseError [as constructor] (/home/lally/workspace/mongoose/playground/node_modules/mongoose/lib/error/mongooseError.js:11:11)\r\n    at new ParallelSaveError (/home/lally/workspace/mongoose/playground/node_modules/mongoose/lib/error/parallelSave.js:18:17)\r\n    at model.Model.save (/home/lally/workspace/mongoose/playground/node_modules/mongoose/lib/model.js:342:23)\r\n    at toExecute.push.callback (/home/lally/workspace/mongoose/playground/node_modules/mongoose/lib/model.js:2244:16)\r\n    at /home/lally/workspace/mongoose/playground/node_modules/async/internal/parallel.js:31:39\r\n    at eachOfArrayLike (/home/lally/workspace/mongoose/playground/node_modules/async/eachOf.js:65:9)\r\n    at exports.default (/home/lally/workspace/mongoose/playground/node_modules/async/eachOf.js:9:5)\r\n    at _parallel (/home/lally/workspace/mongoose/playground/node_modules/async/internal/parallel.js:30:5)\r\n    at parallelLimit (/home/lally/workspace/mongoose/playground/node_modules/async/parallel.js:88:26)\r\n    at utils.promiseOrCallback.cb (/home/lally/workspace/mongoose/playground/node_modules/mongoose/lib/model.js:2248:5)\r\n    at Object.promiseOrCallback (/home/lally/workspace/mongoose/playground/node_modules/mongoose/lib/utils.js:222:14)\r\n    at Function.create (/home/lally/workspace/mongoose/playground/node_modules/mongoose/lib/model.js:2209:16)\r\n    at Object.<anonymous> (/home/lally/workspace/mongoose/playground/parallel.save.js:31:6)\r\n    at Module._compile (internal/modules/cjs/loader.js:678:30)\r\n    at Object.Module._extensions..js (internal/modules/cjs/loader.js:689:10)\r\n    at Module.load (internal/modules/cjs/loader.js:589:32)\r\n  message: 'Can\\'t save() the same doc multiple times in parallel. Document: 5b2c9a3276254b3c471396c2',\r\n  name: 'ParallelSaveError' }\r\n```\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```js\r\n#!/usr/bin/env node\r\n\r\n'use strict';\r\n\r\nprocess.env.MONGODB_URI =\r\n    (process.env.MONGODB_URI || 'mongodb://localhost/mongoose-playground');\r\n\r\n/* dependencies */\r\nconst mongoose = require('mongoose');\r\nconst Schema = mongoose.Schema;\r\n\r\n\r\nmongoose.connect(process.env.MONGODB_URI);\r\n\r\nconst NoteSchema = new Schema({\r\n    body: String\r\n});\r\n\r\nNoteSchema.pre('save', function(next) {\r\n    next();\r\n});\r\n\r\nNoteSchema.post('save', function(note, next) {\r\n    note.save(function(error, saved) {\r\n        next(error, saved);\r\n    });\r\n});\r\n\r\nconst Note = mongoose.model('Note', NoteSchema);\r\n\r\nNote.create({ body: 'Quick note' }, function(error, note) {\r\n    console.log(error);\r\n    console.log(note);\r\n});\r\n```\r\n\r\n**What is the expected behavior?**\r\nPost save hook have to work as expected and not restricted with parallel saving checkings\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nnode.js : v10.1.0\r\nmongoose: v5.1.6\r\nMongoDB: v3.4.10\r\n\r\n\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?** Bug :bug: \r\n\r\n**What is the current behavior?**\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nPushing an object into a triple-nested array makes mongoose crash. This is a follow-up of #6398, where pushing into a double-nested array was broken. Standalone example:\r\n```javascript\r\nvar mongoose = require(\"mongoose\");\r\n\r\nvar model = mongoose.model(\"TestModel\", new mongoose.Schema({\r\n\tname: String,\r\n\tarray: [[[{key: String, value: Number}]]]\r\n}));\r\n\r\nmongoose.connect(\"mongodb://localhost/test\");\r\n\r\nmongoose.connection.on(\"connected\", async () => {\r\n\tawait new model({name: \"small\", array: [[[\r\n\t\t{key: \"answer\", value: 42}\r\n\t]]]}).save();\r\n\tvar doc = await model.findOne().exec();\r\n\tdoc.array[0][0].push({key: \"lucky\", value: 7});\r\n\tprocess.exit(0);\r\n});\r\n```\r\n\r\nThis throws a TypeError at the same location as in #6398:\r\n```\r\n(node:30250) UnhandledPromiseRejectionWarning: TypeError: Right-hand side of 'instanceof' is not callable\r\n    at Array._cast (/home/mpsijm/tmp/mongoose-test/node_modules/mongoose/lib/types/documentarray.js:122:15)\r\n    at Array._mapCast (/home/mpsijm/tmp/mongoose-test/node_modules/mongoose/lib/types/array.js:302:17)\r\n    at Arguments.map (<anonymous>)\r\n    at Array.push (/home/mpsijm/tmp/mongoose-test/node_modules/mongoose/lib/types/array.js:316:25)\r\n    at NativeConnection.mongoose.connection.on (/home/mpsijm/tmp/mongoose-test/index.js:15:18)\r\n    at <anonymous>\r\n    at process._tickCallback (internal/process/next_tick.js:182:7)\r\n```\r\n\r\n**What is the expected behavior?**\r\nThe document should be updated without throwing a TypeError.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\n```\r\n$ grep mongoose package.json\r\n    \"mongoose\": \"^5.1.5\"\r\n$ node --version\r\nv9.11.2\r\n$ mongo --version\r\nMongoDB shell version v3.6.5\r\ngit version: a20ecd3e3a174162052ff99913bc2ca9a839d618\r\nOpenSSL version: OpenSSL 1.0.2g  1 Mar 2016\r\nallocator: tcmalloc\r\nmodules: none\r\nbuild environment:\r\n    distmod: ubuntu1604\r\n    distarch: x86_64\r\n    target_arch: x86_64\r\n```\r\n"},{"labels":["bug"],"text":"When calling schema.add at any plugin, the alias is not applied to the schema.\r\n\r\n~~~javascript\r\nschema.add({\r\n    my_field: {\r\n        type: String,\r\n        alias: 'customfieldname'\r\n    }\r\n})\r\n~~~\r\n\r\nAt `schema.js` it seems that the function `aliasFields` is called only in the `constructor`.\r\n\r\nNode.js `8.11.1`\r\nMongoose `5.1.5`\r\n"},{"labels":["bug"],"text":"Currently, mongoose doesn't parse string representation of booleans when it comes to MongoDB operators that use a boolean.\r\n\r\nOne of the use cases here would be receiving the query as a querystring in the HTTP request, which doesn't automatically parse string representation of booleans as booleans, and I believe we're already parsing string representation of numbers for things like `$gt` .\r\n\r\n```js\r\nconst mongoose = require('mongoose');\r\nconst { Schema } = mongoose;\r\nconst assert = require('assert');\r\n\r\nconst userSchema = new Schema({ name: String });\r\n\r\nconst User = mongoose.model('User', userSchema);\r\n\r\nmongoose.connect('mongodb://localhost/test');\r\n\r\nlet user = new User({ name: 'Hafez' });\r\n\r\nconst run = async () => {\r\n  await user.save();\r\n\r\n  let foundUser = await User.findOne({ name: { $exists: 'true' } });\r\n\r\n  assert.ok(foundUser);\r\n};\r\n\r\nrun().catch(console.error);\r\n```\r\n\r\noutput\r\n```\r\nError: $exists parameter must be a boolean!\r\n    at SchemaString.module.exports (E:\\Info\\localhost\\Web Development\\NodeJS\\autotash\\node_modules\\mongoose\\lib\\schema\\operators\\exists.js:9:11)\r\n    at SchemaString.castForQuery (E:\\Info\\localhost\\Web Development\\NodeJS\\autotash\\node_modules\\mongoose\\lib\\schema\\string.js:508:20)\r\n    at SchemaString.SchemaType.castForQueryWrapper (E:\\Info\\localhost\\Web Development\\NodeJS\\autotash\\node_modules\\mongoose\\lib\\schematype.js:1077:17)\r\n    at cast (E:\\Info\\localhost\\Web Development\\NodeJS\\autotash\\node_modules\\mongoose\\lib\\cast.js:281:39)\r\n    at model.Query.Query.cast (E:\\Info\\localhost\\Web Development\\NodeJS\\autotash\\node_modules\\mongoose\\lib\\query.js:3319:12)\r\n    at model.Query.Query._castConditions (E:\\Info\\localhost\\Web Development\\NodeJS\\autotash\\node_modules\\mongoose\\lib\\query.js:1293:10)\r\n    at model.Query.Query._findOne (E:\\Info\\localhost\\Web Development\\NodeJS\\autotash\\node_modules\\mongoose\\lib\\query.js:1518:8)\r\n    at process.nextTick (E:\\Info\\localhost\\Web Development\\NodeJS\\autotash\\node_modules\\kareem\\index.js:333:33)\r\n    at process._tickCallback (internal/process/next_tick.js:61:11)\r\n```\r\n\r\nWould also be nice if mongoose parses numbers to their string representation when text searching.\r\n\r\n```js\r\nconst mongoose = require('mongoose');\r\nconst assert = require('assert');\r\nconst { Schema } = mongoose;\r\n\r\nmongoose.connect('mongodb://localhost/test');\r\n\r\nconst userSchema = new Schema({ zipCode: String });\r\n\r\nuserSchema.index({ zipCode: 'text' });\r\n\r\nconst User = mongoose.model('User', userSchema);\r\n\r\nlet user = new User({ zipCode: '1234' });\r\nlet anotherUser = new User({ zipCode: 'A2345' })\r\n\r\nconst run = async () => {\r\n  await user.save();\r\n\r\n  let foundUser = await User.findOne({ $text: { $search: 1234 } });\r\n  \r\n  assert.ok(foundUser);\r\n};\r\n\r\nrun().catch(console.error);\r\n```\r\n\r\noutput:\r\n```\r\n{ MongoError: \"$search\" had the wrong type. Expected String, found NumberInt32\r\n    at queryCallback (E:\\Info\\localhost\\Web Development\\NodeJS\\autotash\\node_modules\\mongoose\\node_modules\\mongodb-core\\lib\\cursor.js:244:25)\r\n    at E:\\Info\\localhost\\Web Development\\NodeJS\\autotash\\node_modules\\mongoose\\node_modules\\mongodb-core\\lib\\connection\\pool.js:544:18\r\n    at process._tickCallback (internal/process/next_tick.js:61:11)\r\n  name: 'MongoError',\r\n  message:\r\n   '\"$search\" had the wrong type. Expected String, found NumberInt32',\r\n  waitedMS: 0,\r\n  ok: 0,\r\n  errmsg:\r\n   '\"$search\" had the wrong type. Expected String, found NumberInt32',\r\n  code: 14 }\r\n```\r\n\r\nThe idea is that we become more flexible with the types, so that queries coming from different sources can work flawlessly.\r\n\r\nMongoDB v3.2.7\r\nmongoose v5.1.4"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nWhen performing a virtual population using a model that is created with the ```Schema.add``` method, I received the following error:\r\n\r\n```\r\n/Users/mac/Documents/code/playground/mongoose-tests/node_modules/mongoose/lib/utils.js:225\r\n        throw error;\r\n        ^\r\n\r\nTypeError: Cannot read property 'indexOf' of undefined\r\n    at /Users/mac/Documents/code/playground/mongoose-tests/node_modules/mongoose/lib/services/populate/getSchemaTypes.js:45:26\r\n    at Array.reduce (<anonymous>)\r\n    at search (/Users/mac/Documents/code/playground/mongoose-tests/node_modules/mongoose/lib/services/populate/getSchemaTypes.js:44:15)\r\n    at search (/Users/mac/Documents/code/playground/mongoose-tests/node_modules/mongoose/lib/services/populate/getSchemaTypes.js:89:21)\r\n    at search (/Users/mac/Documents/code/playground/mongoose-tests/node_modules/mongoose/lib/services/populate/getSchemaTypes.js:89:21)\r\n    at getSchemaTypes (/Users/mac/Documents/code/playground/mongoose-tests/node_modules/mongoose/lib/services/populate/getSchemaTypes.js:114:10)\r\n    at getModelsMapForPopulate (/Users/mac/Documents/code/playground/mongoose-tests/node_modules/mongoose/lib/model.js:3638:14)\r\n    at populate (/Users/mac/Documents/code/playground/mongoose-tests/node_modules/mongoose/lib/model.js:3254:21)\r\n    at _populate (/Users/mac/Documents/code/playground/mongoose-tests/node_modules/mongoose/lib/model.js:3224:5)\r\n    at utils.promiseOrCallback.cb (/Users/mac/Documents/code/playground/mongoose-tests/node_modules/mongoose/lib/model.js:3197:5)\r\n    at Object.promiseOrCallback (/Users/mac/Documents/code/playground/mongoose-tests/node_modules/mongoose/lib/utils.js:222:14)\r\n    at Function.Model.populate (/Users/mac/Documents/code/playground/mongoose-tests/node_modules/mongoose/lib/model.js:3196:16)\r\n    at cb (/Users/mac/Documents/code/playground/mongoose-tests/node_modules/mongoose/lib/query.js:1347:17)\r\n    at result (/Users/mac/Documents/code/playground/mongoose-tests/node_modules/mongodb/lib/utils.js:414:17)\r\n    at executeCallback (/Users/mac/Documents/code/playground/mongoose-tests/node_modules/mongodb/lib/utils.js:406:9)\r\n    at handleCallback (/Users/mac/Documents/code/playground/mongoose-tests/node_modules/mongodb/lib/utils.js:128:55)\r\n```\r\n\r\nIf I use an object literal to define the Schema instead of using the ```.add``` method, it works. See blow for repo script of working and non-working examples\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\nVirtual population ***WORKING*** when model schema is created with object literal\r\n```js\r\nconst mongoose = require('mongoose')\r\n\r\nmongoose.connect('mongodb://localhost/mongoosetest')\r\nmongoose.connection.once('open', () => {\r\n\r\n  const Schema = mongoose.Schema\r\n\r\n  // Generate Users Model\r\n  const userSchema = new Schema({ id: Number, name: String })\r\n  const UserModel = mongoose.model('Users', userSchema, 'users')\r\n\r\n  // Generate Product Model\r\n  const productSchema = new Schema({ id: Number, name: String })\r\n  const ProductModel = mongoose.model('Products', productSchema, 'product')\r\n\r\n  // ***** Generate Flexible Item Schema with Object Literal *****\r\n  const flexibleItemSchema = new Schema({\r\n    outer: {\r\n      inner: {\r\n        flexible: [\r\n          new Schema(\r\n            { 'kind': String },\r\n            { discriminatorKey: 'kind' }    \r\n          )\r\n        ]\r\n      }\r\n    }\r\n  })\r\n\r\n  const docArray = flexibleItemSchema.path('outer.inner.flexible')\r\n\r\n  // Create Flexible User Discriminator\r\n  const flexibleUserSchema = new Schema({\r\n    users: [{}]\r\n  })\r\n\r\n  flexibleUserSchema.virtual('users_$', {\r\n    ref: 'Users',\r\n    localField: 'users.id',\r\n    foreignField: 'id'\r\n  })\r\n\r\n  docArray.discriminator('flexible_users', flexibleUserSchema)\r\n\r\n  // Create Flexible Product Discriminator\r\n  const flexibleProductSchema = new Schema({\r\n    products: [{}]\r\n  })\r\n  \r\n  flexibleProductSchema.virtual('products_$', {\r\n    ref: 'Products',\r\n    localField: 'products.id',\r\n    foreignField: 'id'\r\n  })\r\n\r\n  docArray.discriminator('flexible_product', flexibleProductSchema)\r\n\r\n  const FlexibleItemModel = mongoose.model('FlexibleModel', flexibleItemSchema, 'items')\r\n\r\n  // Generate Items\r\n  const user = { id: 111, name: 'John Doe' }\r\n  const product = { id: 222, name: 'Notebook' }\r\n  const flexibleItem = {\r\n    outer: {\r\n      inner: {\r\n        flexible: [\r\n          {\r\n            kind: 'flexible_users',\r\n            users: [\r\n              { id: 111, refKey: 'Users' }\r\n            ]\r\n          },\r\n          {\r\n            kind: 'flexible_product',\r\n            products: [\r\n              { id: 222, refKey: 'Products' }\r\n            ]\r\n          }\r\n        ]\r\n      }\r\n    }\r\n  };\r\n\r\n  // Clearing out the collections before creating items\r\n  Promise.all([ UserModel.remove({}), ProductModel.remove({}), FlexibleItemModel.remove({}) ])\r\n  .then(() => Promise.all([UserModel.create(user), ProductModel.create(product), FlexibleItemModel.create(flexibleItem)]))\r\n  .then(function(){\r\n    FlexibleItemModel.find({})\r\n      // Populate virtual field of embedded discriminator\r\n      .populate('outer.inner.flexible.users_$') \r\n      .populate('outer.inner.flexible.products_$') \r\n      .lean()\r\n      .then(results => {\r\n        console.log(JSON.stringify(results, null, 2))\r\n      })\r\n  })\r\n})\r\n```\r\n\r\nVirtual population ***NOT WORKING*** when model schema is created with ```.add``` method\r\n```js\r\nconst mongoose = require('mongoose')\r\n\r\nmongoose.connect('mongodb://localhost/mongoosetest')\r\nmongoose.connection.once('open', () => {\r\n\r\n  const Schema = mongoose.Schema\r\n\r\n  // Generate Users Model\r\n  const userSchema = new Schema({ id: Number, name: String })\r\n  const UserModel = mongoose.model('Users', userSchema, 'users')\r\n\r\n  // Generate Product Model\r\n  const productSchema = new Schema({ id: Number, name: String })\r\n  const ProductModel = mongoose.model('Products', productSchema, 'product')\r\n\r\n  // ***** Generate Flexible Item Schema with Schema.add method *****\r\n  const flexibleItemSchema = new Schema()\r\n  const outerSchema = new Schema()\r\n  const innerSchema = new Schema()\r\n\r\n  flexibleItemSchema.add({\r\n    outer: outerSchema\r\n  })\r\n\r\n  outerSchema.add({\r\n    inner: innerSchema\r\n  })\r\n\r\n  innerSchema.add({\r\n    flexible: [\r\n      new Schema(\r\n        { 'kind': String },\r\n        { discriminatorKey: 'kind' }    \r\n      )\r\n    ]\r\n  })\r\n\r\n  const docArray = innerSchema.path('flexible')\r\n\r\n\r\n  // Create Flexible User Discriminator\r\n  const flexibleUserSchema = new Schema({\r\n    users: [{}]\r\n  })\r\n\r\n  flexibleUserSchema.virtual('users_$', {\r\n    ref: 'Users',\r\n    localField: 'users.id',\r\n    foreignField: 'id'\r\n  })\r\n\r\n  docArray.discriminator('flexible_users', flexibleUserSchema)\r\n\r\n  // Create Flexible Product Discriminator\r\n  const flexibleProductSchema = new Schema({\r\n    products: [{}]\r\n  })\r\n  \r\n  flexibleProductSchema.virtual('products_$', {\r\n    ref: 'Products',\r\n    localField: 'products.id',\r\n    foreignField: 'id'\r\n  })\r\n\r\n  docArray.discriminator('flexible_product', flexibleProductSchema)\r\n\r\n  const FlexibleItemModel = mongoose.model('FlexibleModel', flexibleItemSchema, 'items')\r\n\r\n  // Generate Items\r\n  const user = { id: 111, name: 'John Doe' }\r\n  const product = { id: 222, name: 'Notebook' }\r\n  const flexibleItem = {\r\n    outer: {\r\n      inner: {\r\n        flexible: [\r\n          {\r\n            kind: 'flexible_users',\r\n            users: [\r\n              { id: 111, refKey: 'Users' }\r\n            ]\r\n          },\r\n          {\r\n            kind: 'flexible_product',\r\n            products: [\r\n              { id: 222, refKey: 'Products' }\r\n            ]\r\n          }\r\n        ]\r\n      }\r\n    }\r\n  };\r\n\r\n  // Clearing out the collections before creating items\r\n  Promise.all([ UserModel.remove({}), ProductModel.remove({}), FlexibleItemModel.remove({}) ])\r\n  .then(() => Promise.all([UserModel.create(user), ProductModel.create(product), FlexibleItemModel.create(flexibleItem)]))\r\n  .then(function(){\r\n    FlexibleItemModel.find({})\r\n      // Populate virtual field of embedded discriminator\r\n      .populate('outer.inner.flexible.users_$') \r\n      .populate('outer.inner.flexible.products_$') \r\n      .lean()\r\n      .then(results => {\r\n        console.log(JSON.stringify(results, null, 2))\r\n      })\r\n  })\r\n})\r\n\r\n```\r\n**What is the expected behavior?**\r\nExpected mongoose not to error and to receive populated results similar to:\r\n\r\n```\r\n[\r\n  {\r\n    \"_id\": \"5b1aef1be537c28b6712b8af\",\r\n    \"outer\": {\r\n      \"inner\": {\r\n        \"flexible\": [\r\n          {\r\n            \"users\": [\r\n              {\r\n                \"id\": 111,\r\n                \"refKey\": \"Users\"\r\n              }\r\n            ],\r\n            \"_id\": \"5b1aef1be537c28b6712b8b1\",\r\n            \"kind\": \"flexible_users\",\r\n            \"users_$\": [\r\n              {\r\n                \"_id\": \"5b1aef1be537c28b6712b8ad\",\r\n                \"id\": 111,\r\n                \"name\": \"John Doe\",\r\n                \"__v\": 0\r\n              }\r\n            ],\r\n            \"products_$\": []\r\n          },\r\n          {\r\n            \"products\": [\r\n              {\r\n                \"id\": 222,\r\n                \"refKey\": \"Products\"\r\n              }\r\n            ],\r\n            \"_id\": \"5b1aef1be537c28b6712b8b0\",\r\n            \"kind\": \"flexible_product\",\r\n            \"users_$\": [],\r\n            \"products_$\": [\r\n              {\r\n                \"_id\": \"5b1aef1be537c28b6712b8ae\",\r\n                \"id\": 222,\r\n                \"name\": \"Notebook\",\r\n                \"__v\": 0\r\n              }\r\n            ]\r\n          }\r\n        ]\r\n      }\r\n    },\r\n    \"__v\": 0\r\n  }\r\n]\r\n```\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nMongoose: 5.1.4\r\nNode: 8.11.1\r\nMongo: 3.6.4"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nI would like to report a bug, but this bug occurs in combination with **webpack** only. It seems to be a declaration of a **global** variable named **\"indexes\"** somewhere else in the code. I'm using node js version **v8.9.0**.\r\n\r\n**What is the current behavior?**\r\nThe current behavior is that, during the bundle time of webpack in node js mode I receiving following error: \r\n\r\n`ERROR in ./node_modules/mongoose/lib/services/schema/indexes.js\r\nModule build failed: Duplicate declaration \"indexes\"\r\n\r\n  10 |\r\n  11 | module.exports = function indexes(schema) {\r\n> 12 |   let indexes = [];\r\n     |       ^\r\n  13 |   const schemaStack = [];\r\n  14 |   const indexTypes = schema.constructor.indexTypes;\r\n  15 |\r\n\r\n @ ./node_modules/mongoose/lib/schema.js 17:14-50\r\n @ ./node_modules/mongoose/lib/index.js\r\n @ ./node_modules/mongoose/index.js`\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nSteps to reproduce:\r\n\r\n1. install dependencies: \r\n`$ yarn add mongoose \r\n$ yarn add webpack webpack-cli uglifyjs-webpack-plugin --dev`\r\n2.  import mongoose anywhere in app.js like here:\r\n`import mongoose from 'mongoose';\r\n` in this case you should also install babel latest sytax and create a .babelrc\r\n3. use this webpack config:\r\n\r\n```\r\nlet path = require('path');\r\nlet webpack = require('webpack');\r\nconst BUILD_PATH = path.resolve(__dirname, './dist');\r\nconst UglifyJSPlugin = require('uglifyjs-webpack-plugin');\r\n\r\nmodule.exports = {\r\n  entry: ['babel-polyfill', './app/index.js'],\r\n  output: {\r\n    path: BUILD_PATH,\r\n    filename: 'bundle.js'\r\n  },\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.js$/,\r\n        exclude: '/node_modules/',\r\n        loader: 'babel-loader'\r\n      }\r\n    ]\r\n  },\r\n  plugins: [\r\n    new webpack.HotModuleReplacementPlugin({\r\n      multiStep: true\r\n    }),\r\n    new webpack.NoEmitOnErrorsPlugin(),\r\n    new webpack.DefinePlugin({\r\n      'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV)\r\n    })\r\n  ],\r\n  optimization: {\r\n    minimizer: [\r\n      new UglifyJSPlugin({\r\n        uglifyOptions: {\r\n          warning: \"verbose\",\r\n          ecma: 7,\r\n          beautify: false,\r\n          compress: false,\r\n          comments: false,\r\n          mangle: false,\r\n          toplevel: false,\r\n          keep_classnames: true,\r\n          keep_fnames: true\r\n        }\r\n      })\r\n    ]\r\n  },\r\n  target: 'node',\r\n  node: {\r\n    __filename: false,\r\n    __dirname: false\r\n  },\r\n  devtool: 'eval-source-map',\r\n};\r\n```\r\n\r\n\r\n**What is the expected behavior?**\r\nNo build (bundle) time error. By the way, with version 4.0 and above this bug disappears. \r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNodejs **v8.9.0**\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nReport a bug.\r\n\r\n**What is the current behavior?**\r\nWhen we override mongoose custom methods like toString() on a schema, then we console.log with a template literals expressions string, we got this error.\r\n``` sh\r\n TypeError: Cannot convert object to primitive value\r\n    at Comment.findOne.then.comment (/test.js:37:58)\r\n```\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nrepro script:\r\n```js\r\nconst mongoose = require('mongoose');\r\nconst assert = require('assert');\r\nmongoose.connect('mongodb://localhost:27017/test');\r\nconst connection = mongoose.connection;\r\n\r\nmongoose.plugin(function (schema) {\r\n\r\n  schema.methods.toString = function () {\r\n    return `${this.constructor.modelName}(${this._id})`;\r\n  };\r\n\r\n});\r\n\r\nlet commentSchema = new mongoose.Schema({\r\n  title: {\r\n    type: String,\r\n    index: true\r\n  }\r\n});\r\n\r\nconst Comment = mongoose.model('Comment', commentSchema);\r\n\r\nasync function run() {\r\n  for (let i in [...Array(10).keys()]) {\r\n    let comment = new Comment({\r\n      title: `comment${i}`,\r\n    });\r\n\r\n    await comment.save();\r\n  }\r\n\r\n  await Comment\r\n    .findOne({\r\n      title: 'comment5'\r\n    })\r\n    .then(comment => {\r\n        assert.strictEqual(`Comment(${comment._id})`, `${comment}`);\r\n      }\r\n    );\r\n\r\n  return connection.close();\r\n};\r\n\r\nrun().catch(console.error);\r\n```\r\n**What is the expected behavior?**\r\nOverride mongoose custom methods without using the createWrapper of Kareem lib if the method  does  not have a hook ( look at /mongoose/lib/services/model/applyHooks.js:67)\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNode v9.11.1\r\nMongoDB v3.2.20\r\nMongoose v5.1.3"},{"labels":["bug"],"text":"I believe there is a bug using nested populates and options.\r\n\r\nMy current query is as follows:\r\n```js\r\n...\r\nawait Post.find(\r\n          { teacher: req.params.id },\r\n          {},\r\n          {\r\n            sort: { createdAt: -1 },\r\n            limit: 5,\r\n            skip: parseInt(req.query.skip, 10)\r\n          }\r\n        ).populate([\r\n        {\r\n          path: 'comments',\r\n          options: {\r\n            limit: 5,\r\n            sort: { createdAt: -1 }\r\n          },\r\n          populate: { path: 'user', select: '-password' }\r\n        }\r\n      ])\r\n...\r\n```\r\n\r\nWhen including `options` on the `comments` populate (which has another populate nested inside), it returns more than specified `limit` and `sort` is not applied. If the nested populate is removed, it works as intended.\r\n\r\nCurrently, using:\r\n\r\nNode 10.2.1\r\nMongoose 5.1.2\r\nMongo 3.6.5\r\n\r\nIs this a bug or am I missing something?\r\n\r\nI believe this might be related: https://github.com/Automattic/mongoose/issues/4321"},{"labels":["bug"],"text":"Fix for #6482 only handles single embedded doc discriminators, also need to handle embedded discriminators on document arrays."},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nCurrently the model method on the connection prototype does not check if the passed `name` is a function ie. extending the model class. Therefore it is not registered under the correct name to the connections models and throws a schema not found error. \r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\nThe code to check if the name is an instance of the `Model` should also be used in the connection model method: \r\n\r\n```\r\nif (typeof name === 'function') {\r\n    model = name;\r\n    name = model.name;\r\n    if (!(model.prototype instanceof Model)) {\r\n      throw new mongoose.Error('The provided class ' + name + ' must extend Model');\r\n    }\r\n  }\r\n```\r\n\r\nCurrently the name is registered as a strignified version of the function which when using the correct name is obviously not found locally or if **the cache is off** it also won't be registered to the base instance. As such it will throw a MissingSchema error.\r\n\r\n**What is the expected behavior?**\r\nA model extending the `mongoose.Model` constructor can be passed to a non-default mongoose connection ie. mongoose.createConnection(uri) and register the model correctly.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNode.JS: 8.10, Mongoose 5.1.2, MongoDB 3.6.3 Community"},{"labels":["bug"],"text":"Using this schema,\r\n```\r\nvar cvSchema = new Schema({\r\n    title: String,\r\n    date: { type: Date, default: Date.now },\r\n    sections: [{\r\n        name: String,\r\n        active: Boolean,\r\n        list: [{\r\n            kind: String,\r\n            active: Boolean,\r\n            item: { type: Schema.Types.ObjectId, refPath: 'sections.list.kind' }\r\n        }]\r\n    }]\r\n});\r\n```\r\n```\r\nvar jobSchema = new Schema({\r\n    kind: String,\r\n    title: String,\r\n    company: String\r\n});\r\n```\r\nthis query\r\n```\r\n    CV.find().populate('sections.list.item').exec(function(err, cvs) {\r\n        if (err) {\r\n            res.send(err);\r\n        } else {\r\n            res.json(cvs);\r\n        }\r\n    });\r\n```\r\nreturns this error\r\n> Schema hasn't been registered for model \"Job,Job\". Use mongoose.model(name, schema)\r\n\r\nThis seems to be because the dynamic reference is nested inside the array `sections`. Because the data contains two `Job`s, mongoose is concatenating their `kind` and searching for the `refPath` `Job,Job` rather than `Job`.\r\n\r\nTo test this, I changed the schema to\r\n```\r\nvar cvSchema = new Schema({\r\n    title: String,\r\n    date: { type: Date, default: Date.now },\r\n    sections: {\r\n        name: String,\r\n        active: Boolean,\r\n        list: [{\r\n            kind: String,\r\n            active: Boolean,\r\n            item: { type: Schema.Types.ObjectId, refPath: 'sections.list.kind' }\r\n        }]\r\n    }\r\n});\r\n```\r\nand was successful.\r\n\r\nI'm not sure if this qualifies as a bug, enhancement or my own failure. Thanks for any assistance.\r\n\r\nmongoose: v5.0.2\r\nnode: v6.9.4"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nReport a bug.\r\n\r\n\r\n**What is the current behavior?**\r\nNow, when we use `.lean()` on a query, and populate on the same query, the main document is converted to a POJO, while the subdocs aren't.\r\n\r\n\r\n**What is the expected behavior?**\r\n`.lean()` should convert the document, and all subdocuments to POJO.\r\n\r\nquoting @vkarpov15  on https://github.com/Automattic/mongoose/issues/4802#issuecomment-267864633\r\n\r\n>Just do .lean() on the query if you want to use lean and that'll make the top level doc and every subdoc lean.\r\n\r\nalso, I have other suggestions according to lean that can be sum up in:\r\nThe lean option precedence should be like this:\r\n1- Is it set explicitly? Then use it.\r\n2- not explicitly? find the closest parent that has a lean option set in, and take that as the setting.\r\n\r\nThe closest thing I can think of to this is **css inheritance**, I hope it's clear what I mean, let me know if I can elaborate more in any way.\r\n\r\nIf this behavior is accepted, let me know and I can work on it in a week or so.\r\n\r\nrepro script:\r\n\r\n`nodemon --exec mocha test.js -R min`\r\n\r\n```js\r\n// test.js\r\nconst mongoose = require('mongoose');\r\nconst { Schema } = mongoose;\r\nconst assert = require('assert');\r\n\r\nmongoose.connect('mongodb://localhost:27017/test');\r\n\r\n\r\nconst userSchema = new Schema({\r\n  name: String,\r\n  roomId: { type: Schema.ObjectId, ref: 'Room' }\r\n});\r\nconst officeSchema = new Schema();\r\nconst roomSchema = new Schema({ officeId: { type: Schema.ObjectId, ref: 'Office' } });\r\n\r\nconst User = mongoose.model('User', userSchema);\r\nconst Office = mongoose.model('Office', officeSchema);\r\nconst Room = mongoose.model('Room', roomSchema);\r\n\r\nconst user = new User();\r\nconst office = new Office();\r\nconst room = new Room();\r\n\r\nuser.roomId = room._id;\r\nroom.officeId = office._id;\r\n\r\nconst isLean = (doc) => !(doc instanceof mongoose.Document);\r\n\r\ndescribe('lean', function () {\r\n  this.timeout(10000);\r\n\r\n  before(async () => {\r\n    await Promise.all([User.remove(), Office.remove(), room.remove()]);\r\n    await Promise.all([user.save(), office.save(), room.save()]);\r\n  });\r\n\r\n  it('document, and subdocuments are not lean by default', async () => {\r\n    let user = await User.findOne()\r\n      .populate({\r\n        path: 'roomId',\r\n        populate: {\r\n          path: 'officeId'\r\n        }\r\n      });\r\n\r\n    assert.equal(isLean(user), false);\r\n    assert.equal(isLean(user.roomId), false);\r\n    assert.equal(isLean(user.roomId.officeId), false);\r\n  });\r\n\r\n  describe('lean inheritance', () => {\r\n    it('.lean() makes query result, and all populated fields lean', async () => {\r\n      let user = await User.findOne()\r\n        .populate({\r\n          path: 'roomId',\r\n          populate: {\r\n            path: 'officeId'\r\n          }\r\n        })\r\n        .lean();\r\n\r\n      assert.equal(isLean(user), true);\r\n      assert.equal(isLean(user.roomId), true);\r\n      assert.equal(isLean(user.roomId.officeId), true);\r\n    });\r\n\r\n\r\n    it('disabling lean at some populating level reflects on it, and descendants', async () => {\r\n      let user = await User.findOne()\r\n        .populate({\r\n          path: 'roomId',\r\n          options: { lean: false },\r\n          populate: {\r\n            path: 'officeId'\r\n          }\r\n        })\r\n        .lean();\r\n\r\n      assert.equal(isLean(user), true);\r\n      assert.equal(isLean(user.roomId), false);\r\n      assert.equal(isLean(user.roomId.officeId), false);\r\n    });\r\n\r\n    it('enabling lean at some populating level reflects on it, and descendants', async () => {\r\n      let user = await User.findOne()\r\n        .populate({\r\n          path: 'roomId',\r\n          options: { lean: true },\r\n          populate: {\r\n            path: 'officeId'\r\n          }\r\n        });\r\n\r\n      assert.equal(isLean(user), false);\r\n      assert.equal(isLean(user.roomId), true);\r\n      assert.equal(isLean(user.roomId.officeId), true);\r\n    });\r\n\r\n\r\n    it('disabling lean on nested population overwrites parent lean', async () => {\r\n      let user = await User.findOne()\r\n        .populate({\r\n          path: 'roomId',\r\n          options: { lean: true },\r\n          populate: {\r\n            options: { lean: false },\r\n            path: 'officeId'\r\n          }\r\n        });\r\n\r\n      assert.equal(isLean(user), false);\r\n      assert.equal(isLean(user.roomId), true);\r\n      assert.equal(isLean(user.roomId.officeId), false);\r\n    });\r\n  });\r\n});\r\n```\r\n\r\nNode v10.1.0\r\nMongoDB v3.2.7\r\nMongoose v5.1.2"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nVirtual population of field on an embedded discriminator works when the virtual field is at the root of the embedded object schema. However, if the virtual field is nested within the object it will not work.\r\n\r\nMay be related to: https://github.com/Automattic/mongoose/issues/6487 and https://github.com/Automattic/mongoose/issues/6411\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\nVirtual Population **WORKING** When Virtual Field Is At Root of Embedded Object Schema\r\n\r\n```javascript\r\nconst mongoose = require('mongoose')\r\nmongoose.connect('mongodb://localhost/mongoosetest')\r\nmongoose.connection.once('open', () => {\r\n\r\n  const Schema = mongoose.Schema\r\n\r\n  // Generate Users Model\r\n  const userSchema = new Schema({ employeeId: Number, name: String })\r\n  const UserModel = mongoose.model('Users', userSchema, 'users')\r\n\r\n  // Generate Embedded Discriminators\r\n  const eventSchema = new Schema(\r\n    { message: String },\r\n    { discriminatorKey: 'kind'}\r\n  );\r\n\r\n  const batchSchema = new Schema({\r\n    nested: { \r\n      events: [eventSchema]\r\n    }\r\n  });\r\n\r\n  const docArray = batchSchema.path('nested.events'); \r\n\r\n  // First embedded discriminator schema\r\n  const clickedSchema = new Schema(\r\n    {\r\n      element: { type: String },\r\n      users: [ Number ]\r\n    },\r\n    {\r\n      toJSON: { virtuals: true},\r\n      toObject: { virtuals: true}\r\n    }\r\n  );\r\n\r\n  // Add virtual to first embedded discriminator schema for virtual population\r\n  clickedSchema.virtual('users_$', {    // <=== Virtual at root of embedded discriminator schema\r\n    ref: 'Users',\r\n    localField: 'users',\r\n    foreignField: 'employeeId'\r\n  })\r\n  \r\n  const Clicked = docArray.discriminator('Clicked', clickedSchema);\r\n\r\n  // Second embedded discriminator\r\n  const Purchased = docArray.discriminator('Purchased', new Schema({\r\n    product: { type: String }\r\n  }));\r\n\r\n  const Batch = mongoose.model('EventBatch', batchSchema);\r\n\r\n  // Generate Items\r\n  const user = { employeeId: 1, name: 'Test name' }\r\n  const batch = {\r\n    nested: {   \r\n      events: [\r\n        { kind: 'Clicked', element: '#hero', message: 'hello', users: [1] },\r\n        { kind: 'Purchased', product: 'action-figure-1', message: 'world' }\r\n      ]\r\n    }\r\n  };\r\n\r\n  // Clearing out the collections before creating items\r\n  Promise.all([ UserModel.remove({}), Batch.remove({}) ])\r\n  .then(() => Promise.all([UserModel.create(user), Batch.create(batch)]))\r\n  .then(function(){\r\n    Batch.find({})\r\n      // Populate virtual field of embedded discriminator\r\n      .populate('nested.events.users_$') \r\n      .lean()\r\n      .then(results => {\r\n        console.log(JSON.stringify(results, null, 2))\r\n      })\r\n  })\r\n})\r\n```\r\nReceived correct output with \"users_$\" populated\r\n```json\r\n[\r\n  {\r\n    \"_id\": \"5b01e27d2956fa8bcbd4a5f9\",\r\n    \"nested\": {\r\n      \"events\": [\r\n        {\r\n          \"users\": [\r\n            1\r\n          ],\r\n          \"_id\": \"5b01e27d2956fa8bcbd4a5fb\",\r\n          \"kind\": \"Clicked\",\r\n          \"element\": \"#hero\",\r\n          \"message\": \"hello\",\r\n          \"users_$\": [\r\n            {\r\n              \"_id\": \"5b01e27d2956fa8bcbd4a5f8\",\r\n              \"employeeId\": 1,\r\n              \"name\": \"Test name\",\r\n              \"__v\": 0\r\n            }\r\n          ]\r\n        },\r\n        {\r\n          \"_id\": \"5b01e27d2956fa8bcbd4a5fa\",\r\n          \"kind\": \"Purchased\",\r\n          \"product\": \"action-figure-1\",\r\n          \"message\": \"world\",\r\n          \"users_$\": []\r\n        }\r\n      ]\r\n    },\r\n    \"__v\": 0\r\n  }\r\n]\r\n```\r\nVirtual Population **NOT WORKING** When Virtual Field Is Nested Within Embedded Object Schema\r\n```javascript\r\nconst mongoose = require('mongoose')\r\nmongoose.connect('mongodb://localhost/mongoosetest')\r\nmongoose.connection.once('open', () => {\r\n\r\n  const Schema = mongoose.Schema\r\n\r\n  // Generate Users Model\r\n  const userSchema = new Schema({ employeeId: Number, name: String })\r\n  const UserModel = mongoose.model('Users', userSchema, 'users')\r\n\r\n  // Generate Embedded Discriminators\r\n  const eventSchema = new Schema(\r\n    { message: String },\r\n    { discriminatorKey: 'kind'}\r\n  );\r\n\r\n  const batchSchema = new Schema({\r\n    nested: { \r\n      events: [eventSchema]\r\n    }\r\n  });\r\n\r\n  const docArray = batchSchema.path('nested.events'); \r\n\r\n  // *** Adding Nested Layer and adding virtual to schema of nestedLayer\r\n  const nestedLayerSchema = new Schema({\r\n    users: [ Number ]\r\n  },\r\n  {\r\n    toJSON: { virtuals: true},\r\n    toObject: { virtuals: true}\r\n  })\r\n\r\n  nestedLayerSchema.virtual('users_$', {\r\n    ref: 'Users',\r\n    localField: 'users',\r\n    foreignField: 'employeeId'\r\n  })\r\n  \r\n  // First embedded discriminator schema\r\n  const clickedSchema = new Schema(\r\n    {\r\n      element: { type: String },\r\n      nestedLayer: nestedLayerSchema\r\n    },\r\n    {\r\n      toJSON: { virtuals: true},\r\n      toObject: { virtuals: true}\r\n    }\r\n  );\r\n\r\n  const Clicked = docArray.discriminator('Clicked', clickedSchema);\r\n\r\n  // Second embedded discriminator\r\n  const Purchased = docArray.discriminator('Purchased', new Schema({\r\n    product: { type: String }\r\n  }));\r\n\r\n  const Batch = mongoose.model('EventBatch', batchSchema);\r\n\r\n  // Generate Items\r\n  const user = { employeeId: 1, name: 'Test name' }\r\n  const batch = {\r\n    nested: {   \r\n      events: [\r\n        { kind: 'Clicked', element: '#hero', message: 'hello', nestedLayer: { users: [1] } }, // <--- Added nestedLayer\r\n        { kind: 'Purchased', product: 'action-figure-1', message: 'world' }\r\n      ]\r\n    }\r\n  };\r\n\r\n  // Clearing out the collections before creating items\r\n  Promise.all([ UserModel.remove({}), Batch.remove({}) ])\r\n  .then(() => Promise.all([UserModel.create(user), Batch.create(batch)]))\r\n  .then(function(){\r\n    Batch.find({})\r\n      // Populate virtual field of embedded discriminator\r\n      .populate('nested.events.nestedLayer.users_$')    // <--- Populating users_$ on nestedLayer\r\n      .lean()\r\n      .then(results => {\r\n        console.log(JSON.stringify(results, null, 2))\r\n      })\r\n  })\r\n})\r\n```\r\nExpected output with \"nestedLayer.users_$\" populated but received it unpopulated\r\n```\r\n[\r\n  {\r\n    \"_id\": \"5b01ea6679c45893dadb79dd\",\r\n    \"nested\": {\r\n      \"events\": [\r\n        {\r\n          \"_id\": \"5b01ea6679c45893dadb79df\",\r\n          \"kind\": \"Clicked\",\r\n          \"element\": \"#hero\",\r\n          \"message\": \"hello\",\r\n          \"nestedLayer\": {\r\n            \"users\": [\r\n              1\r\n            ],\r\n            \"_id\": \"5b01ea6679c45893dadb79e0\"\r\n          }\r\n        },\r\n        {\r\n          \"_id\": \"5b01ea6679c45893dadb79de\",\r\n          \"kind\": \"Purchased\",\r\n          \"product\": \"action-figure-1\",\r\n          \"message\": \"world\"\r\n        }\r\n      ]\r\n    },\r\n    \"__v\": 0\r\n  }\r\n]\r\n```\r\n**What is the expected behavior?**\r\nExpected \"nestedLayer.users_$\" to be populated\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nnode: v8.11.1\r\nmongoose: 5.1.1\r\nmongo: 3.6.4"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nWhen I try to populate an embedded discriminator from a model that has a nested schema defined by an Object literal everything works. However, if I do the same but use a nested schema instantiated from mongoose.Schema, it no longer works . See working and non-working example in repro script section.\r\n\r\nThis may be related to: https://github.com/Automattic/mongoose/issues/6411 and https://github.com/Automattic/mongoose/issues/6488\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\nHere's are some examples:\r\n\r\nVirtual Population **WORKING** When Nested Schema is Defined By An Object Literal\r\n\r\n```javascript\r\nconst mongoose = require('mongoose')\r\nmongoose.connect('mongodb://localhost/mongoosetest')\r\nmongoose.connection.once('open', () => {\r\n\r\n  const Schema = mongoose.Schema\r\n\r\n  // Generate Users Model\r\n  const userSchema = new Schema({ employeeId: Number, name: String })\r\n  const UserModel = mongoose.model('Users', userSchema, 'users')\r\n\r\n  // Generate Embedded Discriminators\r\n  const eventSchema = new Schema(\r\n    { message: String },\r\n    { discriminatorKey: 'kind'}\r\n  );\r\n\r\n  const batchSchema = new Schema({\r\n    nested: { \r\n      events: [eventSchema]\r\n    }\r\n  });\r\n\r\n  const docArray = batchSchema.path('nested.events'); \r\n\r\n  // First embedded discriminator schema\r\n  const clickedSchema = new Schema(\r\n    {\r\n      element: { type: String },\r\n      users: [ Number ]\r\n    },\r\n    {\r\n      toJSON: { virtuals: true},\r\n      toObject: { virtuals: true}\r\n    }\r\n  );\r\n\r\n  // Add virtual to first embedded discriminator schema for virtual population\r\n  clickedSchema.virtual('users_$', {\r\n    ref: 'Users',\r\n    localField: 'users',\r\n    foreignField: 'employeeId'\r\n  })\r\n  \r\n  const Clicked = docArray.discriminator('Clicked', clickedSchema);\r\n\r\n  // Second embedded discriminator\r\n  const Purchased = docArray.discriminator('Purchased', new Schema({\r\n    product: { type: String }\r\n  }));\r\n\r\n  const Batch = mongoose.model('EventBatch', batchSchema);\r\n\r\n  // Generate Items\r\n  const user = { employeeId: 1, name: 'Test name' }\r\n  const batch = {\r\n    nested: {   \r\n      events: [\r\n        { kind: 'Clicked', element: '#hero', message: 'hello', users: [1] },\r\n        { kind: 'Purchased', product: 'action-figure-1', message: 'world' }\r\n      ]\r\n    }\r\n  };\r\n\r\n  // Clearing out the collections before creating items\r\n  Promise.all([ UserModel.remove({}), Batch.remove({}) ])\r\n  .then(() => Promise.all([UserModel.create(user), Batch.create(batch)]))\r\n  .then(function(){\r\n    Batch.find({})\r\n      // Populate virtual field of embedded discriminator\r\n      .populate('nested.events.users_$') \r\n      .lean()\r\n      .then(results => {\r\n        console.log(JSON.stringify(results, null, 2))\r\n      })\r\n  })\r\n})\r\n```\r\nReceived correct output with \"users_$\" populated\r\n```json\r\n[\r\n  {\r\n    \"_id\": \"5b01e27d2956fa8bcbd4a5f9\",\r\n    \"nested\": {\r\n      \"events\": [\r\n        {\r\n          \"users\": [\r\n            1\r\n          ],\r\n          \"_id\": \"5b01e27d2956fa8bcbd4a5fb\",\r\n          \"kind\": \"Clicked\",\r\n          \"element\": \"#hero\",\r\n          \"message\": \"hello\",\r\n          \"users_$\": [\r\n            {\r\n              \"_id\": \"5b01e27d2956fa8bcbd4a5f8\",\r\n              \"employeeId\": 1,\r\n              \"name\": \"Test name\",\r\n              \"__v\": 0\r\n            }\r\n          ]\r\n        },\r\n        {\r\n          \"_id\": \"5b01e27d2956fa8bcbd4a5fa\",\r\n          \"kind\": \"Purchased\",\r\n          \"product\": \"action-figure-1\",\r\n          \"message\": \"world\",\r\n          \"users_$\": []\r\n        }\r\n      ]\r\n    },\r\n    \"__v\": 0\r\n  }\r\n]\r\n```\r\n\r\nVirtual Population ***NOT WORKING*** When Nested Schema is by Schema instantiated from mongoose.Schema\r\n\r\n```javascript\r\nconst mongoose = require('mongoose')\r\nmongoose.connect('mongodb://localhost/mongoosetest')\r\nmongoose.connection.once('open', () => {\r\n\r\n  const Schema = mongoose.Schema\r\n\r\n  // Generate Users Model\r\n  const userSchema = new Schema({ employeeId: Number, name: String })\r\n  const UserModel = mongoose.model('Users', userSchema, 'users')\r\n\r\n  // Generate Embedded Discriminators\r\n  const eventSchema = new Schema(\r\n    { message: String },\r\n    { discriminatorKey: 'kind'}\r\n  );\r\n\r\n  const batchSchema = new Schema({\r\n    nested: new Schema({   //<== Schema from mongoose.Schema instead of object literal\r\n      events: [eventSchema]\r\n    })\r\n  });\r\n\r\n  const docArray = batchSchema.path('nested.events'); \r\n\r\n  // First embedded discriminator schema\r\n  const clickedSchema = new Schema(\r\n    {\r\n      element: { type: String },\r\n      users: [ Number ]\r\n    },\r\n    {\r\n      toJSON: { virtuals: true},\r\n      toObject: { virtuals: true}\r\n    }\r\n  );\r\n\r\n  // Add virtual to first embedded discriminator schema for virtual population\r\n  clickedSchema.virtual('users_$', {\r\n    ref: 'Users',\r\n    localField: 'users',\r\n    foreignField: 'employeeId'\r\n  })\r\n  \r\n  const Clicked = docArray.discriminator('Clicked', clickedSchema);\r\n\r\n  // Second embedded discriminator\r\n  const Purchased = docArray.discriminator('Purchased', new Schema({\r\n    product: { type: String }\r\n  }));\r\n\r\n  const Batch = mongoose.model('EventBatch', batchSchema);\r\n\r\n  // Generate Items\r\n  const user = { employeeId: 1, name: 'Test name' }\r\n  const batch = {\r\n    nested: {   \r\n      events: [\r\n        { kind: 'Clicked', element: '#hero', message: 'hello', users: [1] },\r\n        { kind: 'Purchased', product: 'action-figure-1', message: 'world' }\r\n      ]\r\n    }\r\n  };\r\n\r\n  // Clearing out the collections before creating items\r\n  Promise.all([ UserModel.remove({}), Batch.remove({}) ])\r\n  .then(() => Promise.all([UserModel.create(user), Batch.create(batch)]))\r\n  .then(function(){\r\n    Batch.find({})\r\n      // Populate virtual field of embedded discriminator\r\n      .populate('nested.events.users_$') \r\n      .lean()\r\n      .then(results => {\r\n        console.log(JSON.stringify(results, null, 2))\r\n      })\r\n  })\r\n})\r\n```\r\nReceived incorrect output with \"users_$\" not populated\r\n```json\r\n[\r\n  {\r\n    \"_id\": \"5b01e42b623c3a8cf6bf256e\",\r\n    \"nested\": {\r\n      \"_id\": \"5b01e42b623c3a8cf6bf256f\",\r\n      \"events\": [\r\n        {\r\n          \"users\": [\r\n            1\r\n          ],\r\n          \"_id\": \"5b01e42b623c3a8cf6bf2571\",\r\n          \"kind\": \"Clicked\",\r\n          \"element\": \"#hero\",\r\n          \"message\": \"hello\"\r\n        },\r\n        {\r\n          \"_id\": \"5b01e42b623c3a8cf6bf2570\",\r\n          \"kind\": \"Purchased\",\r\n          \"product\": \"action-figure-1\",\r\n          \"message\": \"world\"\r\n        }\r\n      ]\r\n    },\r\n    \"__v\": 0\r\n  }\r\n]\r\n```\r\n**What is the expected behavior?**\r\nExpected \"users_$\" to be populated\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nnode: v8.11.1\r\nmongoose: 5.1.1\r\nmongo: 3.6.4\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nIndexing in embedded discriminators array is not work\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```javascript\r\nconst eventSchema = new mongoose.Schema(\r\n  {\r\n    message: {\r\n      type: String,\r\n      index: true,\r\n    },\r\n  },\r\n  { discriminatorKey: 'kind', _id: false },\r\n);\r\n\r\nconst batchSchema = new mongoose.Schema(\r\n  {\r\n    events: [eventSchema],\r\n  },\r\n);\r\n\r\nconst docArray = batchSchema.path('events');\r\n\r\nconst Clicked = docArray.discriminator('Clicked', new mongoose.Schema(\r\n  {\r\n    element: {\r\n      type: String,\r\n      required: true,\r\n      index: true,\r\n    },\r\n  },\r\n  { _id: false },\r\n));\r\n\r\nconst Purchased = docArray.discriminator('Purchased', new mongoose.Schema(\r\n  {\r\n    product: {\r\n      type: String,\r\n      required: true,\r\n      index: true,\r\n    },\r\n  },\r\n  { _id: false },\r\n));\r\n\r\nconst Batch = mongoose.model('EventBatch', batchSchema);\r\n```\r\n\r\n**What is the expected behavior?**\r\nMongoose should trigger ensureIndex on 3 field\r\n- events.message\r\n- events.element\r\n- events.product\r\n\r\nOnly one field which Mongoose trying to index is events.message\r\n`Mongoose: eventbatches.ensureIndex({ 'events.message': 1 }, { background: true })`\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNode.js v8.9.3\r\nMongoose v5.1.1\r\nMongoDB v3.6"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\nI'm using the latest v4 and cannot switch to v5\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nReport a bug\r\n\r\n**What is the current behavior?**\r\nCannot change the order of fields once they are created. If I'm saving a document with:\r\n```js\r\ncoords: { longitude, latitude }\r\n// vs\r\ncoords: { latitude, longitude }\r\n```\r\nThe order is what I expect it to be, but if I then try to $set the fields the other way around the order is the same I had before... but doing the same $set operation directly in MongoDB works!\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n```js\r\nconst mongoose = require('mongoose')\r\n\r\nmongoose.Promise = global.Promise\r\nmongoose.connect('...', { useMongoClient: true })\r\n\r\nconst placeSchema = new mongoose.Schema({\r\n  coords: {\r\n    longitude: { type: Number },\r\n    latitude: { type: Number },\r\n    altitude: { type: Number },\r\n  }\r\n})\r\n\r\nconst Place = mongoose.model(\"TestPlace\", placeSchema);\r\n\r\nconst latitude = 39.9647598\r\nconst longitude = -79.7652673\r\nconst altitude = 176.3\r\n\r\nconst testPlace1_latlonalt = new Place({\r\n  coords: { latitude, longitude, altitude }\r\n})\r\nconst testPlace1_latlonalt_bis = new Place({\r\n  coords: { latitude, longitude, altitude }\r\n})\r\n\r\nconst testPlace2_lonaltlat = new Place({\r\n  coords: { longitude, altitude, latitude }\r\n})\r\n\r\nconst testPlace3_empty = new Place({})\r\n\r\nasync function run () {\r\n  const test1_latlonalt = await testPlace1_latlonalt.save()\r\n  const test1_latlonalt_bis = await testPlace1_latlonalt_bis.save()\r\n  const test2_lonaltlat = await testPlace2_lonaltlat.save()\r\n  const test1string_latlonalt = JSON.stringify( test1_latlonalt.toObject().coords ) // document in DB matches the one in the code\r\n  // test1string = {\"latitude\":39.9647598,\"longitude\":-79.7652673,\"altitude\":176.3}\r\n  const test2string_lonaltlat = JSON.stringify( test2_lonaltlat.toObject().coords ) // document in DB matches the one in the code\r\n  // test2string = {\"longitude\":-79.7652673,\"altitude\":176.3,\"latitude\":39.9647598}\r\n\r\n  const update1_lataltlon = {$set: { coords: test2_lonaltlat.coords }}\r\n  const update2_lonaltlat = {$set: { coords: test2_lonaltlat.toObject().coords }}\r\n  const update1string = JSON.stringify(update1_lataltlon.$set.coords) // document in code doesn't match the one in the \r\n  // update1string = {\"latitude\":39.9647598,\"altitude\":176.3,\"longitude\":-79.7652673}\r\n  const update2string = JSON.stringify(update2_lonaltlat.$set.coords) // but here it's fine\r\n  // update2string = {\"longitude\":-79.7652673,\"altitude\":176.3,\"latitude\":39.9647598}\r\n\r\n  if (update1string !== update2string) {\r\n    console.error(\r\n      \"why are the fields of the model returned in that order?\"\r\n    )\r\n  } else {\r\n    console.info(\"ok\")\r\n  }\r\n\r\n  const error1_lataltlon = await Place.findByIdAndUpdate(test1_latlonalt._id, update1_lataltlon, { new: true })\r\n  const error1string = JSON.stringify( error1_lataltlon.toObject().coords )\r\n  // error1string = {\"latitude\":39.9647598,\"altitude\":176.3,\"longitude\":-79.7652673}\r\n  const error2_lataltlon = await Place.findByIdAndUpdate(test1_latlonalt._id, update2_lonaltlat, { new: true })\r\n  const error2string = JSON.stringify( error2_lataltlon.toObject().coords )\r\n  // error2string = {\"latitude\":39.9647598,\"altitude\":176.3,\"longitude\":-79.7652673}\r\n\r\n  if (error1string === error2string && update1string !== update2string) {\r\n    console.error(\r\n      \"if the queries had the fields in a different order, why are the update results the same?\"\r\n    )\r\n  } else {\r\n    console.info(\"ok\")\r\n  }\r\n\r\n  // here we test $set on an object without \"coords\"\r\n  const test3_empty = await testPlace3_empty.save()\r\n  const error3_lataltlon = await Place.findByIdAndUpdate(test3_empty._id, update2_lonaltlat, { new: true }) \r\n  const error3string = JSON.stringify( error3_lataltlon.toObject().coords )\r\n  // error3string = {\"latitude\":39.9647598,\"altitude\":176.3,\"longitude\":-79.7652673}\r\n\r\n  if (update2string !== error3string) {\r\n    console.error(\r\n      \"this object did't have the coords field, so something inside mongoose is messing up the field order\"\r\n    )\r\n  } else {\r\n    console.info(\"ok\")\r\n  }\r\n\r\n  // final test, let's try to update the document with the fields in the order I want with the fields in a random order\r\n  const update3_lataltlon = {$set: { coords: error2_lataltlon.toObject().coords }}\r\n  const update3string = JSON.stringify(update3_lataltlon.$set.coords)\r\n  // update3string = {\"latitude\":39.9647598,\"altitude\":176.3,\"longitude\":-79.7652673}\r\n  const error4_lonaltlat = await Place.findByIdAndUpdate(test1_latlonalt_bis._id, update3_lataltlon, { new: true }) \r\n  const error4string = JSON.stringify( error4_lonaltlat.toObject().coords )\r\n  // error4string = {\"longitude\":-79.7652673,\"altitude\":176.3,\"latitude\":39.9647598}\r\n\r\n  if (error3string !== error4string) {\r\n    console.error(\r\n      \"no way!! you must be kidding me... :'(\"\r\n    )\r\n  } else {\r\n    console.info('ok')\r\n  }\r\n}\r\nrun()\r\n\r\n```\r\n\r\n**What is the expected behavior?**\r\n- When I query for the fields of an object they should be returned in the same order they appear in MongoDB or at least in the order they appear in the schema\r\n- When I pass an update query like ```{ $set: { x: { a, b, c } } }``` I don't expect it to be applied as ```{ $set: { x: { b, c, a } } }``` or at least I would expect it to be switched to the order in the schema, not some other random order\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nnode: 8.11.2\r\nmongoose: 4.13.13\r\nmongodb: 3.4.14 or 3.6.4, makes no difference"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBug\r\n\r\n**What is the current behavior?**\r\n\r\nWhen trying to set a property on a embedded discriminator subdoc, there seems to be 2 bugs preventing the change from taking effect.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n\r\n```js\r\nconst assert = require('chai').assert\r\nconst mongoose = require('mongoose')\r\nconst Schema = mongoose.Schema\r\n\r\nit('Embedded discriminator subdoc properties cannot be set using `parentDoc.set`', async () => {\r\n\r\n   // Setup our schemas + model\r\n   // Everything works okay here\r\n\r\n   const mediaSchema = new Schema(\r\n      { file: String },\r\n      { discriminatorKey: 'kind', _id: false }\r\n   )\r\n\r\n   const photoSchema = new Schema({ \r\n      position: String\r\n   })\r\n\r\n   const pageSchema = new Schema({\r\n      media: mediaSchema\r\n   })\r\n\r\n   pageSchema.path('media').discriminator('photo', photoSchema)\r\n\r\n   const Page = mongoose.model('test-page', pageSchema)\r\n\r\n   // Create new Page doc\r\n   // Everything cool here too...\r\n\r\n   let page = new Page({\r\n      media: {\r\n         kind: 'photo',\r\n         file: 'cover.jpg',\r\n         position: 'left'\r\n      }\r\n   })\r\n\r\n   await page.save()\r\n   assert.equal(page.media.kind, 'photo')\r\n   assert.equal(page.media.file, 'cover.jpg')\r\n   assert.equal(page.media.position, 'left')\r\n\r\n   // Try changing the page.media props\r\n   // This is where things start to go off the rails\r\n\r\n   // ** THIS FAILS **\r\n\r\n   page.set('media.position', 'right')\r\n   assert.equal(page.media.position, 'right')\r\n\r\n   // ** BUT IT WORKS IF WE DO IT THIS WAY **\r\n   // (Comment out the above assertion)\r\n\r\n   page.media.set('position', 'right')\r\n   assert.equal(page.media.position, 'right')\r\n\r\n   // ** OH NO! ANOTHER BUG - IT DOESN'T SAVE BECAUSE NO MODIFIED PATHS DETECTED\r\n\r\n   assert.equal(page.modifiedPaths().length > 0, true)\r\n   assert.equal(page.modifiedPaths().includes('media.position'), true)\r\n\r\n   // ** BUT IT WORKS IF WE EXPLICITLY MARK AS MODIFIED **\r\n   // (Comment out the above 2 assertions)\r\n\r\n   page.markModified('media.position')\r\n\r\n   // Phew...we have our expected result!\r\n\r\n   await page.save()\r\n   page = await Page.findById(page.id)\r\n   assert.equal(page.media.kind, 'photo')\r\n   assert.equal(page.media.file, 'cover.jpg')\r\n   assert.equal(page.media.position, 'right')\r\n})\r\n```\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\n\r\nnode.js 8.9.4\r\nmongoose 5.1.1\r\nMongoDB 3.6.4\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nGiven a doc that was created before a new boolean schema field was added, if the boolean schema field is set to `default: false`, it will not be set to false. However, if it is `default: true`, it will be set to true. This is probably clearer looking at the example.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\n```javascript\r\n// index.js\r\nconst mongoose = require('mongoose');\r\n// Import User Schema\r\nrequire('./user');\r\n\r\nmongoose.connect('mongodb://localhost:27017/mongo-default-bug');\r\n\r\nconst User = mongoose.model('User');\r\n\r\nconst newUser = new User({\r\n  otherVal: 99,\r\n  defaultValT: undefined,\r\n  defaultValF: undefined,\r\n});\r\n\r\n// Save the new user doc\r\nnewUser.save().then(() => {\r\n  // Remove defaultValT, defaultValF to simulate this is an old doc before\r\n  // new schema with `defaultValT and `defaultValF` were added in as fields.\r\n  User.collection.update(\r\n    {}, {$unset: {defaultValT: true, defaultValF: true}},\r\n    {multi: true, safe: true},\r\n    () => {\r\n      // Update the user doc\r\n      User.findOne({}).then(user => {\r\n        user.otherVal = 9999;\r\n        user.save();\r\n        console.log(user);\r\n      })\r\n    }\r\n  );\r\n});\r\n```\r\n```javascript\r\n// user.js\r\nconst mongoose = require('mongoose');\r\nconst { Schema } = mongoose;\r\n\r\n/**\r\n * User Schema\r\n */\r\nconst UserSchema = new Schema({\r\n  defaultValT: { type: Boolean, default: true },\r\n  defaultValF: { type: Boolean, default: false },\r\n  otherVal: 0,\r\n});\r\n\r\nmongoose.model('User', UserSchema);\r\n```\r\n\r\nThe console.log statement will print:\r\n```\r\n{ defaultValT: true,\r\n  defaultValF: false,\r\n  _id: 5afc7908d5b4056e35502493,\r\n  otherVal: 9999,\r\n  __v: 0 }\r\n```\r\n\r\nHowever looking at the db from mongo shell and mongo compass db:\r\n```\r\n{\r\n\t\"_id\" : ObjectId(\"5afc7908d5b4056e35502493\"),\r\n\t\"otherVal\" : 9999,\r\n\t\"__v\" : 0,\r\n\t\"defaultValT\" : true\r\n}\r\n```\r\n\r\n**What is the expected behavior?**\r\n\r\nHonestly I'm not sure, the [default value docs](http://mongoosejs.com/docs/defaults.html) seem to state that *none* of the fields should be updated to the default value since default only applies on insert, unless `setDefaultsOnInsert`. But it seems like it's being applied anyways, no idea why, but it should at least be consistent between `default: true` and `default: false`.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\n\r\n```\r\nnode --version\r\nv8.4.0\r\nmongoose@5.1.1\r\nMongoDB server version: 3.6.2\r\n```"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nbug\r\n\r\n**What is the current behavior?**\r\nsince mongoose 5.1.0 (upgraded from 5.0.14) I get the following error:\r\nTypeError: rawIds[i].reduce is not a function\r\n  File \"/var/node_modules/mongoose/lib/model.js\", line 3461, col 29, in assignVals\r\n    rawIds[i] = rawIds[i].reduce((cur, v, i) => {\r\n  File \"/var/node_modules/mongoose/lib/model.js\", line 3395, col 5, in _assign\r\n    assignVals({\r\n  File \"/var/node_modules/mongoose/lib/model.js\", line 3314, col 5, in next\r\n    _assign(null, vals, options, assignmentOpts);\r\n  File \"/var/node_modules/mongoose/lib/model.js\", line 4161, col 16, in null.<anonymous>\r\n    callback.apply(null, arguments);\r\n  File \"/var/node_modules/mongoose/lib/query.js\", line 3129, col 7, in (anonymous function).call\r\n    cb(null, res);\r\n  File \"/var/node_modules/mongoose/lib/query.js\", line 1340, col 11, in cb\r\n    ? callback(null, docs)\r\n  File \"/var/node_modules/mongoose/node_modules/mongodb/lib/utils.js\", line 414, col 17, in result\r\n    result => callback(null, result),\r\n  File \"/var/node_modules/mongoose/node_modules/mongodb/lib/utils.js\", line 406, col 9, in executeCallback\r\n    resolve(result);\r\n  File \"/var/node_modules/mongoose/node_modules/mongodb/lib/utils.js\", line 128, col 55, in handleCallback\r\n    return value2 ? callback(err, value1, value2) : callback(err, value1);\r\n  File \"/var/node_modules/mongoose/node_modules/mongodb/lib/cursor.js\", line 904, col 60, in self.close\r\n    return self.close({ skipKillCursors: true }, () => handleCallback(callback, null, items));\r\n  File \"/var/node_modules/mongoose/node_modules/mongodb/lib/utils.js\", line 128, col 55, in handleCallback\r\n    return value2 ? callback(err, value1, value2) : callback(err, value1);\r\n  File \"/var/node_modules/mongoose/node_modules/mongodb/lib/cursor.js\", line 1043, col 14, in completeClose\r\n    return handleCallback(callback, null, this);\r\n  File \"/var/node_modules/mongoose/node_modules/mongodb/lib/cursor.js\", line 1053, col 35, in _endSession\r\n    return this._endSession(() => completeClose());\r\n  File \"/var/node_modules/mongoose/node_modules/mongodb-core/lib/cursor.js\", line 190, col 5, in Cursor._endSession\r\n    callback();\r\n  File \"/var/node_modules/mongoose/node_modules/mongodb/lib/cursor.js\", line 217, col 59, in Cursor._endSession\r\n    const didCloseCursor = CoreCursor.prototype._endSession.apply(this, arguments);\r\n  File \"/var/node_modules/mongoose/node_modules/mongodb/lib/cursor.js\", line 1053, col 17, in Cursor.close\r\n    return this._endSession(() => completeClose());\r\n  File \"/var/node_modules/mongoose/node_modules/mongodb/lib/cursor.js\", line 904, col 21, in null.<anonymous>\r\n    return self.close({ skipKillCursors: true }, () => handleCallback(callback, null, items));\r\n  File \"/var/node_modules/mongoose/node_modules/mongodb-core/lib/cursor.js\", line 199, col 5, in handleCallback\r\n    callback(err, result);\r\n  File \"/var/node_modules/mongoose/node_modules/mongodb-core/lib/cursor.js\", line 556, col 38, in _setCursorNotifiedImpl\r\n    _setCursorNotifiedImpl(self, () => handleCallback(callback, null, null));\r\n  File \"/var/node_modules/mongoose/node_modules/mongodb-core/lib/cursor.js\", line 564, col 46, in self._endSession\r\n    return self._endSession(undefined, () => callback());\r\n  File \"/var/node_modules/mongoose/node_modules/mongodb-core/lib/sessions.js\", line 72, col 41, in ClientSession.endSession\r\n    if (typeof callback === 'function') callback(null, null);\r\n  File \"/var/node_modules/mongoose/node_modules/mongodb-core/lib/cursor.js\", line 185, col 13, in Cursor._endSession\r\n    session.endSession(callback);\r\n  File \"/var/node_modules/mongoose/node_modules/mongodb/lib/cursor.js\", line 217, col 59, in Cursor._endSession\r\n    const didCloseCursor = CoreCursor.prototype._endSession.apply(this, arguments);\r\n  File \"/var/node_modules/mongoose/node_modules/mongodb-core/lib/cursor.js\", line 564, col 17, in _setCursorNotifiedImpl\r\n    return self._endSession(undefined, () => callback());\r\n  File \"/var/node_modules/mongoose/node_modules/mongodb-core/lib/cursor.js\", line 556, col 3, in setCursorNotified\r\n    _setCursorNotifiedImpl(self, () => handleCallback(callback, null, null));\r\n  File \"/var/node_modules/mongoose/node_modules/mongodb-core/lib/cursor.js\", line 549, col 3, in setCursorDeadAndNotified\r\n    setCursorNotified(self, callback);\r\n  File \"/var/node_modules/mongoose/node_modules/mongodb-core/lib/cursor.js\", line 769, col 5, in nextFunction\r\n    setCursorDeadAndNotified(self, callback);\r\n  File \"/var/node_modules/mongoose/node_modules/mongodb-core/lib/cursor.js\", line 810, col 3, in Cursor.next\r\n    nextFunction(this, callback);\r\n  File \"/var/node_modules/mongoose/node_modules/mongodb/lib/cursor.js\", line 202, col 36, in Cursor._next\r\n    return CoreCursor.prototype.next.apply(this, arguments);\r\n  File \"/var/node_modules/mongoose/node_modules/mongodb/lib/cursor.js\", line 897, col 10, in fetchDocs\r\n    self._next(function(err, doc) {\r\n  File \"/var/node_modules/mongoose/node_modules/mongodb/lib/cursor.js\", line 923, col 7, in null.<anonymous>\r\n    fetchDocs();\r\n  File \"/var/node_modules/mongoose/node_modules/mongodb-core/lib/cursor.js\", line 199, col 5, in handleCallback\r\n    callback(err, result);\r\n  File \"/var/node_modules/mongoose/node_modules/mongodb-core/lib/cursor.js\", line 800, col 5, in nextFunction\r\n    handleCallback(callback, null, doc);\r\n  File \"/var/node_modules/mongoose/node_modules/mongodb-core/lib/cursor.js\", line 682, col 7, in null.<anonymous>\r\n    nextFunction(self, callback);\r\n  File \"/var/node_modules/mongoose/node_modules/mongodb-core/lib/cursor.js\", line 263, col 16, in queryCallback\r\n    return callback(null, result);\r\n  File \"/var/node_modules/mongoose/node_modules/mongodb-core/lib/connection/pool.js\", line 544, col 18, in null.<anonymous>\r\n    return cb(err, result);\r\n  File \"internal/process/next_tick.js\", line 131, col 7, in _combinedTickCallback\r\n  File \"internal/process/next_tick.js\", line 218, col 9, in process._tickDomainCallback\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nnot sure yet, not in front of a computer right now\r\n\r\n**What is the expected behavior?**\r\nno crash ;)\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nmongoose 5.1.0\r\nmongo 3.6.4\r\nnode 8.10.0\r\n\r\nregards\r\nSimon"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nWhen executing a query created from a [query constructor](http://mongoosejs.com/docs/api.html#query_Query-toConstructor) does not execute hooks\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```\r\nconst mongoose = require('mongoose');\r\n\r\n// Define schema\r\nconst schema = new mongoose.Schema({});\r\n\r\n// Add a find query hook\r\nschema.pre('find', function logHook() {\r\n    // Log the execution of the hook\r\n    console.log(`Executing hook`);\r\n});\r\n\r\n// Create model\r\nconst model = mongoose.model('Model', schema);\r\n\r\n// The following code should cause the pre 'find' hook to execute but does not\r\n\r\n// Create a query constructor\r\nconst Query = model.find({}).toConstructor();\r\n\r\n// Create and execute a query from the query constructor\r\nconst query = new Query().exec();\r\n```\r\n\r\n**What is the expected behavior?**\r\nHooks should execute when queries created from query constructors are executed.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\n- node 8.2.1\r\n- mongoose 5.0.18\r\n- MongoDB 3.6.4\r\n\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug in `5.0.18`\r\n**`NOTE: `IT WORKS CORRECTLY IN 5.0.17!**\r\n\r\n**What is the current behavior?**\r\nWhen you populate a query and use `.match` to filter the results, documents which violate the match conditions are added to the result.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nIn my case, the query is as follows:\r\n```\r\nStuffModel.find({ visible: true })\r\n    .populate({\r\n      path: 'content',\r\n      select: '-stuffs -defaultStuff',\r\n      match: { online: true },\r\n    })\r\n```\r\nWhen this returns, content field contains documents with `online: false`\r\n\r\n**What is the expected behavior?**\r\nIt should filter correctly.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNode: v10.1.0\r\nMongoose: 5.0.18\r\nMongoDB: 3.6\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?** bug\r\n\r\n**What is the current behavior?**\r\n\r\nWhen using populate and post init hook, mongoose is entering in an infinite loop and causing JS memory leaks.\r\n\r\n```\r\nFATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory\r\n\r\n<--- Last few GCs --->\r\n\r\n[24:0x55ad71f2f000]    64362 ms: Mark-sweep 1378.0 (1459.0) -> 1378.0 (1459.0) MB, 356.3 / 0.0 ms  allocation failure GC in old space requested\r\n[24:0x55ad71f2f000]    64702 ms: Mark-sweep 1378.0 (1459.0) -> 1378.0 (1452.0) MB, 339.5 / 0.0 ms  last resort GC in old space requested\r\n[24:0x55ad71f2f000]    64965 ms: Mark-sweep 1378.0 (1452.0) -> 1378.0 (1452.0) MB, 262.8 / 0.0 ms  last resort GC in old space requested\r\n\r\n\r\n<--- JS stacktrace --->\r\n\r\n==== JS stack trace =========================================\r\n\r\nSecurity context: 0xf922b0a57c1 <JSObject>\r\n    1: gatherPaths(aka gatherPaths) [/drone/src/github.com/kessiler/xxx-server/node_modules/mongoose/lib/queryhelpers.js:~119] [pc=0x6903310baa5](this=0x1cb8a97822d1 <undefined>,obj=0x10e5215e9461 <InternalCache map = 0x8d717674249>,map=0x10e5215e93d9 <Object map = 0x27d747d02a99>,path=0x607173f5231 <Very long string[27617]>)\r\n    2: gatherPaths(aka gatherPaths) [/drone/src/github.com/...\r\n```\r\n\r\nMy code is basically doing a simple populate as the following below:\r\n\r\n```\r\nawait User.find(userId).populate('_organization');\r\n```\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\nhttps://gist.github.com/kessiler/4f1dc0e7203a55fadc4e3c817ba379bc\r\n\r\n**What is the expected behavior?**\r\nDo not cause memory leaks.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nmongoose - 5.0.18\r\nnodejs - 8.11.1\r\nMongoDB - 3.2\r\n"},{"labels":["bug"],"text":"**Node Version**: 8.9.4\r\n\r\n**Mongoose Version**: 5.0.17; 4.13.12\r\n\r\n**Mongodb Version**: 3.2.9\r\n\r\nThis is how to reproduce this bug:\r\n\r\n```js\r\nconst mongoose = require('mongoose');\r\n\r\nmongoose.connect('mongodb://localhost/test', {debug: true});\r\nmongoose.set('debug', true);\r\n\r\nconst Cat = mongoose.model('Cat', {\r\n  name: String,\r\n  props: [\r\n    new mongoose.Schema(\r\n      {\r\n        name: String\r\n      },\r\n      {_id: false}\r\n    )\r\n  ]\r\n});\r\n\r\n(async function () {\r\n  let kitty = new Cat({name: 'Zildjian',\r\n    props: [\r\n      {name: 'invalid'},\r\n      {name: 'abc'},\r\n      {name: 'def'}\r\n    ]\r\n  });\r\n  await kitty.save();\r\n\r\n  kitty = await Cat.findById(kitty._id);\r\n  console.log(kitty.props);\r\n\r\n  // The setter is casted as `{ '$pull': { props: {} } }`, which leads the all embedded documents of `props` field to be removed.\r\n  await Cat.update({_id: kitty._id}, {$pull: {props: {$in: [{name: 'invalid'}, {name: 'def'}]}}});\r\n\r\n  kitty = await Cat.findById(kitty._id);\r\n  console.log('result:', kitty.props); // Expect an array with 1 embedded document inside, but get 0 here.\r\n}());\r\n\r\n```\r\n\r\n**Expected Behavior**: `$pull` + `$in` should only remove the embedded documents match the assigned conditions, not all of them."},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n*Bug*\r\n\r\n**What is the current behavior?**\r\nPopulating an array containing null values results in deletion of null values and violation of array sequence.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\nSmall example with output:\r\n```javascript\r\nlet mongoose = require('mongoose');\r\nlet Schema = mongoose.Schema;\r\n\r\nmongoose.Promise = global.Promise;\r\n\r\nmongoose.set('debug', true);\r\nmongoose.connect(`mongodb://localhost:27019/test`);\r\n\r\nlet UsersSchema = new Schema({\r\n    id: Number,\r\n    roles: [{type: Schema.Types.ObjectId, ref: 'roles'}]\r\n}, {versionKey: false});\r\n\r\nlet Users = mongoose.model('users', UsersSchema);\r\n\r\nlet RolesSchema = new Schema({\r\n    id: Number,\r\n    name: String\r\n}, {versionKey: false});\r\n\r\nlet Roles = mongoose.model('roles', RolesSchema);\r\n\r\nsetTimeout(async() => {\r\n    await Roles.remove({})\r\n               .exec();\r\n    await Users.remove({})\r\n               .exec();\r\n\r\n    let role_1 = new Roles({id: 1, name: 'Role 1'});\r\n    await role_1.save();\r\n\r\n    let role_2 = new Roles({id: 2, name: 'Role 2'});\r\n    await role_2.save();\r\n\r\n    let user = new Users({id: 1, roles: [null, role_1, null, role_2, null, null]})\r\n    await user.save();\r\n\r\n    console.log('Before ==>', user);\r\n\r\n    await Users.populate(user, [{path: 'roles'}]);\r\n\r\n    console.log('After ==>', user);\r\n\r\n    console.log('Selection ==>',\r\n        await Users\r\n            .find()\r\n            .populate('roles')\r\n            .exec()\r\n    );\r\n})\r\n```\r\n\r\nOutput:\r\n**Mongoose without changes** (console screenshot - https://i.imgur.com/MBkY5eT.png)\r\n```javascript\r\nMongoose: roles.remove({}, {})\r\nMongoose: users.remove({}, {})\r\nMongoose: roles.insertOne({ _id: ObjectId(\"5af5a89373668541b49094bf\"), id: 1, name: 'Role 1' })\r\nMongoose: roles.insertOne({ _id: ObjectId(\"5af5a89373668541b49094c0\"), id: 2, name: 'Role 2' })\r\nMongoose: users.insertOne({ roles: [ '\\u001b[1mnull\\u001b[22m', ObjectId(\"5af5a89373668541b49094bf\"), '\\u001b[1mnull\\u001b[22m', ObjectId(\"5af5a89373668541b49094c0\"), '\\u001b[1mnull\\u001b[22m', '\\u001b[1mnull\\u001b[22m' ], _id: ObjectId(\"5af5a89373668541b49094c1\"), id: 1 })\r\nBefore ==> { roles: \r\n   [ null,\r\n     5af5a89373668541b49094bf,\r\n     null,\r\n     5af5a89373668541b49094c0,\r\n     null,\r\n     null ],\r\n  _id: 5af5a89373668541b49094c1,\r\n  id: 1 }\r\nMongoose: roles.find({ _id: { '$in': [ '\\u001b[1mnull\\u001b[22m', ObjectId(\"5af5a89373668541b49094bf\"), '\\u001b[1mnull\\u001b[22m', ObjectId(\"5af5a89373668541b49094c0\"), '\\u001b[1mnull\\u001b[22m', '\\u001b[1mnull\\u001b[22m' ] } }, { fields: {} })\r\nAfter ==> { roles: \r\n   [ { _id: 5af5a89373668541b49094bf, id: 1, name: 'Role 1' },\r\n     { _id: 5af5a89373668541b49094c0, id: 2, name: 'Role 2' } ],\r\n  _id: 5af5a89373668541b49094c1,\r\n  id: 1 }\r\nMongoose: users.find({}, { fields: {} })\r\nMongoose: roles.find({ _id: { '$in': [ '\\u001b[1mnull\\u001b[22m', ObjectId(\"5af5a89373668541b49094bf\"), '\\u001b[1mnull\\u001b[22m', ObjectId(\"5af5a89373668541b49094c0\"), '\\u001b[1mnull\\u001b[22m', '\\u001b[1mnull\\u001b[22m' ] } }, { fields: {} })\r\nSelection ==> [ { roles: [ [Object], [Object] ],\r\n    _id: 5af5a89373668541b49094c1,\r\n    id: 1 } ]\r\n```\r\n**Mongoose with changes** (console screenshot - https://i.imgur.com/j3tUzv7.png)\r\n```javascript\r\nMongoose: roles.remove({}, {})\r\nMongoose: users.remove({}, {})\r\nMongoose: roles.insert({ _id: ObjectId(\"5af5a8bab5a66042e4c894b5\"), id: 1, name: 'Role 1' })\r\nMongoose: roles.insert({ _id: ObjectId(\"5af5a8bab5a66042e4c894b6\"), id: 2, name: 'Role 2' })\r\nMongoose: users.insert({ roles: [ '\\u001b[1mnull\\u001b[22m', ObjectId(\"5af5a8bab5a66042e4c894b5\"), '\\u001b[1mnull\\u001b[22m', ObjectId(\"5af5a8bab5a66042e4c894b6\"), '\\u001b[1mnull\\u001b[22m', '\\u001b[1mnull\\u001b[22m' ], _id: ObjectId(\"5af5a8bab5a66042e4c894b7\"), id: 1 })\r\nBefore ==> { roles: \r\n   [ null,\r\n     5af5a8bab5a66042e4c894b5,\r\n     null,\r\n     5af5a8bab5a66042e4c894b6,\r\n     null,\r\n     null ],\r\n  _id: 5af5a8bab5a66042e4c894b7,\r\n  id: 1 }\r\nMongoose: roles.find({ _id: { '$in': [ ObjectId(\"5af5a8bab5a66042e4c894b5\"), ObjectId(\"5af5a8bab5a66042e4c894b6\") ] } }, { fields: {} })\r\nAfter ==> { roles: \r\n   [ null,\r\n     { _id: 5af5a8bab5a66042e4c894b5, id: 1, name: 'Role 1' },\r\n     null,\r\n     { _id: 5af5a8bab5a66042e4c894b6, id: 2, name: 'Role 2' },\r\n     null,\r\n     null ],\r\n  _id: 5af5a8bab5a66042e4c894b7,\r\n  id: 1 }\r\nMongoose: users.find({}, { fields: {} })\r\nMongoose: roles.find({ _id: { '$in': [ ObjectId(\"5af5a8bab5a66042e4c894b5\"), ObjectId(\"5af5a8bab5a66042e4c894b6\") ] } }, { fields: {} })\r\nSelection ==> [ { roles: [ null, [Object], null, [Object], null, null ],\r\n    _id: 5af5a8bab5a66042e4c894b7,\r\n    id: 1 } ]\r\n```\r\n\r\n**What is the expected behavior?**\r\nNull/invalid values in the array must not be removed. Array order must be same as before populating.\r\n\r\nP.S. Why Mongoose includes null values when querying ObjectID to MongoDB?\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNodeJS: 9.9.0\r\nMongoose: 5.0.17\r\nMongoDB: 3.6.3\r\n"},{"labels":["bug"],"text":"I'm using MongoDB 3.6.4 Community, NodeJS 8.9.4 and Mongoose 5.0.17, on Windows 10 Professional\r\n\r\nFrom time to time the following stack trace shows on console, stopping the application:\r\n\r\n```\r\nF:\\Proj1\\node_modules\\mongoose\\node_modules\\mongodb\\lib\\utils.js:132\r\n      throw err;\r\n      ^\r\n\r\nTypeError: Cannot assign to read only property 'remove' of object '[object Array]'\r\n    at new MongooseDocumentArray (F:\\Proj1\\node_modules\\mongoose\\lib\\types\\documentarray.js:45:20)\r\n    at DocumentArray.cast (F:\\Proj1\\node_modules\\mongoose\\lib\\schema\\documentarray.js:274:13)\r\n    at DocumentArray.SchemaType.getDefault (F:\\Proj1\\node_modules\\mongoose\\lib\\schematype.js:671:23)\r\n    at $__applyDefaults (F:\\Proj1\\node_modules\\mongoose\\lib\\document.js:298:22)\r\n    at model.Document (F:\\Proj1\\node_modules\\mongoose\\lib\\document.js:118:3)\r\n    at model.Model (F:\\Proj1\\node_modules\\mongoose\\lib\\model.js:62:12)\r\n    at new model (F:\\Proj1\\node_modules\\mongoose\\lib\\model.js:3776:13)\r\n    at Object.createModel (F:\\Proj1\\node_modules\\mongoose\\lib\\queryhelpers.js:106:10)\r\n    at completeMany (F:\\Proj1\\node_modules\\mongoose\\lib\\query.js:1467:22)\r\n    at cb (F:\\Proj1\\node_modules\\mongoose\\lib\\query.js:1328:11)\r\n    at result (F:\\Proj1\\node_modules\\mongoose\\node_modules\\mongodb\\lib\\utils.js:414:17)\r\n    at executeCallback (F:\\Proj1\\node_modules\\mongoose\\node_modules\\mongodb\\lib\\utils.js:406:9)\r\n    at handleCallback (F:\\Proj1\\node_modules\\mongoose\\node_modules\\mongodb\\lib\\utils.js:128:55)\r\n    at self.close (F:\\Proj1\\node_modules\\mongoose\\node_modules\\mongodb\\lib\\cursor.js:904:60)\r\n    at handleCallback (F:\\Proj1\\node_modules\\mongoose\\node_modules\\mongodb\\lib\\utils.js:128:55)\r\n    at completeClose (F:\\Proj1\\node_modules\\mongoose\\node_modules\\mongodb\\lib\\cursor.js:1043:14)\r\nWaiting for the debugger to disconnect...\r\n```\r\n\r\nIs it a bug? It doesn't trace back to any of my project files.\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nWhen trying to perform a virtual population of a field on an embedded discriminator that is at the root of the model, everything is populated correctly. However, when I try do the same on a **_nested_** embedded discriminator, the results are not populated. See working and non-working example in repro script section.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\nHere's are some examples:\r\n\r\nVirtual Population **WORKING** When Embedded Discriminator Field Is At The Root\r\n```javascript\r\nconst mongoose = require('mongoose')\r\nmongoose.connect('mongodb://localhost/mongoosetest')\r\nmongoose.connection.once('open', () => {\r\n\r\n  const Schema = mongoose.Schema\r\n\r\n  // Generate Users Model\r\n  const userSchema = new Schema({ employeeId: Number, name: String })\r\n  const UserModel = mongoose.model('Users', userSchema, 'users')\r\n\r\n  // Generate Embedded Discriminators\r\n  const eventSchema = new Schema(\r\n    { message: String },\r\n    { discriminatorKey: 'kind'}\r\n  );\r\n\r\n  const batchSchema = new Schema({ events: [eventSchema] });  // <-- Embedded Discrminator at root\r\n  const docArray = batchSchema.path('events');\r\n\r\n  // First embedded discriminator schema\r\n  const clickedSchema = new Schema(\r\n    {\r\n      element: { type: String },\r\n      users: [ Number ]\r\n    },\r\n    {\r\n      toJSON: { virtuals: true},\r\n      toObject: { virtuals: true}\r\n    }\r\n  );\r\n\r\n  // Add virtual to first embedded discriminator schema for virtual population\r\n  clickedSchema.virtual('users_$', {\r\n    ref: 'Users',\r\n    localField: 'users',\r\n    foreignField: 'employeeId'\r\n  })\r\n  \r\n  const Clicked = docArray.discriminator('Clicked', clickedSchema);\r\n\r\n  // Second embedded discriminator\r\n  const Purchased = docArray.discriminator('Purchased', new Schema({\r\n    product: { type: String }\r\n  }));\r\n\r\n  const Batch = mongoose.model('EventBatch', batchSchema);\r\n\r\n  // Generate Items\r\n  const user = { employeeId: 1, name: 'Test name' }\r\n  const batch = {\r\n    events: [\r\n      { kind: 'Clicked', element: '#hero', message: 'hello', users: [1] },\r\n      { kind: 'Purchased', product: 'action-figure-1', message: 'world' }\r\n    ]\r\n  };\r\n\r\n  Promise.all([UserModel.create(user), Batch.create(batch)])\r\n    .then(function(){\r\n      Batch.find({})\r\n        // Populate virtual field of embedded discriminator\r\n        .populate('events.users_$')\r\n        .lean()\r\n        .then(results => console.log(results) )\r\n    })\r\n \r\n  /*  Correct Results with \"events.users_$\" populated\r\n  [\r\n      {\r\n          \"_id\": \"5ae8ccc0daad6931954ceebf\",\r\n          \"events\": [\r\n              {\r\n                  \"users\": [\r\n                      1\r\n                  ],\r\n                  \"_id\": \"5ae8ccc0daad6931954ceec1\",\r\n                  \"kind\": \"Clicked\",\r\n                  \"element\": \"#hero\",\r\n                  \"message\": \"hello\",\r\n                  \"users_$\": [\r\n                      {\r\n                          \"_id\": \"5ae8ccc0daad6931954ceebe\",\r\n                          \"employeeId\": 1,\r\n                          \"name\": \"Test name\",\r\n                          \"__v\": 0\r\n                      }\r\n                  ]\r\n              },\r\n              {\r\n                  \"_id\": \"5ae8ccc0daad6931954ceec0\",\r\n                  \"kind\": \"Purchased\",\r\n                  \"product\": \"action-figure-1\",\r\n                  \"message\": \"world\"\r\n              }\r\n          ],\r\n          \"__v\": 0\r\n      }\r\n  ]\r\n  */\r\n})\r\n\r\n```\r\n\r\nVirtual Population **NOT WORKING** When Embedded Discriminator Field Is Nested\r\n```javascript\r\nconst mongoose = require('mongoose')\r\nmongoose.connect('mongodb://localhost/mongoosetest')\r\nmongoose.connection.once('open', () => {\r\n\r\n  const Schema = mongoose.Schema\r\n\r\n  // Generate Users Model\r\n  const userSchema = new Schema({ employeeId: Number, name: String })\r\n  const UserModel = mongoose.model('Users', userSchema, 'users')\r\n\r\n  // Generate Embedded Discriminators\r\n  const eventSchema = new Schema(\r\n    { message: String },\r\n    { discriminatorKey: 'kind'}\r\n  );\r\n\r\n  const batchSchema = new Schema({\r\n    nested: { // <--- Added Nesting\r\n      events: [eventSchema]\r\n    }\r\n  });\r\n\r\n  const docArray = batchSchema.path('nested.events'); // <--- Added Nesting\r\n\r\n  // First embedded discriminator schema\r\n  const clickedSchema = new Schema(\r\n    {\r\n      element: { type: String },\r\n      users: [ Number ]\r\n    },\r\n    {\r\n      toJSON: { virtuals: true},\r\n      toObject: { virtuals: true}\r\n    }\r\n  );\r\n\r\n  // Add virtual to first embedded discriminator schema for virtual population\r\n  clickedSchema.virtual('users_$', {\r\n    ref: 'Users',\r\n    localField: 'users',\r\n    foreignField: 'employeeId'\r\n  })\r\n  \r\n  const Clicked = docArray.discriminator('Clicked', clickedSchema);\r\n\r\n  // Second embedded discriminator\r\n  const Purchased = docArray.discriminator('Purchased', new Schema({\r\n    product: { type: String }\r\n  }));\r\n\r\n  const Batch = mongoose.model('EventBatch', batchSchema);\r\n\r\n  // Generate Items\r\n  const user = { employeeId: 1, name: 'Test name' }\r\n  const batch = {\r\n    nested: {   // <--- Added Nesting\r\n      events: [\r\n        { kind: 'Clicked', element: '#hero', message: 'hello', users: [1] },\r\n        { kind: 'Purchased', product: 'action-figure-1', message: 'world' }\r\n      ]\r\n    }\r\n  };\r\n\r\n  Promise.all([UserModel.create(user), Batch.create(batch)])\r\n    .then(function(){\r\n      Batch.find({})\r\n        // Populate virtual field of embedded discriminator\r\n        .populate('nested.events.users_$') // <--- Added Nesting\r\n        .lean()\r\n        .then(results => console.log(results) )\r\n    })\r\n  }\r\n)\r\n  /*  Results. Expected \"nested.events.users_$\" to be populated\r\n  [\r\n    {\r\n        \"_id\": \"5ae8d2f453e7c03deb827438\",\r\n        \"nested\": {\r\n            \"events\": [\r\n                {\r\n                    \"users\": [\r\n                        1\r\n                    ],\r\n\r\n                    \"_id\": \"5ae8d2f453e7c03deb82743a\",\r\n                    \"kind\": \"Clicked\",\r\n                    \"element\": \"#hero\",\r\n                    \"message\": \"hello\"\r\n                },\r\n                {\r\n                    \"_id\": \"5ae8d2f453e7c03deb827439\",\r\n                    \"kind\": \"Purchased\",\r\n                    \"product\": \"action-figure-1\",\r\n                    \"message\": \"world\"\r\n                }\r\n            ]\r\n        },\r\n        \"__v\": 0\r\n    }\r\n  ]\r\n  */\r\n```\r\n\r\n**What is the expected behavior?**\r\nThe virtual field at \"nested.events.users_$\" is populated\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nnode: 10.0.0\r\nmongoose: 5.0.17\r\nmongodb: 3.6.4"},{"labels":["bug"],"text":"model.Model.$__delta assumes that this._doc._id. In unlikely cases it can be null (mongodb certainly allows it). \r\nHowever instead of failing and return an MongooseError the function crashes and no callback is called causing the server running mongoose to crash / hang\r\n\r\n\r\nHere is a simple reproduction:\r\n\r\n```\r\nvar mongoose = require('mongoose');\r\n\r\nmongoose.connect(\"mongodb://localhost:27017/bug\");\r\nvar TestModel = mongoose.model('test-collection',\r\n  new mongoose.Schema({_id: Number, val:String})\r\n);\r\nvar _id = null;\r\n\r\nreturn Promise.resolve(null)\r\n  .then( ()=> {\r\n    return TestModel.findOneAndUpdate(\r\n      {_id:_id},\r\n      { val:\"bug-test\"},\r\n      {upsert:true});\r\n  })\r\n  .then( ()=> {\r\n    return TestModel.findOne({_id:_id});\r\n  })\r\n  .then( doc=> {\r\n    doc.val = \"update\";\r\n    return doc.save();\r\n  })\r\n  .then( doc => {\r\n    console.log(\"Success\")\r\n  })\r\n  .catch( err => console.log(\"Success\"))\r\n  .then(()=> mongoose.disconnect(), ()=> mongoose.disconnect())\r\n```\r\nI'd expect this code to reach either the then block or catch block for all documents, not to crash.\r\nI was using:\r\nmongoose 5.0.16\r\nmongo: 3.4.7\r\nnode: 8.9.1\r\n\r\n"},{"labels":["bug"],"text":"\r\n**What is the current behavior?**\r\n\r\n```js\r\nconst mongoose = require('mongoose')\r\nconst { Schema } = mongoose\r\n\r\nmongoose.connect('mongodb://localhost/test')\r\n\r\nconst CatSchema = new Schema(\r\n  {\r\n    name: String,\r\n    age: Number,\r\n    createdAt: {\r\n      type: Date,\r\n      default() {\r\n        const d = new Date()\r\n        d.setHours(0)\r\n        d.setMinutes(0)\r\n        d.setSeconds(0)\r\n        d.setMilliseconds(0)\r\n        return d\r\n      }\r\n    }\r\n  },\r\n  {\r\n    timestamps: {\r\n      updatedAt: true\r\n    }\r\n  }\r\n)\r\n\r\nconst Cat = mongoose.model('Cat', CatSchema)\r\n\r\nasync function run() {\r\n  const d = new Date()\r\n  d.setHours(0)\r\n  d.setMinutes(0)\r\n  d.setSeconds(0)\r\n  d.setMilliseconds(0)\r\n  d.setDate(d.getDate() - 1)\r\n\r\n  await new Cat({ name: 'ob' }).save()\r\n  await Cat.findOneAndUpdate(\r\n    { name: 'Zildjian' },\r\n    {},\r\n    { new: true, upsert: true }\r\n  )\r\n  await Cat.insertMany([{ name: 'a' }, { name: 'b', createdAt: d }])\r\n  await Cat.findOneAndUpdate(\r\n    {\r\n      name: 'a'\r\n    },\r\n    {\r\n      $set: {\r\n        age: 2\r\n      }\r\n    },\r\n    {\r\n      new: true,\r\n      upsert: true\r\n    }\r\n  )\r\n}\r\n\r\nrun()\r\n  .then(process.exit)\r\n  .catch(console.error)\r\n```\r\n\r\nIn Mongodb:\r\n\r\n```\r\n> db.cats.drop()\r\ntrue\r\n> db.cats.find().pretty()\r\n{\r\n        \"_id\" : ObjectId(\"5adcd1635abadda24b9bfbfe\"),\r\n        \"name\" : \"ob\",\r\n        \"createdAt\" : ISODate(\"2018-04-22T16:00:00Z\"),\r\n        \"updatedAt\" : ISODate(\"2018-04-22T16:00:00Z\"),\r\n        \"__v\" : 0\r\n}\r\n{\r\n        \"_id\" : ObjectId(\"5adcd16334c40029c9612115\"),\r\n        \"name\" : \"Zildjian\",\r\n        \"updatedAt\" : ISODate(\"2018-04-22T18:16:03.364Z\"),\r\n        \"__v\" : 0,\r\n        \"createdAt\" : ISODate(\"2018-04-22T18:16:03.364Z\")\r\n}\r\n{\r\n        \"_id\" : ObjectId(\"5adcd1635abadda24b9bfbff\"),\r\n        \"name\" : \"a\",\r\n        \"createdAt\" : ISODate(\"2018-04-22T16:00:00Z\"),\r\n        \"__v\" : 0,\r\n        \"updatedAt\" : ISODate(\"2018-04-22T18:16:03.372Z\"),\r\n        \"age\" : 2\r\n}\r\n{\r\n        \"_id\" : ObjectId(\"5adcd1635abadda24b9bfc00\"),\r\n        \"name\" : \"b\",\r\n        \"createdAt\" : ISODate(\"2018-04-21T16:00:00Z\"),\r\n        \"__v\" : 0,\r\n        \"updatedAt\" : ISODate(\"2018-04-22T18:16:03.371Z\")\r\n}\r\n>\r\n```\r\n\r\n\r\nWhy Zildjian and ob's createdAt or updatedAt  is different?\r\nWhich behavior is right?\r\n\r\n* node: v8.11.1\r\n* mongodb: stable 3.6.4\r\n* mongoose: 5.0.15\r\n"},{"labels":["bug"],"text":"\r\n**What is the current behavior?**\r\nAfter upgrading to mongoose 5.0.15 -- with the addition of the 'toHexString()' function (#6115) -- documents are now considered valid ObjectIds because of the below check in ObjectID.isValid() of the bson module (https://github.com/mongodb/js-bson/blob/1.0-branch/lib/bson/objectid.js#L351):\r\n\r\n```\r\nObjectID.isValid = function isValid(id) {\r\n\r\n...\r\n\r\n  // Duck-Typing detection of ObjectId like objects\r\n  if (id.toHexString) {\r\n    return id.id.length === 12 || (id.id.length === 24 && checkForHexRegExp.test(id.id));\r\n  }\r\n};\r\n```\r\nIf nothing else, this change may have more impact than first realized. For all I know, this is the intended behavior, but adding this in case this effect was not considered. \r\n\r\nIt at least causes breaking changes to my code, as I was relying on ObjectID.isValid to tell me if a field was populated or not -- where a populated field would be invalid, and an unpopulated field valid (again, there is likely a better way to do this -- including using the newly added toHexString()).\r\n\r\nContrived example below:\r\n```\r\nlet user = await User.findOne({name: 'test'}).populate('project');\r\nlet projectId = (ObjectId.isValid(user.project)) ? user.project : user.project._id;\r\n```\r\nBut where in 5.0.14, projectId was assigned user.project._id, it now is assigned user.project (the populated project document)."},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nWhen using $pull to remove item by ID from nested array, I get ValidationError stating that the fields, holding that array is required. I've checked various cases and each time ensured that nested array always have more than 1 item in it.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\n```\r\nconst RecordingSchema = new Schema({\r\n    created_on: Date,\r\n    submitted_on: Date,\r\n    uploaded_on: Date,\r\n    published_on: Date,\r\n    updated_on: {\r\n        type: Date,\r\n        required: true,\r\n        default: Date.now\r\n    },\r\n    srid: String,\r\n    status: String\r\n}, {\r\n    usePushEach: true\r\n});\r\n\r\nconst ItemSchema = new Schema({\r\n    type: String,\r\n    status: String,\r\n    summary: String,\r\n    description: String,\r\n    created_on: Date,\r\n    submitted_on: Date,\r\n    published_on: Date,\r\n    recordings: {\r\n        type: [RecordingSchema],\r\n        required: true\r\n    }\r\n}, {\r\n    timestamps: {\r\n        createdAt: 'created_on',\r\n        updatedAt: 'updated_on'\r\n    },\r\n    usePushEach: true,\r\n    runSettersOnQuery: true\r\n});\r\n\r\n// This is how I try to remove an item from nested array (from 'recordings')\r\nitemsModel.findOneAndUpdate({\r\n    _id: item._id\r\n}, {\r\n    $pull: {\r\n        recordings: {\r\n            _id: recId\r\n        }\r\n    }\r\n}, {\r\n    runValidators: true,\r\n    context: 'query',\r\n    fields: {\r\n        _id: true\r\n    }\r\n}, err => console.log(err));\r\n\r\nFinally, I get \"Validation failed: recordings: Path `recordings` is required.\" in my console.\r\n```\r\n\r\n**What is the expected behavior?**\r\nItem from nested array must be deleted (no ValidationError should be raised).\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNode.JS: 8.9.4\r\nMongoose: 5.0.14\r\nMongoDB: 3.6\r\n"},{"labels":["bug"],"text":"Mongoose throws `TypeError` on `Model.count()` when I use object without prototype in the query.\r\n\r\n```js\r\nconst Model = connection.model('Model');\r\n\r\nlet query = {\r\n  key: 'value'\r\n}\r\n\r\nlet priceQuery = Object.create(null);\r\n\r\npriceQuery.$gte = 0;\r\npriceQuery.$lte = 200;\r\n\r\nObject.assign(query, { price: priceQuery });\r\n\r\nModel.count(query).exec();\r\n\r\n// =>\r\n//\r\n// TypeError: Cannot read property 'name' of undefined\r\n//     at cast (/home/olnazx/beatgun/node_modules/mongoose/lib/cast.js:239:34)\r\n//     at model.Query.Query.cast (/home/olnazx/beatgun/node_modules/mongoose/lib/query.js:3208:12)\r\n//     at model.Query.Query._count (/home/olnazx/beatgun/node_modules/mongoose/lib/query.js:1628:10)\r\n//     at process.nextTick (/home/olnazx/beatgun/node_modules/kareem/index.js:311:33)\r\n//     at process._tickCallback (internal/process/next_tick.js:150:11)\r\n//     at Function.Module.runMain (module.js:703:11)\r\n//     at startup (bootstrap_node.js:193:16)\r\n//     at bootstrap_node.js:617:3\r\n```\r\n\r\n```js\r\nconst Model = connection.model('Model');\r\n\r\nlet query = {\r\n  key: 'value'\r\n}\r\n\r\nlet priceQuery = Object.create(null);\r\n\r\npriceQuery.$gte = 0;\r\npriceQuery.$lte = 200;\r\n\r\nObject.assign(query, { price: priceQuery });\r\n\r\nModel.find(query).exec();\r\n\r\n// => 'find' works fine\r\n```\r\n```js\r\nconst Model = connection.model('Model');\r\n\r\nlet query = {\r\n  key: 'value'\r\n}\r\n\r\nlet priceQuery = {};\r\n\r\npriceQuery.$gte = 0;\r\npriceQuery.$lte = 200;\r\n\r\nObject.assign(query, { price: priceQuery });\r\n\r\nModel.count(query).exec();\r\n\r\n// => also works fine\r\n```\r\n\r\n**Node.js**: 9.4.0\r\n**Mongoose**: 5.0.13\r\n**MongoDB**: 3.6.3"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nSchema toObject default \"depopulate\" option is not applied when called on a document.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n```javascript\r\nconst mongoose = require('mongoose');\r\n\r\nconst { Schema } = mongoose;\r\n\r\nconst personSchema = Schema({\r\n  name: String,\r\n  car: {\r\n    type: Schema.Types.ObjectId,\r\n    ref: 'Car',\r\n  },\r\n});\r\n\r\npersonSchema.set('toObject', {\r\n  depopulate: true,\r\n});\r\n\r\nconst carSchema = Schema({\r\n  name: String,\r\n});\r\n\r\nconst Car = mongoose.model('Car', carSchema);\r\nconst Person = mongoose.model('Person', personSchema);\r\n\r\nconst car = new Car({\r\n  name: 'Ford',\r\n});\r\n\r\nconst person = new Person({\r\n  name: 'John',\r\n  car,\r\n});\r\n\r\n// Test\r\nconsole.log(person.toObject().car); // Expected id\r\nconsole.log(person.toObject({ depopulate: true }).car); // Expected id\r\n```\r\n\r\n**What is the expected behavior?**\r\nExpected output of console logs is:\r\n```\r\n5ac4db7ddcb2084498b99c2e\r\n5ac4db7ddcb2084498b99c2e\r\n```\r\nActual output however is:\r\n```\r\n{ _id: 5ac4db7ddcb2084498b99c2e, name: 'Ford' }\r\n5ac4db7ddcb2084498b99c2e\r\n```\r\nObjects should have depopulated car property in both cases because \"depopulate\" was set in default toObjctions options.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNodes.js : 8.11.0\r\nMongoose : 5.0.12\r\nMongoDB : 3.6.0\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nI am using [decimal.js](https://github.com/MikeMcl/decimal.js/) to work with numbers, and it's supposed to have a cast to `Number` support, so you can just substitute Decimal objects whenever you'd use `Number`'s\r\n\r\nHowever, when I pass these values to a Mongoose model, it seems to incorrectly cast it to a Number. The value becomes an object instead.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```js\r\n'use strict';\r\n\r\nconst mongoose = require('mongoose');\r\nconst Decimal = require('decimal.js');\r\nconst {Schema, Types: {ObjectId}} = mongoose;\r\n\r\nconst TestSchema = new Schema({\r\n  amount1: {\r\n    type: Number,\r\n  },\r\n  amount2: {\r\n    type: Number,\r\n  },\r\n});\r\n\r\nconst Test = mongoose.model('Test', TestSchema);\r\n\r\n//Create test number\r\nconst num = new Decimal(10);\r\n\r\n//For reference, use toNumber and casted values\r\nconst toNum = num.toNumber();\r\nconst casted = Number(num);\r\n\r\n//Create instance\r\nconst test = new Test({\r\n  amount1: 5,\r\n  amount2: num,\r\n});\r\n\r\n//Test output\r\nconsole.log(toNum, typeof toNum); //Expected 10, 'number'\r\nconsole.log(casted, typeof casted); //Expected 10, 'number'\r\nconsole.log(test.amount1, typeof test.amount1); //Expected 5, 'number'\r\nconsole.log(test.amount2, typeof test.amount2); //Expected 10, 'number'\r\n```\r\n\r\n**What is the expected behavior?**\r\nExpected output of console logs is:\r\n\r\n```\r\n10 'number'\r\n10 'number'\r\n5 'number'\r\n10 'number'\r\n```\r\n\r\nActual output however is:\r\n```\r\n10 'number'\r\n10 'number'\r\n5 'number'\r\n[Number: 10] 'object'\r\n```\r\n\r\nThat last entry is boggling me. What is Mongoose doing to produce this kind of strange object? It seems to neither cast the value to a `Number`, nor call the `toNumber()` method.\r\n\r\nWorth noting that after actual persisting to database, the value is correctly cast and saved.\r\n\r\n**Possible solutions**\r\nI don't know where in the code this casting happens, but it may be that a `typeof value === 'object'` check is done and then it incorrectly converts. Maybe it needs a check for a `toNumber` method and then call it instead, or simply coerce with `Number(value)`?\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNode 8.10.0\r\nMongoose 5.0.12"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nAssume a schema contains a virtual in an inner object.  The`toJSON` method _does_ include the virtual when invoked at root level but _does not_ include virtual when invoked on a sub-object within the Document.  Observe the following script and its output when run:\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```javascript\r\n\"use strict\";\r\n\r\nconst Promise = require('bluebird');\r\nconst assert = require('assert');\r\nconst mongoose = require('mongoose');\r\nconst process = require('process');\r\n\r\nmongoose.Promise = Promise;\r\n\r\nvar schema = mongoose.Schema({\r\n  foo: {\r\n    bar: String\r\n  }\r\n});\r\n\r\nschema.virtual('foo.biz').get(() => 'I am String #2');\r\n\r\nschema.set('toJSON', {\r\n  virtuals: true\r\n});\r\n\r\nvar Model = mongoose.model('Thing', schema);\r\n\r\nModel.on('error', function(err) {\r\n  console.log('Hit Model Error ', err.message);\r\n});\r\n\r\nfunction main() {\r\n  const m1 = new Model({\r\n    foo: {\r\n      bar: 'I am String #1'\r\n    }\r\n  });\r\n\r\n  console.log('This will include the virtual:');\r\n  console.log('toJSON at root level\\n', m1.toJSON());\r\n  console.log();\r\n  console.log('This will omit the virtual:');\r\n  console.log('toJSON at foo level\\n', m1.foo.toJSON());\r\n};\r\n\r\nconsole.log('Environment Info:');\r\nconsole.log('* Mongoose version:', mongoose.version);\r\nconsole.log('* Node version:', process.version);\r\nconsole.log();\r\n\r\nmain();\r\n```\r\n\r\n```\r\n$ npm start\r\nEnvironment Info:\r\n* Mongoose version: 5.0.12\r\n* Node version: v8.9.4\r\n\r\nThis will include the virtual:\r\ntoJSON at root level\r\n { foo: { bar: 'I am String #1', biz: 'I am String #2' },\r\n  _id: 5abdcb2e9a9da40ab8569fb9,\r\n  id: '5abdcb2e9a9da40ab8569fb9' }\r\n\r\nThis will omit the virtual:\r\ntoJSON at foo level\r\n { bar: 'I am String #1' }\r\n```\r\n\r\n**What is the expected behavior?**\r\nBoth invocations of `toJSON` should include the virtual because the virtual remains part of the object that is being converted into an object that is designed to be passed to `JSON.stringify`. \r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\n* Mongoose version: 5.0.12\r\n* Node version: v8.9.4"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nbug\r\n\r\n**What is the current behavior?**\r\nArray setter function not called on find query\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nhttps://gist.github.com/natanavra/abaf9a334e69d663a66952d8cb02297c\r\n\r\n**What is the expected behavior?**\r\nThe array setter should be called when running a query.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNode 9.6.1\r\nMongo 3.4.0"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nWhen trying to perform a virtual population of a field on an embedded discriminator, I receive the following error:\r\n\r\n```\r\nVM182 utils.js:214 Uncaught TypeError: Cannot read property 'length' of undefined\r\n    at getModelsMapForPopulate (/Users/Documents/Code/mongoose-test/node_modules/mongoose/lib/model.js:3462:24)\r\n    at populate (/Users/Documents/Code/mongoose-test/node_modules/mongoose/lib/model.js:3039:15)\r\n    at _populate (/Users/Documents/Code/mongoose-test/node_modules/mongoose/lib/model.js:3007:5)\r\n    at utils.promiseOrCallback.cb (/Users/Documents/Code/mongoose-test/node_modules/mongoose/lib/model.js:2980:5)\r\n    at Object.promiseOrCallback (/Users/Documents/Code/mongoose-test/node_modules/mongoose/lib/utils.js:211:14)\r\n    at Function.Model.populate (/Users/Documents/Code/mongoose-test/node_modules/mongoose/lib/model.js:2979:16)\r\n    at cb (/Users/Documents/Code/mongoose-test/node_modules/mongoose/lib/query.js:1325:17)\r\n    at result (/Users/Documents/Code/mongoose-test/node_modules/mongodb/lib/utils.js:413:17)\r\n    at executeCallback (/Users/Documents/Code/mongoose-test/node_modules/mongodb/lib/utils.js:405:9)\r\n    at handleCallback (/Users/Documents/Code/mongoose-test/node_modules/mongodb/lib/utils.js:128:55)\r\n    at self.close (/Users/Documents/Code/mongoose-test/node_modules/mongodb/lib/cursor.js:934:60)\r\n    at handleCallback (/Users/Documents/Code/mongoose-test/node_modules/mongodb/lib/utils.js:128:55)\r\n    at completeClose (/Users/Documents/Code/mongoose-test/node_modules/mongodb/lib/cursor.js:1073:14)\r\n    at Cursor.close (/Users/Documents/Code/mongoose-test/node_modules/mongodb/lib/cursor.js:1086:10)\r\n    at /Users/Documents/Code/mongoose-test/node_modules/mongodb/lib/cursor.js:934:21\r\n    at handleCallback (/Users/Documents/Code/mongoose-test/node_modules/mongodb-core/lib/cursor.js:178:5)\r\n```\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n\r\n```javascript\r\nconst mongoose = require('mongoose')\r\nmongoose.connect('mongodb://localhost/mongoosetest')\r\nmongoose.connection.once('open', () => {\r\n\r\n  const Schema = mongoose.Schema\r\n\r\n  // Generate Users Model\r\n  const userSchema = new Schema({ employeeId: Number, name: String })\r\n  const UserModel = mongoose.model('Users', userSchema, 'users')\r\n\r\n  // Generate Embedded Discriminators\r\n  const eventSchema = new Schema(\r\n    { message: String },\r\n    { discriminatorKey: 'kind'}\r\n  );\r\n\r\n  const batchSchema = new Schema({ events: [eventSchema] });\r\n  const docArray = batchSchema.path('events');\r\n\r\n  // First embedded discriminator schema\r\n  const clickedSchema = new Schema(\r\n    {\r\n      element: { type: String },\r\n      users: [ Number ]\r\n    },\r\n    {\r\n      toJSON: { virtuals: true},\r\n      toObject: { virtuals: true}\r\n    }\r\n  );\r\n\r\n  // Add virtual to first embedded discriminator schema for virtual population\r\n  clickedSchema.virtual('users_$', {\r\n    ref: 'Users',\r\n    localField: 'users',\r\n    foreignField: 'employeeId'\r\n  })\r\n  \r\n  const Clicked = docArray.discriminator('Clicked', clickedSchema);\r\n\r\n  // Second embedded discriminator\r\n  const Purchased = docArray.discriminator('Purchased', new Schema({\r\n    product: { type: String }\r\n  }));\r\n\r\n  const Batch = mongoose.model('EventBatch', batchSchema);\r\n\r\n  // Generate Items\r\n  const user = { employeeId: 1, name: 'Test name' }\r\n  const batch = {\r\n    events: [\r\n      { kind: 'Clicked', element: '#hero', message: 'hello', users: [1] },\r\n      { kind: 'Purchased', product: 'action-figure-1', message: 'world' }\r\n    ]\r\n  };\r\n\r\n  Promise.all([UserModel.create(user), Batch.create(batch)])\r\n    .then(function(){\r\n      Batch.find({})\r\n        // Populate virtual field of embedded discriminator\r\n        .populate('events.users_$')\r\n        .lean()\r\n        .then(results => console.log(results) )\r\n    })\r\n})\r\n\r\n```\r\n\r\n**What is the expected behavior?**\r\nThe query should not have errored and should have populated the virtual field.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nnode: v9.7.1, mongoose: 5.0.11, MongoDB: v3.2.5"},{"labels":["bug"],"text":"- mongodb v3.6.3\r\n- mongoose v5.0.11\r\n- node v8.9.4\r\n\r\nThe strange problem is described in the comment below.\r\n\r\n```javascript\r\nasync function newVisit(ctx) {\r\n  let {\r\n    shortid,\r\n  } = ctx.params;\r\n\r\n  let { stringify } = JSON;\r\n  let { openSync } = maxmind;\r\n\r\n  let cityLookup = openSync(process.env.GEODATA);\r\n\r\n  // test ip: 219.76.153.227\r\n  let city = cityLookup.get('219.76.153.227');\r\n\r\n  let TblShortUrlVisiting = ctx.model('Short Url Visiting');\r\n\r\n  let shortUrlVisitingRecord = await TblShortUrlVisiting.findOne({\r\n    'stId': shortid,\r\n  });\r\n\r\n  // no visiting record\r\n  if (isEmpty(shortUrlVisitingRecord)) {\r\n    let toBeSave = {\r\n      stId: shortid,\r\n      birth: now(),\r\n      visitDetails: [\r\n        {\r\n          date: now(),\r\n          ua: stringify(ctx.userAgent),\r\n          geo: stringify(city),\r\n        }\r\n      ],\r\n    };\r\n\r\n    let tblShortUrlVisiting = new TblShortUrlVisiting(toBeSave);\r\n\r\n    await tblShortUrlVisiting.save();\r\n\r\n  } else {\r\n\r\n    // has visiting record\r\n\r\n    await TblShortUrlVisiting.update({\r\n      'stId': shortid,\r\n    }, {\r\n\r\n      /**\r\n       * ATTENTION:\r\n       * \r\n       * I have to set 0.5 to increment 1.\r\n       * If I set 1, it will going to increment by 2.\r\n       * OMG!\r\n       */\r\n      $inc: {\r\n        visitTimes: 0.5,\r\n      },\r\n\r\n      // This has been pushed twice...\r\n      $push: {\r\n        visitDetails: {\r\n          date: now(),\r\n          ua: stringify(ctx.userAgent),\r\n          geo: stringify(city),\r\n        },\r\n      },\r\n    }, {\r\n      safe: true,\r\n      upsert: false,\r\n    }, (err, rawResponse) => {\r\n      if (err) {\r\n        throw err;\r\n      }\r\n    });\r\n\r\n  }\r\n}\r\n```"},{"labels":["bug"],"text":"Mongoose version 4.13.8\r\n\r\nI was suprised to see a subdocument created when I create the parent with `findOneAndUpdate()` and options `setDefaultsOnInsert: true`.  My schema has no default value set for the field with the subdocument.\r\n\r\n``` javascript\r\nSubDocSchema = new mongoose.Schema({},{\r\n  autoIndex : true, \r\n  toObject: { virtuals: true },\r\n  toJSON: { virtuals: true },\r\n});\r\n\r\nParentSchema = new mongoose.Schema({\r\n  docVal: String,\r\n  subDoc: SubDocSchema, // no default is set here!\r\n},{\r\n  autoIndex : true, \r\n  toObject: { virtuals: true },\r\n  toJSON: { virtuals: true },\r\n});\r\n\r\nparentModel.findOneAndUpdate(\r\n  {_id: parentId}, \r\n  {docVal: 'newDocVal'}, \r\n  {upsert: true, setDefaultsOnInsert: true}\r\n).exec();\r\n```\r\n\r\n\r\n``` javascript\r\n{\r\n  _id: ObjectId(\"5ab55f0facdae000111d39c0\"),\r\n  docVal: 'newDocVal',\r\n    subdoc: {\r\n      _id: ObjectId(\"5ab55d59bf634e001091024c\")\r\n  }\r\n}\r\n```\r\n\r\nIs it possible to prevent the subdocument without using `$unset`?"},{"labels":["bug"],"text":"In the `mongoose-delete` plugin (https://github.com/dsanel/mongoose-delete/issues/36) the tests started failing when `kareem` package was updated to version 2.0.5. After some debugging it turns out that this only occurs when passing a callback function to the the overloaded function. I've created a test case that fails on the last assertion:\r\n\r\n```\r\nit('statics', async (done) => {\r\n  var called = false;\r\n  var filter_plugin = function(schema) {\r\n    schema.add({ filter: Boolean })\r\n    schema.statics.count = function() {\r\n      called = true;\r\n      return mongoose.Model['count'].apply(this, arguments).where('filter').eq(true);\r\n    }\r\n  }\r\n\r\n  var TestSchema = new Schema({ name: String });\r\n  TestSchema.plugin(filter_plugin);\r\n  var TestModel = db.model('PluginTests', TestSchema);\r\n\r\n  await TestModel.create(\r\n      [\r\n          { name: 'Obi-Wan Kenobi', filter: true},\r\n          { name: 'Darth Vader'},\r\n          { name: 'Luke Skywalker', filter: true}\r\n      ]);\r\n\r\n  assert.equal(called, false);\r\n  var count = await TestModel.count();\r\n  assert.equal(called, true);\r\n  assert.equal(count, 2);\r\n\r\n  return TestModel.count(function (err, count) {\r\n    assert.equal(called, true);\r\n    assert.equal(count, 2);\r\n    done();\r\n  })\r\n});\r\n```\r\n\r\nThe error is due to this commit: https://github.com/vkarpov15/kareem/commit/5afc5b9ab34f82702c8cd3a700c0f67fdfe4c86d I'm not sure though if where this bug belongs. Since the failure above doesn't use hooks, I've decided to first post the issue here. \r\n\r\nA full standalone test-file is available in my fork: https://github.com/gforge/mongoose/blob/master/test/schema.plugins.test.js"},{"labels":["bug",null],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nbug\r\n\r\n**What is the current behavior?**\r\nAfter the connection is `re-connected` and DB goes down again, there is no disconnection event and the `readyState` stays in `1 - connected`\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n1. start the DB\r\n2. start the app - make sure the `readyState` is 1\r\n3. stop the DB\r\n4. wait for disconnection - `readyState` is 0\r\n5. start the DB\r\n6. wait for reconnection - `readyState` is 1\r\n7. stop the DB\r\n8. the connection never gets a `disconnected` event and the `readyState` is 1\r\n\r\nusing the below script, the console output is:\r\n\r\n> connected\r\nopen\r\ncreateConnection\r\nping: true readyState: 1\r\nping: true readyState: 1\r\nping: false readyState: 1\r\ndisconnected\r\nping: false readyState: 0\r\nping: false readyState: 0\r\nping: false readyState: 0\r\nping: false readyState: 0\r\nping: false readyState: 0\r\nping: true readyState: 0\r\nping: true readyState: 0\r\nping: true readyState: 0\r\nping: true readyState: 0\r\nconnected\r\nreconnected\r\nping: true readyState: 1\r\nping: true readyState: 1\r\nping: false readyState: 1\r\nping: false readyState: 1\r\nping: false readyState: 1\r\nping: false readyState: 1\r\nping: false readyState: 1\r\nping: false readyState: 1\r\nping: false readyState: 1\r\nping: false readyState: 1\r\n...\r\n\r\nyou can see that the ping to the server turns to `false` but there is no disconnection.\r\nthe script that is used:\r\n```javascript\r\nconst tcpp          = require('tcp-ping');\r\nconst Promise       = require('bluebird');\r\nconst mongoose      = require('mongoose');\r\nmongoose.Promise = Promise;\r\n\r\nconst host = 'localhost';\r\nconst port = '2244';\r\nconst DB_URL = `mongodb://${host}:${port}/test_database`;\r\nconst ConnectionOptions = {\r\n    promiseLibrary: Promise,\r\n    reconnectTries: Number.MAX_VALUE\r\n};\r\n\r\nconst DbConnection = mongoose.createConnection(DB_URL, ConnectionOptions, (err) => {\r\n    console.log('createConnection');\r\n    if (err) {\r\n        console.log('createConnection', err.message);\r\n    }\r\n});\r\n\r\nDbConnection.on('error', function (error) {\r\n    console.log('error: ', error.message)\r\n});\r\n\r\nDbConnection.on('disconnected', function () {\r\n    console.log('disconnected');\r\n});\r\n\r\nDbConnection.on('close', function () {\r\n    console.log('close');\r\n});\r\n\r\nDbConnection.on('open', function () {\r\n    console.log('open');\r\n});\r\n\r\nDbConnection.on('connected', function () {\r\n    console.log('connected');\r\n});\r\n\r\nDbConnection.on('connecting', function () {\r\n    console.log('connecting');\r\n});\r\n\r\nDbConnection.on('reconnected', function () {\r\n    console.log('reconnected');\r\n});\r\n\r\nprocess.on('unhandledRejection', function (err) {\r\n    if ('MongoError' === err.name) {\r\n        console.log('unhandledRejection: ' + err.message);\r\n    }\r\n});\r\n\r\nsetInterval(() => {\r\n    tcpp.probe(host, port, (err, available) => {\r\n        console.log('ping:', available, 'readyState:', DbConnection.readyState);\r\n    })\r\n}, 3000);\r\n\r\nmodule.exports = DbConnection;\r\n``` \r\n\r\n**What is the expected behavior?**\r\nWhen there is a connection loss, there should be a `disconnected` event and the `readyState` should update accordingly, like in the first disconnection.\r\nI've tested almost the same script with the latest native driver using the `isConnected` function instead of the `readyState` and it works fine there. whenever the ping is gone, the `isConnected` function returns `false`. \r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nnode.js - 8.10.0\r\nmongoose - 5.0.10\r\nMongoDB - 3.4.10"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nbug\r\n\r\n**What is the current behavior?**\r\nI'm initializing the DB connection with the `createConnection` function.\r\nIf I'm doing so while the DB is down, the `readyState` of the connection stays at `2` (connecting), and when starting the DB there is no re-connection until process restart.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nusing the following script:\r\n\r\n```javascript\r\nconst Promise       = require('bluebird');\r\nconst mongoose      = require('mongoose');\r\nmongoose.Promise = Promise;\r\n\r\nconst DB_URL = 'mongodb://localhost:27017/test_database';\r\n\r\nconst DbConnection = mongoose.createConnection(DB_URL, {\r\n    promiseLibrary: Promise,\r\n    poolSize: 20,\r\n    socketTimeoutMS: 0,\r\n    connectTimeoutMS: 0,\r\n    reconnectTries: Number.MAX_VALUE\r\n});\r\n\r\nlet currentState = DbConnection.readyState;\r\nlet counter = 0 ;\r\nconsole.log(DbConnection.readyState);\r\nsetInterval(() => {\r\n    if (DbConnection.readyState === currentState) {\r\n        counter++;\r\n    } else {\r\n        counter = 0;\r\n        currentState = DbConnection.readyState;\r\n    }\r\n    console.log(DbConnection.readyState + ' - ' + counter);\r\n\r\n}, 3000);\r\n\r\nDbConnection.on('error', function (error) {\r\n    console.log('error: ' + error.message)\r\n});\r\n\r\nDbConnection.on('disconnected', function () {\r\n    console.log('disconnected');\r\n});\r\n\r\nDbConnection.on('close', function () {\r\n    console.log('close');\r\n});\r\n\r\nDbConnection.on('open', function () {\r\n    console.log('open');\r\n});\r\n\r\nDbConnection.on('connected', function () {\r\n    console.log('connected');\r\n});\r\n\r\nDbConnection.on('connecting', function () {\r\n    console.log('connecting');\r\n});\r\n\r\nDbConnection.on('reconnected', function () {\r\n    console.log('reconnected');\r\n});\r\n\r\nprocess.on('unhandledRejection', function (err) {\r\n    if ('MongoError' === err.name) {\r\n        console.log('unhandledRejection: ' + err.message);\r\n    }\r\n});\r\n\r\nmodule.exports = DbConnection;\r\n```\r\nwhile the DB is down from the beginning, the console output is:\r\n\r\n> 2\r\nerror: failed to connect to server [localhost:27017] on first connect [MongoNetworkError: connect ECONNREFUSED 127.0.0.1:27017]\r\n2 - 1\r\n2 - 2\r\n2 - 3\r\n2 - 4\r\n\r\nand the counter continues to go up on the `2` `readyState` even when starting the DB in the middle.  \r\n\r\n**What is the expected behavior?**\r\nThe connection should re-connect after starting the DB. The re-connection works fine if the DB goes down and up in the middle of the running process.\r\nFor example, using the same script as above when the DB is up at the beginning, and goes down and up in the middle of the run, the console output is:\r\n\r\n> 2\r\nconnected\r\nopen\r\n1 - 0\r\n1 - 1\r\ndisconnected\r\n0 - 0\r\n0 - 1\r\nconnected\r\nreconnected\r\n1 - 0\r\n1 - 1\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nnode.js - 8.10.0\r\nmongoose - 5.0.10\r\nMongoDB - 3.4\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n**What is the current behavior?**\r\n\r\nI have a schema like this:\r\n\r\n```\r\nconst highlightSchema = new mongoose.Schema({\r\n  _id: {\r\n    type: String,\r\n    required: true\r\n  },\r\n  color: {\r\n    type: String,\r\n    required: true\r\n  },\r\n  range: {\r\n    start: {\r\n      type: Number,\r\n      required: true\r\n    },\r\n    end: {\r\n      type: Number,\r\n      required: true\r\n    }\r\n  }\r\n});\r\n\r\nconst schema = new mongoose.Schema({\r\n  _id: {\r\n    type: String,\r\n    required: true\r\n  },\r\n  highlights: [highlightSchema],\r\n});\r\n```\r\n\r\nwhat I am trying to do is I want to remove some `highligh subdocuments` by using `findByIdAndUpdate` & `$pull`:\r\n\r\n```\r\nmongoose.findByIdAndUpdate(id, {\r\n  $pull: {\r\n    highlights: {\r\n      _id: {\r\n        $in:  ['1', '2', '3', '4']\r\n      }\r\n    }\r\n  }\r\n});\r\n``` \r\nIf I add `runValidators: true` to the function, it will throw error:\r\n\r\n```\r\nconsole.log dist/server/src/database/mongodb/models/user-lesson-schema/__tests__/highlight/pull.test.js:84\r\nValidationError: highlights._id: Path `_id` is required., highlights._id.$in: Path `_id` is required.\r\nat Object.<anonymous> (/app/dist/server/src/database/mongodb/utilites/findByIdAndUpdate.js:39:27)\r\nat Generator.throw (<anonymous>)\r\nat rejected (/app/dist/server/src/database/mongodb/utilites/findByIdAndUpdate.js:16:40)\r\nat <anonymous>\r\nat process._tickCallback (internal/process/next_tick.js:118:7)\r\n```\r\n\r\nIt works perfectly if I change `runValidators` to `false`\r\n\r\n**What is the expected behavior?**\r\nI am wondering what is causing this issue? Am I using the `$pull` function in a wrong way?\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNode: 9.7.1\r\nMongoDB: 3.4.10\r\nmongoose: 5.0.10\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBug\r\n\r\n**What is the current behavior?**\r\n\r\nThe bug occurs when using the [Populate Virtuals](http://mongoosejs.com/docs/populate.html#populate-virtuals) feature. If the virtual field have the `justOne: true` option set, but you populate while using a [`lean()`](http://mongoosejs.com/docs/api.html#query_Query-lean) query, the option is ignored and an array is always returned.\r\n\r\nConsider the following setup taken directly from the documentation example, with `justOne` modified to be `true` instead of `false`:\r\n\r\n```javascript\r\nvar PersonSchema = new mongoose.Schema({\r\n  name: String,\r\n  band: String\r\n});\r\n\r\nvar BandSchema = new mongoose.Schema({\r\n  name: String\r\n}, { toJSON: { virtuals: true } });\r\n\r\nBandSchema.virtual('members', {\r\n  ref: 'Person',\r\n  localField: 'name',\r\n  foreignField: 'band', \r\n  justOne: true\r\n},);\r\n\r\nvar Person = mongoose.model('Person', PersonSchema);\r\nvar Band = mongoose.model('Band', BandSchema);\r\n```\r\n\r\nWe then insert the following documents and perform a query based on the documentation example.\r\n\r\n```javascript\r\nBand.create({ name: `Guns N' Roses` })\r\n    .then(function(doc) {\r\n      return Band.create({ name: `Motley Crue` });\r\n    })\r\n    .then(function(doc) {\r\n      return Person.create({ name: `Axl Rose`, band: `Guns N' Roses` });\r\n    })\r\n    .then(function(doc) {\r\n      return Person.create({ name: `Slash`, band: `Guns N' Roses` });\r\n    })\r\n    .then(function(doc) {\r\n      return Person.create({ name: `Vince Neil`, band: `Motley Crue` });\r\n    })\r\n    .then(function(doc) {\r\n      return Person.create({ name: `Nikki Sixx`, band: `Motley Crue` });\r\n    })\r\n    .then(function(doc) {\r\n      return Band.find().populate('members').lean();\r\n    })\r\n    .then(function(bands) {\r\n      console.log(JSON.stringify(bands, null, 2));\r\n    })\r\n    .catch(function(err) {\r\n      console.log(err);\r\n    });\r\n```\r\n\r\nThe resulting output is as follows:\r\n\r\n```json\r\n[\r\n  {\r\n    \"_id\": \"5aa7021ee737327080141e83\",\r\n    \"name\": \"Guns N' Roses\",\r\n    \"__v\": 0,\r\n    \"members\": [\r\n      {\r\n        \"_id\": \"5aa7021fe737327080141e85\",\r\n        \"name\": \"Axl Rose\",\r\n        \"band\": \"Guns N' Roses\",\r\n        \"__v\": 0\r\n      },\r\n      {\r\n        \"_id\": \"5aa7021fe737327080141e86\",\r\n        \"name\": \"Slash\",\r\n        \"band\": \"Guns N' Roses\",\r\n        \"__v\": 0\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"_id\": \"5aa7021fe737327080141e84\",\r\n    \"name\": \"Motley Crue\",\r\n    \"__v\": 0,\r\n    \"members\": [\r\n      {\r\n        \"_id\": \"5aa7021fe737327080141e87\",\r\n        \"name\": \"Vince Neil\",\r\n        \"band\": \"Motley Crue\",\r\n        \"__v\": 0\r\n      },\r\n      {\r\n        \"_id\": \"5aa7021fe737327080141e88\",\r\n        \"name\": \"Nikki Sixx\",\r\n        \"band\": \"Motley Crue\",\r\n        \"__v\": 0\r\n      }\r\n    ]\r\n  }\r\n]\r\n```\r\n\r\n**What is the expected behavior?**\r\n\r\nSince `justOne: true` is set for the virtual field `members`, the expected behavior is for `members` to contain a single object, rather than an array of objects. In other words, the expected behavior is for the output to be the same as if the query was not performed with `lean()`, as I am not expecting `lean()` to change the actual result of the query itself.\r\n\r\n```json\r\n[\r\n  {\r\n    \"_id\": \"5aa7021ee737327080141e83\",\r\n    \"name\": \"Guns N' Roses\",\r\n    \"__v\": 0,\r\n    \"members\": {\r\n      \"_id\": \"5aa7021fe737327080141e85\",\r\n      \"name\": \"Axl Rose\",\r\n      \"band\": \"Guns N' Roses\",\r\n      \"__v\": 0\r\n    },\r\n    \"id\": \"5aa7021ee737327080141e83\"\r\n  },\r\n  {\r\n    \"_id\": \"5aa7021fe737327080141e84\",\r\n    \"name\": \"Motley Crue\",\r\n    \"__v\": 0,\r\n    \"members\": {\r\n      \"_id\": \"5aa7021fe737327080141e87\",\r\n      \"name\": \"Vince Neil\",\r\n      \"band\": \"Motley Crue\",\r\n      \"__v\": 0\r\n    },\r\n    \"id\": \"5aa7021fe737327080141e84\"\r\n  }\r\n]\r\n```\r\n\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\n\r\nnode.js: v8.9.4\r\nMongoDB: v3.4.13\r\nmongoose: v5.0.9"},{"labels":["bug"],"text":"I'm breaking out your comment from #6178 into it's own issue @bgSosh. #6178 didn't mention version 4 so I think we can bring the discussion into a separate issue.\r\n\r\nhere is a slightly modified version of the code from the gist mentioned in [the comment](https://github.com/Automattic/mongoose/issues/6178#issuecomment-369906957)\r\n```\r\n#!/usr/bin/env node\r\n'use strict'\r\n\r\nvar mongoose = require('./lib/test_db')\r\nmongoose.set('debug', true)\r\nvar AnimalSchema = new mongoose.Schema({\r\n  name: String\r\n})\r\n\r\nAnimalSchema.statics.foo = function (callback) {\r\n  var animalId = new mongoose.mongo.ObjectId('5a994cf7d5ae8a6fc32e72fd')\r\n\r\n  this.findById(animalId, { name: 1 }, function (err, animal) {\r\n    if (err) {\r\n      return callback(new Error('findById returned error: ' + err.toString()))\r\n    }\r\n\r\n    throw new Error('This is a thrown exception')\r\n  })\r\n}\r\n\r\nvar Animal = mongoose.model('Animal', AnimalSchema)\r\n\r\nAnimal.foo(function (err) {\r\n  if (err) {\r\n    console.log('from callback: ', err) // added a string to illustrate how the error is handled.\r\n  } else {\r\n    console.log('OK!')\r\n  }\r\n})\r\n\r\n```\r\n## output mongoose4:\r\n```\r\nInspiredMacPro:mongoose4 lineus$ ./6178_2.js \r\nMongoose: animals.findOne({ _id: ObjectId(\"5a994cf7d5ae8a6fc32e72fd\") }, { fields: { name: 1 } })\r\nevents.js:183\r\n      throw er; // Unhandled 'error' event\r\n      ^\r\n\r\nError: This is a thrown exception\r\n    at /Users/lineus/dev/Help/mongoose4/6178_2.js:18:11\r\n    at model.Query.<anonymous> (/Users/lineus/dev/Help/mongoose4/node_modules/mongoose/lib/model.js:4074:16)\r\n    at /Users/lineus/dev/Help/mongoose4/node_modules/kareem/index.js:273:21\r\n    at /Users/lineus/dev/Help/mongoose4/node_modules/kareem/index.js:131:16\r\n    at _combinedTickCallback (internal/process/next_tick.js:131:7)\r\n    at process._tickCallback (internal/process/next_tick.js:180:9)\r\n```\r\n## output mongoose5:\r\n```\r\nInspiredMacPro:mongoose5 lineus$ ./6178_2.js \r\nMongoose: animals.findOne({ _id: ObjectId(\"5a994cf7d5ae8a6fc32e72fd\") }, { fields: { name: 1 } })\r\nfrom callback:  Error: findById returned error: Error: This is a thrown exception\r\n    at /Users/lineus/dev/Help/mongoose5/6178_2.js:15:23\r\n    at /Users/lineus/dev/Help/mongoose5/node_modules/mongoose/lib/model.js:3928:16\r\n    at _init (/Users/lineus/dev/Help/mongoose5/node_modules/mongoose/lib/query.js:2003:14)\r\n    at completeOne (/Users/lineus/dev/Help/mongoose5/node_modules/mongoose/lib/query.js:1998:5)\r\n    at Immediate.<anonymous> (/Users/lineus/dev/Help/mongoose5/node_modules/mongoose/lib/query.js:1516:11)\r\n    at Immediate.<anonymous> (/Users/lineus/dev/Help/mongoose5/node_modules/mquery/lib/utils.js:119:16)\r\n    at runCallback (timers.js:789:20)\r\n    at tryOnImmediate (timers.js:751:5)\r\n    at processImmediate [as _immediateCallback] (timers.js:722:5)\r\n^C\r\nInspiredMacPro:mongoose5 lineus$ cd ../mongoose4\r\n```"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nWhen creating a document with nested schemas two levels deep if the lowest nested document is null then the parent doesn't have a value even if other keys are set. The issue seems to only occur when strict is false on the nested schema. The issue only happens in versions greater than 5.0.4.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```\r\n  describe('nested fields with a schema', function() {\r\n    it('saves', function(done) {\r\n      var NestedSchema = new Schema({\r\n        parent: new Schema({\r\n          name: String,\r\n          child: {\r\n            name: String\r\n          }\r\n        }, { strict: false })\r\n      });\r\n      var NestedModel = db.model('Nested', NestedSchema);\r\n      var n = new NestedModel({\r\n        parent: {\r\n          name: 'foo',\r\n          child: null // does not fail if undefined\r\n        }\r\n      });\r\n\r\n      assert.equal(n.parent.name, 'foo');\r\n      done();\r\n    });\r\n  });\r\n```\r\n\r\n**What is the expected behavior?**\r\nThe parent nested object has a value.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nnode: 9.6.1\r\nmongoose: 5.0.7\r\nmongodb: 3.6.3\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nReport a bug.\r\n\r\n**What is the current behavior?**\r\nAs in #5434, setters are being run twice during findOne().\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\nSee the repro in #5434; the same trace on the setter function demonstrates the issue; i.e., the setter function is called twice, once with the original input, and then again with the result of the first transformation.\r\n\r\n**What is the expected behavior?**\r\nSetter function should only be called once during findOne().\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nnode 8.9.4\r\nmongoose 5.0.6\r\nMongoDB 3.2.11\r\n"},{"labels":["bug",null],"text":"With the latest version of mongoose (currently `5.0.4`), `document.save()` takes way more time and sometimes times out when updating a large array of embedded documents. It used to work perfectly with the version 4 but not anymore. I know it is not recommended to have arrays that big, but you know how it is when they keep changing the specs\r\n\r\nThe workaround I found is to perform another query instead of updating the document and then calling `.save()`\r\n\r\nI used to do that and it worked perfectly\r\n\r\n```javascript\r\nModel.findOne({}).then(doc => {\r\n  for (let i = 0; i < 1000; i++) {\r\n    doc.push({\r\n      example: true,\r\n      count: i,\r\n    })\r\n  }\r\n  return doc.save()\r\n})\r\n```\r\n\r\n```javascript\r\nModel.findOne({}).then(doc => {\r\n  const toInsert =[]\r\n  for (let i = 0; i < 1000; i++) {\r\n    toInsert.push({\r\n      example: true,\r\n      count: i,\r\n    })\r\n  }\r\n  return Model.findOneAndUpdate(\r\n    {_id: doc._id},\r\n    {\r\n      $addToSet:{\r\n        $each: toInsert\r\n      }\r\n    },\r\n    {new:true}\r\n  )\r\n})\r\n```\r\n\r\nMy questions are:\r\n- Is it normal to have delay now when performing this kind of operation?\r\n- Does anyone face the same issue?\r\n- Is there any options to pass to save to keep the \"old\" performances ?"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\n```js\r\nvar SomeModel = db.model('SomeModel', new Schema({\r\n  uid: String,\r\n  binaryProp: Buffer\r\n});\r\nSomeModel.replaceOne({ uid:'test' }, { uid:'test', binaryProp: new Buffer([255]) }, { upsert: true })\r\n```\r\nresults in one of these errors:\r\n```\r\nTypeError: Cannot delete property '0' of [object Uint8Array]\r\n    at walkUpdatePath (project/node_modules/mongoose/lib/services/query/castUpdate.js:217:22)\r\n    at castUpdate (project/node_modules/mongoose/lib/services/query/castUpdate.js:72:18)\r\n    at model.Query._castUpdate (project/node_modules/mongoose/lib/query.js:3181:10)\r\n    at _update (project/node_modules/mongoose/lib/query.js:3031:23)\r\n    at model.Query.Query.replaceOne (project/node_modules/mongoose/lib/query.js:2965:10)\r\n    at _update (project/node_modules/mongoose/lib/model.js:2621:16)\r\n    at Function.replaceOne (project/node_modules/mongoose/lib/model.js:2589:10)\r\n\r\nTypeError: Cannot read property 'slice' of undefined\r\n    at Binary.value (project/node_modules/bson/lib/bson/binary.js:223:21)\r\n    at SchemaBuffer.cast (project/node_modules/mongoose/lib/schema/buffer.js:123:36)\r\n    at SchemaBuffer.SchemaType._castForQuery (project/node_modules/mongoose/lib/schematype.js:1088:15)\r\n    at SchemaBuffer.castForQuery (project/node_modules/mongoose/lib/schema/buffer.js:208:21)\r\n    at SchemaBuffer.SchemaType.castForQueryWrapper (project/node_modules/mongoose/lib/schematype.js:1045:15)\r\n    at castUpdateVal (project/node_modules/mongoose/lib/services/query/castUpdate.js:346:19)\r\n    at walkUpdatePath (project/node_modules/mongoose/lib/services/query/castUpdate.js:229:22)\r\n    at castUpdate (project/node_modules/mongoose/lib/services/query/castUpdate.js:80:7)\r\n    at model.Query._castUpdate (project/node_modules/mongoose/lib/query.js:3181:10)\r\n    at _update (project/node_modules/mongoose/lib/query.js:3031:23)\r\n    at model.Query.Query.replaceOne (project/node_modules/mongoose/lib/query.js:2965:10)\r\n    at _update (project/node_modules/mongoose/lib/model.js:2621:16)\r\n    at Function.replaceOne (project/node_modules/mongoose/lib/model.js:2589:10)\r\n```\r\n- can't pin down exactly what causes one or the other to appear\r\n- `SomeModel.update(...)` works\r\n\r\n**What is the expected behavior?**\r\nIt works.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nnode 8.4.0\r\nmongoose 4.13.11 and 5.0.4\r\nmongodb 3.4.7"},{"labels":["bug",null],"text":"Running the latest version of Node.js on macOS. Also running the latest version of Mongoose.\r\n\r\nSeeing `Error: cyclic dependency detected` with literally no way to debug. Everything points back to Mongoose. Any suggestions? Started happening today.\r\n\r\n```\r\n/Users/nickparsons/Code/winds-2.0/api/src/node_modules/mongoose/lib/utils.js:417\r\n        throw err;\r\n        ^\r\n\r\nError: cyclic dependency detected\r\n    at serializeObject (/Users/nickparsons/Code/winds-2.0/api/src/node_modules/bson/lib/bson/parser/serializer.js:296:33)\r\n    at serializeInto (/Users/nickparsons/Code/winds-2.0/api/src/node_modules/bson/lib/bson/parser/serializer.js:776:17)\r\n    at serializeObject (/Users/nickparsons/Code/winds-2.0/api/src/node_modules/bson/lib/bson/parser/serializer.js:308:18)\r\n    at serializeInto (/Users/nickparsons/Code/winds-2.0/api/src/node_modules/bson/lib/bson/parser/serializer.js:776:17)\r\n    at serializeObject (/Users/nickparsons/Code/winds-2.0/api/src/node_modules/bson/lib/bson/parser/serializer.js:308:18)\r\n    at serializeInto (/Users/nickparsons/Code/winds-2.0/api/src/node_modules/bson/lib/bson/parser/serializer.js:776:17)\r\n    at serializeObject (/Users/nickparsons/Code/winds-2.0/api/src/node_modules/bson/lib/bson/parser/serializer.js:308:18)\r\n    at serializeInto (/Users/nickparsons/Code/winds-2.0/api/src/node_modules/bson/lib/bson/parser/serializer.js:776:17)\r\n    at serializeObject (/Users/nickparsons/Code/winds-2.0/api/src/node_modules/bson/lib/bson/parser/serializer.js:308:18)\r\n    at serializeInto (/Users/nickparsons/Code/winds-2.0/api/src/node_modules/bson/lib/bson/parser/serializer.js:776:17)\r\n    at serializeObject (/Users/nickparsons/Code/winds-2.0/api/src/node_modules/bson/lib/bson/parser/serializer.js:308:18)\r\n    at serializeInto (/Users/nickparsons/Code/winds-2.0/api/src/node_modules/bson/lib/bson/parser/serializer.js:776:17)\r\n    at serializeObject (/Users/nickparsons/Code/winds-2.0/api/src/node_modules/bson/lib/bson/parser/serializer.js:308:18)\r\n    at serializeInto (/Users/nickparsons/Code/winds-2.0/api/src/node_modules/bson/lib/bson/parser/serializer.js:776:17)\r\n    at serializeObject (/Users/nickparsons/Code/winds-2.0/api/src/node_modules/bson/lib/bson/parser/serializer.js:308:18)\r\n    at serializeInto (/Users/nickparsons/Code/winds-2.0/api/src/node_modules/bson/lib/bson/parser/serializer.js:776:17)\r\n    at serializeObject (/Users/nickparsons/Code/winds-2.0/api/src/node_modules/bson/lib/bson/parser/serializer.js:308:18)\r\n    at serializeInto (/Users/nickparsons/Code/winds-2.0/api/src/node_modules/bson/lib/bson/parser/serializer.js:776:17)\r\n    at serializeObject (/Users/nickparsons/Code/winds-2.0/api/src/node_modules/bson/lib/bson/parser/serializer.js:308:18)\r\n    at serializeInto (/Users/nickparsons/Code/winds-2.0/api/src/node_modules/bson/lib/bson/parser/serializer.js:618:17)\r\n    at serializeObject (/Users/nickparsons/Code/winds-2.0/api/src/node_modules/bson/lib/bson/parser/serializer.js:308:18)\r\n    at serializeInto (/Users/nickparsons/Code/winds-2.0/api/src/node_modules/bson/lib/bson/parser/serializer.js:776:17)\r\n```\r\n"},{"labels":["bug"],"text":"The `mongodb+srv` protocol for mongodb atlas [doesn't support specifying the db name in the connection string](https://github.com/mongodb/specifications/blob/master/source/initial-dns-seedlist-discovery/initial-dns-seedlist-discovery.rst#specification). That means mongoose will always connect to admin, which is bad because atlas doesn't allow raw queries on admin"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nbug\r\n\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n```js\r\nvar bluebird = require(\"bluebird\");\r\nvar mongoose = require(\"mongoose\");\r\nmongoose.set(\"debug\", true);\r\nmongoose.Promise = bluebird.Promise;\r\n\r\nvar db = mongoose.createConnection(\"mongodb://localhost/issue-123\");\r\n\r\n\r\nconst MySchema = new mongoose.Schema({\r\n\tarray: {\r\n\t\ttype: [String],\r\n\t\tenum: [\"qwerty\"]\r\n\t},\r\n});\r\n\r\n\r\nvar MyModel = db.model(\"MySchema\", MySchema);\r\n\r\n\r\nMyModel.create({array: [\"qwerty\", \"asdfgh\"]})\r\n\t.then(model => {\r\n\t\tconsole.log(model); // saved\r\n\t});\r\n```\r\n\r\n**What is the current behavior?**\r\nmodel is saved with 2 values\r\n\r\n**What is the expected behavior?**\r\nshould throw validation error because \"asdfgh\" is not in enum\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nnode 8.9\r\nmongoose 5.0.3\r\n"},{"labels":["bug"],"text":"Example code:\r\n```js\r\n// default query\r\nconst userQuery = User.where({ status: 'approved' }); \r\n\r\n// some logic, which generates additional criterias or change default\r\nconst someFilter = { \r\n  status: { $ne: 'delayed' },\r\n};\r\n\r\n// merging criterias and query execution\r\nconst data = await userQuery.where(someFilter).exec();\r\n```\r\n\r\n**With Mongoose 4 it works without problem**\r\nIt generates/merge following criteria: `{ status: { $ne: 'delayed' } }`.\r\n\r\n**With Mongoose 5.0.3 it fails with error** \r\n<details>\r\n  <summary>`Cannot create property '$ne' on string 'approved'`</summary>\r\n\r\n  - utils.js:320 merge\r\n    [npm_ram_disk]/[mongoose]/lib/utils.js:320:15\r\n  - utils.js:322 Object.merge\r\n    [npm_ram_disk]/[mongoose]/lib/utils.js:322:7\r\n  - query.js:1417 model.Query.Query.merge\r\n    [npm_ram_disk]/[mongoose]/lib/query.js:1417:9\r\n  - mquery.js:276 model.Query.Query.where\r\n    [npm_ram_disk]/[mquery]/lib/mquery.js:276:17\r\n  - filter.js:151 filterHelper\r\n    [npm_ram_disk]/[graphql-compose-mongoose]/lib/resolvers/helpers/filter.js:151:47\r\n  - count.js:40 resolve\r\n    [npm_ram_disk]/[graphql-compose-mongoose]/lib/resolvers/count.js:40:33\r\n  - connectionResolver.js:147 _callee$\r\n    [npm_ram_disk]/[graphql-compose-connection]/lib/connectionResolver.js:147:34\r\n  - runtime.js:62 tryCatch\r\n    [npm_ram_disk]/[regenerator-runtime]/runtime.js:62:40\r\n  - runtime.js:296 Generator.invoke [as _invoke]\r\n    [npm_ram_disk]/[regenerator-runtime]/runtime.js:296:22\r\n  - runtime.js:114 Generator.prototype.(anonymous function) [as next]\r\n    [npm_ram_disk]/[regenerator-runtime]/runtime.js:114:21\r\n  - asyncToGenerator.js:17 step\r\n    [npm_ram_disk]/[babel-runtime]/helpers/asyncToGenerator.js:17:30\r\n  - asyncToGenerator.js:35\r\n    [npm_ram_disk]/[babel-runtime]/helpers/asyncToGenerator.js:35:14\r\n  - Promise\r\n  - _export.js:35 F\r\n    [npm_ram_disk]/[core-js]/library/modules/_export.js:35:28\r\n  - asyncToGenerator.js:14\r\n    [npm_ram_disk]/[babel-runtime]/helpers/asyncToGenerator.js:14:12\r\n  - connectionResolver.js:275 resolve\r\n    [npm_ram_disk]/[graphql-compose-connection]/lib/connectionResolver.js:275:21\r\n  - resolver.js:523\r\n    [npm_ram_disk]/[graphql-compose]/lib/resolver.js:523:18\r\n  - resolver.js:523\r\n    [npm_ram_disk]/[graphql-compose]/lib/resolver.js:523:18\r\n  - resolver.js:523\r\n    [npm_ram_disk]/[graphql-compose]/lib/resolver.js:523:18\r\n  - jobTC.js:554 rp\r\n    /Volumes/npm_ram_disk/build/development/webpack:/src/schema/job/jobTC.js:554:1\r\n  - resolver.js:354\r\n    [npm_ram_disk]/[graphql-compose]/lib/resolver.js:354:18\r\n  - resolver.js:341 resolve\r\n    [npm_ram_disk]/[graphql-compose]/lib/resolver.js:341:29\r\n  - Array.reduce\r\n  - Array.reduce\r\n  - index.js:164\r\n    [npm_ram_disk]/[express-graphql]/dist/index.js:164:37\r\n  - next_tick.js:228 process._tickDomainCallback\r\n    internal/process/next_tick.js:228:7\r\n</details>\r\n\r\n\r\n### As a workaround what you can suggest me?\r\nHow to remove some keys from creteria? Is there public mongoose api for this:\r\n```diff\r\nconst userQuery = User.where({ status: 'approved' });\r\nconst someFilter = { status: { $ne: 'delayed' } };\r\n\r\nObject.keys(someFilter).forEach(key => {\r\n-   delete userQuery._criteria[key];\r\n+   some proper way to remove existed condition, for avoiding incorrect merge behavior\r\n});\r\n \r\nconst data = await userQuery.where(someFilter).exec();\r\n```"},{"labels":["bug"],"text":"I upgraded to latest mongoose 5 and ran into some strange issues. I believe lot of stuff got cleaned up and error reporting got better, which shows some issues in my application ;) Unfortantuntely it doesn't tell me where it happens.\r\n\r\nE.g. now I'm seeing a lot of TypeErrors like this:\r\n```\r\nTypeError: Cannot set property '_id' of undefined\r\n    at model.Query.resetId (/var/node_modules/mongoose/lib/schema/objectid.js:214:18)\r\n    at ObjectId.SchemaType._applySetters (/var/node_modules/mongoose/lib/schematype.js:670:22)\r\n    at ObjectId.SchemaType.applySetters (/var/node_modules/mongoose/lib/schematype.js:694:16)\r\n    at ObjectId.SchemaType._castForQuery (/var/node_modules/mongoose/lib/schematype.js:1072:15)\r\n    at ObjectId.castForQuery (/var/node_modules/mongoose/lib/schema/objectid.js:198:15)\r\n    at ObjectId.handleArray (/var/node_modules/mongoose/lib/schematype.js:1008:18)\r\n    at ObjectId.castForQuery (/var/node_modules/mongoose/lib/schema/objectid.js:196:20)\r\n    at ObjectId.SchemaType.castForQueryWrapper (/var/node_modules/mongoose/lib/schematype.js:1036:17)\r\n    at cast (/var/node_modules/mongoose/lib/cast.js:250:39)\r\n    at model.Query.Query.cast (/var/node_modules/mongoose/lib/query.js:3133:12)\r\n    at model.Query.Query._castConditions (/var/node_modules/mongoose/lib/query.js:1269:10)\r\n    at model.Query.Query._find (/var/node_modules/mongoose/lib/query.js:1284:8)\r\n    at /var/node_modules/kareem/index.js:276:8\r\n    at /var/node_modules/kareem/index.js:23:7\r\n    at _combinedTickCallback (internal/process/next_tick.js:131:7)\r\n    at process._tickDomainCallback (internal/process/next_tick.js:218:9)\r\n```\r\n\r\nThis happens when I run a query like this:\r\n`Model.find({'_id': [undefined]})` or `Model.find({'_id': {$in: [undefined]}})`\r\n\r\nWell, I'm aware that this is indeed something that shouldn't work, but it would be great to see where exactly it comes from. Is there any chance to improve this error message? Adding the related model or even better the whole query that triggers this?\r\n\r\nnode v9.3.0\r\nmongoose 5.0.3\r\nmongodb: 3.4\r\n\r\nThanks\r\nSimon"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nbug\r\n\r\n**What is the current behavior?**\r\nWhen to I try to update a document using the $addToSet operator with strings, mongoose simply concatenates it to a single element, when I try it with numbers mongoose simply cleans the whole array.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nMinimum steps to reproduce this behavior: https://github.com/melyourhero/mongoose-bug\r\n\r\n**What is the expected behavior?**\r\nThe expected behavior described in official MongoDB native driver documentation here: https://docs.mongodb.com/manual/reference/operator/update/addToSet/#behavior\r\n\r\n**Please mention your node.js, mongoose, and MongoDB version.**\r\nNode: v8.5.0\r\nMongoDB: v3.4.10\r\nmongoose: v5.0.3\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nIf I describe a schema for a discriminator in which a top level field Object but a child field within the object has specific requirements, the casting will not apply and will cause validation failures.  If the top level fields are different types then it works as expected.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n[See the following code](https://github.com/stieg/mongoose-discriminator-recursion-failure)\r\n```javascript\r\n\"use strict\";\r\nconst Promise = require('bluebird');\r\nconst assert = require('assert');\r\nconst mongoose = require('mongoose');\r\n\r\nconsole.log('mongoose version:', mongoose.version);\r\nmongoose.Promise = Promise;\r\n\r\nvar schema = mongoose.Schema({\r\n  account: {\r\n    type: Object,\r\n  },\r\n  info: {\r\n    ref: 'Bar',\r\n    required: true,\r\n    type: mongoose.Schema.Types.ObjectId,\r\n  }\r\n});\r\n\r\nvar Model = mongoose.model('Thing', schema);\r\nModel.on('error', function(err) {\r\n  console.log('Hit Model Error ', err.message);\r\n});\r\n\r\nvar discSchema = mongoose.Schema({\r\n  account: {\r\n    user: {\r\n      ref: 'Foo',\r\n      required: true,\r\n      type: mongoose.Schema.Types.ObjectId,\r\n    }\r\n  }\r\n});\r\n\r\nvar Disc = Model.discriminator('ThingDisc', discSchema);\r\n\r\nfunction main() {\r\n  const m1 = new Model({\r\n    info: 'AAAAAAAAAAAAAAAAAAAAAAAA',\r\n  });\r\n  const m1Err = m1.validateSync();\r\n  console.log('M1:', m1);\r\n  assert(!m1Err, m1Err);\r\n\r\n  const d1 = new Disc({\r\n    account: {\r\n      user: 'AAAAAAAAAAAAAAAAAAAAAAAA',\r\n    },\r\n    info: 'AAAAAAAAAAAAAAAAAAAAAAAA',\r\n  });\r\n  console.log('D1:', d1);\r\n  const d1Err = d1.validateSync();\r\n  assert(!d1Err, d1Err);\r\n\r\n  console.log('Success');\r\n};\r\n\r\nmain();\r\n```\r\n\r\n**What is the expected behavior?**\r\nI would expect that the discriminator schema would win out over the parent and would properly cast the objects recursively.\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNode v8.9.4\r\nMongoose 5.0.2, 4.13.{9,10}"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nNoticed some tests failing, turns out that after upgrading to 5.0.x using sinon.useFakeTimers (http://sinonjs.org/releases/v4.2.2/fake-timers/) is the cause.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nhttps://gist.github.com/paglias/943c6f3c3efbce095c0e6257eac9b4ae -> Using mongoose 4 it works correctly, with version 5 it doesn't unless you comment out line 12. I've tried with past and future dates and even enabling mongoose debugging but there's no info at all. \r\n\r\nFrom testing I noticed that it arrives up to the pre validate hooks but not further\r\n\r\n**What is the expected behavior?**\r\nIt should save docs with sinon.js and useFakeTimers\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nnode 6 or 8\r\nmongo 3.4\r\nmongoose"},{"labels":["bug"],"text":"Lately, I've been going through a course named **The Web Developer Course**.\r\nIn which the final project is based on Camps.\r\nIn the project, the **comment** database and the **campground** database are referenced, that is, the **ObjectIds** of the **comments** which are posted in a **campground** is stored in an **array**. This is what to be happened actually.\r\n\r\nBut in my case, the exact scenario's changed..When I try to Add a **new comment** what actually happens is that the **total object** gets stored in the **comments array** instead of the **ObjectId of the comment**. \r\nI've almost gone through Stackoverflow seeking solution for my problem but failed.\r\n\r\nI just wanted the **ObjectId** to be stored in the **comments array** instead it stores the whole Object which brings me problem in **updating and deleting** a comment. When I delete or update a comment the operation does happen in the Comments database but doesn't reflect in the Campgrounds database. Please help me with this issue. If anyone's taking the same course, Please give me solutions if you've experienced something like this already. The Schema are as given below\r\n\r\n**Campground Schema:**\r\n\r\n    var mongoose = require(\"mongoose\");\r\n    \r\n    var campgroundSchema = mongoose.Schema({\r\n        campGroundName: String,\r\n        campGroundImage: String,\r\n        description: String,\r\n        comments: [\r\n            {\r\n                type: mongoose.Schema.Types.ObjectId,\r\n                ref: \"Comment\"\r\n            }    \r\n        ],\r\n        addedBy: {\r\n            id: {\r\n                type: mongoose.Schema.Types.ObjectId,\r\n                ref: \"User\"\r\n            },\r\n            username: String\r\n        }\r\n    });\r\n    \r\n    module.exports = mongoose.model(\"Campground\", campgroundSchema);\r\n**Comment Schema:**\r\n\r\n    var mongoose = require(\"mongoose\");\r\n    \r\n    var commentSchema = mongoose.Schema({\r\n        text: String,\r\n        author: {\r\n            id: {\r\n                type: mongoose.Schema.Types.ObjectId,\r\n                ref: \"User\"\r\n            },\r\n            username: String\r\n        }\r\n    });\r\n    \r\n    module.exports = mongoose.model(\"Comment\", commentSchema);\r\n\r\n**Post request for creating a comment:**\r\n\r\n    router.post(\"/\", middleware.isLoggedIn, function(req, res) {\r\n        Comment.create(req.body.comment, function(err, createdComment) {\r\n              if(err) {\r\n                  console.log(err);\r\n              } else {\r\n                  createdComment.author.id = req.user._id;\r\n                  createdComment.author.username = req.user.username;\r\n                  createdComment.save();                  Campground.findById(req.params.id).populate(\"comments\").exec(function(err, foundCampground){\r\n                  foundCampground.comments.push(createdComment);\r\n                  foundCampground.save();\r\n                  req.flash(\"success\" , \"Comment created successfully\");\r\n                  res.redirect(\"/index/\" + req.params.id); \r\n                 });\r\n              }        \r\n        });\r\n    });\r\n\r\nThe whole source code is below,\r\n\r\nhttps://1drv.ms/u/s!AmISAco3PGaPhQl_Riu8nroCom5h\r\n\r\nNodeJS : v6.11.4\r\nNPM: v6.11.4\r\nMongoose: v5.0.0-rc2\r\n\r\nPlease help me fix this issue!"},{"labels":["bug",null],"text":"Tested on **5.0.1** and **Node 8.9.4**\r\n\r\n```js\r\nconst mongoose = require( 'mongoose' );\r\nconst m = new mongoose.Mongoose();\r\n\r\nm.connect( 'mongodb://thisdoesntexist:27017' )\r\n  .then(\r\n    () => { console.log( 'Success!' ); },\r\n    ( err ) => { console.error( err ); }\r\n  );\r\n```\r\n\r\nResults:\r\n1. Promise is rejected pretty much immediately. (As expected)\r\n1. Node.js process hangs (=does not exit) for 30 seconds. (Not expected)\r\n\r\nIntuitive expectation would be that connection process comes to an end when the `.connect()` promise is rejected. Seems like something keeps going on in the background after that, though."},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nI want to report a bug.\r\n\r\n**What is the current behavior?**\r\nThe `Model.find()` does not correctly parse discriminated single nested document.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\nHere is my test script:\r\n\r\n    const Mongoose = require('mongoose');\r\n    const Schema = Mongoose.Schema;\r\n    const expect = require('expect.js');\r\n    \r\n    describe('Mongoose', function () {\r\n      Mongoose.Promise = global.Promise;\r\n      Mongoose.set('debug', true);\r\n      \r\n      const ownerSchema = new Schema({\r\n        _id: false,\r\n      }, {\r\n        discriminatorKey: 'type',\r\n      });\r\n      \r\n      const userOwnerSchema = new Schema({\r\n        id: {type: Schema.Types.ObjectId, required: true},\r\n      });\r\n      \r\n      const tagOwnerSchema = new Schema({\r\n        id: {type: String, required: true},\r\n      });\r\n      \r\n      const activitySchema = new Schema({\r\n        owner: {type: ownerSchema, required: true},\r\n      });\r\n      \r\n      activitySchema.path('owner').discriminator('user', userOwnerSchema);\r\n      activitySchema.path('owner').discriminator('tag', tagOwnerSchema);\r\n      \r\n      const Activity = Mongoose.model('Activity', activitySchema);\r\n      \r\n      before(async function () {\r\n        await Mongoose.connect('mongodb://localhost/test', {useMongoClient: true});\r\n      });\r\n      \r\n      after(async function () {\r\n      });\r\n      \r\n      describe('insertMany()', function () {\r\n        it('should save without error', async function () {\r\n          const newActivity = await Activity.insertMany([\r\n            {\r\n              owner: {\r\n                id  : '5a042f742a91c1db447534d5',\r\n                type: 'user',\r\n              },\r\n            },\r\n            {\r\n              owner: {\r\n                id  : 'asdf',\r\n                type: 'tag',\r\n              },\r\n            },\r\n          ]);\r\n          \r\n          expect(newActivity.length).to.be(2);\r\n        });\r\n      });\r\n      \r\n      describe('find()', function () {\r\n        it('should be parse with correct schema', async function () {\r\n          const activity = await Activity.find({\r\n              owner: {\r\n                id  : '5a042f742a91c1db447534d5',\r\n                type: 'user',\r\n              },\r\n            })\r\n            .exec();\r\n          \r\n          expect(activity.length).to.be(1);\r\n        });\r\n      });\r\n    });\r\n\r\nRunning above script produces these errors:\r\n\r\n    to String failed for value \"user\" at path \"type\"\r\n      at CastError (node_modules/mongoose/lib/error/cast.js:27:11)\r\n      at SingleNested.$set (node_modules/mongoose/lib/document.js:773:7)\r\n      at SingleNested._handleI\r\n\r\n**What is the expected behavior?**\r\n\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nI am using the latest Mongoose."},{"labels":["bug"],"text":"It happens if I call findOneAndUpdate or findByIdAndUpdate. If I remove __v from document, it does not appear.\r\n\r\n../node_modules/mongoose/lib/query.js:3119:9\r\n\r\nMongoDB shell version v3.6.1\r\nMongoose v.4.13.9\r\nNode v.8.9.4"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nI like to report what I think is a bug in 5.0.0-rc2\r\n\r\n**What is the current behavior?**\r\nI'm trying to populate a referenced document inside an embedded discriminator.\r\n\r\nPopulating works when storing the discriminator in a separate collection, but it doesn't when it's embedded.\r\n\r\nSituation: Bundle has Item (Books or Ebooks) that refer to an Author\r\n\r\n1. Separate collections for Bundle, Item and Author (population of Item and Author works)\r\n2. Collections for Bundle and Author (Item are embedded in Bundle and reference Author, which does not get populated)\r\n\r\n**Repro script for 1, separate collections, the author is correctly populated**\r\n```js\r\n// Modules\r\nconst mongoose = require('mongoose');\r\n\r\n// DB\r\nlet connect = mongoose.connect(\"mongodb://localhost:27017/test\");\r\n\r\n// Models\r\nconst Author = mongoose.model('Author', new mongoose.Schema({\r\n  firstName: {\r\n    type: String,\r\n    required: true\r\n  },\r\n  lastName: {\r\n    type: String,\r\n    required: true\r\n  }\r\n}));\r\n\r\nconst ItemSchema = new mongoose.Schema({\r\n  title: {\r\n    type: String,\r\n    required: true\r\n  }\r\n}, {discriminatorKey: 'type'});\r\nconst Item = mongoose.model('Item', ItemSchema);\r\n\r\nconst ItemBookSchema = new mongoose.Schema({\r\n  author: {\r\n    type: mongoose.Schema.ObjectId,\r\n    ref: 'Author'\r\n  }\r\n});\r\nItem.discriminator('Book', ItemBookSchema);\r\nconst Book = mongoose.model('Book');\r\n\r\nconst ItemEBookSchema = new mongoose.Schema({\r\n  author: {\r\n    type: mongoose.Schema.ObjectId,\r\n    ref: 'Author'\r\n  },\r\n  url: {\r\n    type: String\r\n  }\r\n});\r\nItem.discriminator('EBook', ItemEBookSchema);\r\nconst EBook = mongoose.model('EBook');\r\n\r\nconst Bundle = mongoose.model('Bundle', new mongoose.Schema({\r\n  name: {\r\n    type: String,\r\n    required: true\r\n  },\r\n  items: [{\r\n    type: mongoose.Schema.ObjectId,\r\n    ref: 'Item',\r\n    required: false\r\n  }]\r\n}));\r\n\r\n// Populate\r\nconst population = {\r\n  path: 'items',\r\n  populate: {\r\n    path: 'author'\r\n  }\r\n}\r\n\r\n// Create test data\r\nconnect.then(() => {\r\n  // Create author\r\n  return new Author({firstName: 'David', lastName: 'Flanagan'}).save();\r\n}).then((author) => {\r\n  // Create items\r\n  let createBook = new Book({title: 'JavaScript: The Definitive Guide', author: author}).save()\r\n  let createEBook = new EBook({\r\n    title: 'JavaScript: The Definitive Guide Ebook',\r\n    url: 'https://google.com',\r\n    author: author\r\n  }).save();\r\n  return Promise.all([createBook, createEBook]);\r\n}).then((items) => {\r\n  // Create bundle with referenced items\r\n  return new Bundle({name: 'Javascript Book Collection', items: items}).save();\r\n}).then(() => {\r\n  return Bundle.findOne({}).populate(population).lean().exec();\r\n}).then((bundle) => {\r\n  console.log(bundle.items[0].author); \r\n  // { _id: 5a513af060436559217875c2,\r\n  //   firstName: 'David',\r\n  //   lastName: 'Flanagan',\r\n  //   __v: 0 }\r\n});\r\n```\r\n\r\n**Repro script for 2, embedded discriminator, the author is not populated**\r\n```js\r\n// Modules\r\nconst mongoose = require('mongoose');\r\n\r\n// DB\r\nlet connect = mongoose.connect(\"mongodb://localhost:27017/test\");\r\n\r\n// Models\r\nconst Author = mongoose.model('Author', new mongoose.Schema({\r\n  firstName: {\r\n    type: String,\r\n    required: true\r\n  },\r\n  lastName: {\r\n    type: String,\r\n    required: true\r\n  }\r\n}));\r\n\r\nconst ItemSchema = new mongoose.Schema({\r\n  title: {\r\n    type: String,\r\n    required: true\r\n  }\r\n}, {discriminatorKey: 'type'});\r\n\r\nconst ItemBookSchema = new mongoose.Schema({\r\n  author: {\r\n    type: mongoose.Schema.ObjectId,\r\n    ref: 'Author'\r\n  }\r\n});\r\n\r\nconst ItemEBookSchema = new mongoose.Schema({\r\n  author: {\r\n    type: mongoose.Schema.ObjectId,\r\n    ref: 'Author'\r\n  },\r\n  url: {\r\n    type: String\r\n  }\r\n});\r\n\r\nconst BundleSchema = new mongoose.Schema({\r\n  name: {\r\n    type: String,\r\n    required: true\r\n  },\r\n  items: [{\r\n    type: ItemSchema,\r\n    required: false\r\n  }]\r\n});\r\nconst Bundle = mongoose.model('Bundle', BundleSchema);\r\n\r\n// Add discriminators on items path\r\nBundleSchema.path('items').discriminator('Book', ItemBookSchema);\r\nBundleSchema.path('items').discriminator('EBook', ItemEBookSchema);\r\n\r\n// Populate\r\nconst population = {\r\n  path: 'items',\r\n  populate: {\r\n    path: 'author'\r\n  }\r\n}\r\n\r\n// Create test data\r\nconnect.then(() => {\r\n  // Create author\r\n  return new Author({firstName: 'David', lastName: 'Flanagan'}).save();\r\n}).then((author) => {\r\n  // Create bundle with embedded items\r\n  return new Bundle({\r\n    name: 'Javascript Book Collection', items: [\r\n      {type: 'Book', title: 'JavaScript: The Definitive Guide', author: author},\r\n      {\r\n        type: 'EBook',\r\n        title: 'JavaScript: The Definitive Guide Ebook',\r\n        url: 'https://google.com',\r\n        author: author\r\n      }\r\n    ]\r\n  }).save();\r\n}).then(() => {\r\n  // Find bundle, populate author of items\r\n  return Bundle.findOne({}).populate(population).lean().exec();\r\n}).then((bundle) => {\r\n  // Log bundle\r\n  console.log(bundle.items[0].author); // 5a513b01a7a24459239e6c14\r\n});\r\n```\r\n**What is the expected behavior?**\r\nAuthor needs to get populated when Items are embedded\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\n- node: 9.3.0\r\n- mongoose: 5.0.0-rc2\r\n- mongodb version: 3.6.0"},{"labels":["bug"],"text":"Similar to a previously reported issue (#3884) except it appears to only happen for subdoc arrays now.\r\n\r\nTested on 4.13.5\r\n\r\n```javascript\r\nvar Schema = mongoose.Schema;\r\n\r\nvar childSchema = new Schema({\r\n  name: { type: String },\r\n  friends: [{ type: String }]\r\n});\r\n\r\nchildSchema.pre('validate', function (next) {\r\n    console.log('Child pre validate');\r\n    next();\r\n});\r\n\r\nchildSchema.pre('save', function (next) {\r\n    console.log('Child pre save');\r\n    next();\r\n});\r\n\r\nvar parentSchema = new Schema({\r\n  name: { type: String },\r\n  children: [childSchema]\r\n});\r\n\r\nparentSchema.pre('validate', function (next) {\r\n    console.log('Parent pre validate');\r\n    next();\r\n});\r\n\r\nparentSchema.pre('save', function (next) {\r\n    console.log('Parent pre save');\r\n    next();\r\n});\r\n\r\nvar Parent = connection.model('Parent', parentSchema);\r\nvar parent = new Parent({\r\n  name: 'Mufasa',\r\n  children: [{\r\n    name: 'Simba',\r\n    friends: ['Pumbaa', 'Timon', 'Nala']\r\n  }]\r\n});\r\n\r\nparent.save({new: true}).then(function(savedParent) {\r\n  if (savedParent) {\r\n    console.log(savedParent);\r\n    savedParent.children[0].friends.push('Rafiki');\r\n    return savedParent.save({new: true});\r\n  } else {\r\n    throw new Error('Parent was not saved');\r\n  }\r\n}).then(function(updatedParent) {\r\n  console.log(updatedParent);\r\n}).catch(function(err) {\r\n  console.error(err);\r\n});\r\n```\r\n\r\noutputs:\r\n\r\n```javascript\r\n// initial save\r\nParent pre validate\r\nChild pre validate\r\nChild pre save\r\nParent pre save\r\n{\r\n  _id: 5a1f71acc21e58e2cdc53a26,\r\n  children: [{ friends: [ 'Pumbaa', 'Timon', 'Nala' ], name: 'Simba', _id: 5a1f71acc21e58e2cdc53a27 }],\r\n  name: 'Mufasa',\r\n  __v: 0\r\n}\r\n\r\n// subsequent save\r\nParent pre validate\r\nChild pre save\r\nParent pre save\r\n{\r\n  _id: 5a1f71acc21e58e2cdc53a26,\r\n  children: [{ friends: [ 'Pumbaa', 'Timon', 'Nala', 'Rafiki' ], name: 'Simba', _id: 5a1f71acc21e58e2cdc53a27 }],\r\n  name: 'Mufasa',\r\n  __v: 1\r\n}\r\n```"},{"labels":["bug"],"text":"I am attempting to use `.select` in a query with a discriminator model. The example below uses the projection to pull a `textScore` (meant for use with a `$text` query) but the bug is not specifically related to this use case.\r\n\r\nWhen making a `find` call, the returned objects do NOT have `trackField` or `eventField` and they are selected out automatically without me specifying it.\r\n\r\nSee Repro Script:\r\n```\r\nconst mongoose = require('./');\r\nmongoose.set('debug', true);\r\n\r\nconst Schema = mongoose.Schema;\r\n\r\nmongoose.connect('mongodb://127.0.0.1/test');\r\nconst db = mongoose.connection;\r\n\r\ndb.once('open', async () => {\r\n  try {\r\n    const eventSchema = new Schema({\r\n      eventField: String\r\n    }, { id: false });\r\n\r\n    const Event = mongoose.model('Event', eventSchema);\r\n\r\n    const trackSchema = new Schema({\r\n      trackField: String,\r\n    });\r\n\r\n    const Track = Event.discriminator('Track', trackSchema);\r\n\r\n    const trackedItem = new Track({\r\n      trackField: 'trackField',\r\n      eventField: 'eventField',\r\n    });\r\n    await trackedItem.save();\r\n\r\n    const events = await Event.find({}).select({ score: { $meta: 'textScore' } }).exec();\r\n    const tracks = await Track.find({}).select({ score: { $meta: 'textScore' } }).exec();\r\n    console.log(events); // no trackField or eventField\r\n    console.log(tracks); // no trackField or eventField\r\n\r\n    db.close();\r\n  } catch (e) {\r\n    console.log(e);\r\n  }\r\n});\r\n\r\n```\r\n\r\nWhen you attach the debugger, it shows this query:\r\n`events.find({}, { fields: { score: { '$meta': 'textScore' }, __t: 1 } })`\r\n\r\nI imagine that the `__t: 1` is causing this.\r\n\r\nIf I run `await Event.find({}).exec()`, the mongoose debugger shows \r\n`events.find({}, { fields: {} })` which is why normally everything is selected.\r\n\r\nThe problem that this causes is that you can't run a $text query sorting by textScore on anything that has a discriminator without specifically projecting every single field in the schema.\r\n\r\nIs there any way to override the `__t: 1`? I tried setting `{__t: null}` but that didn't work. Or is there a mongodb projection operator that I'm not aware that might solve this problem?"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nOnly the \"parent\" or \"batch\" schema of an discriminator type array gets updated.\r\n\r\nI have the following schema to store different types of objects in an array. A \"site\" Model can have different sections like \"header\" or \"text\". \r\n\r\n```\r\nconst mongoose = require('mongoose');\r\nconst Schema = mongoose.Schema;\r\nconst logoSchema = require('./site-sections/logo');\r\nconst shortid = require('shortid');\r\n\r\nvar sectionSchema = new Schema(\r\n  {\r\n    show: Boolean,\r\n    order: Number\r\n  },\r\n  { discriminatorKey: 'type', _id: false }\r\n);\r\n\r\nvar siteSchema = new Schema({\r\n  _id: {\r\n    type: String,\r\n    default: shortid.generate\r\n  },\r\n  _user: { type: Schema.Types.ObjectId, ref: 'User' },\r\n  type: { type: String, required: true },\r\n  title: { type: String, default: '' },\r\n  name: { type: String, required: true },\r\n  password: { type: String, default: '' },\r\n  caching: { type: Number, default: 1 },\r\n  sections: [sectionSchema]\r\n});\r\n\r\nvar sectionArray = siteSchema.path('sections');\r\n\r\nvar headerSchema = new Schema(\r\n  {\r\n    image: String,\r\n    title: String,\r\n    sub_title: String,\r\n    show: Boolean\r\n  },\r\n  { _id: false }\r\n);\r\n\r\nsectionArray.discriminator('header', headerSchema);\r\n\r\nvar textSchema = new Schema(\r\n  {\r\n    text: String\r\n  },\r\n  { _id: false }\r\n);\r\n\r\nsectionArray.discriminator('text', textSchema);\r\n\r\nmodule.exports = mongoose.model('site', siteSchema);\r\n```\r\n\r\n**What is the expected behavior?**\r\nWhen I try to update values from the \"headerSchema\" or \"textSchema\" nothings happens and the output says: `{ ok: 0, n: 0, nModified: 0 }` It should set the title value from the sections array with type: 'header' to 'Test'.\r\n\r\nMy update look like this:\r\n```\r\nconst Site = require('../models/site');\r\n  Site.update(\r\n    {\r\n      _id: site_id,\r\n      _user: user.id,\r\n      'sections.type': 'header'\r\n    },\r\n    {\r\n      $set: {\r\n        'sections.$.title': 'Test'\r\n      }\r\n    },\r\n    function(err, status) {\r\n      if (err) {\r\n        console.log('Error:', err);\r\n      }\r\n      console.log(status);\r\n    }\r\n  );\r\n```\r\n\r\nThe strange thing is... If I'am updating values from the \"sectionSchema\" like in the following statement, everything is working fine...\r\n\r\n```\r\n const Site = require('../models/site');\r\n  Site.update(\r\n    {\r\n      _id: site_id,\r\n      _user: user.id,\r\n      'sections.type': 'header'\r\n    },\r\n    {\r\n      $set: {\r\n        'sections.$.show': false\r\n      }\r\n    },\r\n    function(err, status) {\r\n      if (err) {\r\n        console.log('Error:', err);\r\n      }\r\n      console.log(status);\r\n    }\r\n  );\r\n```\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\n\"mongoose\": \"^4.13.4\", \"node\": \"8.4.0\", mongod version: 3.4.9 (heroku addon)\r\n\r\nThanks in advance for any help. Best regards Markus\r\n"},{"labels":["bug"],"text":"If I am not mistaken, `findOneAndUpdate()` with `{upsert: 1}` will perform an upsert, but `updateOne()` with `{upsert: 1}` will not!\r\n\r\nIf I use `{upsert: true}` then both work as expected.\r\n\r\nThis inconsistent behaviour is somewhat confusing for developers.\r\n\r\nI guess the most developer-friendly solution is to make `{upsert: 1}` work for `updateOne()` (and any other places that `{upsert: true}` can work).\r\n\r\nBut an alternative solution could be to throw an error if `{upsert: 1}` is used for `updateOne()`, rather than just silently do the unexpected thing.\r\n\r\n(Using mongoose 4.11.7 and node v8.1.2 today)"},{"labels":["bug"],"text":"```node\r\n/**\r\n * BUG REPORT: `toObject()` transform causes lost data during save.\r\n */\r\n\r\nconst mongoose = require('mongoose');\r\n\r\n\r\n/** Embedded Schema */\r\nconst MyEmbeddedSchema = mongoose.Schema(\r\n  {\r\n    someMoreData: String,\r\n  },\r\n);\r\n\r\n\r\n/**\r\n * This plugin filters out the `someMoreData` property\r\n * when calling `toObject()` or `toJSON()` on MyEmbeddedSchema.\r\n */\r\nMyEmbeddedSchema.plugin(schema => {\r\n  const filterSomeMoreData = (doc, returnDoc) => {\r\n    delete returnDoc.someMoreData;\r\n    return returnDoc;\r\n  };\r\n  // The use case for this is hiding sensitive data from the client\r\n  schema.options.toJSON = { transform: filterSomeMoreData };\r\n  schema.options.toObject = { transform: filterSomeMoreData };\r\n});\r\n\r\n\r\n/** Base Schema */\r\nconst MySchema = mongoose.Schema(\r\n  {\r\n    embedded: MyEmbeddedSchema,\r\n  }\r\n);\r\n\r\nconst Model = mongoose.model('MODEL', MySchema);\r\n\r\n\r\n/** Application Logic */\r\n(async () => {\r\n  await new Promise(resolve => {\r\n    mongoose.Promise = global.Promise;\r\n    mongoose.connect('mongodb://127.0.0.1/mytestdb', { useMongoClient: true });\r\n    mongoose.connection.once('open', () => {\r\n      resolve(mongoose.connection);\r\n    });\r\n  });\r\n\r\n  const model = new Model();\r\n\r\n  // Commenting this out results in `someMoreData` saving as expected\r\n  await model.save();\r\n\r\n  model.embedded = {\r\n    someMoreData: 'something',\r\n  };\r\n\r\n  await model.save();\r\n\r\n  const fetched = await Model.findById(model._id).exec();\r\n\r\n  process.stdout.write(`Should log 'something': ${fetched.embedded.someMoreData}`);\r\n\r\n  await mongoose.connection.close();\r\n})();\r\n```\r\n\r\nThe output of this script is:\r\n```bash\r\n$ node BUG.js\r\nShould log `something`: undefined\r\n```"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nParent field gets overwritten by .set of nested field in pre-save hook when document is incomplete due to .select\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nhttps://gist.github.com/zoellner/f022ac62a7ed968a85784edf1a6690c8\r\n\r\n**What is the expected behavior?**\r\nNested field gets updated without overwriting the parent field.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nnode.js 6.11.1\r\nmongoose 4.13.0\r\nmongoDB 3.4.7\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n***bug***\r\n\r\n**What is the current behavior?**\r\n\r\nI set like this.\r\n```\r\npermissions: {\r\n        type: [[Number]],\r\n        default: [[0, 1]]\r\n    },\r\n```\r\nBut the result default is this:\r\n```\r\npermissions: [ [ 0 ], [ 1 ] ],\r\n```\r\nI want this:\r\n```\r\npermissions: [ [ 0, 1 ] ],\r\n```\r\nnode.js mongoose  and MongoDB  is the latest version.\r\n"},{"labels":["bug"],"text":"Using discriminators on subdocument schema causes fields to be deselected in query.\r\n\r\n```javascript\r\nvar itemSchema = new Schema({ \r\n  type: String, \r\n  active: { type: Boolean, default: true }\r\n}, {\r\n  discriminatorKey: 'type'\r\n});\r\n\r\nvar collectionSchema = new Schema({ \r\n  items: [itemSchema] \r\n});\r\n\r\ncollectionSchema.path('items').discriminator('type1', new Schema({ count: Number }));\r\n\r\nvar collection = mongoose.model('Collection', collectionSchema);\r\ncollection.create({ \r\n  items: [ \r\n    { type: 'type1', active: false, count: 3 }\r\n  ]\r\n});\r\n```\r\n\r\nIf I execute the query\r\n```javascript\r\ncollection.find().select('items');\r\n```\r\nI'd expect the result to be `{ :items [{ type: 'type1', active: false, count: 3 }]}`.\r\nInstead, it returns `{:items [{ type: 'type1' }]}`.\r\n\r\nWhen I don't specify any fields for the query it behaves as expected.\r\n\r\n___\r\n\r\nmongoDB version: 3.4.1\r\nnode version: 8.5.0\r\nmongoose version: 4.12.5"},{"labels":["bug"],"text":"**Mongo: 3.4.9 Node: 8.1.2 Mongoose: 4.12.4**\r\n\r\nIn general when you run a query using a date, such as a count, you can write something like\r\n`return Foo.count({ imADate: { '$gte': new Date() } })`\r\nor using Moment JS:\r\n`return Foo.count({ imADate: {  '$gte': moment().toISOString() } })`\r\n\r\nand a few other variations.\r\n\r\nDebug output shows something to the effect of:\r\n`Mongoose: foos.count({ imADate: { '$gte': new Date(\"Sat, 28 Oct 2017 03:49:28 GMT\") } }, {})`\r\n\r\nAll is well and good.\r\n\r\nHowever in the query field on a geoNear query:\r\n```\r\nreturn Foo.geoNear({\r\n              type: 'Point',\r\n              coordinates: [lng, lat],\r\n            }, {\r\n              spherical: true,\r\n              maxDistance: 100000,\r\n              num: 10,\r\n              query: { imADate: { '$gte' : moment().toISOString() } }\r\n            })\r\n```\r\n\r\nNo such casting seems to occur. The result outputs:\r\n```\r\nMongoose: foos.geoNear({\r\n type: 'Point', coordinates: [ -118.24368, 34.05223 ] }, { spherical: true, maxDistance: 100000, num: 10, query: { imADate: { '$gte': '2017-10-28T03:53:23.395Z' } } })\r\n```\r\n\r\nThe date is not wrapped in a `new Date(` and therefore doesn't work. Is there improper use on my part or is this a bug?\r\n\r\n"},{"labels":["bug",null],"text":"The issue appeared when I updated mongoose 4.9 to 4.10.\r\n\r\nWe had a connection string like \"mongodb://my.mongo.com/db\".\r\nOur mongodb has only ipv6, no ipv4.\r\n\r\nAfter updating to 4.10+ mongoose starts to show \"MongoError: getaddrinfo ENOTFOUND my.mongo.com\". So the old code stops working.\r\n\r\nI guess, we should supply `family=6` somewhere?\r\n\r\nPosting this, because it looks strange that updating to a minor version broke the existing connection code.\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nbug/feature\r\n\r\n**What is the current behavior?**\r\n`schema.clone()` does not currently clone the `schema.queries` property.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\nBasically I have a plugin that adds some ACL to a query. For example:\r\n``` javascript\r\nschema.query.asUser = function (user) {\r\n  return this.find({\r\n    // my query\r\n  })\r\n}\r\n```\r\nThen, I have another plugin that ends up cloning this schema. \r\n\r\n**What is the expected behavior?**\r\nThe problem is that the `schema.clone()` method does not clone the chained queries so the `asUser` method does not exist on the cloned schema.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\n```\r\nnode.js: 8.7.0\r\nmongoose: 4.11.10\r\nMongoDB: 3.4.9\r\n```\r\n\r\n"},{"labels":["bug"],"text":"Bug, mongoose 4.12.4, Node 8.7.0, MongoDB 3.4.9\r\n\r\n**Current Behavior**\r\nUpdate validator for ObjectId fields is not parsing `$pull` updates that include objects (example below).\r\n\r\n**Steps to reproduce**\r\n- Create a schema that includes a subdocument array\r\n- Insert a document into that collection\r\n- Attempt a `$pull` update with an `$in` operator (e.g. `{ $pull: { field: { _id: { $in: [] } } } }`)\r\n- Validator rejects saying the JSON object `{ $in: [] }` is not a valid ObjectId\r\n\r\nIllustrated in code:\r\n```javascript\r\nconst mongoose = require('mongoose');\r\nconst exampleSchema = mongoose.Schema({\r\n    subdocuments: [{\r\n        name: String\r\n    }]\r\n});\r\nconst ExampleModel = mongoose.model('Example', exampleSchema);\r\nconst exampleDocument = {\r\n    subdocuments: [{\r\n        // _id field created implicitly by mongoose\r\n        name: 'First'\r\n    }, {\r\n        name: 'Second'\r\n    }]\r\n};\r\nExampleModel.create(exampleDocument)\r\n    .then(savedDocument => {\r\n        ExampleModel.update({\r\n            _id: savedDocument._id\r\n        }, {\r\n            $pull: {\r\n                subdocuments: {\r\n                    _id: {\r\n                        $in: [] // could be an empty or could contain valid ObjectIds, error occurs either way\r\n                    }\r\n                }\r\n            }\r\n        }, {\r\n            runValidators: true\r\n        })\r\n        .catch(error => {\r\n            // CastError: Cast to ObjectID failed for value \"{ '$in': [] }\" at path \"_id\"\r\n        });\r\n    });\r\n```\r\n\r\n**What is the expected behavior?**\r\n- Validator should check that the values inside the `$in` array are ObjectIds, not the whole object mapped to `_id`.\r\n\r\n**Stacktrace example:**\r\n```\r\nCastError: Cast to ObjectID failed for value \"{ '$in': [ 59dff36f566439001cd9bae3 ] }\" at path \"_id\"\r\n    at new CastError (/Users/richard/Sites/tenthousandcoffees/api-server/node_modules/mongoose/lib/error/cast.js:27:11)\r\n    at EmbeddedDocument.Document.set (/Users/richard/Sites/tenthousandcoffees/api-server/node_modules/mongoose/lib/document.js:773:7)\r\n    at EmbeddedDocument._handleIndex (/Users/richard/Sites/tenthousandcoffees/api-server/node_modules/mongoose/lib/document.js:602:14)\r\n    at EmbeddedDocument.Document.set (/Users/richard/Sites/tenthousandcoffees/api-server/node_modules/mongoose/lib/document.js:562:24)\r\n    at EmbeddedDocument.Document (/Users/richard/Sites/tenthousandcoffees/api-server/node_modules/mongoose/lib/document.js:77:12)\r\n    at EmbeddedDocument [as constructor] (/Users/richard/Sites/tenthousandcoffees/api-server/node_modules/mongoose/lib/types/embedded.js:31:12)\r\n    at new EmbeddedDocument (/Users/richard/Sites/tenthousandcoffees/api-server/node_modules/mongoose/lib/schema/documentarray.js:70:17)\r\n    at /Users/richard/Sites/tenthousandcoffees/api-server/node_modules/mongoose/lib/schema/documentarray.js:173:26\r\n    at DocumentArray.SchemaType.doValidate (/Users/richard/Sites/tenthousandcoffees/api-server/node_modules/mongoose/lib/schematype.js:766:12)\r\n    at DocumentArray.doValidate (/Users/richard/Sites/tenthousandcoffees/api-server/node_modules/mongoose/lib/schema/documentarray.js:133:35)\r\n    at /Users/richard/Sites/tenthousandcoffees/api-server/node_modules/mongoose/lib/services/updateValidators.js:113:22\r\n    at /Users/richard/Sites/tenthousandcoffees/api-server/node_modules/mongoose/node_modules/async/internal/parallel.js:27:9\r\n    at eachOfArrayLike (/Users/richard/Sites/tenthousandcoffees/api-server/node_modules/mongoose/node_modules/async/eachOf.js:57:9)\r\n    at exports.default (/Users/richard/Sites/tenthousandcoffees/api-server/node_modules/mongoose/node_modules/async/eachOf.js:9:5)\r\n    at _parallel (/Users/richard/Sites/tenthousandcoffees/api-server/node_modules/mongoose/node_modules/async/internal/parallel.js:26:5)\r\n    at parallelLimit (/Users/richard/Sites/tenthousandcoffees/api-server/node_modules/mongoose/node_modules/async/parallel.js:85:26)\r\n```"},{"labels":["bug"],"text":"Hi,\r\n\r\nsince updating from 4.10 to 4.12 I am struggling with a \"RangeError: Maximum call stack size exceeded\".\r\n\r\nFinally, I managed to reproduce this issue:\r\n\r\n```javascript\r\nvar mongoose = require(\"mongoose\");\r\n\r\nmongoose.Promise = Promise;\r\nError.stackTraceLimit = Infinity;\r\n\r\nvar conA = mongoose.createConnection('mongodb://127.0.0.1/testA');\r\n\r\nvar schema = new mongoose.Schema({\r\n  name: String\r\n});\r\n\r\nvar schemaExt = new mongoose.Schema({\r\n  nameExt: String\r\n});\r\n\r\nvar modelA = conA.model(\"A\", schema);\r\nvar modelAExt = modelA.discriminator(\"AExt\", schemaExt);\r\n\r\nmodelA.findOneAndUpdate({name: \"ABC\"}, { $set: {name: \"ABC\"}}).exec().then(x => {\r\n  var conB = mongoose.createConnection('mongodb://127.0.0.1/testB');\r\n\r\n  var modelB = conB.model(\"A\", schema.clone());\r\n  var modelBExt = modelB.discriminator(\"AExt\", schemaExt.clone());\r\n}).catch(err => {\r\n  console.log(err);\r\n});\r\n```\r\n\r\nOutput is:\r\n\r\n    RangeError: Maximum call stack size exceeded\r\n    at merge (/root/test/node_modules/mongoose/lib/utils.js:411:31)\r\n    at merge (/root/test/node_modules/mongoose/lib/utils.js:424:9)\r\n    at merge (/root/test/node_modules/mongoose/lib/utils.js:424:9)\r\n    at merge (/root/test/node_modules/mongoose/lib/utils.js:424:9)\r\n    at merge (/root/test/node_modules/mongoose/lib/utils.js:424:9)\r\n    at merge (/root/test/node_modules/mongoose/lib/utils.js:424:9)\r\n    at merge (/root/test/node_modules/mongoose/lib/utils.js:424:9)\r\n    at merge (/root/test/node_modules/mongoose/lib/utils.js:424:9)\r\n    ...\r\n    at merge (/root/test/node_modules/mongoose/lib/utils.js:424:9)\r\n    at Object.merge (/root/test/node_modules/mongoose/lib/utils.js:424:9)\r\n    at merge (/root/test/node_modules/mongoose/lib/services/model/discriminator.js:65:11)\r\n    at discriminator (/root/test/node_modules/mongoose/lib/services/model/discriminator.js:123:3)\r\n    at Function.Model.discriminator (/root/test/node_modules/mongoose/lib/model.js:836:12)\r\n    at modelA.findOneAndUpdate.exec.then.x (/root/test/con.js:23:26)\r\n    at process._tickCallback (internal/process/next_tick.js:103:7)\r\n\r\nBackground: We are working on a multi tenant application, each tenant having its own db. The connection is opened on login. When creating all connections at startup there is no error.\r\n\r\nI work around this issue now by creating all the schemas per tenant, but its still strange that a findAndUpdate on one connection influences modelling on another connection.\r\n\r\nWhat I can tell, the error starts with mongoose@4.11.10\r\n\r\nThank you!\r\n\r\n"},{"labels":["bug"],"text":"Mongoose: 4.12.2\r\nOS: Win\r\nNode 7.9.0\r\nMongoDB: 3.2\r\n\r\n``NativeConnection`` object from ``onConnected`` event, that was created with and without ``useMongoClient`` option has a slightly different structure. In particular with ``useMongoClient = true`` it has a ``.then()`` method and other promise-related fields, whereas otherwise it doesn't.\r\n\r\nIt becomes problematic in my case, since I pass it through a Q's promise. Q tries to \"intelligently\" (which means dumb as a brick, but anyway) resolve the whole promise chain, if it detects one and it does so by testing the resolved value and every chain-descendant value against ``isPromiseLike`` util, which in turn returns true if the said value has the ``.then()`` method.\r\n\r\nNow, you can probably see the problem here already. If I depend my app flow on the first promise's triggering - the app would stall if the promise is resolved with such a ``NativeConnection`` object:\r\n\r\n```js\r\nvar Q = require('q'),\r\n        bootMongo = Q.defer(),\r\n    mongoose = require('mongoose'),\r\n        connOpts = {},\r\n    GITHUB_ISSUE = `gh-5714`\r\n;\r\nmongoose.Promise = require('q').Promise;\r\nconnOpts.useMongoClient = true; // toggle for different output\r\nmongoose.connect(`mongodb://localhost:27017/${GITHUB_ISSUE}`, connOpts)\r\nmongoose.connection\r\n.on('error', function(er) {\r\n    bootMongo.reject(new Error(`failed to connect to DB! ${er}`));\r\n})\r\n.on('connected', function() {\r\n    console.log( 'mongooseConnection connected' );\r\n    // for useMongoClient = true ``this`` is a NativeConnection object with .then() method\r\n    // without useMongoClient ``this`` is a NativeConnection object without .then() method\r\n    bootMongo.resolve(this);\r\n})\r\n;\r\nbootMongo.promise\r\n.then(function (conn) {\r\n    // will trigger without useMongoClient = true;\r\n})\r\n.catch(function (err) {\r\n    // will trigger with useMongoClient = true; \"promise.then is not a function\"\r\n});\r\n```\r\n\r\nTechnically it is Q who is causing the problem, but Q was doing this in such manner all along and it is also the expected behavior for it. Mongoose however is the one who introduced such game-breaking change.\r\n\r\nI can easily fix my problem by wrapping ``this`` from the event callback with another object and pass it into the promise. But I think you still have a problem of inconsistency...\r\n\r\nThank you."},{"labels":["bug"],"text":"file: ReportModel.js\r\n```js\r\nconst newSchema  = new Schema({\r\ncounter: {type: Number, default: 0},\r\nname: {type: String, default: 'nothing' },\r\ncountry: String\r\n}, {versionKey: false});\r\n\r\nmodule.exports = connection.model('reports', newSchema);\r\n```\r\n-------\r\nfile: another-job.js\r\n```js\r\n  await ReportModel.updateOne(recordConditions, {\r\n        $inc: {\r\n          'counter': 1\r\n        },\r\n      }, { upsert: true, setDefaultsOnInsert: true });\r\n\r\n```\r\n- **result:** upsert and setDefaultsOnInsert works here.\r\n-------\r\n\r\nfile: job.js\r\n```js\r\nconst reportOperations = [];\r\n\r\nconst filter = {\r\n country: 'US',\r\n};\r\n\r\nreportOperations.push({\r\n     updateOne: {\r\n       filter,\r\n       update: {\r\n         $inc: {\r\n           'counter': 1,\r\n         },\r\n       },\r\n       upsert: true,\r\n      setDefaultsOnInsert: true,\r\n     },\r\n});\r\n\r\nawait ReportModel.bulkWrite(reportsOperations);\r\n```\r\nthe **upsert** works here, but what seems to not work is the **setDefaultsOnInsert**.\r\n\r\nthe **upserted record** has no **report.name** property.\r\n\r\nWhats needs to be done here?\r\n\r\nsources: \r\n- http://mongoosejs.com/docs/api.html#model_Model.bulkWrite\r\n- http://mongoosejs.com/docs/defaults.html"},{"labels":["bug"],"text":"Hi,\r\n\r\nThe following script causes an error: \"RangeError: Maximum call stack size exceeded\".\r\nNOTE that if I remove the pre findOneAndUpdate hook it works OK.\r\n\r\n```js\r\nvar mongoose = require('mongoose'),\r\n    uuid = require('uuid'),\r\n    uuidParse = require('uuid-parse');\r\n\r\nmongoose.Promise = Promise;\r\n\r\nfunction toUUID(string) {\r\n\tif (!string) {return null;}\r\n\tif (Buffer.isBuffer(string) || Buffer.isBuffer(string.buffer)) { return string; }\r\n\tvar buffer = uuidParse.parse(string);\r\n\treturn new mongoose.Types.Buffer(buffer).toObject(0x04);\r\n}\r\n\r\nfunction fromUUID(buffer) {\r\n    if (!buffer || buffer.length !== 16) { return null; }\r\n    return uuidParse.unparse(buffer);\r\n}\r\n\r\nvar UserSchema = new mongoose.Schema({\r\n\tname: String,\r\n\tlastUpdate: {type: Date},\r\n\tfriends: [{\r\n\t\t_id: false,\r\n\t\tstatus: {type: String, required: true},\r\n\t\tid: {\r\n\t\t\ttype: mongoose.Schema.Types.Buffer,\r\n\t\t\tget: fromUUID,\r\n\t\t\tset: toUUID,\r\n\t\t\tref: 'User'\r\n\t\t}\r\n\t}]\r\n}, { collection: 'users', runSettersOnQuery: true });\r\n\r\nUserSchema.pre('findOneAndUpdate', function() {\r\n\tthis.update({},{ $set: {lastUpdate: new Date()} });\r\n});\r\n\r\nvar UserModel = mongoose.model('User', UserSchema);\r\n\r\nvar connStr = 'mongodb://test:test@127.0.0.1/test';\r\nmongoose.connect(connStr);\r\n\r\nvar friendId = uuid.v4();\r\nvar user = { name: 'Sean', friends: [{status: 'New', id: friendId}] };\r\nconsole.log('Inserting first user', user);\r\nvar dalUser = new UserModel(user);\r\ndalUser.save().then(() => {\r\n\tconsole.log('User inserted successfully, updating frind status');\r\n\tvar q = {_id: dalUser._id.toString(), 'friends.id': friendId};\r\n\tvar upd = {'friends.$.status': 'Active'};\r\n\tUserModel.findOneAndUpdate(q, upd, {new: true}).lean().exec().then(res => {\r\n\t\tconsole.log('success:', res);\r\n\t}).catch(err => {\r\n\t\tconsole.log('ERR:', err)\r\n\t});\r\n\r\n}).catch(console.error.bind(console));\r\n```\r\nOutput:\r\n```\r\nInserting first user { name: 'Sean',\r\n  friends: [ { status: 'New', id: '1a4d4f8c-a73f-43ff-af91-74988ba2e178' } ] }\r\nUser inserted successfully, updating frind status\r\nERR: RangeError: Maximum call stack size exceeded\r\n    at merge (C:\\temp\\mongoosebug\\node_modules\\mongoose\\lib\\utils.js:432:13)\r\n    at merge (C:\\temp\\mongoosebug\\node_modules\\mongoose\\lib\\utils.js:435:9)\r\n    at merge (C:\\temp\\mongoosebug\\node_modules\\mongoose\\lib\\utils.js:435:9)\r\n    at merge (C:\\temp\\mongoosebug\\node_modules\\mongoose\\lib\\utils.js:435:9)\r\n    ...\r\n```\r\n\r\nMongoose: 4.12.1\r\nThx."},{"labels":["bug"],"text":"I would like to report what I believe to be a bug in mongoose `4.12.0`. It is related to the newly-added discriminator support for single nested documents that was added via https://github.com/Automattic/mongoose/commit/a072f8381941a0a8f040e7d94a1e44b5cea31aed (which by the way, thanks for adding!).\r\n\r\nIt seems using `.set` on a parent mongoose document to modify a subdocument causes an error to be thrown. I have written a test case to exemplify the issue:\r\n\r\n```js\r\nit('Single nested subdocs using discriminator can be modified', async () => {\r\n   const eventSchema = new Schema(\r\n      { message: String },\r\n      { discriminatorKey: 'kind', _id: false }\r\n   )\r\n\r\n   const trackSchema = new Schema({\r\n      event: eventSchema\r\n   })\r\n\r\n   trackSchema.path('event').discriminator('Clicked',\r\n      new Schema({\r\n         element: String\r\n      }, { _id: false })\r\n   )\r\n\r\n   trackSchema.path('event').discriminator('Purchased',\r\n      new Schema({\r\n         product: String\r\n      }, { _id: false })\r\n   )\r\n\r\n   const MyModel = mongoose.model('track', trackSchema)\r\n\r\n   const doc = new MyModel({\r\n      event: {\r\n         message: 'Test',\r\n         kind: 'Clicked',\r\n         element: 'Amazon Link'\r\n      }\r\n   })\r\n\r\n   await doc.save()\r\n   assert.equal(doc.event.message, 'Test')\r\n   assert.equal(doc.event.kind, 'Clicked')\r\n   assert.equal(doc.event.element, 'Amazon Link')\r\n   assert.ok(!doc.event.product)\r\n\r\n   // ** THIS IS WHERE THE ISSUE IS **\r\n\r\n   doc.set('event', {\r\n      kind: 'Purchased',\r\n      product: 'Professional AngularJS'\r\n   })\r\n\r\n   await doc.save()\r\n\r\n   assert.equal(doc.event.kind, 'Purchased')\r\n   assert.equal(doc.event.product, 'Professional AngularJS')\r\n   assert.ok(!doc.event.element)\r\n   assert.ok(!doc.event.message)\r\n})\r\n```\r\n\r\nHere is the error stack trace that is logged when the `set` operation is attempted:\r\n\r\n```\r\ntrack validation failed: event: Cast to Embedded failed for value \"{ kind: 'Purchased', product: 'Professional AngularJS' }\" at path \"event\"\r\n  ValidationError: \r\n      at ValidationError (node_modules/mongoose/lib/error/validation.js:28:11)\r\n      at model.Document.invalidate (node_modules/mongoose/lib/document.js:1632:32)\r\n      at model.Document.set (node_modules/mongoose/lib/document.js:768:10)\r\n      at _callee$ (tests/unit/mongoosebug.js:46:11)\r\n```\r\n\r\nThis brings up another question relating to what should happen if you had individual `set` operations rather than setting the subdocument all in one go, as was done in the test case above. For example, what would be the expected result of the following operation:\r\n\r\n```js\r\ndoc.set('event.kind', 'Purchased')\r\ndoc.set('event.product', 'Professional AngularJS')\r\n``` \r\n\r\nOr here's an example that reverses the order of the `set`s which might make it harder to anticipate what should happen:\r\n\r\n```js\r\ndoc.set('event.product', 'Professional AngularJS')\r\ndoc.set('event.kind', 'Purchased')\r\n``` \r\n\r\nI hope that's clear. Thanks again."},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nA custom method applied via a global plugin does not get applied to child schema's.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```js\r\nconst mongoose = require('mongoose');\r\nconst {Schema, Types: {ObjectId}} = mongoose;\r\n\r\nfunction setStock(schema) {\r\n  schema.methods.setStock = function(stock) {\r\n    this.stock = stock;\r\n  };\r\n};\r\n\r\nmongoose.plugin(setStock);\r\n\r\nconst SizeSchema = new Schema({\r\n  size: {\r\n    type: String,\r\n    enum: ['S', 'M', 'L'],\r\n  },\r\n  stock: {\r\n    type: Number,\r\n    default: 0,\r\n  },\r\n});\r\n\r\nconst ProductSchema = new Schema({\r\n  name: {\r\n    type: String,\r\n    trim: true,\r\n    required: true,\r\n  },\r\n  stock: Number,\r\n  sizes: [SizeSchema],\r\n});\r\n\r\nconst Product = mongoose.model('Product', ProductSchema);\r\n\r\nconst _id = new ObjectId();\r\nconst product = new Product({\r\n  name: 'Test',\r\n  stock: 1,\r\n  sizes: [\r\n    {\r\n      _id,\r\n      size: 'S',\r\n      stock: 2,\r\n    },\r\n    {\r\n      size: 'M',\r\n      stock: 3,\r\n    },\r\n  ],\r\n});\r\n\r\nconst size = product.sizes.id(_id);\r\nproduct.setStock(6);\r\nsize.setStock(5);\r\n\r\nconsole.log(product.toJSON());\r\nconsole.log(size.toJSON());\r\n```\r\n\r\nThrows a TypeError:\r\n\r\n```\r\nTypeError: size.setStock is not a function\r\n```\r\n\r\nWorks fine on the parent schema/model.\r\n\r\n**What is the expected behavior?**\r\nFor the method to be present on the child schema.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNode 8.5.0, mongoose ^4.11.9, MongoDB irrelevant\r\n\r\nRef: #4271 "},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nbug\r\n\r\n**What is the current behavior?**\r\n\r\nIf you specify field selection and population it will throw \"Projection cannot have a mix of inclusion and exclusion.\" error. In older versions (before 4.11.14) it's executed properly.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\n```javascript\r\nconst Promise = require('bluebird');\r\nconst mongoose = require('mongoose');\r\n\r\nmongoose.Promise = Promise;\r\n\r\nconst connection = mongoose.createConnection('mongodb://localhost:27017/mongoose-population');\r\nconnection.on('error', () => {\r\n    throw new Error('Unable to connect')\r\n});\r\nconnection.on('open', () => {\r\n    const schemaA = new mongoose.Schema({\r\n        name: String\r\n    });\r\n    const modelA = connection.model('A', schemaA);\r\n\r\n    const schemaB = new mongoose.Schema({\r\n        some: String,\r\n        ref: {\r\n            type: mongoose.Schema.Types.ObjectId,\r\n            ref: 'A'\r\n        }\r\n    });\r\n    const modelB = connection.model('B', schemaB);\r\n\r\n    Promise.resolve(modelA.create({name: 'test'}))\r\n        .then((a) => modelB.create({ref: a}))\r\n        .then(() => {\r\n            return modelB.find({}, {some: false, __v: false}).populate('ref').exec();\r\n        })\r\n        .then((result) => {\r\n            console.log('OK', result);\r\n            process.exit(0)\r\n        })\r\n        .catch((err) => {\r\n            console.error(err.message);\r\n            process.exit(1);\r\n        })\r\n\r\n});\r\n```\r\n**What is the expected behavior?**\r\n\r\nIt should run as before (because of minor version has been changed only).\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\n\r\n* node - v6.11.3\r\n* mongoose - v4.11.14\r\n* mongodb - v3.4.9"},{"labels":["bug"],"text":"This is a **bug report**.  I am using Mongoose version **4.11.14**.\r\n\r\nWhen using the same (sub)schema in multiple discriminated embedded arrays, I receive the following error:\r\n```\r\nError: Discriminator \"Child\" cannot have field with name \"__t\"\r\n    at discriminator (/home/c1moore/omninox/omnistack/node_modules/mongoose/lib/services/model/discriminator.js:33:11)\r\n    at DocumentArray.discriminator (/home/c1moore/omninox/omnistack/node_modules/mongoose/lib/schema/documentarray.js:107:12)\r\n    at Object.<anonymous> (/home/c1moore/omninox/omnistack/MultipleDiscriminatorTest.js:18:38)\r\n    at Module._compile (module.js:570:32)\r\n    at Object.Module._extensions..js (module.js:579:10)\r\n    at Module.load (module.js:487:32)\r\n    at tryModuleLoad (module.js:446:12)\r\n    at Function.Module._load (module.js:438:3)\r\n    at Module.runMain (module.js:604:10)\r\n    at run (bootstrap_node.js:394:7)\r\n    at startup (bootstrap_node.js:149:9)\r\n    at bootstrap_node.js:509:3\r\n```\r\nIt seems Mongoose adds the `__t` field to the schema the first time the schema is used and throws the error on subsequent uses.  The below code is what threw the error (line 18, the one that threw the error, is the last line).\r\n\r\n```javascript\r\n'use strict';\r\n\r\nconst Schema = require('mongoose').Schema;\r\n\r\nconst ParentSchema = new Schema({});\r\nconst ChildSchema = new Schema({});\r\n\r\nconst FirstContainerSchema = new Schema({\r\n  stuff:  [ParentSchema]\r\n});\r\n\r\nFirstContainerSchema.path('stuff').discriminator('Child', ChildSchema);\r\n\r\nconst SecondContainerSchema = new Schema({\r\n  things: [ParentSchema]\r\n});\r\n\r\nSecondContainerSchema.path('things').discriminator('Child', ChildSchema);\r\n```"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nfeature\r\n**What is the current behavior?**\r\n\r\nFor a common products <=> categories relationship, given the following model:\r\n\r\n```javascript\r\nconst ProductSchema = new mongoose.Schema({\r\n  name: {\r\n    type: String,\r\n  },\r\n  categories: {\r\n    type: [{\r\n      type: mongoose.Schema.Types.ObjectId,\r\n      ref: 'Category',\r\n    }],\r\n    select: false, // Notice that this is set to false\r\n  },\r\n});\r\n```\r\n\r\nI'm getting the following results:\r\n```javascript\r\nProduct.findById(id) // results in { name: 'Something' }\r\n\r\nProduct.findById(id)\r\n  .populate('categories')\r\n  // results in { name: 'Something' }\r\n\r\nProduct.findById(id)\r\n  .select('+categories')\r\n  .populate('categories')\r\n  // results in { name: 'Something', categories: [{ name: 'Category' }]}\r\n```\r\n\r\n**What is the expected behavior?**\r\n\r\n```javascript\r\nProduct.findById(id)\r\n  .populate('categories')\r\n  // results in { name: 'Something', categories: [{ name: 'Category' }]}\r\n```\r\n\r\nI think we could select the categories field too, the dev should be able to overwrite this selection if he calls: ``` select('-categories')```.\r\n\r\nI'm using it like this since I don't want to send an array containing only id's since in my specific usecase this isn't an useful information and sometimes I might have ids of categories that doesn't exist anymore (were deleted) so I'd like to send this info only if it's been populated.\r\n\r\nAnother solution would be to add more values to the ``` select ``` option this way we could call ``` select: 'populate' ``` inside the Schema and achieve this behavior.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\n\r\nNode 8.4.0\r\nMongoDB 3.4.7\r\nMongoose 4.10.8"},{"labels":["bug"],"text":"Hey!\r\nTrying to write good reusable wrapper for testing models with mongoose and stuck a bit with dropping database. When write operations are executed after calling `dropDatabase()` it triggers re-creation of database. So, when there are any queries which was launched without awaiting result (or returning promise, but example is `async/await`-based) and right after that I call `dropDatabase()` it end up with dropped database and creating new one with same name. Is there any way to fix that behaviour given that I can't enforce user to `await` for all his queries or returning promise?\r\n\r\nHere is brief example: \r\n```\r\nconst mongoose = require('mongoose');\r\n\r\nasync function withTempDb(dbName, action) {\r\n\tconst mongoUri\t= `mongodb://localhost:27017/${dbName}`;\r\n\tconst opts\t= {useMongoClient: true, promiseLibrary: global.Promise };\r\n\r\n\tconst conn = mongoose.createConnection(mongoUri, opts);\t\t\t\t\t\t\t\r\n\tconst onceOpen = new Promise( resolve => conn.once('open', resolve ));\t\t\t\r\n\tawait onceOpen;\t\t\t\t\t\t\r\n\r\n\tlet result;\r\n\r\n\ttry {\r\n\t\tresult = await action(conn);\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t} finally {\r\n\t\tawait conn.dropDatabase();\r\n\t\tawait conn.close();\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\nwithTempDb('dummy', () => console.log('Sync ok'));\r\n\r\nwithTempDb('correct', async db => {\r\n\tconst collection = db.collection('languages');\r\n\tawait collection.insert({name: 'JS'});\r\n\tconsole.log('correct async okay');\r\n});\r\n\r\n// do not forget to drop 'tempDB-incorrect' after \r\nwithTempDb('tempDB-incorrect', async db => {\r\n\tconst collection = db.collection('languages');\r\n\tcollection.insert({name: 'JS'});  // note, no await here, so not waiting for query result\r\n\tconsole.log('not waiting for insert result here...');\r\n});\r\n```\r\n\r\nI'm expecting that after calling `Connection.close()` no new queries are accepted and `close` event emitted after every query performed through given connection is finished. But seems like even when `close` emitted queries are still in progress.\r\n\r\nP.S. also tried with `conn.db.close(true)` - same result."},{"labels":["bug"],"text":"**What is the current behavior?**\r\n\r\nIf I try to use  ES6-Classes inside mongoose Models and use them with discriminators, the schema of the derived model won't be extended. The additional fields are simply missing. I tried to use the given Car/Vehice-Tests as well as the repro code in #5104.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n\r\n```\r\nconst { Mongoose, Model, Schema } = require('mongoose');\r\n\r\ndescribe('mongoose discriminated classes', () => {\r\n  it('should query correctly', done => {\r\n    class Shape extends Model { };\r\n    class Circle extends Shape { };\r\n    mongoose.model(Shape, new Schema({ color: String }));\r\n    Shape.discriminator(Circle, new Schema({ radius: Number }));\r\n\r\n    mongoose.connect(/* your connection string here */, () => {\r\n      let circle = new Circle({ color: 'blue', radius: 3 });\r\n      circle.save(() => {\r\n\r\n        // Done preparing, now do your thing\r\n        Circle.find({}, (err, circles) => {\r\n          assert.equal(err, null);\r\n\r\n          assert.notEqual(circles.length, 0); // Fails here\r\n\r\n          done();\r\n        });\r\n      });\r\n    });\r\n  });\r\n});\r\n\r\n```\r\n\r\nThe code runs, but the field \"radius\" of the subclass is simply missing.\r\n\r\n```\r\n[ { _id: 59b649ffc5359f6c3ec977aa, color: 'blue', __v: 0 },\r\n  { _id: 59b64c7ac990c771ea114364, color: 'blue', __v: 0 } ]\r\n```\r\n\r\nExtension via loadClass() works as expected.\r\n\r\n**What is the expected behavior?**\r\n\r\nField \"radius\" should be added.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nnode v8.4.0\r\nmongoose: 4.11.10\r\nmongodb: 3.4.7\r\n\r\non Mac OS Sierra"},{"labels":["bug"],"text":"Bug: If you re-save an array of objects which are pulled from another collection, it fails to save. In hindsight, we probably shouldn't do this, but this turned into a fairly deep rabbit hole of pain since it's allowed and has been in production for a few years.\r\n\r\nThis behaviour was introduced in `4.11.7` (works in `4.11.6` and below) and is still present in master. Fails on both node `4.4.7` and `6.9.4`. Probably relevant:\r\n\r\n> fix(document): ensure overwriting a doc array cleans out individual docs #5523\r\n\r\n```javascript\r\nit('Cannot re-nest subdocs from another collection', function(done) {\r\n  var MainSchema = new Schema({\r\n    name: { type: String },\r\n    children: [{\r\n      _id: { type: mongoose.Schema.ObjectId },\r\n      name: { type: String }\r\n    }]\r\n  });\r\n  var RelatedSchema = new Schema({ name: { type: String } });\r\n  var Model = db.model('tmain', MainSchema);\r\n  var RelatedModel = db.model('trelated', RelatedSchema);\r\n\r\n  var relation = new RelatedModel({ name: 'what' });\r\n  relation.save(function(err) {\r\n    if (err) return done(err);\r\n\r\n    var doc = new Model({ name: 'test1', children: [relation] });\r\n    doc.save(function(err) {\r\n      if (err) return done(err);\r\n      doc.children = [relation];\r\n      doc.save(done); // boom\r\n    });\r\n  });\r\n});\r\n```\r\n\r\n```\r\nMongoError: cannot use the part (children of children.-1._id) to traverse the element ({children: [ { _id: ObjectId('59b2e03a5c80674c59d6ad02'), name: \"what\" } ]})\r\n```\r\n\r\nThe current delta it's trying to apply, is: (from `model.$__delta()`)\r\n\r\n```\r\n[\r\n    {\r\n        \"_id\": \"59b2e201eebe2056c9b3f3bb\",\r\n        \"__v\": 0\r\n    },\r\n    {\r\n        \"$set\": {\r\n            \"children.-1._id\": [\r\n                null\r\n            ],\r\n            \"children.-1.name\": [\r\n                null\r\n            ]\r\n        },\r\n        \"$inc\": {\r\n            \"__v\": 1\r\n        }\r\n    }\r\n]\r\n```\r\nwhich looks like complete madness >.<\r\n\r\n"},{"labels":["bug"],"text":"When using `findOneAndUpdate` with options `upsert: true` and `overwrite: true`, and the document does not previously exist, mongoose will insert `null` values into an array field. Reproduced with 4.11.10 with the following script:\r\n\r\n```javascript\r\n'use strict';\r\n\r\nvar assert = require('assert');\r\nvar mongoose = require('mongoose');\r\nmongoose.Promise = global.Promise;\r\n\r\nmongoose.connect('mongodb://localhost/test-data');\r\nmongoose.set('debug', true);\r\n\r\nvar testSchema = new mongoose.Schema({\r\n    customIdentifier: String,\r\n    tags: [String]\r\n});\r\n\r\nvar TestModel = mongoose.model('test', testSchema);\r\n\r\nvar identifier = 'does-not-exist';\r\n\r\nvar update = {\r\n    customIdentifier: identifier,\r\n    tags: ['tag1', 'tag2']\r\n};\r\n\r\nTestModel.findOneAndUpdate({\r\n    customIdentifier: identifier\r\n}, update, {\r\n    upsert: true,\r\n    new: true,\r\n    overwrite: true\r\n}, function(err, model) {\r\n    assert.equal(model.tags[0], 'tag1');\r\n    assert.equal(model.tags[1], 'tag2');\r\n    process.exit(0);\r\n});\r\n```\r\n\r\nResults in the error\r\n\r\n```\r\nevents.js:160\r\n      throw er; // Unhandled 'error' event\r\n      ^\r\nAssertionError: null == 'tag1'\r\n    at /.../test.js:31:12\r\n    at Query.<anonymous> (/.../node_modules/mongoose/lib/model.js:3832:16)\r\n    at /.../node_modules/kareem/index.js:273:21\r\n    at /.../node_modules/kareem/index.js:131:16\r\n    at _combinedTickCallback (internal/process/next_tick.js:73:7)\r\n    at process._tickCallback (internal/process/next_tick.js:104:9)\r\n```\r\n\r\nWithout the `overwrite: true` option, the insert is successful. We recently upgraded from 4.5.5 where this was working correctly, not sure in exactly which version this regression occurred."},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nWhen updating an element in array using the positional $ operator, passed value will be casted to Array.\r\nIn the script below, `elems` field will be updated to `[[\"c\"], \"b\"]` from `[\"a\", \"b\"]`.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\n```js\r\nconst mongoose = require('mongoose');\r\n\r\nmongoose.set('debug', true);\r\n\r\nconst Schema = new mongoose.Schema({\r\n  elems: [String]\r\n});\r\n\r\nconst Model = mongoose.model('Test', Schema);\r\n\r\nconst main = async () => {\r\n  await mongoose.connect('mongodb://localhost/test');\r\n\r\n  const doc = await Model.create({elems: ['a', 'b']});\r\n  const newDoc = await Model.findOneAndUpdate({\r\n    _id: doc._id,\r\n    elems: 'a'\r\n  }, {\r\n    $set: {\r\n      \"elems.$\": 'c'\r\n    }\r\n  }, {\r\n    new: true, upsert: false\r\n  });\r\n  // -- mongoose@4.11.10 --\r\n  // Mongoose: tests.findAndModify({ elems: 'a', _id: ObjectId(\"59b11adf79133519770c23a9\") }, [], { '$set': { 'elems.$': [ 'c' ] } }, { new: true, upsert: false, remove: false, fields: {} })\r\n\r\n  // -- mongoose@4.11.1 --\r\n  // Mongoose: tests.findAndModify({ elems: 'a', _id: ObjectId(\"59b11a4177f861195e97c0d7\") }, [], { '$set': { 'elems.$': 'c' } }, { new: true, upsert: false, remove: false, fields: {} })\r\n\r\n};\r\n\r\nmain()\r\n  .then(() => process.exit())\r\n  .catch((err) => console.error(err));\r\n```\r\n\r\n**What is the expected behavior?**\r\nIn the script above, the expected behavior would be updating `elems` field to `[\"c\", \"b\"]`.\r\nIn mongoose@4.11.1, I get the expected result `[\"c\", \"b\"]`. But in mongoose@4.11.10, I get `[[\"c\"], \"b\"]`.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nnode.js : 8.4.0\r\nmongoose : 4.11.10\r\nMongoDB : 3.4.3"},{"labels":["bug"],"text":"Probable BUG: I just started a new project with mongoose after few years. The latest useMongoClient option is causing my callback not to be called when there's an error on the connection.\r\n\r\n```javascript\r\nmongoose.connect(mongoUri, { useMongoClient: true }, (err: Error) : void => {\r\n  console.log(\"cb called\");  // not called when there's an error on the connection\r\n})\r\n```\r\n\r\n**VERSIONS**\r\n\r\nmongoose = 4.11.10\r\nmongodb = 2.2.31\r\nnode = 7.6.0\r\n"},{"labels":["bug",null],"text":"**Do you want to request a *feature* or report a *bug*?**\r\n\r\nReport a bug, I believe.\r\n\r\n**What is the current behavior?**\r\n\r\n```js\r\nconst Organization = mongoose.model(\"Organization\", OrgSchema);\r\nconst School =  Organization.discriminator(\"School\", SchoolSchema);\r\n\r\n// The update below runs successfully, \r\n// but the discriminator key in the update doc is ignored\r\nOrganization.findByIdAndUpdate(someOrgId, { \r\n  [OrgSchema.options.discriminatorKey]: 'School' \r\n}).exec()\r\n```\r\n\r\n**What is the expected behavior?**\r\nThe update should change the value of the discriminator field on the matching document.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNode 8.2.1, mongoose 4.11.9, mongo 3.4.6"},{"labels":["bug"],"text":""},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?** BUG\r\n\r\n**What is the current behavior?** \r\nWhen `bufferCommands` is set to false, and mongoose fails to connect, any request/query will immediately throw an error that can be caught with a try/catch. However, if the connection is dropped (mongod service stopped) the disconnect event fires, and any query after that hangs. Shouldn't `bufferCommands` keep this from happening? I am relatively new to MongoDB and mongoose.\r\n\r\nI also noticed auto reconnect doesn't work if the initial connection fails.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n1. Create schema with `bufferCommands: false`\r\n\r\n2. Start the `mongod` service and run a query (should be successful) \r\n\r\n3. Stop mongod and try to query. Notice how the request hangs instead of throwing an error.\r\n![image](https://user-images.githubusercontent.com/6901336/29910719-99d94db4-8df0-11e7-90e5-0225aede3e19.png)\r\n\r\ndatabase.js\r\n```javascript\r\nmodule.exports = () => {\r\n    const mongoose = require(\"mongoose\");\r\n    mongoose.connect(process.env.DBUri, {\r\n        useMongoClient: true,\r\n        authSource: \"admin\",\r\n        autoReconnect: true,\r\n        reconnectTries: Number.MAX_VALUE,\r\n        reconnectInterval: 3000\r\n    });\r\n\r\n    mongoose.Promise = Promise; // yea... this is kinda odd \r\n\r\n    mongoose.connection.on(\"connected\", () => {\r\n        console.log(\"Connection Established\");\r\n    });\r\n\r\n    mongoose.connection.on(\"reconnected\", () => {\r\n        console.log(\"Connection Reestablished\");\r\n    });\r\n\r\n    mongoose.connection.on(\"disconnected\", () => {\r\n        console.log(\"Connection Disconnected\");\r\n    });\r\n\r\n    mongoose.connection.on(\"close\", () => {\r\n        console.log(\"Connection Closed\");\r\n    });\r\n\r\n    mongoose.connection.on(\"error\", (error) => {\r\n        console.log(\"ERROR: \" + error);\r\n    });\r\n    return mongoose;\r\n};\r\n```\r\n\r\n**What is the expected behavior?**\r\nMongoose should throw an error instead of hang/buffer commands when the app gets disconnected from the database. Also, `mongoose.connection.readyState` doesn't seem to change on disconnect.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNodeJS: 8.4.0\r\nMongoose: 4.11.9\r\nMongoDB: 3.4.6"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\n\r\nIn the script below, when we pull the parent document, we see that `child` comes back as `{}`, but `child2` comes back as `{ field: 'test'}` despite the fact that `ChildSchema.field` has `select: false`.\r\n\r\nWhen looking at the debugger, only `child.field` is being selected out and `child2.field` is not.\r\n\r\n```\r\n\r\n\r\nconst mongoose = require('mongoose');\r\n\r\nmongoose.connect('mongodb://127.0.0.1/test');\r\nconst db = mongoose.connection;\r\n\r\ndb.once('open', async () => {\r\n  try {\r\n    const ChildSchema = new mongoose.Schema({\r\n      field: {\r\n        type: String,\r\n        select: false,\r\n      },\r\n      _id: false,\r\n    }, { id: false });\r\n\r\n    const ParentSchema = new mongoose.Schema({\r\n      child: ChildSchema,\r\n      child2: ChildSchema,\r\n    });\r\n    const Parent = mongoose.model('Parent', ParentSchema);\r\n    const ogParent = new Parent();\r\n    ogParent.child = { field: 'test' };\r\n    ogParent.child2 = { field: 'test' };\r\n    await ogParent.save();\r\n\r\n    const foundParent = await Parent.findById(ogParent._id).exec();\r\n    console.log(foundParent);\r\n\r\n    db.close();\r\n  } catch (e) {\r\n    console.log(e);\r\n  }\r\n});\r\n\r\n\r\n```\r\n\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\n4.11.8"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n**What is the current behavior?**\r\n\r\nThis script below causes an error: `ValidationError: Parent validation failed: child: Cast to Embedded failed for value \"{ number: '55555555-5555' }\" at path \"child\"`\r\n```\r\nconst mongoose = require('mongoose');\r\n\r\nmongoose.connect('mongodb://127.0.0.1/test');\r\nconst db = mongoose.connection;\r\n\r\ndb.once('open', async () => {\r\n  try {\r\n    const ChildSchema = new mongoose.Schema({\r\n      number: {\r\n        type: String,\r\n        set: v => v.replace(/\\D/g, ''),\r\n      },\r\n      _id: false,\r\n    });\r\n    ChildSchema.set('toObject', { getters: true, minimize: false });\r\n\r\n    const ParentSchema = new mongoose.Schema({\r\n      child: {\r\n        type: ChildSchema,\r\n        default: {},\r\n      },\r\n    });\r\n\r\n    const Parent = mongoose.model('Parent', ParentSchema);\r\n\r\n    const ogParent = new Parent();\r\n    ogParent.child = { number: '55555555-5555' };\r\n    await ogParent.save();\r\n\r\n    const foundParent = await Parent.findById(ogParent._id).exec();\r\n    console.log(foundParent);\r\n\r\n    db.close();\r\n  } catch (e) {\r\n    console.log(e);\r\n  }\r\n});\r\n\r\n```\r\n\r\nOdd behavior includes if I made set `set: v=> v+\"_\"` instead of that regex, it works. If I remove {getters: true} it works. If I remove {minimize: true} it works.\r\n\r\nNot really sure why this is happening... \r\n\r\nAdding a `default: ''` to `number` does seem to solve this problem.\r\n\r\n~~This is an issue with latest 4.11.9 but NOT 4.11.8~~\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nDuring a `find` operation, if multiple models produce an error in the post init hook, the final callback is called multiple times.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```\r\nvar mongoose = require('mongoose');\r\nvar Schema = mongoose.Schema;\r\n\r\nvar uri = 'mongodb://localhost:27017/development';\r\n\r\nmongoose.connect(uri, function (err) {\r\n    if (err) throw new Error(err);\r\n    console.log(`Connected to ${uri}`);\r\n\r\n    var TestSchema = new Schema();\r\n\r\n    TestSchema.post('init', function (model, next) {\r\n        return next(new Error(`Failure ${model._id}`));\r\n    });\r\n\r\n    var TestModel = mongoose.model('Test', TestSchema);\r\n\r\n    var modelsToSave = [];\r\n\r\n    for (var i = 0; i < 10; i++) {\r\n        modelsToSave.push(new TestModel());\r\n    }\r\n\r\n    Promise.all(modelsToSave.map(model => model.save()))\r\n        .then(() => {\r\n            var i = 0;\r\n            TestModel.find({},\r\n                // called multiple times\r\n                function (err) {\r\n                    console.log(`called ${++i} times`, err);\r\n                });\r\n        });\r\n});\r\n```\r\n\r\n**What is the expected behavior?**\r\nWhen multiple errors are produced, the expected behavior would be to call the final `find` callback only once with the first error produced.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNode.js version:  6.10.3\r\nMongoose version: 4.11.9\r\nMongoDB version: 3.2.12"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n**What is the current behavior?**\r\nCastError\r\n```\r\n{ CastError: Cast to ObjectId failed for value \"123456\" at path \"_id\"\r\n    at CastError (/Users/derek.spaulding/projects/reproduce-mongoose-error/without-discriminator/node_modules/mongoose/lib/error/cast.js:27:11)\r\n    at ObjectId.cast (/Users/derek.spaulding/projects/reproduce-mongoose-error/without-discriminator/node_modules/mongoose/lib/schema/objectid.js:154:13)\r\n    at ObjectId.SchemaType._castForQuery (/Users/derek.spaulding/projects/reproduce-mongoose-error/without-discriminator/node_modules/mongoose/lib/schematype.js:1064:15)\r\n    at ObjectId.castForQuery (/Users/derek.spaulding/projects/reproduce-mongoose-error/without-discriminator/node_modules/mongoose/lib/schema/objectid.js:194:15)\r\n    at ObjectId.SchemaType.castForQueryWrapper (/Users/derek.spaulding/projects/reproduce-mongoose-error/without-discriminator/node_modules/mongoose/lib/schematype.js:1021:15)\r\n    at cast (/Users/derek.spaulding/projects/reproduce-mongoose-error/without-discriminator/node_modules/mongoose/lib/cast.js:269:32)\r\n    at model.Query.Query.cast (/Users/derek.spaulding/projects/reproduce-mongoose-error/without-discriminator/node_modules/mongoose/lib/query.js:3104:12)\r\n    at model.Query.Query._castConditions (/Users/derek.spaulding/projects/reproduce-mongoose-error/without-discriminator/node_modules/mongoose/lib/query.js:1145:10)\r\n    at model.Query.Query._findOneAndUpdate (/Users/derek.spaulding/projects/reproduce-mongoose-error/without-discriminator/node_modules/mongoose/lib/query.js:1977:8)\r\n    at /Users/derek.spaulding/projects/reproduce-mongoose-error/without-discriminator/node_modules/kareem/index.js:250:8\r\n    at /Users/derek.spaulding/projects/reproduce-mongoose-error/without-discriminator/node_modules/kareem/index.js:23:7\r\n    at _combinedTickCallback (internal/process/next_tick.js:131:7)\r\n    at process._tickCallback (internal/process/next_tick.js:180:9)\r\n  message: 'Cast to ObjectId failed for value \"123456\" at path \"_id\" for model \"subModel1\"',\r\n  name: 'CastError',\r\n  stringValue: '\"123456\"',\r\n  kind: 'ObjectId',\r\n  value: '123456',\r\n  path: '_id',\r\n  reason: undefined,\r\n```\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n[Gist to reproduce](https://gist.github.com/derekaspaulding/cd04217478a955bdb1ea9b3d0fb27da0)\r\nrunning `node test.js` will give the error above\r\n\r\n**What is the expected behavior?**\r\n\r\nI would expect this to insert successfully. [This Gist](https://gist.github.com/derekaspaulding/6ff2740717e8fe397b457c1513d267ec) doesn't use discriminators and works as I would expect it to when using a discriminator.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNode: 8.2.1\r\nMongoose: 4.11.9\r\nMongoDB: 3.4.7\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nReport a bug\r\n\r\n**What is the current behavior?**\r\nThe warning is shown even if we're not creating a new ObjectId\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n```javascript\r\nvar mongoose = require('mongoose');\r\n\r\nvar zoneSchema = new mongoose.Schema({\r\n    employees: {\r\n        certifications: {type: mongoose.Schema.Types.ObjectId, ref: 'Certifications'}\r\n    }\r\n});\r\n\r\nvar certificationsSchema = new mongoose.Schema({\r\n    type: String,\r\n    list: [{type: mongoose.Schema.Types.ObjectId, ref: 'Certification'}]\r\n});\r\n\r\nvar certificationSchema = new mongoose.Schema({\r\n    name: String\r\n});\r\n\r\nvar Zone = mongoose.model('Zone', zoneSchema);\r\nvar Certifications = mongoose.model('Certifications', certificationsSchema);\r\nvar Certification = mongoose.model('Certification', certificationSchema);\r\n\r\nvar newZone = new Zone();\r\n```\r\n**What is the expected behavior?**\r\nDo not show the warning when it is not an explicit instance of new ObjectId\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNode v8.2.1\r\nMongoose v4.11.8\r\nMongoDB v3.2.7"},{"labels":["bug"],"text":"As described exactly [in this closed issue](https://github.com/Automattic/mongoose/issues/2166) I am making a $text search, and using a $meta textScore to sort on a base model that has some discriminator children schemas. In this base schema I have an instance method. Inside this method the `this` keyword only contains three properties: the `score`, the `_id` and the `__t`. All the rest of the properties are missing. If I remove the $text search then `this` inside the instance method shows all properties as intended.\r\n\r\nMy code sample would be exactly like this user posted [in this closed issue](https://github.com/Automattic/mongoose/issues/2166) except the base schema would have, instead, an instance method that has console.log(this) inside of it showing how `this` is missing all it's properties.\r\n\r\nI can provide a full sample if needed, but I hope that was clear."},{"labels":["bug"],"text":"This is a reopen of #5497 (as I couldn't get a response there).\r\nReproduction was on Mongoose v4.11.7\r\n\r\nCalling `findOneAndUpdate` and updating a binary field saves the binary data incorrectly.\r\nAs mentioned in #5497 this is a breaking change that apparently introduced in version 4.11.2 (I suspect this commit: 1613ef5).\r\n\r\nPlease see the reproduction script below (which include `runSettersOnQuery: true`):\r\n\r\n```js\r\nvar mongoose = require('mongoose'),\r\n\tuuid = require('uuid'),\r\n\tuuidParse = require('uuid-parse');\r\n\r\nmongoose.Promise = Promise;\r\n\r\nfunction generateUUID() {\r\n\tvar buffer = uuid.v4(null, new Buffer(16));\r\n\treturn new mongoose.Types.Buffer(buffer).toObject(0x04);\r\n}\r\n\r\nfunction toUUID(string) {\r\n\tif (!string) {return null;}\r\n\tif (Buffer.isBuffer(string) || Buffer.isBuffer(string.buffer)) { return string; }\r\n\tvar buffer = uuidParse.parse(string);\r\n\treturn new mongoose.Types.Buffer(buffer).toObject(0x04);\r\n}\r\n\r\nfunction fromUUID(buffer) {\r\n\tif (!buffer || buffer.length !== 16) {return null;}\r\n\treturn uuidParse.unparse(buffer);\r\n}\r\n\r\nvar UserSchema = new mongoose.Schema({\r\n\tname: String,\r\n\tfoo: {\r\n\t\ttype: mongoose.Schema.Types.Buffer,\r\n\t\tget: fromUUID,\r\n\t\tset: toUUID\r\n\t}\r\n}, {collection: 'users'});\r\n\r\nvar UserModel = mongoose.model('User', UserSchema);\r\n\r\nvar connStr = 'mongodb://test:test@127.0.0.1/test';\r\nmongoose.connect(connStr);\r\n\r\nvar user = {name: 'insert', foo: uuid.v4()};\r\nconsole.log('Inserting user, my foo will be OK:', user);\r\nvar dalUser = new UserModel(user);\r\ndalUser.save().then(() => {\r\n\tconsole.log('User inserted successfully');\r\n}).catch(console.error);\r\n\r\n\r\nuser = {name: 'upsert', foo: uuid.v4()};\r\nconsole.log('Upserting user, my foo will be wrong:', user);\r\nvar opts = {upsert: true, setDefaultsOnInsert: true, runSettersOnQuery: true };\r\nUserModel.findOneAndUpdate({foo: user.foo}, user, opts).exec().then(() => {\r\n\tconsole.log('User upserted successfully');\r\n}).catch(console.error);\r\n```\r\n\r\nAnd the result in the DB is:\r\n![image](https://user-images.githubusercontent.com/4539636/29287951-a9c72632-813f-11e7-9d8c-2c3a24319092.png)\r\n\r\nThanks!\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nIn the below script, you can see that when we call `toJSON()` to `child`, we see a `{ id: null }` despite having called `ChildSchema.set('id', false')`. \r\n\r\nHowever, if we include `{ id: false }` option when creating the schema, then everything works and we see `{}` instead of `{id: null}`.\r\n\r\n```\r\nconst mongoose = require('mongoose');\r\n\r\nmongoose.connect('mongodb://127.0.0.1/test');\r\nconst db = mongoose.connection;\r\n\r\ndb.once('open', async () => {\r\n  try {\r\n    const ChildSchema = new mongoose.Schema(\r\n      {\r\n        name: String,\r\n        _id: false,\r\n      },\r\n      // If we include this, then everything works correctly\r\n      // {\r\n      //   id: false\r\n      // }\r\n    );\r\n    ChildSchema.set('id', false);\r\n    ChildSchema.set('toJSON', { getters: true})\r\n\r\n    const ParentSchema = new mongoose.Schema({\r\n      child: {\r\n        type: ChildSchema,\r\n        default: {},\r\n      },\r\n    });\r\n\r\n    const Parent = mongoose.model('Parent', ParentSchema);\r\n\r\n    const ogParent = new Parent();\r\n    await ogParent.save();\r\n\r\n    const foundParent = await Parent.findById(ogParent._id).exec();\r\n    console.log(foundParent.child.toJSON()); // { id: null };\r\n\r\n    db.close();\r\n  } catch (e) {\r\n    console.log(e);\r\n  }\r\n\r\n});\r\n\r\n```\r\n\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nLatest nodejs. Mongoose 4.10.8, latest mongodb"},{"labels":["bug"],"text":"node: 8.2.1\r\nmongoose: 4.11.5\r\nmongodb: 3.4.6\r\n\r\nSee example repository [here](https://github.com/j-klassen/mongoose-issue)\r\n\r\nI am having an issue where assigning data to an array with existing elements is retaining the old values, rather than replacing them.\r\n\r\n```javascript\r\nconst mongoose = require('mongoose');\r\n\r\nmongoose.Promise = global.Promise;\r\n\r\n// Create Schemas/Models\r\n\r\nconst FriendSchema = new mongoose.Schema(\r\n  {\r\n    _id: String,\r\n    name: String,\r\n    age: Number,\r\n    dob: Date,\r\n  },\r\n  { _id: false },\r\n);\r\n\r\nconst SocialSchema = new mongoose.Schema(\r\n  {\r\n    friends: [FriendSchema],\r\n  },\r\n  { _id: false },\r\n);\r\n\r\nconst UserSchema = new mongoose.Schema({\r\n  social: {\r\n    type: SocialSchema,\r\n    required: true,\r\n  },\r\n});\r\n\r\nconst User = mongoose.model('User', UserSchema);\r\n\r\n// APP\r\n\r\nasync function run() {\r\n  // Hypothetical lookup map to replace existing data. Some API data perhaps.\r\n  const FRIENDS = [{ id: 'mino' }, { id: 'jakeklassen' }];\r\n\r\n  const user = new User({\r\n    social: {\r\n      friends: [\r\n        { _id: 'mino', name: 'Amin', age: 26 },\r\n        {\r\n          _id: 'jakeklassen',\r\n          name: 'Jake',\r\n          age: 30,\r\n        },\r\n      ],\r\n    },\r\n  });\r\n\r\n  // Generate some new friends data from our \"API\" FRIENDS\r\n  const newFriendsInfo = user.social.friends\r\n    .map(friend => FRIENDS.find(({ id }) => id === friend._id))\r\n    .filter(latest => !!latest)\r\n    .map(latest => Object.assign({}, { _id: latest.id }, latest));\r\n\r\n  const newFriends = newFriendsInfo;\r\n\r\n  console.log(newFriends); // correct output, `id` would be removed by schema\r\n\r\n  // If you clear the friends array first, the results of the below assignment\r\n  // are correct.\r\n  // user.social.friends = [];\r\n\r\n  user.social.friends = newFriends;\r\n\r\n  console.log(user.social.friends); // incorrect - should be [{ _id: 'mino' }, { _id: 'jakeklassen' }]\r\n}\r\n\r\nrun().catch(console.error);\r\n\r\n```\r\nThe contents of `user.social.friends` is:\r\n\r\n```javascript\r\n[ { age: 26, name: 'Amin', _id: 'mino' },\r\n  { age: 30, name: 'Jake', _id: 'jakeklassen' } ]\r\n```\r\n\r\nWhat I would expect:\r\n\r\n```javascript\r\n[ { _id: 'mino' }, { _id: 'jakeklassen' } ]\r\n```"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBug?\r\n\r\n**What is the current behavior?**\r\n````\r\nconst childSchema = mongoose.Schema({\r\n  name: String\r\n})\r\n\r\nconst parentSchema = mongoose.Schema({\r\n  children: [{type: childSchema}]\r\n})\r\n````\r\nthrows:\r\n````\r\nTypeError: Undefined type `undefined` at array `children`\r\n    at Function.Schema.interpretAsType (.../node_modules/mongoose/lib/schema.js:626:15)\r\n    at Schema.path (.../node_modules/mongoose/lib/schema.js:519:29)\r\n    at Schema.add (.../node_modules/mongoose/lib/schema.js:400:12)\r\n````\r\n\r\nThough this works well:\r\n````\r\nconst parentSchema = mongoose.Schema({\r\n  children: {type: childSchema}\r\n})\r\n````\r\nAnd this also:\r\n````\r\nconst parentSchema = mongoose.Schema({\r\n  children: [childSchema]\r\n})\r\n````\r\nAs well as this:\r\n````\r\nconst parentSchema = mongoose.Schema({\r\n  children: [{type: mongoose.Schema.Types.ObjectId}]\r\n})\r\n````\r\n\r\n**What is the expected behavior?**\r\n\r\nI expect\r\n````\r\nconst childSchema = mongoose.Schema({\r\n  name: String\r\n})\r\n\r\nconst parentSchema = mongoose.Schema({\r\n  children: [{type: childSchema}]\r\n})\r\n````\r\nto work as well\r\n\r\n**Please mention your node.js, mongoose and MongoDB version**\r\n\r\n* node.js v7.8.0\r\n* mongoose v4.11.4\r\n* MongoDB v3.4.4\r\n"},{"labels":["bug"],"text":"I know this issue has already been discussed in https://github.com/Automattic/mongoose/issues/4943, but I am still facing this issue :(\r\n\r\nHere is a repro script with latest packages:\r\n\r\n- https://github.com/pawsong/mongoose-reproduce-4943\r\n- mongoose v4.11.4\r\n- jest v20.0.4\r\n- node v7.10.0"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug. This used to work in v4.10.8. Recently upgraded to v4.11.4 and this is now broken\r\n\r\n**What is the current behavior?**\r\nI have a schema for `Application`:\r\n```\r\n{\r\n   docs: {\r\n      type: Envelope,\r\n      default: {}\r\n   }\r\n}\r\n```\r\n\r\nI have a schema for `Envelope`:\r\n```\r\n\r\nconst Envelope = new mongoose.Schema({\r\n  envelopeId: String,\r\n  status: String,\r\n  documents: {\r\n    type: [{\r\n      key: String,\r\n      bucket: String,\r\n      name: String,\r\n      _id: false,\r\n    }],\r\n    default: [],\r\n  },\r\n  _id: false,\r\n});\r\n\r\n```\r\n\r\nLet's say my `app.docs` has some data in `envelopeId`, `status`, etc. and my goal is to \"reset\" the entire property by doing to following:\r\n```\r\napp.docs = {}\r\napp.save()\r\n```\r\n\r\nThis should reset the MongoDB entry for that application's `docs` to be:\r\n```\r\n{\r\n   documents: []\r\n}\r\n```\r\n\r\nPreviously in v4.10.8, this works as expected above. In v4.11.4, nothing happens and `docs` is not reset.\r\n\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNode 7.10. Mongoose 4.11.4, latest mongo"},{"labels":["bug"],"text":"This is a bug report and I am using Mongoose v4.11.1 and MongoDB v3.2.  This bug is best explained in the code snippet below.  Basically, when using `MongooseArray.push()`, what gets pushed to the MongooseArray depends on the contents of the MongooseArray.  If the MongooseArray was initialized with a subdocument, `push()` adds a subdocument to the array, this is the expected behavior.  However, if the MongooseArray was empty, just the `ObjectId` of the subdocument is added to the list.\r\n\r\nIn my opinion, what is pushed to the array is what should be added to the array.  Mongoose attempting to determine what to push to the array based on current contents can result in unexpected behavior.  For example, I'm not sure how it would handle of mixture of `ObjectId`s and subdocuments.\r\n\r\n```javascript\r\n'use strict';\r\n\r\nconst mongoose = require('mongoose');\r\nconst Schema = mongoose.Schema;\r\n\r\nmongoose.Promise = require('bluebird');\r\n\r\nvar Referrer;\r\n\r\nfunction endProcess(error) {\r\n  error && console.error(error);\r\n\r\n  Referrer.remove({});\r\n\r\n  process.exit();\r\n};\r\n\r\nmongoose.connect('mongodb://localhost/test', {\r\n  useMongoClient: true\r\n}).then(\r\n  function() {\r\n    var referenceA,\r\n        referenceB,\r\n        referrerA,\r\n        referrerB;\r\n\r\n    const ReferringSchema = new Schema({\r\n      reference:  [{\r\n        type:       Schema.Types.ObjectId,\r\n        ref:        'Referrer'\r\n      }]\r\n    });\r\n\r\n    Referrer = mongoose.model('Referrer', ReferringSchema);\r\n\r\n    referenceA = new Referrer();\r\n    referenceB = new Referrer();\r\n\r\n    referrerA = new Referrer({reference: [referenceA]});\r\n    referrerB = new Referrer();\r\n\r\n    referrerA.reference.push(referenceB);\r\n    console.log(referrerA);\r\n    console.log(referrerA.reference[0] instanceof Referrer);  // true, as expected\r\n    console.log(referrerA.reference[1] instanceof Referrer);  // true, as expected\r\n\r\n    referrerB.reference.push(referenceB);\r\n    console.log(referrerB);\r\n    console.log(referrerB.reference[0] instanceof Referrer);  // false\r\n  },\r\n  function(error) {\r\n    console.error(error);\r\n\r\n    process.exit();\r\n  }\r\n).then(endProcess, endProcess);\r\n```\r\n"},{"labels":["bug"],"text":"With reference to [the connection API documentation](http://mongoosejs.com/docs/api.html#connection_Connection), looks like some connection events are not emitted when `useMongoClient` is true.\r\nEspecially, listeners are invoked for `connecting`, `connected` and `open` events when you first connect to the db.\r\nHowever, I cannot get `disconnected` and `reconnected` events on reconnection scenarios.\r\nThose events are properly emitted when `useMongoClient` is false.\r\n\r\n**Software version:**\r\nNode 6.10.2\r\nMongodb 3.4.1\r\nMongoose 4.11.4"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug.\r\n\r\n**What is the current behavior?**\r\n```javascript\r\nconst schema =  new mongoose.Schema({\r\n   some_field: Number,\r\n}, {\r\n    toObject: { virtuals: true },\r\n    toJSON: { virtuals: true },\r\n})\r\nschema.virtual('test.a', function() {\r\n    return 1;\r\n});\r\nschema.virtual('test.b', function() {\r\n    return 2;\r\n})\r\n\r\n///\r\nconsole.log(model.toJSON()); // don't see test object\r\n{\r\n    some_field: 1\r\n}\r\n```\r\n**What is the expected behavior?**\r\n```javascript\r\n{\r\n    some_field: 1,\r\n    test: {a:1,b:1}\r\n}\r\n```\r\nbut when `model.test.a` -> works, toJSON -> not\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nMongoose: 4.11.3\r\nNodeJS: 7.6.0\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\n*bug*\r\n\r\n**What is the current behavior?**\r\n*exception thrown*\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n\r\n> can't share exact code; pseudo code below to explain the situation causing the bug\r\n> example populating the pre/next related docs with doc._id being a number\r\n```\r\nTestSchema = new mongoose.Schema({\r\n\t_id: Number,\r\n\tprevnxt: { type: [Number], ref: 'test' }\r\n});\r\n\r\nmodel = mongoose.model('test', TestSchema, 'TestCollection');\r\nmodel._populate = model.populate\r\nmodel.populate = (doc, options, callback)=>\r\n\tdoc.prevnext = [doc._id+1, doc._id-1];\r\n\toptions.filter((pop)-> pop.path is 'prevnext').forEach((opt)=> opt.limit = 2);\r\n\tmodel._populate doc, options, callback\r\n```\r\n\r\n**What is the expected behavior?**\r\npopulate to complete without exceptions with all array elements populated\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nnodejs 6.9.4, mongodb 3.2.x, mongoose 4.9.10\r\n\r\nhere is the options shown in the debug when streaming a large set of data whilst populating on the fly\r\n`{ limit: 9223372036854776000, fields: {} }`\r\n\r\ncommenting out the following line in lib\\model.js (line 3039) solves the issue\r\n`mod.options.options.limit = mod.options.options.limit * ids.length;`\r\n\r\n[related to 1251 as per this comment](https://github.com/Automattic/mongoose/issues/2151#issuecomment-305006030)"},{"labels":["bug"],"text":"An error is thrown whenever I query for documents that contain geo points near a given point.\r\n\r\nReproduction:\r\n\r\n```js\r\nconst mongoose = require('mongoose');\r\nconst bluebird = require('bluebird');\r\n\r\nmongoose.Promise = bluebird;\r\n\r\nconst uri = 'mongodb://localhost:27017/mongoose_test';\r\nconst db = mongoose.createConnection(uri, { db: { safe: true } });\r\n\r\nconst storySchema = new mongoose.Schema({\r\n  gallery: [{\r\n    src: String,\r\n    location: {\r\n      type: { type: String, enum: ['Point'] },\r\n      coordinates: { type: [Number], default: void 0 } // eslint-disable-line\r\n    },\r\n    timestamp: Date\r\n  }]\r\n});\r\n\r\nstorySchema.index({ 'gallery.location': '2dsphere' });\r\n\r\nconst Story = mongoose.model('Story', storySchema);\r\n\r\nconst coordinates = [51.53377166666667, -0.1197471666666667];\r\n\r\nStory.update({\r\n  'gallery.location': {\r\n    $near: {\r\n      $geometry: {\r\n         type: 'Point',\r\n         coordinates\r\n      },\r\n      $maxDistance: 500\r\n    }\r\n  }\r\n}, {\r\n  $push: {\r\n    gallery: {\r\n      $each: [{\r\n        src: 'test',\r\n        location: {\r\n          type: 'Point',\r\n          coordinates,\r\n        },\r\n        timestamp: Date.now()\r\n      }],\r\n      $sort: { timestamp: 1 }\r\n    }\r\n  }\r\n}, { upsert: true })\r\n.then(resolve => console.log(resolve))\r\n.catch(error => console.error(error));\r\n```\r\n\r\nError is:\r\n\r\n```\r\n{\r\n  message: 'Path \"location\" is not in schema, strict mode is `true`, and upsert is `true`.',\r\n  name: 'StrictModeError',\r\n  path: 'location'\r\n}\r\n```\r\n\r\nnode v8.1.4, mongodb v3.4.2, mongoose v4.11.2\r\n"},{"labels":["bug"],"text":"Looks like the fix for issue #5405 breaks error handling middleware on `save`.\r\nWith Mongoose 4.11.2 the 2nd argument of the error handling middleware is indeed `null`, while it is the document - as expected - with earlier Mongoose versions. \r\n\r\nHere's a repro:\r\n\r\n````javascript\r\nconst assert = require('assert');\r\nconst mongoose = require('mongoose');\r\n\r\nconst GITHUB_ISSUE = `gh-5466`;\r\n\r\nmongoose.connect(`mongodb://localhost:27017/${ GITHUB_ISSUE }`);\r\n\r\nvar Schema = mongoose.Schema;\r\n\r\ndescribe('Error Handling Middleware', function() {\r\n  before(async function() {\r\n    await mongoose.connection.dropDatabase();\r\n  });\r\n\r\n  it('On save res should not be null', function(done) {\r\n    var schema = new Schema({\r\n      name: {\r\n        type: String,\r\n        unique: true\r\n      }\r\n    });\r\n    \r\n    var handleE11000 = function(error, res, next) {\r\n      assert.equal(error.name, 'MongoError');\r\n      assert.equal(error.code, 11000);\r\n      assert.equal(typeof next, 'function');\r\n      assert.notStrictEqual(null, res);  // with mongoose 4.11.1 and below res is the document; with 4.11.2+ is null\r\n      next();\r\n    };\r\n\r\n    schema.post('save', handleE11000);\r\n\r\n    var Person = mongoose.model('Person', schema);\r\n\r\n    var person1 = { name: 'David' };\r\n    var person2 = { name: 'David' };\r\n\r\n    Person.on('index', function(error) {\r\n      assert.ifError(error);\r\n      Person.create([person1, person2], function(error) {\r\n        done();\r\n      });\r\n    });\r\n  });\r\n});\r\n````\r\n**Software version:**\r\nNode 6.10.2\r\nMongodb 3.4.1\r\nMongoose 4.11.2 and above are affected; versions 4.11.1 and below work correctly"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBUG\r\n\r\n**What is the current behavior?**\r\nfindOneAndUpdate options `setDefaultsOnInsert` looks weird.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n\r\nschema:\r\n\r\n```\r\nimport mongoose from 'mongoose';\r\nlet Schema = mongoose.Schema;\r\n\r\nlet schema = new Schema({\r\n    placement: {\r\n        type: String,\r\n        default: null\r\n    },\r\n    name: {\r\n        type: String,\r\n        default: null\r\n    },\r\n    exposure: {\r\n        type: Number,\r\n        default: 0\r\n    },\r\n    click: {\r\n        type: Number,\r\n        default: 0\r\n    },\r\n    createdAt: {\r\n        type: Date,\r\n        default: Date.now\r\n    }\r\n}, {\r\n    versionKey: false\r\n});\r\n\r\nmodule.exports = schema;\r\n```\r\n\r\nmy code:\r\n\r\n```\r\nlet foo = await myModel.findOneAndUpdateAsync({\r\n    placement,\r\n    name\r\n}, {\r\n    $inc: { exposure: 1 }\r\n}, {\r\n    upsert: true,\r\n    new: true,\r\n    setDefaultsOnInsert: true\r\n});\r\n```\r\n\r\n`console.log(foo)` result:\r\n\r\n```\r\n{\r\n    _id: 5964bdac86968efd5a0b8564,\r\n    createdAt: 2017-07-11T11:59:40.130Z,\r\n    click: 0,\r\n    exposure: 1,\r\n    name: 'XXXXXXXXXXX',\r\n    placement: null\r\n}\r\n```\r\n\r\ndebug mode log:\r\n\r\n```\r\nMongoose: nowlinks.findAndModify({ name: 'LunchVideoAD', placement: 'lunch' }, [], { '$inc': { exposure: 1 }, '$setOnInsert': { placement: null, click: 0, createdAt: new Date(\"Tue, 11 Jul 2017 12:18:28 GMT\") } }, { upsert: true, new: true, setDefaultsOnInsert: true, remove: false, fields: {} })\r\n```\r\n\r\n**What is the expected behavior?**\r\nI pass the **name** and **placement** arguments to model and not *undefined* or *null* , but **name** is `not null`  but **placement** is `null`\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nmongoose: 4.11.1\r\nnode: 7.7.2\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nReport a bug\r\n\r\n**What is the current behavior?**\r\nWhen calling .slice({'subArray':[number]}) on a request, the subarray is sliced properly, but the result returns properties that have \"select: false\" set.  Subarray meaning a property of a schema that is an array.  Example below.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nhttps://gist.github.com/JacobReynolds/f2284c4142ebdf7dc101bce0778350a4\r\n\r\n**What is the expected behavior?**\r\nThe subarray will be sliced and \"select:false\" properties will not be returned.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\n#### Mongoose\r\n```\r\n> var mongoose = require('mongoose')\r\nundefined\r\n> mongoose.version\r\n'4.11.1'\r\n```\r\n#### MongoDB\r\n```\r\nC:\\>\"C:\\Program Files\\MongoDB\\Server\\3.4\\bin\\mongod.exe\" --version\r\ndb version v3.4.6\r\ngit version: c55eb86ef46ee7aede3b1e2a5d184a7df4bfb5b5\r\nallocator: tcmalloc\r\nmodules: none\r\nbuild environment:\r\n    distmod: 2008plus\r\n    distarch: x86_64\r\n    target_arch: x86_64\r\n```\r\n#### Node\r\n```\r\nC:\\>node --version\r\nv6.10.3\r\n```"},{"labels":["bug"],"text":"If we set a default non selected field in a model that use discriminator, we can't explicitly select them later.\r\n\r\nThis fails in 4.11.1, but works in 4.8.1.\r\nFails with a model using discriminator, works fine without.\r\n\r\nSimplified step to reproduce:\r\n\r\n```javascript\r\n    const mongoose = require('mongoose');\r\n    \r\n    let schema = new mongoose.Schema({\r\n        foo: String,\r\n        hiddenColumn: {\r\n            type: String, \r\n            select: false,\r\n        }\r\n    });\r\n\r\n    const Foo = mongoose.model('Foo', schema);\r\n    const Bar = Foo.discriminator('Bar', new mongoose.Schema({\r\n        bar: String\r\n    }));\r\n    \r\n    return Foo.remove().then(() => {\r\n        return Bar.create({\r\n            foo: \"test\", \r\n            hiddenColumn: \"Wanna see me?\",\r\n            bar: \"test\"\r\n        });\r\n    }).then(() => {\r\n        return Foo.find()\r\n            .select('+hiddenColumn')\r\n            .then(([row]) => {\r\n                console.log(row.hiddenColumn); //Expect to see something\r\n            })\r\n    }).then(() => {\r\n        return mongoose.connection.close();\r\n    }).catch(console.log).finally(process.exit);\r\n```"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nIn 4.11.1, pre-save hooks are not getting called on an embedded schema.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n\r\nplugin.js\r\n--\r\n```\r\nmodule.exports = function(schema) {\r\n  schema.pre('save', function(next) {\r\n    console.log(schema.obj);\r\n    next();\r\n  });\r\n};\r\n```\r\n\r\nschema_test.js\r\n--\r\n```\r\nconst mongoose = require('mongoose');\r\nconst pluginName = require('./plugin');\r\nmongoose.plugin(pluginName);\r\n\r\nconst childSchema = mongoose.Schema({\r\n  childName: String,\r\n  childGender: String\r\n});\r\nconst modelSchema = mongoose.Schema({\r\n  name: String,\r\n  child: {\r\n    type: childSchema\r\n  }\r\n});\r\nconst Model = mongoose.model('Model', modelSchema);\r\n```\r\n\r\n```\r\nmodelObject = new Model({\r\n  name: 'Name',\r\n  child: {\r\n    name: 'Child name',\r\n    gender: 'female'\r\n  }\r\n});\r\nmodelObject.save();\r\n```\r\n\r\n**What is the expected behavior?**\r\n\r\nIn 4.6.5\r\n--\r\n```\r\n{ childName: [Function: String],\r\n  childGender: [Function: String] }\r\n{ name: [Function: String],\r\n  child: \r\n   { type: \r\n      Schema {\r\n        obj: [Object],\r\n        paths: [Object],\r\n        subpaths: {},\r\n        virtuals: [Object],\r\n        singleNestedPaths: {},\r\n        nested: {},\r\n        inherits: {},\r\n        callQueue: [Object],\r\n        _indexes: [],\r\n        methods: {},\r\n        statics: {},\r\n        tree: [Object],\r\n        _requiredpaths: [],\r\n        discriminatorMapping: undefined,\r\n        _indexedpaths: undefined,\r\n        query: {},\r\n        childSchemas: [],\r\n        s: [Object],\r\n        options: [Object],\r\n        '$globalPluginsApplied': true } } }\r\n```\r\n\r\nIn 4.11.1\r\n--\r\n```\r\n{ name: [Function: String],\r\n  child: \r\n   { type: \r\n      Schema {\r\n        obj: [Object],\r\n        paths: [Object],\r\n        aliases: {},\r\n        subpaths: {},\r\n        virtuals: [Object],\r\n        singleNestedPaths: {},\r\n        nested: {},\r\n        inherits: {},\r\n        callQueue: [Object],\r\n        _indexes: [],\r\n        methods: {},\r\n        statics: {},\r\n        tree: [Object],\r\n        query: {},\r\n        childSchemas: [],\r\n        plugins: [Object],\r\n        s: [Object],\r\n        options: [Object],\r\n        '$globalPluginsApplied': true,\r\n        _requiredpaths: [] } } }\r\n```\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNode - 6.9.4\r\nmongoose - 4.11.1\r\nmongodb - 3.2"},{"labels":["bug"],"text":"Hi,\r\n\r\nLooks like `runSettersOnQuery `  will run the setters twice in `find`/`findOne` commands.\r\nExample:\r\n```js\r\nvar mongoose = require('mongoose');\r\n\r\nmongoose.Promise = Promise;\r\n\r\nvar UserSchema = new mongoose.Schema({\r\n\tname: String,\r\n\tfoo: {\r\n\t\ttype: Number,\r\n\t\tget: function(val) {\r\n\t\t\treturn val.toString();\r\n\t\t},\r\n\t\tset: function(val) {\r\n\t\t\tconsole.log('===>>> Setter called with type: %s, value: %s', typeof val, val);\r\n\t\t\tif (typeof val !== 'string') {\r\n\t\t\t\tthrow new Error('Must be called with string');\r\n\t\t\t}\r\n\r\n\t\t\tvar res = parseFloat(val);\r\n\t\t\tconsole.log('Returning:', res);\r\n\t\t\treturn res;\r\n\t\t}\r\n\t}\r\n}, {collection: 'users', runSettersOnQuery: true});\r\n\r\nvar UserModel = mongoose.model('User', UserSchema);\r\n\r\nvar connStr = 'mongodb://test:test@127.0.0.1/test';\r\nmongoose.connect(connStr);\r\n\r\nconsole.log('Running query...');\r\nUserModel.find({foo: '123'}).exec().then(res => {\r\n\tconsole.log('Got result:', res);\r\n}).catch(err => {\r\n\tconsole.error('ERROR:', err)\r\n});\r\n```\r\nThe output is:\r\n```\r\nRunning query...\r\n===>>> Setter called with type: string, value: 123\r\nReturning: 123\r\n===>>> Setter called with type: number, value: 123\r\nERROR: Error: Must be called with string\r\n...\r\n```\r\n\r\nPlease note that in `findOneAndUpdate` command it works OK.\r\n\r\nVersions:\r\nmongoose: 4.11.1\r\nMongoDB: 3.4.0\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n*bug*\r\n\r\n**What is the current behavior?**\r\nDocument is not populated\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\n```\r\n'use strict';\r\n\r\nconst mongoose = require('.');\r\nmongoose.Promise = global.Promise;\r\nmongoose.connect('mongodb://localhost/test');\r\n\r\nconst personSchema = new mongoose.Schema({\r\n  name: String,\r\n  band: String\r\n});\r\n\r\nconst bandSchema = new mongoose.Schema({\r\n    name: String\r\n  , data: {\r\n        field: String\r\n    }\r\n});\r\nbandSchema.virtual('data.members', {\r\n  ref: 'Person',\r\n  localField: 'name',\r\n  foreignField: 'band',\r\n  justOne: false\r\n});\r\n\r\nbandSchema.set('toObject', { virtuals: true })\r\n\r\nconst Person = mongoose.model('Person', personSchema);\r\nconst Band = mongoose.model('Band', bandSchema);\r\n\r\nBand.find({}).populate('data.members').exec(function(error, bands) {\r\n    // Doesn't work, data.members is not populated\r\n    console.log(error || bands)\r\n    /*[{\r\n        _id: 59594234430f451a6c97ce07,\r\n        name: 'band1',\r\n        __v: 0,\r\n        data: { members: null },\r\n        id: '59594234430f451a6c97ce07'\r\n    }]*/\r\n\r\n    bands.forEach(band => band.populate('data.members', err => {\r\n        // works\r\n        console.log(err || band)\r\n        /*{\r\n            _id: 59594234430f451a6c97ce07,\r\n            name: 'band1',\r\n            __v: 0,\r\n            data: { members: [ [Object], [Object] ] },\r\n            id: '59594234430f451a6c97ce07'\r\n        }*/\r\n    }));\r\n});\r\n```\r\n\r\n**What is the expected behavior?**\r\nDocument should be populated\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nnode 8.1.3\r\nmongoose 4.11.0 and master fb3636d4\r\nmongo 3.4.4"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\nI'm getting the following error on push command when updating the array of nested documents with `{runValidators: true}`:\r\n```\r\nTypeError: this.__parentArray._markModified is not a function\r\n    at EmbeddedDocument.markModified (/Users/antonpash1/PhpstormProjects/addspo/backend/node_modules/mongoose/lib/types/embedded.js:87:24)\r\n    at EmbeddedDocument.Document.$__set (/Users/antonpash1/PhpstormProjects/addspo/backend/node_modules/mongoose/lib/document.js:852:10)\r\n    at EmbeddedDocument.Document.set (/Users/antonpash1/PhpstormProjects/addspo/backend/node_modules/mongoose/lib/document.js:763:10)\r\n    at EmbeddedDocument._handleIndex (/Users/antonpash1/PhpstormProjects/addspo/backend/node_modules/mongoose/lib/document.js:591:14)\r\n    at EmbeddedDocument.Document.set (/Users/antonpash1/PhpstormProjects/addspo/backend/node_modules/mongoose/lib/document.js:551:24)\r\n    at EmbeddedDocument.Document (/Users/antonpash1/PhpstormProjects/addspo/backend/node_modules/mongoose/lib/document.js:71:12)\r\n    at EmbeddedDocument [as constructor] (/Users/antonpash1/PhpstormProjects/addspo/backend/node_modules/mongoose/lib/types/embedded.js:31:12)\r\n    at new EmbeddedDocument (/Users/antonpash1/PhpstormProjects/addspo/backend/node_modules/mongoose/lib/schema/documentarray.js:70:17)\r\n    at /Users/antonpash1/PhpstormProjects/addspo/backend/node_modules/mongoose/lib/schema/documentarray.js:172:26\r\n    at DocumentArray.SchemaType.doValidate (/Users/antonpash1/PhpstormProjects/addspo/backend/node_modules/mongoose/lib/schematype.js:743:12)\r\n    at DocumentArray.doValidate (/Users/antonpash1/PhpstormProjects/addspo/backend/node_modules/mongoose/lib/schema/documentarray.js:135:35)\r\n    at /Users/antonpash1/PhpstormProjects/addspo/backend/node_modules/mongoose/lib/services/updateValidators.js:110:22\r\n    at /Users/antonpash1/PhpstormProjects/addspo/backend/node_modules/mongoose/node_modules/async/internal/parallel.js:27:9\r\n    at eachOfArrayLike (/Users/antonpash1/PhpstormProjects/addspo/backend/node_modules/mongoose/node_modules/async/eachOf.js:57:9)\r\n    at exports.default (/Users/antonpash1/PhpstormProjects/addspo/backend/node_modules/mongoose/node_modules/async/eachOf.js:9:5)\r\n    at _parallel (/Users/antonpash1/PhpstormProjects/addspo/backend/node_modules/mongoose/node_modules/async/internal/parallel.js:26:5)\r\n    at parallelLimit (/Users/antonpash1/PhpstormProjects/addspo/backend/node_modules/mongoose/node_modules/async/parallel.js:85:26)\r\n    at /Users/antonpash1/PhpstormProjects/addspo/backend/node_modules/mongoose/lib/services/updateValidators.js:145:5\r\n    at model.Query.Query._execUpdate (/Users/antonpash1/PhpstormProjects/addspo/backend/node_modules/mongoose/lib/query.js:2267:7)\r\n    at /Users/antonpash1/PhpstormProjects/addspo/backend/node_modules/kareem/index.js:257:8\r\n    at args (/Users/antonpash1/PhpstormProjects/addspo/backend/node_modules/kareem/index.js:76:20)\r\n    at model.Query.<anonymous> (/Users/antonpash1/PhpstormProjects/addspo/backend/node_modules/mongoose/lib/schema.js:881:7)\r\nPOST /api/events/5958e32ce679150ad808e2b2/invite-friends 500 92.338 ms - 52\r\n```\r\n\r\nHere is my schemas:\r\n```javascript\r\n//Part of UserSchema\r\nnotifications: {\r\n\ttype: [NotificationSchema]\r\n},\r\n\r\n//NotificationSchema\r\nvar NotificationSchema = new Schema({\r\n\ttype: {\r\n\t\ttype: String,\r\n\t\tenum: Object.values(NOTIFICATION_TYPES),\r\n\t\trequired: true\r\n\t},\r\n\tmessage: {\r\n\t\ttype: String,\r\n\t\trequired: true\r\n\t},\r\n\tevent: {\r\n\t\ttype: Schema.Types.ObjectId,\r\n\t\tref: 'Event',\r\n\t\trequired: function () {\r\n\t\t\treturn this.type === NOTIFICATION_TYPES.INVITATION;\r\n\t\t}\r\n\t}\r\n}, {\r\n\ttimestamps: true\r\n});\r\n\r\nNotificationSchema.statics.NOTIFICATION_TYPES = NOTIFICATION_TYPES;\r\n\r\nexports.Schema = NotificationSchema;\r\nexports.Model = mongoose.model('Notification', NotificationSchema);\r\n```\r\n\r\nAnd this actually the code:\r\n```javascript\r\nUser.update(\r\n\t{'_id': {'$in': friends_ids}},\r\n\t{\r\n\t\t'$push': {\r\n\t\t\t'notifications': {\r\n\t\t\t\t'$each': [notification]\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\t{multi: true, runValidators: true}\r\n);\r\n```\r\n\r\nThe error seems to be gone if command would be without `{runValidators: true}` option\r\n\r\nVersions:\r\n```\r\nMongoDB: 3.4.1\r\nNode: 7.9.0\r\nMongoose: 4.11.0\r\n```\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nCast to embedded failed\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n\r\n```js\r\nvar assert = require('assert');\r\nvar mongoose = require('mongoose');\r\nmongoose.Promise = global.Promise;\r\nvar Schema = mongoose.Schema;\r\n\r\nmongoose.connect('mongodb://localhost/gh4743');\r\nmongoose.set('debug', true);\r\n\r\nvar tbl_Test = new mongoose.Schema({\r\n  name: String,\r\n  areas: [{\r\n    price: Number,\r\n    area: {\r\n        type: String,\r\n        coordinates: [Array]\r\n    }\r\n  }]\r\n});\r\n\r\nvar Test = mongoose.model('Test', tbl_Test);\r\n\r\nvar area = {\r\n    type: 'Polygon',\r\n    coordinates: [ \r\n        [ \r\n            131.023807525635, \r\n            -25.3688458240828\r\n        ], \r\n        [ \r\n            131.03479385376, \r\n            -25.3537994315234\r\n        ], \r\n        [ \r\n            131.044750213623, \r\n            -25.3635720440125\r\n        ], \r\n        [ \r\n            131.036510467529, \r\n            -25.3745846761659\r\n        ]\r\n    ]\r\n}\r\nTest.create({ name: 'test' })\r\n  .then(doc => {\r\n    return doc\r\n  })\r\n  .then(doc => {\r\n    return Test.update({_id: doc._id}, {$push: {areas: {price: 10, area: area}}})\r\n  })\r\n  .then(ok => {\r\n    console.log(ok)\r\n  })\r\n  .catch(err => {\r\n    console.log(err)\r\n  })\r\n```\r\n\r\n**What is the expected behavior?**\r\nPush the data\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNode 7.10\r\nMongoose 4.11.0\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nA bug\r\n\r\n**What is the current behavior?**\r\nWhen I try to upsert a document with timestamps enabled, mongoDB throws the following error:\r\n```\r\n{ MongoError: The dollar ($) prefixed field '$set' in '$set' is not valid for storage.\r\n    at Function.MongoError.create (/home/benjamin/development/test/node_modules/mongodb-core/lib/error.js:31:11)\r\n    at toError (/home/benjamin/development/test/node_modules/mongodb/lib/utils.js:139:22)\r\n    at /home/benjamin/development/test/node_modules/mongodb/lib/collection.js:1060:67\r\n    at /home/benjamin/development/test/node_modules/mongodb-core/lib/connection/pool.js:469:18\r\n    at _combinedTickCallback (internal/process/next_tick.js:73:7)\r\n    at process._tickCallback (internal/process/next_tick.js:104:9)\r\n  name: 'MongoError',\r\n  message: 'The dollar ($) prefixed field \\'$set\\' in \\'$set\\' is not valid for storage.',\r\n  driver: true,\r\n  index: 0,\r\n  code: 52,\r\n  errmsg: 'The dollar ($) prefixed field \\'$set\\' in \\'$set\\' is not valid for storage.' }\r\n```\r\nmongoose.set('debug', true) outputs the following when trying to run the below code:\r\n```\r\nMongoose: testmodels.update({ _id: 'someFancyId' }, { updatedAt: new Date(\"Thu, 29 Jun 2017 07:28:54 GMT\"), createdAt: new Date(\"Thu, 29 Jun 2017 07:28:54 GMT\"), '$set': { data: 'aValue' } }, { overwrite: true, upsert: true })\r\n```\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```\r\nconst mongoose = require('mongoose');\r\n\r\nmongoose.connect('mongodb://localhost/mongoosetest');\r\nconst db = mongoose.connection;\r\n\r\ndb.once('open', () => {\r\n\tconst schema = new mongoose.Schema({\r\n\t\t_id: { type: String, index: true, required: true },\r\n\t\tdata: String\r\n\t}, {\r\n\t\ttimestamps: true\r\n\t});\r\n\r\n\tconst model = mongoose.model('testModel', schema);\r\n\r\n\twriteToDb('someFancyId', 'aValue')\r\n\t\t.then(console.log)\r\n\t\t.catch(console.error);\r\n\r\n\tfunction writeToDb(_id, data) {\r\n\t\tmongoose.set('debug', true);\r\n\t\treturn model\r\n\t\t\t.where({_id})\r\n\t\t\t.setOptions({overwrite: true, upsert: true})\r\n\t\t\t.update({data})\r\n\t\t\t.exec();\r\n\t}\r\n});\r\n```\r\n\r\n**What is the expected behavior?**\r\nI would expect the update to be successful.\r\nEither the timestamps should also be inside the $set operation or the data given in .update() should be outside of it.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nnode.js: v6.11.0\r\nmongoose: v4.11.0\r\nMongoDB: v3.0.15"},{"labels":["bug"],"text":"I don't know if it's a bug or a bad use of mongoose schemas.\r\n\r\nBut, if I don't specified the property to update with 'markModified', the new value added to the nested schema is not saved.\r\n\r\n```\r\nvar nestedValueSchema = new mongoose.Schema({\r\n    _id: false,\r\n    value: Number\r\n  });\r\n  var nestedPropertySchema = new mongoose.Schema({\r\n    _id: false,\r\n    active: Boolean,\r\n    nestedValue: nestedValueSchema\r\n  });\r\n  var nestedSchema = new mongoose.Schema({\r\n    _id: false,\r\n    nestedProperty: nestedPropertySchema,\r\n    nestedTwoProperty: nestedPropertySchema\r\n  });\r\n  var optionsSchema = new mongoose.Schema({\r\n    _id: false,\r\n    nestedField: nestedSchema\r\n  });\r\n  var TestSchema = new mongoose.Schema({\r\n    fieldOne: String,\r\n    options: optionsSchema\r\n  });\r\n\r\n  var Test = mongoose.model('Test', TestSchema);\r\n\r\n  var test = new Test({\r\n    fieldOne: 'Test One',\r\n    options: {\r\n      nestedField: {\r\n        nestedProperty: {\r\n          active: true,\r\n          nestedValue: {\r\n            value: 42\r\n          }\r\n        }\r\n      }\r\n    }\r\n  });\r\n  \r\n  return test\r\n    .save()\r\n    .then(function () {\r\n      test.options.nestedField.nestedTwoProperty = {\r\n        active: true,\r\n        nestedValue: {\r\n          value: 1337\r\n        }\r\n      };\r\n      // test.markModified('options');\r\n      return test\r\n        .save();\r\n    })\r\n    .then(function () {\r\n      return Test.findOne({_id: test._id})\r\n        .then(function (data) {\r\n          console.log(data.options.nestedField);\r\n        });\r\n    });\r\n```\r\n\r\nSo, If I un-comment 'test.markModified('options');', the 'test.options.nestedField.nestedTwoProperty' is saved.\r\n\r\n**Without test.markModified('options'):**\r\n`{ nestedProperty: { active: true, nestedValue: { value: 42 } } }`\r\n\r\n**With test.markModified('options'):**\r\n`{ nestedTwoProperty: { active: true, nestedValue: { value: 1337 } },\r\n  nestedProperty: { active: true, nestedValue: { value: 42 } } }`"},{"labels":["bug"],"text":"Looks like error is passed as the 1st and the 2nd argument of findOneAndUpdate error handling middleware.\r\nThe 2nd argument should be the doc instead. Correct me if I'm wrong, because I'm new to this feature and still experimenting.\r\n\r\nHere's a repro test inspired by [this blog post](http://thecodebarbarian.com/mongoose-error-handling):\r\n\r\n````javascript\r\nvar Schema = mongoose.Schema;\r\n\r\ndescribe('Error Handling Middleware', function() {\r\n\r\n  it('On findOneAndUpdate error and res arguments of handleE11000 should be different', function(done) {\r\n    var schema = new Schema({\r\n      name: {\r\n        type: String,\r\n        unique: true\r\n      }\r\n    });\r\n    \r\n    var handleE11000 = function(error, res, next) {\r\n      assert.equal(error.name, 'MongoError');\r\n      assert.equal(error.code, 11000);\r\n      assert.equal(typeof next, 'function');\r\n      assert.notStrictEqual(error, res);  // This makes the test fail\r\n      next();\r\n    };\r\n\r\n    schema.post('findOneAndUpdate', handleE11000);\r\n\r\n    var Person = mongoose.model('Person', schema);\r\n\r\n    var person1 = { name: 'p1' };\r\n    var person2 = { name: 'p2' };\r\n\r\n    Person.create([person1, person2], function(error) {\r\n      // Cause a duplicate key error\r\n      Person.findOneAndUpdate({name: 'p2'}, {$set:{name: 'p1'}}, {runValidators:true}, function(error) {\r\n        done();\r\n      });\r\n    });\r\n  });\r\n});\r\n````\r\n**Software version:**\r\nNode 6.10.2\r\nMongodb 3.4.1\r\nMongoose 4.9.x , 4.10.x and 4.11.0 are all affected by this issue"},{"labels":["bug",null],"text":"In Model.update documentation (http://mongoosejs.com/docs/api.html#model_Model.update) is says:\r\n\r\n> All update values are cast to their appropriate SchemaTypes before being sent.\r\n\r\nIt doesn't work as I expected in this case:\r\n\r\n```javascript\r\nvar mongoose = require('mongoose');\r\n\r\nmongoose.set('debug', true);\r\n\r\nvar Schema = new mongoose.Schema({\r\n  colors: [{type: String}]\r\n});\r\n\r\nvar Model = mongoose.model('Test', Schema);\r\n\r\nmongoose.connect('mongodb://localhost/db');\r\n\r\nmongoose.connection.once('open', function() {\r\n  Model\r\n    .update({}, {colors: 'red'})\r\n    .exec();\r\n\r\n  var document = new Model({colors: 'red'});\r\n\r\n  document.save();\r\n});\r\n```\r\n\r\n```\r\nMongoose: tests.update({}, { '$set': { colors: 'red' } }, {})\r\nMongoose: tests.insert({ _id: ObjectId(\"59515913df3ff64d688abcfb\"), colors: [ 'red' ], __v: 0 })\r\n```\r\n\r\nAs you can see, in the first case it saves a raw value, 'red'. In the second case it converts 'red' to ['red'], which is what I expected to happen with Model.update as well.\r\n\r\nIs this how it supposed to work? How do I determine when I need to massage data by myself and when it will be prepared by mongoose?\r\n\r\nNode.js 6.9.5\r\nmongoose 4.11.0\r\nMongoDB 3.4.2\r\n"},{"labels":["bug"],"text":"Thanks for all the great work on mongoose.\r\n\r\nI'd like to report (what I believe to be) a bug - it seems that post-remove hooks do not fire on subdocuments when the parent document is removed (even though pre-remove hooks do fire on the subdocs). I've written a simple script that reproduces the issue:\r\n\r\n```js\r\nconst mongoose = require('mongoose')\r\nconst Schema = mongoose.Schema\r\n\r\n// The subdocument schema\r\nconst contentSchema = new Schema({\r\n   blocks: [{ type: String }],\r\n   summary: { type: String }\r\n})\r\n\r\n// Subdocument pre-remove middleware\r\ncontentSchema.pre('remove', function (next) {\r\n   console.log('Subdoc pre-remove middleware has fired!')\r\n   next()\r\n})\r\n\r\n// Subdocument post-remove middleware\r\n// â†’ This doesn't seem to fire!\r\ncontentSchema.post('remove', function () {\r\n   console.log('Subdoc post-remove middleware has fired!')\r\n})\r\n\r\n// Normal schema that uses the above subdocument schema as single nested subdocs\r\nconst noteSchema = new Schema({\r\n   title: { type: String, required: true },\r\n   body: { type: contentSchema }\r\n})\r\n\r\n// Document pre-remove middleware\r\nnoteSchema.pre('remove', function (next) {\r\n   console.log('Parent doc pre-remove middleware has fired!')\r\n   next()\r\n})\r\n\r\n// Document post-remove middleware\r\nnoteSchema.post('remove', function () {\r\n   console.log('Parent doc post-remove middleware has fired!')\r\n})\r\n\r\nconst Note = mongoose.model('note-subdoc-test', noteSchema)\r\n\r\n// Create a new Note\r\nconst note = new Note({\r\n   title: 'Lorem Ipsum Dolor',\r\n   body: {\r\n      summary: 'Summary Test',\r\n      blocks: ['html']\r\n   }\r\n})\r\n\r\nnote.save()\r\n.then(note => note.remove())\r\n.then(() => console.log('All done!'))\r\n```\r\n\r\nThe output of this snippet is:\r\n\r\n```\r\nSubdoc pre-remove middleware has fired!\r\nParent doc pre-remove middleware has fired!\r\nParent doc post-remove middleware has fired!\r\nAll done!\r\n```\r\n\r\nA quick adaptation of this script shows that this is not just true for single nested subdocs, but for fully-fledged embedded subdoc arrays as well.\r\n\r\nUsing version 4.10.7 of mongoose and version 6.11.0 of node.js. Thanks in advance!\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\nI just upgraded from mongoose 4.6.5 to mongoose 4.10.7 and populating embedded arrays with refPath does not seem to work anymore. Follows a detailed description of the issue.\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nLets say I have two models `ModelA`, and `ModelB` with their own schemas. Additionally,\r\n\r\n```\r\nParentSchema = mongoose.Schema({\r\n  children: [ChildSchema]\r\n});\r\n\r\nChildSchema = mongoose.Schema({\r\n  name: String,\r\n  toy: {\r\n    kind: {\r\n      type: String,\r\n      enum: ['ModelA', 'ModelB']\r\n    },\r\n    value: {\r\n      type: ObjectId,\r\n      refPath: 'children.toy.kind'\r\n    }\r\n  }\r\n});\r\n```\r\n\r\nLets say I have a parent document:\r\n\r\n```\r\nparent = new Parent({\r\n  children: [\r\n    {\r\n       name: 'Child 1',\r\n       toy: {kind: 'ModelA', value: ObjectId(123)}\r\n    },\r\n    {\r\n      name: 'Child 2'\r\n    },\r\n    {\r\n       name: 'Child 3',\r\n       toy: {kind: 'ModelB', value: ObjectId(234)}\r\n    }\r\n  ]\r\n});\r\n```\r\n\r\nIf I do\r\n\r\n```\r\nparent.populate('children.toy.value')\r\n```\r\n\r\nit only populates the first child with toy `ModelA`. Note that there is a child with no toys. Any and all children after the child with no toy do not get the `toy.value` populated.\r\n\r\nIt was populating both children correctly in mongoose 4.6.5.\r\n\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\n\r\n**What is the expected behavior?**\r\nPopulate both children with ModelA and ModelB.\r\n\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nnode - v.6.9.4\r\nmongo 3.2.10\r\nmongoose 4.10.7"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n**Do you want to request a *feature* or report a *bug*?**\r\nbug\r\n\r\n**What is the current behavior?**\r\nwhen updating a field of embedded document with required function, in the save function, \"this\" is referencing the father document instead of the embedded son document.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a standalone script / gist to reproduce your issue -->\r\nthis is my user schema file:\r\n```javascript\r\n'use strict';\r\n\r\nconst mongoose = require('mongoose');\r\n\r\nconst UserSchema = new mongoose.Schema(\r\n    {\r\n        username: {\r\n            type: String,\r\n            required: true\r\n        },\r\n        sms_notifications: {\r\n            is_enabled: {\r\n                type: Boolean,\r\n                required: true\r\n            }\r\n        },\r\n        phone_number: {\r\n            required: function () {\r\n                return true === this.sms_notifications.is_enabled;\r\n            },\r\n            type: String\r\n        }\r\n    }\r\n);\r\n\r\nmodule.exports = UserSchema;\r\n```\r\n\r\nand this is the account schema file that uses the user schema:\r\n\r\n```javascript\r\n'use strict';\r\n\r\nconst mongoose = require('mongoose');\r\nconst userSchema = require('./user');\r\nconst dbConnection = require('./db-connection');\r\n\r\nconst AccountSchema = new mongoose.Schema(\r\n    {\r\n        account_name: {\r\n            type: String,\r\n            required: true\r\n        },\r\n        users: [userSchema]\r\n    },\r\n    {\r\n        collection: 'accounts',\r\n        versionKey: false\r\n    }\r\n);\r\n\r\nmodule.exports = dbConnection.model('account', AccountSchema);\r\n```\r\n\r\nlet's assume that the starting point is this mongo document of an account with one user:\r\n\r\n```javascript\r\n{\r\n    \"_id\" : ObjectId(\"593e302d711077a5c3847727\"),\r\n    \"account_name\" : \"test account\",\r\n    \"users\" : [ \r\n        {\r\n            \"username\" : \"tom\",\r\n            \"sms_notifications\" : {\r\n                \"is_enabled\" : false\r\n            },\r\n            \"_id\" : ObjectId(\"593e31978d98e6364164458b\")\r\n        }\r\n    ]\r\n}\r\n```\r\n\r\nWhen I'm trying to update this only user with a `phone_number` value in the following way:\r\n\r\n```javascript\r\nrouter.post(\r\n    '/edituser',\r\n    function (req, res) {\r\n        return accountModel.findOne().exec().then(\r\n            (resultAccount) => {\r\n                let userModel = resultAccount.users.id('593e31978d98e6364164458b');\r\n                userModel.username = 'tom';\r\n                userModel.phone_number = '123445546';\r\n                userModel.sms_notifications.is_enabled = false;\r\n\r\n                let validationResult = userModel.validateSync();\r\n\r\n                if (undefined !== validationResult) {\r\n                    throw new Error(validationResult);\r\n                }\r\n\r\n                return resultAccount.save();\r\n            }\r\n        ).then(\r\n            () => {\r\n                return res.end();\r\n            }\r\n        ).catch(\r\n            (errorInst) => {\r\n                return res.status(500).end(errorInst.message);\r\n            }\r\n        )\r\n    }\r\n);\r\n```\r\n\r\nI'm getting the following error on the `save()` call, **not on the `validateSync()`** call:\r\n**account validation failed: users.0.phone_number: Path `phone_number` is required.**\r\nand as you can see, there is a phone number.\r\nWhen i'm updating the user without any phone number, everything is fine.\r\nUsing break point on the phone_number required function I see it gets called 3 times. first time on the `validateSync` call which is ok, and two times on the `save()` call where in one of these calls, the \"this\" reference to the account document and not the user document.\r\nIn mongoose 4.7.1 this issue causes a crash, and in the latest 4.10.5 it caused the error above.\r\n\r\n**What is the expected behavior?**\r\n\"this\" should always reference to the schema it is written in.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nnode.js LTS 6.10.2\r\nmongoose 4.10.5 and 4.7.1\r\nMongoDB 3.4"},{"labels":["bug"],"text":"I have some code like this:\r\n\r\n```javascript\r\nvar myModelSchema = new Schema({\r\n  virtualRefKey: {type: String, ref: \"OtherModel\"}\r\n});\r\nmyModelSchema.set('toJSON', {virtuals:true});\r\nmyModelSchema.virtual(\"populatedVirtualRef\", {\r\n  ref: \"OtherModel\",\r\n  localField: \"virtualRefKey\",\r\n  foreignField: \"handle\"\r\n});\r\n\r\nvar otherModelSchema = new Schema({\r\n  handle: String\r\n});\r\n\r\nvar MyModel = mongoose.model(\"MyModel\", myModelSchema);\r\nvar OtherModel = mongoose.model(\"OtherModel\", otherModelSchema);\r\n\r\n\r\nreturn Promise.resolve()\r\n    .then(()=>{\r\n      return MyModel.create({\r\n        virtualRefKey: \"a-valid-handle-for-an-other-model-document\"\r\n      })\r\n    })\r\n    .then((doc)=>{\r\n      return MyModel.populate(doc, \"populatedVirtualRef\");\r\n    })\r\n    .then((populatedDoc)=>{\r\n      //true in 4.10.4, but false in 4.10.5\r\n      Array.isArray(populatedDoc.populatedVirtualRef)\r\n      //true in 4.10.5, but false in 4.10.4\r\n      populatedDoc.populatedVirtualRef === null;\r\n    })\r\n\r\n```\r\nIn version 4.10.5, the document is no longer populated.  Everything works if I switch to 4.10.4.  Is there a breaking change in this release, or am I doing something incorrect?\r\n"},{"labels":["bug"],"text":"To test, disable autoIndex for your model:\r\n\r\n```\r\nvar yourSchema = new mongoose.Schema({\r\n  email: {type: String, required: true, unique: true},\r\n  // etc\r\n}, {\r\n  id: false,\r\n  autoIndex: false\r\n});\r\n```\r\n\r\nThen call ensureIndexes() on your model and check mongo for your collection and see that indexes are *not* created.\r\n\r\nI have traced this to the function _ensureIndexes() where a couple of lines where preventing the operation to continue:\r\n\r\n```\r\nif (model.schema.options.autoIndex === false ||\r\n   (model.schema.options.autoIndex == null && model.db.config.autoIndex === false)) {\r\n      return done();\r\n}\r\n```\r\nThese same check is done in init() where it belongs so it seemed safe to remove them here. This seems to have fixed my problems.\r\n\r\nI have created a fix in #5324\r\nnote: that there was already an test-error in master when I started this fix.\r\n\r\nIt might be related to #5317, waiting for a response from the OP.\r\n\r\nMongoDB version: 3.4.4\r\nMongoose version: 4.10.4\r\nNodeJS version: v6.10.3\r\n\r\n(edit: added used software versions)"},{"labels":["bug"],"text":"Node v6.10.0 - Mongo 3.4.2 - Mongoose 4.8+ / 4.10.4\r\n\r\nChanging typeKey in array of { type: Schema.Types.ObjectId, ref: 'Book' } results in a single array of Ids instead of dealing with the objects)\r\n\r\n    var mongoose = require('mongoose')\r\n      , Schema = mongoose.Schema\r\n\r\n    var personSchema = Schema(\r\n      {\r\n        name    : {$type: String},\r\n        favorite: { $type: Schema.Types.ObjectId, ref: 'Book' }, // works\r\n        books : [{ $type: Schema.Types.ObjectId, ref: 'Book' }] // doesn't work => ids instead of objects\r\n      },\r\n      {\r\n        typeKey: '$type'\r\n      }\r\n    );\r\n\r\n    var bookSchema = Schema({\r\n      title    : String\r\n    });\r\n\r\n    var Book  = mongoose.model('Book', bookSchema);\r\n    var Person = mongoose.model('Person', personSchema);\r\n\r\n    var book1 = new Book({title: 'The Jungle Book'});\r\n    var book2 = new Book({title: '1984'});\r\n\r\n    var person = new Person({name: 'Bob', favorite: book1, books: [book1, book2]})\r\n\r\n    console.log(person); \r\n\r\nThis codes logs:\r\n\r\n    { name: 'Bob',\r\n      favorite: { title: 'The Jungle Book', _id: 592e4c38f9c3bc48349608d0 },  \r\n    _id: 592e4c38f9c3bc48349608d2,\r\n      books: [ 592e4c38f9c3bc48349608d0, 592e4c38f9c3bc48349608d1 ] }\r\n\r\nWhile the same code without a custom typeKey logs:\r\n\r\n    { name: 'Bob',\r\n      favorite: { title: 'The Jungle Book', _id: 592e4bae83ec144817516ab4 },\r\n      _id: 592e4bae83ec144817516ab6,\r\n      books:\r\n      [ { title: 'The Jungle Book', _id: 592e4bae83ec144817516ab4 },\r\n        { title: '1984', _id: 592e4bae83ec144817516ab5 } ] }\r\n\r\nWhen using typeKey, the books data are lost and replaced by the _id"},{"labels":["bug",null],"text":"I'm using a connection method like :\r\n\r\n```\r\nvar Mongoose = require('mongoose');\r\nconnectionUrl = mongodb://some_login:some_pwd@some_host:27017/some_db?authSource=admin\r\nMongoose.connect(connectionUrl); \r\n```\r\n... as indicated in the [docs](http://mongoosejs.com/docs/connections.html), but receiving the following **warning** on NodeJS console :\r\n\r\n```\r\nDb.prototype.authenticate method will no longer be available \r\nin the next major release 3.x as MongoDB 3.6 will only allow auth \r\nagainst users in the admin db and will no longer allow multiple credentials on a socket. \r\nPlease authenticate using MongoClient.connect with auth credentials.\r\n\r\nConnection with database succeeded.\r\n```\r\n\r\n(I get an authentication failure if I omit `?authSource=admin`)\r\n\r\n**Is this normal at this stage (do we need to wait for a next mongoose release ?), \r\nor what should I  change from now ?**\r\n\r\nVersions :\r\n\r\nNode : 7.10.0\r\nMongoose : 4.10.3\r\nMongoDB : 3.4\r\n\r\nThank you."},{"labels":["bug",null],"text":"4.10.3 in the NPM repo extracts to almost 1GB:\r\n\r\n```\r\n$ du -kcs *\r\n925156\tpackage/\r\n```\r\n\r\nThere are a few, what look to be, temporary directories in `package/tools` that are the culprit:\r\n```\r\n$ du -kcs package/tools/*\r\n307932\tpackage/tools/31000/\r\n307932\tpackage/tools/31001/\r\n307960\tpackage/tools/31002/\r\n```\r\n\r\nThey seem to contain MongoDB databases."},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nError like below:\r\n```\r\n         TypeError: Cannot read property 'length' of undefined\r\n             at model.validators.push.validator.maxlengthValidator (/Users/tsuneo/gino/cloud/node_modules/mongoose/lib/schema/string.js:306:31)\r\n             at /Users/tsuneo/gino/cloud/node_modules/mongoose/lib/schematype.js:776:26\r\n             at Array.forEach (native)\r\n             at SchemaString.SchemaType.doValidate (/Users/tsuneo/gino/cloud/node_modules/mongoose/lib/schematype.js:750:19)\r\n             at /Users/tsuneo/gino/cloud/node_modules/mongoose/lib/document.js:1461:9\r\n             at _combinedTickCallback (internal/process/next_tick.js:73:7)\r\n             at process._tickCallback (internal/process/next_tick.js:104:9) } },\r\n\r\n```\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nSet schema like below, and create a document without name. (i.e. name is undefined)\r\n```\r\n  name: {\r\n    type: String,\r\n    maxlength: 63,\r\n    required: function(){\r\n      return false;\r\n    },\r\n  },\r\n```\r\n\r\n**What is the expected behavior?**\r\nNo error\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNode.js v6.10.2\r\nMongoDB 3.2.7\r\nMongoose 4.10.2\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\n\r\nA bug.\r\n\r\n**What is the current behavior?**\r\n\r\nI'm afraid I can't provide a script to reproduce it, but I have the debug logs:\r\n\r\nMongoose: obj.update({ _id: ObjectId(\"59277caacb208dbcca7c77dc\"), __v: 0 }, { '$unset': { one: 1, two: 1, three: 1, four: 1 }, '$set': { currency_formats: null, urls: [ 'http://www.google.com' ], updated_at: new Date(\"Fri, 26 May 2017 00:54:08 GMT\") }, '$inc': { __v: 1 } }, { j: 1, w: 'majority', wtimeout: 10000, checkKeys: true, serializeFunctions: undefined, promiseLibrary: { [Function: wrappedPromise] accept: undefined, all: { [Function: __NR_wrappedCast] __NR_original: [Function: all], __NR_unwrap: [Function: __NR_unwrap] }, defer: undefined, race: { [Function: __NR_wrappedCast] __NR_original: [Function: race], __NR_unwrap: [Function: __NR_unwrap] }, reject: { [Function: __NR_wrappedCast] __NR_original: [Function: reject], __NR_unwrap: [Function: __NR_unwrap] }, resolve: { [Function: __NR_wrappedCast] __NR_original: [Function: resolve], __NR_unwrap: [Function: __NR_unwrap] }, super_: [Function: Promise], __NR_original: [Function: Promise], __NR_unwrap: [Function: __NR_unwrap] } })\r\n\r\nAnd the message is:\r\nError: key $unset must not start with '$'\r\n\r\n**What is the expected behavior?**\r\n\r\nTo save the object.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nnode v7.9.0\r\nâ”œâ”€â”¬ mongoose@4.10.2\r\nâ”‚ â”œâ”€â”¬ mongodb@2.2.26\r\nâ”‚ â”‚ â”œâ”€â”¬ mongodb-core@2.1.10"},{"labels":["bug",null],"text":"I'm having some issues with the Mongoose 4.10.1 (tested on Node 7.1, 6.4 and 4.2) when I have an array of arrays in my schema (and the new document I'm trying to save).\r\n\r\nThe promise returned by `.save()` never resolves, neither do callbacks. Then it causes a huge spike in memory and CPU usage. Enough to crash a few of our production Heroku dynos. \r\n\r\nHere's a minimal failing test case:\r\n\r\n```javascript\r\nconst mongoose = require('mongoose');\r\nconst mainDB = require('../databases/mainDB'); /* connects to one of two databases */\r\nconst Schema = mongoose.Schema;\r\n\r\nconst testAccountSchema = new Schema({\r\n  redirects: [ [ String, String ] ],\r\n});\r\n\r\nlet TestAccount = mainDB.model('TestAccount', testAccountSchema);\r\n\r\nnew TestAccount({\r\n  redirects: [\r\n    ['/from', '/to']\r\n  ],\r\n}).save()\r\n  .then(account => console.log(account))\r\n  .catch(err => console.log(err));\r\n```\r\n Any help would be ðŸ’¯. I've rolled back to Mongoose 4.8.6 for now, issue not present. Only started this week, so assumedly after the 4.10.1 release.\r\n"},{"labels":["bug"],"text":"I have some problem with populating virtuals of nested schema.\r\nSeems that different version of mongoose had different behaviors.\r\nI tested only 4.7.7 and 4.9.8(last).\r\nI did a gist test for describe the situation.\r\n[gits test](https://gist.github.com/SergioDonati/7e47760102db5b91029b1264e45a2e04)\r\n\r\n```javascript\r\n'use strict';\r\nconst mongoose = require('mongoose');\r\nconst Schema = mongoose.Schema;\r\nconst ObjectId = Schema.ObjectId;\r\n\r\nconst should = require('should');\r\n\r\ndescribe('POPULATE VIRTUALS', function(){\r\n\r\n\tbefore(function(done){\r\n\t\tconst ASchema = new Schema({\r\n\t\t\tname: { type: String }\r\n\t\t});\r\n\r\n\t\tconst BSchema = new Schema({\r\n\t\t  name: { type: String },\r\n\t\t  _a: { type: ObjectId }\r\n\t\t}, {\r\n\t\t  toObject: { virtuals: true },\r\n\t\t  toJSON:   { virtuals: true }\r\n\t\t});\r\n\r\n\t\tBSchema.virtual('a', {\r\n\t\t  ref: 'A',\r\n\t\t  localField: '_a',\r\n\t\t  foreignField: '_id',\r\n\t\t  justOne: true\r\n\t\t});\r\n\r\n\t\tconst CSchema = new Schema({\r\n\t\t  name: { type: String },\r\n\t\t  bs: [BSchema]\r\n\t\t}, {\r\n\t\t  toObject: { virtuals: true },\r\n\t\t  toJSON:   { virtuals: true }\r\n\t\t});\r\n\r\n\t\tmongoose.model('A', ASchema);\r\n\t\tmongoose.model('C', CSchema);\r\n\r\n\t\tmongoose.Promise = global.Promise;\r\n\t\tmongoose.connect(\"mongodb://.......\");\r\n\t\tmongoose.connection.on('connected', function () {\r\n\t\t\tmongoose.model('A').create({ name: \"example A\" }, function(err, a){\r\n\t\t\t\tif (err) return done(err);\r\n\t\t\t\tmongoose.model('C').create({\r\n\t\t\t\t\tname: \"example C\",\r\n\t\t\t\t\tbs: [{\r\n\t\t\t\t\t\tname: 'example B',\r\n\t\t\t\t\t\t_a: a._id\r\n\t\t\t\t\t}]\r\n\t\t\t\t}, done);\r\n\t\t\t});\r\n\t\t});\r\n\t});\r\n\r\n\t// FAIL in mongoose@4.7.7\r\n\t// WORK in mongoose@4.9.8\r\n\tit('should return A model by populating', function(done){\r\n\t\tmongoose.model('C').find({}).populate({ path:'bs.a', model:'A' }).exec((err, cs) => {\r\n\t\t   if (err) return done(err);\r\n\t\t   const c = cs[0];\r\n\t\t   should(c).have.property('bs');\r\n\r\n\t\t   should.exist(c.bs);\r\n\t\t   should.equal(c.bs.length, 1);\r\n\r\n\t\t   const b = c.bs[0];\r\n\r\n\t\t   should(b).have.property('a'); // FAIL in mongoose@4.7.7\r\n\t\t   should.exist(b.a);\r\n\t\t   should(b.a).have.property('name');\r\n\t\t   should.equal(b.a.name, 'example A');\r\n\t\t   done();\r\n\t\t});\r\n\t});\r\n\r\n\t// WORK in mongoose@4.7.7\r\n\t// FAIL in mongoose@4.9.8\r\n\tit('should return A model in two step', function(done){\r\n\t\tconst CModel = mongoose.model('C');\r\n\t\tCModel.find({}).exec((err, cs) => {\r\n\t\t   if (err) return done(err);\r\n\t\t   CModel.populate(cs, { path:'bs.a', model:'A' }, function(err, cs){\r\n\t\t\t   if (err) return done(err);\r\n\t\t\t   const c = cs[0];\r\n\t\t\t   should.exist(c.bs);\r\n\t\t\t   should.equal(c.bs.length, 1);\r\n\r\n\t\t\t   const b = c.bs[0];\r\n\t\t\t   should(b).have.property('a');\r\n\r\n\t\t\t   should.exist(b.a);\t// FAIL in mongoose@4.9.8\r\n\r\n\t\t\t   should(b.a).have.property('name');\r\n\t\t\t   should.equal(b.a.name, 'example A');\r\n\r\n\t\t\t   done();\r\n\t\t   }).catch(done);\r\n\t\t});\r\n\t});\r\n\r\n\tafter(function(done){\r\n\t\tmongoose.model('A').remove({}, function(){\r\n\t\t\tmongoose.model('C').remove({}, function(){\r\n\t\t\t\tdone();\r\n\t\t\t});\r\n\t\t});\r\n\t});\r\n});\r\n```\r\n\r\nI need to know the expected behavior and what is the correct method for populate in this situation.\r\n(there is a bug?)\r\n\r\nnodejs@7.10.0(last)\r\nmongodb@3.2.11\r\n"},{"labels":["bug"],"text":"Errors that are thrown or passed to `next()` in the pre validation middleware of a sub doc are not propagated correctly to the error handler, but instead get lost somewhere (Unhandled Rejection) (forgive my terminology).\r\n\r\nI assume this is a bug as pre save errors get caught correctly, as well as pre save and pre validate errors on regular (no sub doc) docs.\r\n\r\n[Here is a gist](https://gist.github.com/c0d0g3n/ba2df311ea76963a066874b5183d1624) to reproduce the bug.\r\n\r\nI'm using Mongoose 4.9.6.\r\n"},{"labels":["bug"],"text":"**Bug**\r\n\r\n**What is the current behavior?**\r\nWhen I modify an ENTIRE object that nest an array, instance.modifiedPaths() should return object and nested array that have been modified.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nhttps://gist.github.com/lcalvy/30c3d5438bd0dcdb4ebade2d43bf0c50\r\n```\r\n$ nvm use 7\r\n$ npm i mongoose@4.6.2 bluebird\r\n$ node modifiedPaths-simple.js\r\n```\r\nOutput of last save is \r\n`modifiedPaths [ 'surnames', 'surnames.cutes' ]`\r\n\r\n```\r\n$ npm i mongoose@4.6.3\r\n$ node modifiedPaths-simple.js\r\n```\r\nOutput is  now:  \r\n`modifiedPaths [ 'surnames' ]`\r\n\r\n**What is the expected behavior?**\r\nmodifiedPaths should be consistent\r\n\r\nplease note that on a more complex schema, https://gist.github.com/lcalvy/802184713b30d9206dce07f01688b61e, result is inverted\r\nmongoose 4.6.2: `modifiedPaths [ 'surnames', 'surnames.cutes' ]`\r\nmongoose 4.6.3: `modifiedPaths [ 'surnames', 'surnames.cutes2', 'surnames.cutes' ]`\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nnodejs v7.9.0, tested also on nodejs 6.10\r\nmongoose 4.6.3\r\nmongodb 3.0.14\r\n"},{"labels":["bug"],"text":"**Bug**:\r\n\r\nWhen a mongoose schema is used as a type of field within a mongoose schema, and then THIS schema is used in a third schema, and there is an index on the inner most schema, it is created in the external schema as if it is created for the middle schema.\r\n\r\ne.g:\r\nSchemaA { f: String }\r\nSchemaA.index({ f: 1 })\r\nSchemaB { a: SchemaA }\r\nSchameC { b : SchemaB }\r\nmongoose.model('TopSchema', SchameC )\r\n*Result:*\r\ntopschemas.ensureIndex({ 'a.f': 1 }, {})\r\n\r\n**The expected result is:**\r\ntopschemas.ensureIndex({ 'b.a.f': 1 }, {})\r\n\r\n*******************************\r\n**nodejs code to reproduce:**\r\n\r\n```javascript\r\nconst mongoose = require('mongoose');\r\nmongoose.Promise = require('bluebird'); //this is only to remove the warning\r\nmongoose.set('debug', true);\r\n\r\nconst SubSubSchema = mongoose.Schema({\r\n    flavour: { type: String }\r\n});\r\n\r\nSubSubSchema.index({ flavour: 1 });\r\n\r\nconst SubSchema = mongoose.Schema({\r\n    status: { type: String },\r\n    containedInContained: { type: SubSubSchema }\r\n});\r\n\r\nSubSchema.index({ status: 1 });\r\n\r\nconst ContainerSchema = mongoose.Schema({\r\n    name: { type: String },\r\n    contained: { type: SubSchema }\r\n});\r\n\r\nContainerSchema.index({ name: 1 });\r\n\r\nconst Container = mongoose.model('Container', ContainerSchema);\r\n\r\nmongoose.connect('mongodb://localhost/test');\r\n\r\nvar db = mongoose.connection;\r\n\r\n\r\ndb.once('open', function () {\r\n    console.log('(waiting for all the indexes to be created)')\r\n    setTimeout(function () {\r\n        process.exit()\r\n    }, 1000)\r\n});\r\n```\r\n**Console output:**\r\n```\r\nMongoose: containers.ensureIndex({ 'containedInContained.flavour': 1 }, {})\r\n(waiting for all the indexes to be created)\r\nMongoose: containers.ensureIndex({ 'contained.status': 1 }, {})\r\nMongoose: containers.ensureIndex({ name: 1 }, { background: true })\r\n```\r\n*`containedInContained.flavour`* should have been: *contained.containedInContained.flavour*\r\n\r\n*******************************\r\nmongoose npm version: 4.9.6 \r\nnodejs v6.9.1\r\nMongoDB: v3.2.9\r\n\r\n"},{"labels":["bug"],"text":"It looks like `remove` should be added to the reserved keyword list, since using it in a schema causes an error.\r\n\r\nSee https://github.com/TobyEalden/mongoose-remove-bug\r\n\r\ne.g.\r\n\r\n```\r\n  const mongoose = require('mongoose');\r\n  mongoose.connect('mongodb://localhost/test');\r\n\r\n  const Cat = mongoose.model(\r\n    'Cat',\r\n    {\r\n      name: String,\r\n      remove: String,   // <-- using 'remove' as a schema property name causes the error.\r\n    }\r\n  );\r\n\r\n  const kitty = new Cat({ name: 'Zildjian' });\r\n  kitty.save(function (err) {\r\n    if (err) {\r\n      console.log(err);\r\n    } else {\r\n      console.log('meow');\r\n    }\r\n  });\r\n```\r\ngives:\r\n```\r\n/home/nuc/dev/mongoose-remove-bug/node_modules/mongoose/lib/document.js:1898\r\n        return this.get.call(this.$__.scope || this, path);\r\n                                     ^\r\n\r\nTypeError: Cannot read property 'scope' of undefined\r\n    at model.Object.defineProperty.get [as remove] (/home/nuc/dev/mongoose-remove-bug/node_modules/mongoose/lib/document.js\r\n:1898:38)\r\n    at applyHooks (/home/nuc/dev/mongoose-remove-bug/node_modules/mongoose/lib/services/model/applyHooks.js:95:25)\r\n    at Function.compile (/home/nuc/dev/mongoose-remove-bug/node_modules/mongoose/lib/model.js:3619:3)\r\n    at Mongoose.model (/home/nuc/dev/mongoose-remove-bug/node_modules/mongoose/lib/index.js:408:22)\r\n    at /home/nuc/dev/mongoose-remove-bug/index.js:7:24\r\n    at Object.<anonymous> (/home/nuc/dev/mongoose-remove-bug/index.js:17:2)\r\n    at Module._compile (module.js:409:26)\r\n    at Object.Module._extensions..js (module.js:416:10)\r\n    at Module.load (module.js:343:32)\r\n    at Function.Module._load (module.js:300:12)\r\n    at Function.Module.runMain (module.js:441:10)\r\n    at startup (node.js:139:18)\r\n    at node.js:990:3\r\n```\r\n\r\nnodejs: 4.7.3\r\nmongoose: 4.9.5\r\nmongodb: 3.4.3"},{"labels":["bug"],"text":"When using insertMany on a model whose schema contains a Decimal type, the operation fails with the error:\r\n`Error: key $numberDecimal must not start with '$'`\r\n\r\n**Steps to reproduce:**\r\nThe following code reproduces the issue: \r\n```javascript\r\nconst mongoose  = require('mongoose');\r\nmongoose.Promise = global.Promise;\r\n\r\nmongoose.connect('mongodb://localhost:27017/test');\r\n\r\nvar schema = new mongoose.Schema({\r\n    amount : mongoose.Schema.Types.Decimal\r\n});\r\nvar Money = mongoose.model('Money', schema);\r\n\r\nMoney.create({amount : '123.45'});  // Works fine\r\n\r\n// This does not work\r\nMoney.insertMany([{amount : '123.45'},{amount : '321.54'}]).then((docs) => { \r\n    console.log(docs.length);\r\n}).catch((err) => {\r\n    console.log(err);\r\n});\r\n```\r\n**Current Behavior:**\r\nThe insert operation fails with the error: \r\n`Error: key $numberDecimal must not start with '$'`\r\n\r\n**Expectation:**\r\nI expect the documents passed to insertMany to be inserted into MongoDB.\r\n\r\n**Versions:**\r\nMongoose **v4.9.5**\r\nMongoDB **v3.4.3**\r\nNode **v6.9.1**\r\n"},{"labels":["bug"],"text":"\r\nnode v6.10.1\r\nmongoose@4.9.5\r\nmongodb@2.2.25\r\n\r\nI'd like to do it this way...\r\n\r\n```\r\nvar mongoose = require(\"mongoose\");\r\n\r\nschema.pre('findOneAndRemove', true, function (next, done) {\r\n    next();\r\n    if (this instanceof mongoose.Query) {\r\n        this.findOne(function (err, doc) {\r\n            console.log('>>>> %s', doc._id.toString());\r\n            done();\r\n        });\r\n    }\r\n    else {\r\n        console.log('>>>>> %s', this._id.toString());\r\n        done();\r\n    }\r\n});\r\n```\r\n\r\nThe **done()** in the if-branch gets called but the hook seems **not** to signal that it is **done**. It hangs.\r\nIf I do a **done(new mongoose.Error('bla'));** the hook signals an error as expected.\r\nWhy it doesn't work without error? \r\n"},{"labels":["bug"],"text":"I'm having the following issue which is this [resurfaced issue](https://github.com/Automattic/mongoose/issues/4540) but with the latest mongoose version 4.9.4\r\n\r\n```\r\n/home/user/Desktop/node_modules/mongoose/lib/types/embedded.js:87\r\n    this.__parentArray._markModified();\r\n                       ^\r\n\r\nTypeError: this.__parentArray._markModified is not a function\r\n    at EmbeddedDocument.markModified (/home/user/Desktop/node_modules/mongoose/lib/types/embedded.js:87:24)\r\n    at SingleNested.Subdocument.markModified (/home/user/Desktop/node_modules/mongoose/lib/types/subdocument.js:62:18)\r\n    at SingleNested.Document.$__set (/home/user/Desktop/node_modules/mongoose/lib/document.js:874:10)\r\n    at SingleNested.Document.set (/home/user/Desktop/node_modules/mongoose/lib/document.js:785:10)\r\n    at SingleNested._handleIndex (/home/user/Desktop/node_modules/mongoose/lib/document.js:625:14)\r\n    at SingleNested.Document.set (/home/user/Desktop/node_modules/mongoose/lib/document.js:585:24)\r\n    at SchemaType.Embedded.cast (/home/user/Desktop/node_modules/mongoose/lib/schema/embedded.js:132:12)\r\n    at SchemaType.getDefault (/home/user/Desktop/node_modules/mongoose/lib/schematype.js:616:23)\r\n    at EmbeddedDocument.Document.$__buildDoc (/home/user/Desktop/node_modules/mongoose/lib/document.js:265:22)\r\n    at EmbeddedDocument.Document (/home/user/Desktop/node_modules/mongoose/lib/document.js:61:20)\r\n    at EmbeddedDocument [as constructor] (/home/user/Desktop/node_modules/mongoose/lib/types/embedded.js:31:12)\r\n    at new EmbeddedDocument (/home/user/Desktop/node_modules/mongoose/lib/schema/documentarray.js:70:17)\r\n    at DocumentArray.SchemaArray (/home/user/Desktop/node_modules/mongoose/lib/schema/array.js:67:21)\r\n    at new DocumentArray (/home/user/Desktop/node_modules/mongoose/lib/schema/documentarray.js:31:13)\r\n    at Function.Schema.interpretAsType (/home/user/Desktop/node_modules/mongoose/lib/schema.js:618:14)\r\n    at Schema.path (/home/user/Desktop/node_modules/mongoose/lib/schema.js:563:29)\r\n```\r\nThe code is the following \r\n\r\n```\r\n\"use strict\";\r\n\r\nvar mongoose = require('mongoose');\r\n\r\nvar db = mongoose.createConnection(\"mongodb://localhost:27017/testDB\");\r\n\r\nlet RatingsItemSchema = new mongoose.Schema({\r\n    id: Number,\r\n    value: Number,\r\n    _id: false\r\n});\r\n\r\nlet RatingsItem = db.model('RatingsItem', RatingsItemSchema);\r\n\r\nlet RatingsSchema = new mongoose.Schema({\r\n    ratings: {\r\n        type: RatingsItemSchema,\r\n        default: \r\n            { id: 1, value: 0 }\r\n        \r\n    },\r\n    _id: false\r\n});\r\n\r\nlet RestaurantSchema = new mongoose.Schema({\r\n    ratings: {\r\n        type: [RatingsItemSchema],\r\n        default: [\r\n            { id: 1, value: 0 },\r\n            { id: 2, value: 0 },\r\n            { id: 3, value: 0 },\r\n            { id: 4, value: 0 },\r\n            { id: 5, value: 0 }\r\n        ]\r\n    },\r\n    menu: {\r\n        type: [RatingsSchema]\r\n    }\r\n});\r\n\r\nlet Ratings = db.model('Ratings', RatingsSchema);\r\nlet Restaurant = db.model('Restaurant', RestaurantSchema);\r\n\r\nvar rest = new Restaurant();\r\nrest.menu.push(new Ratings());\r\nconsole.log(JSON.stringify(rest, null, 2));\r\n```\r\n\r\nVersion \r\n\r\n```\r\nmongoose 4.9.4 \r\nmongodb 3.4.2\r\nnode 5.10.0\r\n```\r\n\r\nThe workaround specified in the beginning of [referenced issue](https://github.com/Automattic/mongoose/issues/4540) fix this issue (adding ` || !this.__parentArray._markModified` to the prototype in `node_modules/mongoose/lib/types/embedded.js`)\r\n\r\n_____\r\n\r\nFurthermore, I've discovered the issue caused another issue (not sure if thats a separate issue), I have got the following error \r\n\r\n```\r\n/home/user/Desktop/node_modules/mongoose/lib/schema/documentarray.js:322\r\n            throw new CastError('embedded', valueInErrorMessage,\r\n            ^\r\nCastError: Cast to embedded failed for value \"{ id: 5, value: 0 }\" at path \"ratings\"\r\n    at MongooseError.CastError (/home/user/Desktop/node_modules/mongoose/lib/error/cast.js:26:11)\r\n    at DocumentArray.cast (/home/user/Desktop/node_modules/mongoose/lib/schema/documentarray.js:322:19)\r\n    at DocumentArray.SchemaType.getDefault (/home/user/Desktop/node_modules/mongoose/lib/schematype.js:616:23)\r\n    at EmbeddedDocument.Document.$__buildDoc (/home/user/Desktop/node_modules/mongoose/lib/document.js:265:22)\r\n    at EmbeddedDocument.Document (/home/user/Desktop/node_modules/mongoose/lib/document.js:61:20)\r\n    at EmbeddedDocument [as constructor] (/home/user/Desktop/node_modules/mongoose/lib/types/embedded.js:31:12)\r\n    at new EmbeddedDocument (/home/user/Desktop/node_modules/mongoose/lib/schema/documentarray.js:70:17)\r\n    at DocumentArray.SchemaArray (/home/user/Desktop/node_modules/mongoose/lib/schema/array.js:67:21)\r\n    at new DocumentArray (/home/user/Desktop/node_modules/mongoose/lib/schema/documentarray.js:31:13)\r\n    at Function.Schema.interpretAsType (/home/user/Desktop/node_modules/mongoose/lib/schema.js:618:14)\r\n    at Schema.path (/home/user/Desktop/node_modules/mongoose/lib/schema.js:563:29)\r\n    at Schema.add (/home/user/Desktop/node_modules/mongoose/lib/schema.js:445:12)\r\n    at new Schema (/home/user/Desktop/node_modules/mongoose/lib/schema.js:99:10)\r\n    at Object.<anonymous> (/home/user/Desktop/mongoose.js:38:24)\r\n    at Module._compile (module.js:413:34)\r\n    at Object.Module._extensions..js (module.js:422:10)\r\n\r\n```\r\n\r\nWhich occurs when I specify a nested array instead of a nested object and setting a `default` value for this array. The code is the following\r\n\r\n```\r\n\"use strict\";\r\n\r\nvar mongoose = require('mongoose');\r\n\r\nvar db = mongoose.createConnection(\"mongodb://localhost:27017/testDB\");\r\n\r\nlet RatingsItemSchema = new mongoose.Schema({\r\n    id: Number,\r\n    value: Number,\r\n    _id: false\r\n});\r\n\r\nlet RatingsItem = db.model('RatingsItem', RatingsItemSchema);\r\n\r\nlet RatingsSchema = new mongoose.Schema({\r\n    ratings: {\r\n        type: [RatingsItemSchema],\r\n        default: [\r\n            { id: 1, value: 0 },\r\n            { id: 2, value: 0 },\r\n            { id: 3, value: 0 },\r\n            { id: 4, value: 0 },\r\n            { id: 5, value: 0 }\r\n        ]\r\n    },\r\n    _id: false\r\n});\r\n\r\nlet RestaurantSchema = new mongoose.Schema({\r\n    ratings: {\r\n        type: [RatingsItemSchema],\r\n        default: [\r\n            { id: 1, value: 0 },\r\n            { id: 2, value: 0 },\r\n            { id: 3, value: 0 },\r\n            { id: 4, value: 0 },\r\n            { id: 5, value: 0 }\r\n        ]\r\n    },\r\n    menu: {\r\n        type: [RatingsSchema]\r\n    }\r\n});\r\n\r\nlet Ratings = db.model('Ratings', RatingsSchema);\r\nlet Restaurant = db.model('Restaurant', RestaurantSchema);\r\n\r\nvar rest = new Restaurant();\r\nrest.menu.push(new Ratings());\r\nconsole.log(JSON.stringify(rest, null, 2));\r\n\r\n```\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nThis seems like a bug.\r\n\r\n**What is the current behavior?**\r\nAfter [#5128](https://github.com/Automattic/mongoose/issues/5128) is fixed, returned documents have circular virtual ref field as null.\r\n\r\nSo `a.brefs.arefs.brefs` is returned as `null` instead of array of `ObjectId`.  But if `a.brefs.arefs.brefs` is requested in populate then `brefs` get populated properly. \r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```js\r\nit('handles circular virtual null (gh-5161)', function(done) {\r\n        var ASchema = new Schema({\r\n          title: { type: String, required: true, trim : true },\r\n          crefs: [{ type: ObjectId, required: true, ref: 'gh5161_1' }]\r\n        });\r\n\r\n        ASchema.virtual('brefs', {\r\n          ref: 'gh5161_0',\r\n          localField: '_id',\r\n          foreignField: 'arefs'\r\n        });\r\n\r\n        var BSchema = new Schema({\r\n          arefs: [{ type: ObjectId, required: true, ref: 'gh5161' }]\r\n        });\r\n        \r\n        var CSchema = new Schema({\r\n            title: [{ type: String, required: true }]\r\n        });\r\n\r\n        var a = db.model('gh5161', ASchema);\r\n        var b = db.model('gh5161_0', BSchema);\r\n        var c = db.model('gh5161_1', CSchema);\r\n\r\n        var id1 = new mongoose.Types.ObjectId();\r\n        var idC = new mongoose.Types.ObjectId();\r\n\r\n        c.create({ _id: idC, title: 'c1' }).\r\n        then(function() {\r\n            a.create({ _id: id1, title: 'test', crefs: [idC] }).\r\n            then(function() { return b.create({ arefs: [id1] }); }).\r\n            then(function() {\r\n                return a.findOne({ _id: id1 }).populate([{\r\n                    path: 'brefs',\r\n                    model: 'gh5161_0',\r\n                    populate: [{\r\n                        path: 'arefs',\r\n                        model: 'gh5161'\r\n                    }]\r\n                }]);\r\n            }).\r\n            then(function(doc) {\r\n                assert.equal(doc.brefs[0].arefs[0].title, 'test'); // <-- this is ok\r\n                assert.ok(doc.brefs[0].arefs[0].crefs.indexOf(doc.crefs[0]) > -1); // <-- this is ok\r\n                assert.ok(doc.brefs[0].arefs[0].brefs.indexOf(doc.brefs[0]._id) > -1); // <-- here doc.brefs[0].arefs[0].brefs is null\r\n                done();\r\n            }).\r\n            catch(done);\r\n        });\r\n});\r\n```\r\n\r\n**What is the expected behavior?**\r\nfor `a.brefs.arefs.brefs`, array of `ObjectId` should be returned when `brefs` are not requested in populate instead of null.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nMongoose: 4.9.4\r\nMongodb: 3.4.0\r\nNode: 7.8.0"},{"labels":["bug"],"text":"Mongoose 4.9.3\r\n\r\nI use schema inheritance, as described [here](http://mongoosejs.com/docs/discriminators.html). Samle code:\r\n\r\n```\r\nvar options = {discriminatorKey: 'kind'};\r\n\r\nvar eventSchema = new mongoose.Schema({time: Date}, options);\r\neventSchema.pre('findOneAndUpdate', function() {\r\n  console.log('eventSchema: findOneAndUpdate');\r\n});\r\nvar Event = mongoose.model('Event', eventSchema);\r\n\r\nvar clickedEventSchema = new mongoose.Schema({url: String}, options)\r\nclickedEventSchema.pre('findOneAndUpdate', function() {\r\n  console.log('clickedEventSchema: findOneAndUpdate');\r\n});\r\nvar ClickedLinkEvent = Event.discriminator('ClickedLink', clickedEventSchema);\r\n\r\n\r\nmongoose.connect('mongodb://localhost:27017/test');\r\n\r\nClickedLinkEvent.findOneAndUpdate(\r\n  { url: 'example.com' },\r\n  { time: new Date() },\r\n  { new: true, upsert: true },\r\n  function(err, result) {\r\n    console.log(err || result);\r\n  }\r\n);\r\n```\r\n\r\n`eventSchema` and `clickedEventSchema` **each** have their `findOneAndUpdate` hook.\r\n\r\nUpon`findOneAndUpdate`, only the `clickedEventSchema`'s hook is executed:\r\n\r\n```\r\nclickedEventSchema: findOneAndUpdate\r\n```\r\n\r\nThis is contrary to what the documentation states:\r\n\r\n> Discriminators also take their base schema's pre and post middleware. However, you can also attach middleware to the discriminator schema without affecting the base schema.\r\n\r\nBug? Outdated documentation? Misunderstanding?\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nAs the title says `embedded discriminators + updateOne + $set = no-go` where no-go means that the discriminator key and the properties of the specialized subdocument are lost.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nThe test below is a modified version of the test at commit https://github.com/Automattic/mongoose/commit/7d6c2594af889e6e2a47e8ae2c217171af778bf1\r\n\r\n````javascript\r\n  it('embedded discriminators with $set (gh-5130)', function(done) {\r\n    var eventSchema = new Schema({ message: String },\r\n      { discriminatorKey: 'kind' });\r\n    var batchSchema = new Schema({ events: [eventSchema] });\r\n    var docArray = batchSchema.path('events');\r\n\r\n    var Clicked = docArray.discriminator('Clicked', new Schema({\r\n      element: {\r\n        type: String,\r\n        required: true\r\n      }\r\n    }));\r\n\r\n    var Purchased = docArray.discriminator('Purchased', new Schema({\r\n      product: {\r\n        type: String,\r\n        required: true\r\n      }\r\n    }));\r\n\r\n    var Batch = mongoose.model('gh5130', batchSchema);\r\n\r\n    var batch = {\r\n      events: [\r\n        { kind: 'Clicked', element: '#hero' }\r\n      ]\r\n    };\r\n\r\n    Batch.create(batch).\r\n      then(function(doc) {\r\n        assert.equal(doc.events.length, 1);\r\n        return Batch.updateOne({ _id: doc._id, 'events._id': doc.events[0]._id }, {\r\n            $set: {\r\n                'events.$':  { message: 'updated', kind: 'Clicked', element: '#hero2' } \r\n              }\r\n            })\r\n            .then(function() {\r\n               return doc;\r\n            });\r\n      }).\r\n      then(function(doc) {\r\n        return Batch.findOne({ _id: doc._id });\r\n      }).\r\n      then(function(doc) {\r\n        assert.equal(doc.events.length, 1);\r\n        assert.equal(doc.events[0].message, 'updated');\r\n        assert.equal(doc.events[0].element, '#hero2');    // <-- test failed\r\n        assert.equal(doc.events[0].kind, 'Clicked');      // <-- test failed \r\n        done();\r\n      }).\r\n      catch(done);\r\n  });\r\n````\r\n\r\n**What is the expected behavior?**\r\nProperties `element` and `kind` should be persisted.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\n- node 6.9.4\r\n- mongodb 3.4.2\r\n- mongoose 4.9.2\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nIt seems to be a bug\r\n\r\n**What is the current behavior?**\r\nCircular populate for virtual is not working.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nCircular virtual ref Population is not working for me.\r\n\r\n```js\r\nvar ASchema = new Schema({\r\n    title: { type: String, required: true, trim : true },\r\n}, {\r\n    toObject: { virtuals: true },\r\n    toJSON: { virtuals: true }\r\n});\r\n\r\nASchema.virtual('brefs', {\r\n  ref: 'BSchema',\r\n  localField: '_id',\r\n  foreignField: 'arefs'\r\n});\r\n\r\nvar BSchema = new Schema({\r\n    arefs: [{ type: ObjectId, required: true, ref : 'A' }],\r\n});\r\n\r\nvar a = db.model('A', ASchema);\r\nvar b = db.model('B', BSchema);\r\n\r\nvar res = await a.find({}).populate([{ \r\n  path: 'brefs', // this gets populated\r\n  model: 'B', \r\n  populate: [{\r\n    path: 'arefs', // <---- this is returned as [ObjectId], not populated\r\n    model: 'A',\r\n    populate: []\r\n  }]\r\n}]).exec();\r\n```\r\n\r\nIt returns array of IDs but not populated documents.\r\n\r\n**What is the expected behavior?**\r\n`a.brefs.arefs` should fetch populated 'a' documents for 'arefs'.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNode: 6.9.1\r\nMongodb: 3.4.6\r\nMongoose: 4.9.1\r\n\r\nSeems related to [#4631](https://github.com/Automattic/mongoose/issues/4631)"},{"labels":["bug"],"text":"I created a custom schema type to store `Point` geojson format. I used `findOneAndUpdate` and `$setOnInsert` on this custom schema type but failed, if I change from `$setOnInsert` to `$set` it works but that's not what I want as I only want to set the field when it is inserted.\r\n\r\n```javascript\r\nvar mongoose = require('mongoose');\r\n\r\nfunction Point(key, options) {\r\n  mongoose.SchemaType.call(this, key, options, 'Point');\r\n}\r\n\r\nPoint.prototype = Object.create(mongoose.SchemaType.prototype);\r\n\r\nPoint.prototype.cast = function(point) {\r\n  if (!point.type) {\r\n    throw new mongoose.Error('Point', point.type, 'point.type'); // will throw error here because `point` here is a string not an object\r\n  }\r\n  // type must be Point\r\n  if (point.type !== 'Point') {\r\n    throw new mongoose.Error(point.type + ' is not a valid GeoJSON type');\r\n  }\r\n\r\n  return point;\r\n};\r\n\r\nmongoose.connect('mongodb://localhost/test');\r\nmongoose.Schema.Types.Point = Point;\r\n\r\nvar testSchema = new mongoose.Schema({ name: String, test: Point });\r\nvar Test = mongoose.model('Test', testSchema);\r\n\r\nTest.findOneAndUpdate({\r\n  name: 'a',\r\n}, {\r\n  $setOnInsert: {\r\n    name: 'a',\r\n  },\r\n  test: {\r\n    type: 'Point',\r\n  },\r\n}, {\r\n  new: true, upsert: true,\r\n})\r\n  .then(function (test) {\r\n    console.log('test', test);\r\n  }, function (error) {\r\n    console.log('error', error);\r\n  });\r\n```\r\nThis will return an `mongoose.Error` that `point` doesn't have property `type` because the parameter being casted is a string. However, if I change from `$setOnInsert` to `$set` it can be run properly. \r\n\r\n```javascript\r\nTest.findOneAndUpdate({\r\n  name: 'a',\r\n}, {\r\n  $setOnInsert: {\r\n    name: 'a',\r\n  },\r\n  $set: {\r\n    test: {\r\n      type: 'Point',\r\n    },\r\n  }\r\n}, {\r\n  new: true, upsert: true,\r\n})\r\n```\r\n\r\nSo by tracing the error, `$set` is matched in [castUpdate.js L147](https://github.com/Automattic/mongoose/blob/0a8808547f9b04d38604337ed0b23b8779022aba/lib/services/query/castUpdate.js#L147) and therefore `castUpdateVal` is run correctly with correct parameters `castUpdateVal(Point, { type: 'Point' }, '$set')` but `$setOnInsert` does not and continue to call `walkUpdatePath` with `location.type`. Therefore, `castUpdateVal` is called with wrong parameters this time `castUpdateVal(Point, 'Point', '$setOnInsert', 'type')`.\r\n\r\n**What is the expected behavior?**\r\nExpected `$setOnInsert` to work correctly with this custom schema type field same as `$set`.\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nnode.js - 7.2.0\r\nmongoose - 4.9.2\r\nMongoDB - 3.4.0"},{"labels":["bug"],"text":"This is a follow-up on #5019. It took me a while to get on it, version 4.8+ required some additional changes in my project that I hadn't got time to solve until recently. On with this issue...\r\n\r\nI declare a model and a discriminator (subclass) of it, using ES6 classes. I save some documents. The data in the collections look ok. But querying on the discriminator produces no results.\r\n\r\n### Repro\r\n```JavaScript\r\nconst { Mongoose, Model, Schema } = require('mongoose');\r\n\r\ndescribe('mongoose discriminated classes', () => {\r\n  it('should query correctly', done => {\r\n    class Shape extends Model { };\r\n    class Circle extends Shape { };\r\n    mongoose.model(Shape, new Schema({ color: String }));\r\n    Shape.discriminator(Circle, new Schema({ radius: Number }));\r\n\r\n    mongoose.connect(/* your connection string here */, () => {\r\n      let circle = new Circle({ color: 'blue', radius: 3 });\r\n      circle.save(() => {\r\n\r\n        // Done preparing, now do your thing\r\n        Circle.find({}, (err, circles) => {\r\n          assert.equal(err, null);\r\n\r\n          assert.notEqual(circles.length, 0); // Fails here\r\n\r\n          done();\r\n        });\r\n      });\r\n    });\r\n  });\r\n});\r\n```\r\n\r\nIf I trace the query being made with ```mongoose.set('debug', true)```, I can see why there's no results...\r\n```\r\nMongoose: shapes.find({ __t: 'class Circle extends Shape { }' }, { fields: {} })\r\n```\r\n\r\nThe value of the discriminator is wrong! Sure enough, if I query with ```Shape.find({})``` instead of ```Circle.find()```, I get the expected result. Finally, I added\r\n```JavaScript\r\nCircle.schema.discriminatorMapping.value = Circle.name;\r\n```\r\nand it worked beautifully.\r\n\r\nSo, I guess there's somehing missing in ```Model.discriminator()``` re: ES6 classes."},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nCalling `Schema.clone()` still maintains a reference to the underlying schema such that calling `Parent.discriminator()` more than once will still throw an error relating to the discriminator schema because mongoose will complain the discriminator schema can't have `__t` (or whatever the discrim key is) as a field.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a stadalone script / gist to reproduce your issue -->\r\n```javascript\r\nconst mongoose = require('mongoose');\r\nconst co = require('co');\r\nconst assert = require('assert');\r\nconst _ = require('lodash');\r\n\r\nmongoose.Promise = global.Promise;\r\n\r\n// Globals: place schemas here as a global to mimick the singleton pattern\r\nconst globals = {\r\n  baseSchema: new mongoose.Schema({\r\n    profile: {\r\n      name: String,\r\n      email: String\r\n    }\r\n  }, { timestamps: true }),\r\n\r\n  discriminatorSchema: new mongoose.Schema({\r\n    profile: {\r\n      address: { city: String, line1: String }\r\n    }\r\n  })\r\n};\r\n\r\n// Constants\r\nconst GITHUB_ISSUE = `overwrite-discriminators-bug`;\r\n\r\ndescribe('before each bug with discriminators', function() {\r\n  let Base;\r\n  let Discriminator;\r\n  let db;\r\n\r\n  function init() {\r\n    return co(function* () {\r\n      db = yield connectToDb();\r\n      const models = createModels(db);\r\n      Base = models.Base;\r\n      Discriminator = models.Discriminator;\r\n    });\r\n  }\r\n\r\n  describe('Block 1', function() {\r\n    before(function(done) {\r\n      co(function* () {\r\n        yield init();\r\n        done();\r\n      }).catch(done);\r\n    });\r\n\r\n    after(function(done) {\r\n      db.close();\r\n      done();\r\n    });\r\n\r\n    it('test 1', function(done) {\r\n      assert.ok(true);\r\n      done();\r\n    });\r\n\r\n    it('test 2', function(done) {\r\n      assert.ok(true);\r\n      done();\r\n    });\r\n  });\r\n\r\n  describe('Block 2', function() {\r\n    beforeEach(function(done) {\r\n      co(function* () {\r\n        yield init();\r\n        done();\r\n      }).catch(done);\r\n    });\r\n\r\n    after(function(done) {\r\n      db.close();\r\n      done();\r\n    });\r\n\r\n    it('test 3', function(done) {\r\n      assert.ok(true);\r\n      done();\r\n    });\r\n\r\n    it('test 4', function(done) {\r\n      assert.ok(true);\r\n      done();\r\n    });\r\n  });\r\n});\r\n\r\nfunction createModels(db) {\r\n\r\n  const Base = db.model('Base', globals.baseSchema);\r\n  \r\n  /**\r\n   * This line is still necessary to prevent the shared state from the underlying schema\r\n   */\r\n  // _.unset(globals.discriminatorSchema, 'paths.__t');\r\n  console.log(globals.discriminatorSchema.paths['__t']); // this should be undefined every time\r\n  const Discriminator = Base.discriminator('Discriminator', globals.discriminatorSchema.clone());\r\n  return { Base, Discriminator };\r\n}\r\n\r\nfunction connectToDb() {\r\n  return co(function* () {\r\n    return mongoose.createConnection(`mongodb://localhost:27017/${GITHUB_ISSUE}`);\r\n  });\r\n}\r\n\r\n```\r\n**What is the expected behavior?**\r\n`Schema.clone()` should create a completely new copy of the schema\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNode 6.9.2\r\nMongoose 4.9.1\r\nMongodb 3.4"},{"labels":["bug"],"text":"Not sure if it is a bug or by design, but query middleware is ignored for `.cursor()` calls. If it's by design it should be mentioned in the docs.\r\n\r\nExpected behavior would be the same query for either call. \r\nCurrent behavior is (with test script below): \r\nfind(): `Mongoose: tests.find({ b: true }, { fields: {} })`\r\nfind().cursor(): `Mongoose: tests.find({ isB: true }, { retainKeyOrder: false, fields: {} })`\r\n\r\n```\r\n'use strict';\r\n\r\nconst mongoose = require('mongoose');\r\n\r\nmongoose.connect('mongodb://localhost/github-mongoose-query-middleware-cursor', {});\r\nmongoose.set('debug', true);\r\n\r\nconst TestSchema = new mongoose.Schema({a: {type: String}, b: {type: Boolean}});\r\n\r\nconst queryMiddleware = function() {\r\n  if (this._conditions.hasOwnProperty('isB')) {\r\n    this._conditions.b = this._conditions.isB;\r\n    delete this._conditions.isB;\r\n  }\r\n};\r\n\r\nTestSchema.pre('find', queryMiddleware);\r\nTestSchema.pre('findOne', queryMiddleware);\r\nTestSchema.pre('count', queryMiddleware);\r\n\r\nconst Test = mongoose.model('Test', TestSchema);\r\n\r\nconst query = { user: { $type: 'string' } };\r\n\r\nTest.insertMany([{a: 'b true', b: true}, {a: 'b false', b: false}], function (err) {\r\n  if (err) {console.error(err);}\r\n  Test.find({isB: true}).exec(function(err, t) {\r\n    if (err) {console.error(err);}\r\n    console.log(t);\r\n\r\n    let cursor = Test.find({isB: true}).cursor();\r\n    process.exit();\r\n  });\r\n});\r\n```\r\n\r\nusing\r\nnode.js v6.9.5\r\nmongoose v4.9.1\r\nmongodb v3.4.1\r\n"},{"labels":["bug"],"text":"Hey everyone,\r\n\r\nI just updated mongoose from 4.4.20 to 4.9 and seem to have a bad bug with findOneAndUpdate.\r\n\r\nI now get this message: \"$setOnInsert is empty. You must specify a field like so:\"\r\n\r\n```db.findOneAndUpdate({_id: doc._id}, doc, {new: true})```\r\n\r\nAny idea why this would start with the version upgrade?\r\n\r\nSimple reproduction below... obviously this isn't how you'd actually use findOneAndUpdate, but it is an easy trigger:\r\n\r\n    connect().then(() => {\r\n\tvar mongoose = require(\"mongoose\"),\r\n\t\tRequestSchema;\r\n\r\n\tmongoose.Promise = require(\"bluebird\");\r\n\tRequestSchema = mongoose.Schema({\r\n\t\tsubmitter: {\r\n\t\t\tname: String,\r\n\t\t\temail: String\r\n\t\t},\r\n\t\tidentifier: String,\r\n\t\ttype: {\r\n\t\t\ttype: String,\r\n\t\t\tuppercase: true,\r\n\t\t\tindex: true,\r\n\t\t\trequired: true,\r\n\t\t\tenum: [\"GAME\", \"REVIEW\", \"AUTHOR\"]\r\n\t\t},\r\n\t\tstatus: {\r\n\t\t\ttype: String,\r\n\t\t\tuppercase: true,\r\n\t\t\tindex: true,\r\n\t\t\tdefault: \"NEW\",\r\n\t\t\tenum: [\"NEW\", \"APPROVED\", \"DENIED\"]\r\n\t\t},\r\n\t\tdata: String\r\n\t}, { timestamps: true });\r\n\r\n\tvar db = mongoose.model(\"Request\", RequestSchema, \"Request\");\r\n\r\n\treturn db.findOne({}).then(thing => {\r\n\t\tthing.status = \"APPROVED\";\r\n\t\treturn db.findOneAndUpdate({_id: thing._id}, thing, {new: true});\r\n\t});\r\n      }).then(() => console.log(\"Did it!\"));\r\n      .catch((err) => console.logg(err));`"},{"labels":["bug"],"text":"There is a bug in hooks on arrays of embedded docs, introduced in 4.8.1.\r\n\r\nThe current behavior is that `post save` hooks are executed on these documents before the parent document is persisted to the database. This means that any changes made to these embedded documents in their `post save` hooks are persisted to the database.\r\n\r\n```\r\nvar ChildModel, ChildModelSchema, ParentModel, ParentModelSchema, childDoc, childDoc2, parentDoc;\r\n\r\nChildModelSchema = mongoose.Schema({\r\n  text: {\r\n    type: String\r\n  }\r\n});\r\n\r\nChildModelSchema.post('save', function(doc) {\r\n  return doc.text = 'bar';\r\n});\r\n\r\nParentModelSchema = mongoose.Schema({\r\n  children: [ChildModelSchema]\r\n});\r\n\r\nParentModel = mongoose.model('Parent', ParentModelSchema);\r\n\r\nChildModel = mongoose.model('Child', ChildModelSchema);\r\n\r\nparentDoc = new ParentModel();\r\n\r\nchildDoc = new ChildModel({\r\n  text: 'foo'\r\n});\r\n\r\nchildDoc2 = new ChildModel({\r\n  text: 'foo2'\r\n});\r\n\r\nparentDoc.children.addToSet(childDoc);\r\n\r\nparentDoc.children.addToSet(childDoc2);\r\n\r\nparentDoc.save(function(err) {\r\n  return ParentModel.findById(parentDoc._id, function(err, doc) {\r\n    return console.log(doc);\r\n    /*\r\n    { _id: 58cdcaa9d26baa80019ea8a8,\r\n      __v: 0,\r\n      children: \r\n       [ { _id: 58cdcaa9d26baa80019ea8a9, text: 'bar' },\r\n         { _id: 58cdcaa9d26baa80019ea8aa, text: 'bar' } ] }\r\n     */\r\n  });\r\n});\r\n```\r\n\r\nThese `post save` hooks should run *after* the parent document is persisted.\r\n\r\nNode v6.9.1\r\nMongoose v4.8.1-4.9.0\r\nMongoDB v2.6.3"},{"labels":["bug"],"text":"There seems to be a bug when using $type queries on fields that are an array although that is supported by mongodb. See https://docs.mongodb.com/manual/reference/operator/query/type/#arrays for details.\r\n\r\nusing\r\nnode.js v6.9.5\r\nmongoose v4.9.0\r\nmongodb v3.4.1\r\n\r\nScript to reproduce:\r\n\r\n```\r\n'use strict';\r\n\r\nconst mongoose = require('mongoose');\r\n\r\nmongoose.connect('mongodb://localhost/github-mongoose-type-array-error', {});\r\n\r\nconst TestSchema = new mongoose.Schema({user: {type: [String], index: true}}, {});\r\n\r\nconst Test = mongoose.model('Test', TestSchema);\r\n\r\nconst query = { user: { $type: 'string' } };\r\n\r\nTest.create({user: ['test']}, function(err) {\r\n  if (err) {\r\n    console.log('failed create');\r\n    console.error(err);\r\n  }\r\n  Test.collection.find(query).next(function(err, doc) { //native find command works fine\r\n    if (err) {\r\n      console.log('failed native find');\r\n      console.error(err);\r\n    }\r\n    console.log(doc);\r\n\r\n    Test.find(query).exec(function(err, docs) { //mongoose find command doesn't work\r\n      if (err) {\r\n        console.log('failed mongoose find');\r\n        console.error(err);\r\n      }\r\n      console.log(docs);\r\n      process.exit();\r\n    });\r\n  });\r\n});\r\n\r\n```\r\n\r\ncould be related/similar to #4937"},{"labels":["bug"],"text":"\r\nI have this:\r\n\r\n```js\r\nfunction create(data, cb){\r\n  return Prompt.create(data, cb);\r\n}\r\n```\r\n\r\nIf callback is undefined, **I would expect it to return a Promise**, instead, it's doing some really weird thing, where the first parameter is no longer recognized, and instead it's looking at the second parameter which is of course undefined, and tries to use the second parameter to instantiate the object which of course will fail validation.\r\n\r\n"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\n`this.hook is not a function`\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nCreate a schema like this:\r\n\r\n```js\r\nconst Schema = new Schema({\r\n    name: String,\r\n    hook: String,\r\n})\r\n```\r\n\r\nThen try and save a new document:\r\n\r\n```js\r\nnew Model({ \r\n    name: 'test', \r\n    hook: 'test' \r\n}).save()\r\n```\r\n\r\nYou get the error:\r\n\r\n    TypeError: this.hook is not a function\r\n        at model._lazySetupHooks (/admin/node_modules/hooks-fixed/hooks.js:177:12)\r\n        at model.pre (/admin/node_modules/hooks-fixed/hooks.js:125:10)\r\n        at /admin/node_modules/mongoose/lib/document.js:1831:17\r\n        at Array.forEach (native)\r\n        at /admin/node_modules/mongoose/lib/document.js:1829:26\r\n        at Array.forEach (native)\r\n        at model.Document.$__registerHooksFromSchema (/admin/node_modules/mongoose/lib/document.js:1795:23)\r\n        at model.Document (/admin/node_modules/mongoose/lib/document.js:76:8)\r\n        at model.Model (/admin/node_modules/mongoose/lib/model.js:42:12)\r\n        at new model (/admin/node_modules/mongoose/lib/model.js:3060:11)\r\n\r\nI've tried the Schema:\r\n\r\n```js\r\nconst Schema = new Schema({\r\n    name: String,\r\n    hook: { type: String },\r\n})\r\n```\r\n\r\nBut it yields the same result.\r\n\r\n**What is the expected behavior?**\r\nFor my mongo document document to end up looking like:\r\n\r\n```json\r\n{\r\n    \"name\": \"test\",\r\n    \"hook\": \"test\"\r\n}\r\n```\r\n"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBUG\r\n\r\n**What is the current behavior?**\r\nI have an Activity model with the following schema:\r\n```\r\nconst schema = mongoose.Schema({\r\n  name: String,\r\n  triggers: [ String ],\r\n  inputs: [ [ String ] ] // Array of Arrays of Strings\r\n});\r\n```\r\nWhen I try to run\r\n```\r\n    Activity.findOneAndUpdate({\r\n      name: 'Host Discovery'\r\n    }, {\r\n      triggers: ['boundary-added'],\r\n      inputs: [\r\n        ['ipRange']\r\n      ]\r\n    }, {\r\n      upsert: true\r\n    }).exec()\r\n```\r\nI get the following error:\r\n```\r\nTypeError: Constructor is not a constructor\r\n    at /home/duybui/code/sniper/sniper-master/node_modules/mongoose/lib/schema/array.js:232:15\r\n    at Array.map (native)\r\n    at SchemaArray.castForQuery (/home/duybui/code/sniper/sniper-master/node_modules/mongoose/lib/schema/array.js:223:17)\r\n    at model.Query._castUpdateVal (/home/duybui/code/sniper/sniper-master/node_modules/mongoose/lib/query.js:2879:17)\r\n    at model.Query._walkUpdatePath (/home/duybui/code/sniper/sniper-master/node_modules/mongoose/lib/query.js:2823:25)\r\n    at model.Query._castUpdate (/home/duybui/code/sniper/sniper-master/node_modules/mongoose/lib/query.js:2695:23)\r\n    at castDoc (/home/duybui/code/sniper/sniper-master/node_modules/mongoose/lib/query.js:2902:18)\r\n    at model.Query.Query._findAndModify (/home/duybui/code/sniper/sniper-master/node_modules/mongoose/lib/query.js:1921:17)\r\n    at model.Query.Query._findOneAndUpdate (/home/duybui/code/sniper/sniper-master/node_modules/mongoose/lib/query.js:1777:8)\r\n```\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nnode 7.6.0\r\nmongoose 4.8.5\r\nmongodb 2.6.10"},{"labels":["bug"],"text":"According to the documentation: \r\n\r\n> Note: if you call toObject and pass any options, the transform declared in your schema options will not be applied. To force its application pass `transform: true`\r\nhttp://mongoosejs.com/docs/api.html#document_Document-toObject\r\n\r\nSteps to reproduce the problem\r\nhttps://gist.github.com/exprodrigues/ee73ca2feb9099a3953626b561b5fb84\r\n\r\n`doc.toObject({ hide: '_id old' });` has a different result than expected\r\n\r\n**Expected**\r\n```\r\ndoc.toObject(); // { name: 'John Doe', email: 'john@doe.com', old: 31 }\r\ndoc.toObject({ hide: '_id old' }); // { _id: 'john', name: 'John Doe', email: 'john@doe.com', old: 31 }\r\ndoc.toObject({ hide: '_id old', transform: true }); // { name: 'John Doe', email: 'john@doe.com' }\r\n```\r\n\r\n**Result**\r\n```\r\ndoc.toObject(); // { name: 'John Doe', email: 'john@doe.com', old: 31 }\r\ndoc.toObject({ hide: '_id old' }); // { name: 'John Doe', email: 'john@doe.com' }\r\ndoc.toObject({ hide: '_id old', transform: true }); // { name: 'John Doe', email: 'john@doe.com' }\r\n```\r\n\r\nNodejs: v6.9.4\r\nMongoDB: v3.4.1\r\nmongoose: 4.8.5\r\n"},{"labels":["bug"],"text":"I'm trying to use ES6 classes and inheritance as mongoose models. A while ago I reported #4942, that's been fixed but a little down the road I hit another speedbump: calling .save() causes a stack overflow, due to a recursive action on validation (as far as I can tell).\r\n\r\n### Repro\r\n```JavaScript\r\nconst { Mongoose, Model, Schema } = require('mongoose');\r\n\r\ndescribe('mongoose discriminated classes', () => {\r\n  it('should save correctly', function* () {\r\n    let mongoose = new Mongoose();\r\n    class Shape extends Model { };\r\n    class Circle extends Shape { };\r\n    mongoose.model(Shape, new Schema({ color: String }));\r\n    Shape.discriminator(Circle, new Schema({ radius: Number }));\r\n\r\n    let circle = new Circle({ color: 'blue', radius: 3 });\r\n\r\n    yield circle.save();  // << Throws here (1)\r\n  });\r\n});\r\n```\r\n\r\nThis is the top and bottom of the stack (the middle is the recursive repetition):\r\n```\r\nRangeError: Maximum call stack size exceeded\r\n      at Circle.wrappedPointCut [as validate] (node_modules\\mongoose\\lib\\services\\model\\applyHooks.js:104:29)\r\n      at Circle._done (node_modules\\hooks-fixed\\hooks.js:101:24)\r\n      at _asyncsDone (node_modules\\hooks-fixed\\hooks.js:36:36)\r\n      at fnWrapper (node_modules\\hooks-fixed\\hooks.js:186:8)\r\n      at Circle.fn (node_modules\\mongoose\\lib\\schema.js:255:9)\r\n      at _next (node_modules\\hooks-fixed\\hooks.js:62:30)\r\n      at fnWrapper (node_modules\\hooks-fixed\\hooks.js:186:8)\r\n      at Circle.fn (node_modules\\mongoose\\lib\\schema.js:254:9)\r\n      at Circle._next (node_modules\\hooks-fixed\\hooks.js:62:30)\r\n     [...]\r\n      at Circle.proto.(anonymous function) [as $__original_validate] (node_modules\\hooks-fixed\\hooks.js:108:20)\r\n      at node_modules\\mongoose\\lib\\services\\model\\applyHooks.js:135:27\r\n      at Circle.wrappedPointCut [as validate] (node_modules\\mongoose\\lib\\services\\model\\applyHooks.js:115:23)\r\n      at Circle._done (node_modules\\hooks-fixed\\hooks.js:101:24)\r\n      at _asyncsDone (node_modules\\hooks-fixed\\hooks.js:36:36)\r\n      at fnWrapper (node_modules\\hooks-fixed\\hooks.js:186:8)\r\n      at Circle.fn (node_modules\\mongoose\\lib\\schema.js:255:9)\r\n      at _next (node_modules\\hooks-fixed\\hooks.js:62:30)\r\n      at fnWrapper (node_modules\\hooks-fixed\\hooks.js:186:8)\r\n      at Circle.fn (node_modules\\mongoose\\lib\\schema.js:254:9)\r\n      at Circle._next (node_modules\\hooks-fixed\\hooks.js:62:30)\r\n      at Circle.proto.(anonymous function) [as $__original_validate] (node_modules\\hooks-fixed\\hooks.js:108:20)\r\n      at Circle.fn (node_modules\\mongoose\\lib\\schema.js:198:18)\r\n      at Circle._next (node_modules\\hooks-fixed\\hooks.js:62:30)\r\n      at Circle.proto.(anonymous function) [as $__original_save] (node_modules\\hooks-fixed\\hooks.js:108:20)\r\n      at node_modules\\mongoose\\lib\\services\\model\\applyHooks.js:135:27\r\n      at Circle.wrappedPointCut [as save] (node_modules\\mongoose\\lib\\services\\model\\applyHooks.js:115:23)\r\n     [at unit test (1)]\r\n```\r\n\r\n### Version tested\r\nnode 6.7.0\r\nmongoose 4.8.4\r\nmongodb 3.4"},{"labels":["bug"],"text":"I'm migrating our codebase from lodash 3 to 4 and since (_.clone) doesn't seem to work anymore for Mongoose objects and was anyway discouraged I started to use `mongooseObject.toObject()` in place of it.\r\n\r\nMy impression was that `.toObject()` would create new objects based on the current document data  and no link to the original object like a clone, but instead it seems like changes to original mongoose objects get propagated to the ones created by `toObject()`.\r\n\r\nNot sure if my assumption that toObject would clone is wrong or if it's a bug but anyway I thought it would be useful to report it.\r\n\r\n<img width=\"533\" alt=\"schermata 2017-02-22 alle 18 53 35\" src=\"https://cloud.githubusercontent.com/assets/589911/23224878/3eab9a14-f930-11e6-8ab7-4c13f78b68ee.png\">\r\n<img width=\"841\" alt=\"schermata 2017-02-22 alle 18 53 24\" src=\"https://cloud.githubusercontent.com/assets/589911/23224877/3ea999da-f930-11e6-8d55-21321e5555ec.png\">\r\n\r\nnotice how the change to progress.down is applied to the cloned object too"},{"labels":["bug"],"text":"Hi,\r\n\r\nI was using `.stream()` in some libraries and, in order to fix the :\r\n`DeprecationWarning: Mongoose: Query.prototype.stream() is deprecated in mongoose >= 4.5.0, use Query.prototype.cursor() instead`\r\nI'm basically trying to replace `stream()` by `cursor()` and I'm facing a strange bug (which does not if I rollback to `stream()`), the last document in the database is just not receive.\r\n\r\n    var mongoose = require('mongoose');\r\n    global.Promise = mongoose.Promise = require('bluebird');\r\n\r\n    var userSchema = new mongoose.Schema({\r\n      name:  String\r\n    });\r\n\r\n    var User = mongoose.model('User', userSchema);\r\n\r\n    mongoose.connect(\r\n      'mongodb://127.0.0.1/test',\r\n      {},\r\n      function (err) {\r\n        if (err) {\r\n          return console.error(err);\r\n        }\r\n\r\n        User\r\n          .remove({}) // clean db test\r\n          .exec()\r\n          .then(function () {\r\n            var users = [];\r\n            for (var i = 0; i < 100; i++) {\r\n              users.push({\r\n                _id: mongoose.Types.ObjectId(),\r\n                name: 'Bob' + (i < 10 ? '0' : '') + i\r\n              });\r\n            }\r\n\r\n            console.log('User count: ' + users.length);  // => 100\r\n            return User.insertMany(users);\r\n            /*\r\n            // classic save do the same\r\n            return Promise.all(users.map(function (user) {\r\n              return new User(user).save();\r\n            }));\r\n            */\r\n          })\r\n          .then(function () {\r\n            return new Promise(function (resolve) {\r\n\r\n              var stream = User.find({}).cursor();\r\n              var docs = [];\r\n\r\n              stream.on('data', function (doc) {\r\n                docs.push(doc);\r\n              });\r\n\r\n              stream.on('close', function () {\r\n                var names = docs.map(function (doc) {\r\n                  return doc.name;\r\n                });\r\n                names.sort();\r\n                console.log(names);\r\n\r\n                console.log('Doc count: ' + docs.length); // => return 99 instead of 100\r\n                resolve();\r\n              });\r\n\r\n            });\r\n          })\r\n          .then(function () {\r\n            mongoose.disconnect();\r\n          });\r\n      }\r\n    );\r\n\r\n\r\nIn my case, the missing document is the \"BOB37\" which is in the database the last go by `db.users.find()`+ `it` * 4\r\n\r\nStrangely, the bug seems to depends on the document count in database, there are some count which does not bugs: 2000, 2001 while 2002 bugs...\r\n\r\n\r\n\r\nTested on mongoose 4.5 and 4.8.3 with mongo db version v3.0.7"},{"labels":["bug"],"text":"After the last update to version 4.8.3 the code below gives an exception.\r\n\r\n```js\r\nvar mongoose = require(\"mongoose\");\r\nmongoose.connect('mongodb://localhost:27017/test');\r\nvar db = mongoose.connection;\r\ndb.on('error', console.error.bind(console, 'connection error:'));\r\ndb.once('open', function () {\r\n    console.log(\"Connected...\");\r\n});\r\n\r\nschema = mongoose.Schema({\r\n    _id: {type: Number, match: /^\\d+/},\r\n    description: String\r\n});\r\nvar model = mongoose.model(\"installation\", schema);\r\nmodel.findOneAndUpdate({\"_id\": 140}, {\"_id\": 999}, {new: true}, function (err, data) {\r\n    if (err) return console.error(err);\r\n    console.log(data);\r\n});\r\n```\r\n\r\nResults in:\r\n```\r\nTypeError: Cannot read property 'value' of null\r\n    at C:\\clv\\test_thread_safety\\node_modules\\mongoose\\lib\\query.js:2012:27\r\n    at C:\\clv\\test_thread_safety\\node_modules\\mongoose\\lib\\utils.js:512:16\r\n    at handleCallback (C:\\clv\\test_thread_safety\\node_modules\\mongoose\\node_modules\\mongodb\\lib\\utils.js:95:56)\r\n    at C:\\clv\\test_thread_safety\\node_modules\\mongoose\\node_modules\\mongodb\\lib\\collection.js:2485:22\r\n    at handleCallback (C:\\clv\\test_thread_safety\\node_modules\\mongoose\\node_modules\\mongodb\\lib\\utils.js:95:56)\r\n    at C:\\clv\\test_thread_safety\\node_modules\\mongoose\\node_modules\\mongodb\\lib\\db.js:311:20\r\n    at C:\\clv\\test_thread_safety\\node_modules\\mongoose\\node_modules\\mongodb-core\\lib\\connection\\pool.js:455:18\r\n    at _combinedTickCallback (internal/process/next_tick.js:67:7)\r\n    at process._tickCallback (internal/process/next_tick.js:98:9)\r\n```\r\nIn version 4.8.2 mongoose was returning correclty the error from mongodb when a query tries to change an immutable field:\r\n```js\r\n{ MongoError: After applying the update to the document {_id: 140 , ...}, the (immutable) field '_id' was found to have been altered to _id: 999\r\n    at Function.MongoError.create (C:\\clv\\test_thread_safety\\node_modules\\mongodb-core\\lib\\error.js:31:11)\r\n    at C:\\clv\\test_thread_safety\\node_modules\\mongodb-core\\lib\\connection\\pool.js:483:72\r\n    at authenticateStragglers (C:\\clv\\test_thread_safety\\node_modules\\mongodb-core\\lib\\connection\\pool.js:429:16)\r\n    at Connection.messageHandler (C:\\clv\\test_thread_safety\\node_modules\\mongodb-core\\lib\\connection\\pool.js:463:5)\r\n    at Socket.<anonymous> (C:\\clv\\test_thread_safety\\node_modules\\mongodb-core\\lib\\connection\\connection.js:319:22)\r\n    at emitOne (events.js:96:13)\r\n    at Socket.emit (events.js:188:7)\r\n    at readableAddChunk (_stream_readable.js:176:18)\r\n    at Socket.Readable.push (_stream_readable.js:134:10)\r\n    at TCP.onread (net.js:548:20)\r\n  name: 'MongoError',\r\n  message: 'After applying the update to the document {_id: 140 , ...}, the (immutable) field \\'_id\\' was found to have been altered to _id: 999',\r\n  ok: 0,\r\n  errmsg: 'After applying the update to the document {_id: 140 , ...}, the (immutable) field \\'_id\\' was found to have been altered to _id: 999',\r\n  code: 66,\r\n  codeName: 'ImmutableField' }\r\n```\r\n\r\nMongodb version is 3.4.0. The document with id 140 is in the database in the correct collection (installations)."},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nWhen a base model is used to retrieve a discriminator model document, it does not honor `select: false`.\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n```javascript\r\nconst mongoose = require('mongoose');\r\nmongoose.Promise = global.Promise;\r\nconst co = require('co');\r\nconst chalk = require('chalk');\r\n\r\nconst GITHUB_ISSUE = `test-constructor-emit-bug`;\r\n\r\nexec()\r\n  .then(() => {\r\n    console.log(chalk.green(`Successfully ran program`));\r\n    process.exit(0);\r\n  })\r\n  .catch(error => {\r\n    console.log(chalk.red(`Error: ${ error }\\n${ error.stack }`));\r\n    process.exit(2);\r\n  });\r\n\r\nfunction exec() {\r\n  return co(function* () {\r\n    const db = mongoose.createConnection(`mongodb://localhost:27017/${ GITHUB_ISSUE }`);\r\n    const { Base, Discriminator } = createModels(db);\r\n    const { baseDoc, discrimDoc } = yield seedDb({ Base, Discriminator });\r\n\r\n    const docFromDb = yield Base.findById(discrimDoc._id) // does not honor select: false\r\n    // const docFromDb = yield Discriminator.findById(discrimDoc._id); // honors select: false\r\n    console.log(docFromDb.internal); // should not log `internal.password`\r\n  });\r\n}\r\n\r\nfunction seedDb(models) {\r\n  return co(function*() {\r\n    const { Base, Discriminator } = models;\r\n    \r\n    yield [Base.remove({}), Discriminator.remove({})];\r\n\r\n    const baseDoc = yield Base.create({ internal: { diseases: ['Malaria'] }});\r\n    const discrimDoc = yield Discriminator.create({ internal: {\r\n      diseases: ['MS'],\r\n      password: 'plain_test_password_ftw'\r\n    }});\r\n\r\n    return { baseDoc, discrimDoc };\r\n  });\r\n}\r\n\r\nfunction createModels(db) {\r\n  const baseSchema = new mongoose.Schema({\r\n    internal: {\r\n      diseases: [{ type: String }]\r\n    }\r\n  });\r\n\r\n  const Base = db.model('Base', baseSchema);\r\n  const discriminatorSchema = new mongoose.Schema({\r\n    internal: {\r\n      password: { type: String, select: false }\r\n    }\r\n  });\r\n  const Discriminator = Base.discriminator('Discriminator', discriminatorSchema);\r\n\r\n  return { Base, Discriminator };\r\n}\r\n```\r\n\r\n**What is the expected behavior?**\r\nWe should probably unselect those fields manually after fetching from the database, since mongoose doesn't know ahead of time which discriminators to select for.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nnode 6.9.2, mongoose 4.8.3, mongodb 3.4"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\n\r\nBug\r\n\r\n**What is the current behavior?**\r\n\r\nOutput with debug flag, in version 4.8.3\r\n\r\n```shell\r\nMongoose: tags.remove({}, {})\r\nMongoose: tags.insert({ updatedAt: new Date(\"Thu, 16 Feb 2017 07:25:10 GMT\"), createdAt: new Date(\"Thu, 16 Feb 2017 07:25:10 GMT\"), name: 'test', _id: ObjectId(\"58a553d63c8b3681f702e00b\"), tags: [], __v: 0 })\r\nMongoose: tags.findOne({}, { fields: undefined })\r\nMongoose: tags.update({ _id: ObjectId(\"58a553d63c8b3681f702e00b\") }, { '$set': { updatedAt: new Date(\"Thu, 16 Feb 2017 07:25:10 GMT\") }, '$setOnInsert': { createdAt: new Date(\"Thu, 16 Feb 2017 07:25:10 GMT\") } }, { overwrite: undefined })\r\nMongoose: tags.findOne({ _id: ObjectId(\"58a553d63c8b3681f702e00b\") }, { fields: undefined })\r\n{ _id: 58a553d63c8b3681f702e00b,\r\n  updatedAt: 2017-02-16T07:25:10.938Z,\r\n  createdAt: 2017-02-16T07:25:10.917Z,\r\n  name: 'test',\r\n  __v: 0,\r\n  tags: [] }\r\n```\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a stadalone script / gist to reproduce your issue -->\r\n\r\nReproduce script\r\n\r\n```js\r\nconst mongoose = require('mongoose');\r\nconst Schema = mongoose.Schema;\r\n\r\nmongoose.connect('mongodb://localhost/mongoose-issue');\r\nmongoose.set('debug', true);\r\n\r\nconst TagSchema = new Schema({\r\n    name: String,\r\n    tags: [{\r\n        enum: ['test1', 'test2'],\r\n        type: String,\r\n        index: true,\r\n    }],\r\n}, {\r\n    timestamps: true,\r\n});\r\n\r\nconst Tag = mongoose.model('Tag', TagSchema);\r\nlet tagId;\r\n\r\nTag.remove({}).\r\n    then(() => Tag.create({ name: 'test' })).\r\n    then(() => Tag.findOne()).\r\n    then((tag) => {\r\n        tagId = tag._id;\r\n        return Tag.update({\r\n            _id: tagId\r\n        }, {\r\n            $set: {\r\n                tags: ['test1']\r\n            }\r\n        });\r\n    }).\r\n    then(() => Tag.findById(tagId)).\r\n    then(console.log);\r\n```\r\n\r\n**What is the expected behavior?**\r\n\r\nIn version 4.8.2\r\n\r\n```shell\r\nMongoose: tags.remove({}, {})\r\nMongoose: tags.insert({ updatedAt: new Date(\"Thu, 16 Feb 2017 07:30:28 GMT\"), createdAt: new Date(\"Thu, 16 Feb 2017 07:30:28 GMT\"), name: 'test', _id: ObjectId(\"58a55514714bd682afe1e5fa\"), tags: [], __v: 0 })\r\nMongoose: tags.findOne({}, { fields: undefined })\r\nMongoose: tags.update({ _id: ObjectId(\"58a55514714bd682afe1e5fa\") }, { '$setOnInsert': { createdAt: new Date(\"Thu, 16 Feb 2017 07:30:28 GMT\") }, '$set': { tags: [ 'test1' ], updatedAt: new Date(\"Thu, 16 Feb 2017 07:30:28 GMT\") } }, { overwrite: undefined })\r\nMongoose: tags.findOne({ _id: ObjectId(\"58a55514714bd682afe1e5fa\") }, { fields: undefined })\r\n{ _id: 58a55514714bd682afe1e5fa,\r\n  updatedAt: 2017-02-16T07:30:28.611Z,\r\n  createdAt: 2017-02-16T07:30:28.592Z,\r\n  name: 'test',\r\n  __v: 0,\r\n  tags: [ 'test1' ] }\r\n```\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\n\r\n```\r\nâžœ node --version\r\nv7.3.0\r\nâžœ npm ls | grep mongo\r\nâ”œâ”€â”¬ mongoose@4.8.3\r\nâ”‚ â”œâ”€â”¬ mongodb@2.2.22\r\nâ”‚ â”‚ â”œâ”€â”¬ mongodb-core@2.1.7\r\n```\r\n"},{"labels":["bug"],"text":"#### Do you want to request a feature or report a bug?\r\nBug.\r\n\r\n#### What is the current behavior ?\r\nCreating a document as described in [mongoose guide](http://mongoosejs.com/docs/browser.html) fails with an exception if a [custom type](http://mongoosejs.com/docs/customschematypes.html) is used in the schema.\r\n\r\n- Firefox 50.1.0: \r\n```\r\nTypeError: this.constructor.emit is not a function 1 bundle.js:24619:4\r\n\tDocument.prototype.init http://mihai:8080/bundle.js:24619:4\r\n\tDocument http://mihai:8080/bundle.js:28929:6\r\n\t<anonymous> http://mihai:8080/bundle.js:950:21\r\n\t__webpack_require__ http://mihai:8080/bundle.js:20:12\r\n\t<anonymous> http://mihai:8080/bundle.js:48:19\r\n\t__webpack_require__ http://mihai:8080/bundle.js:20:12\r\n\t<anonymous> http://mihai:8080/bundle.js:40:18\r\n\t<anonymous> http://mihai:8080/bundle.js:1:11\r\n```\r\n- Chromium 55.0.2883.87:\r\n```\r\nUncaught TypeError: this.constructor.emit is not a function\r\n    at Document.init (bundle.js:24619)\r\n    at new Document (bundle.js:28929)\r\n    at Object.<anonymous> (bundle.js:950)\r\n    at __webpack_require__ (bundle.js:20)\r\n    at Object.<anonymous> (bundle.js:48)\r\n    at __webpack_require__ (bundle.js:20)\r\n    at bundle.js:40\r\n    at bundle.js:43\r\n```\r\n\r\n#### If the current behavior is a bug, please provide the steps to reproduce.\r\n+ Directory structure:\r\n```\r\nbuild/\r\n  index.html\r\nnode_modules/\r\npackage.json\r\nsrc/\r\n  main.js\r\nwebpack.config.js\r\n```\r\n\r\n+ package.json (some are redundant):\r\n```\r\n{\r\n  \"name\": \"test\",\r\n  \"version\": \"1.0.0\",\r\n  \"description\": \"\",\r\n  \"main\": \"index.js\",\r\n  \"scripts\": {\r\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\r\n  },\r\n  \"author\": \"\",\r\n  \"license\": \"ISC\",\r\n  \"dependencies\": {\r\n    \"babel-core\": \"^6.18.2\",\r\n    \"babel-loader\": \"^6.2.10\",\r\n    \"babel-preset-es2015\": \"^6.18.0\",\r\n    \"babel-preset-react\": \"^6.16.0\",\r\n    \"babel-preset-stage-0\": \"^6.16.0\",\r\n    \"babel-regenerator-runtime\": \"^6.5.0\",\r\n    \"json-loader\": \"^0.5.4\",\r\n    \"lru-cache\": \"^4.0.2\",\r\n    \"mongoose\": \"^4.8.2\",\r\n    \"unicode-properties\": \"^1.1.0\",\r\n    \"webpack\": \"^1.13.3\"\r\n  }\r\n}\r\n```\r\n\r\n+ webpack.config.js:\r\n```\r\nvar path = require('path');\r\nvar webpack = require('webpack');\r\n\r\nmodule.exports = {\r\n  context: __dirname,\r\n  entry: ['babel-regenerator-runtime', `${__dirname}/src/main.js`],\r\n  output: {\r\n    path: `${__dirname}/build`,\r\n    filename: 'bundle.js',\r\n    publicPath: '/'\r\n  },\r\n  module: {\r\n    loaders: [\r\n      {\r\n        test: /.jsx?$/,\r\n        loader: 'babel-loader',\r\n        exclude: /node_modules/,\r\n        query: {\r\n          presets: ['es2015', 'stage-0', 'react']\r\n        }\r\n      },\r\n      {\r\n        test: /\\.json$/, loader: \"json-loader\"\r\n      }\r\n    ]\r\n  },\r\n  target: 'web',\r\n};\r\n```\r\n\r\n+ build/index.html:\r\n```\r\n<html>\r\n  <head>\r\n    <script type=\"text/javascript\" src='./bundle.js'></script>\r\n  </head>\r\n  <body>\r\n\r\n  </body>\r\n</html>\r\n```\r\n\r\n+ src/main.js:\r\n```\r\nimport {Schema, SchemaType, Document} from 'mongoose';\r\n\r\nclass MyTrueType extends SchemaType {\r\n  constructor(key, options) {\r\n    console.log('Schema instance', key, options);\r\n    super(key, options, 'MyTrueType');\r\n  }\r\n\r\n  cast(val, ...args) {\r\n    console.log('Casting', val, ...args);\r\n\r\n    return val;\r\n  }\r\n}\r\n\r\nSchema.Types.MyTrueType = MyTrueType;\r\n\r\nlet TrueObjectSchema = new Schema({test: MyTrueType});\r\nlet trueDocument = new Document({test: 'bla'}, TrueObjectSchema);\r\n\r\n// Never reaches this point\r\nconsole.log('Here is the true doc', trueDocument);\r\nconsole.log('Validation:', doc.validate());\r\n```\r\n\r\n+ Steps to reproduce:\r\n  - In the terminal, in the main directory:\r\n    ```\r\n    $ npm install\r\n    $ npm install -g webpack-dev-server\r\n    $  webpack-dev-server -w --content-base build/ --port <somePort> --config webpack.config.js\r\n    ```\r\n  - Open a browser at `localhost:<somePort>`, error should be in the console\r\n\r\n#### What is the expected behavior?\r\nIf documentation doesn't explicitly mention this combination to fail, it should work.\r\n\r\nBy what I've grasped from the source, it's not even related to custom types; `this.constructor` points to the `BrowserDocument` class which doesn't have an `emit` method. I don't really know whether it should. I haven't tested documents with simple types, but as I understand it, it should fail as well ?\r\n\r\n#### Please mention your node.js, mongoose and MongoDB version.\r\n- Node: 6.0.0;\r\n- MongoDB: not applicable;\r\n- mongoose: 4.8.2;"},{"labels":["bug",null,null],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?**\r\nDiscriminator models mutate the underlying schema which is passed by reference, rather than by copy. This makes discriminator models significantly harder to test because they retain state from schema singletons across test blocks (and might also cause nasty bugs in applications that statefully use the schemas underlying any given discriminator model). \r\n\r\nIf you try to create the same discriminator model twice within a test file, it'll complain: `Error: Discriminator \"{ModelName}\" cannot have field with name \"{DiscriminatorKey}\"`\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n1) `yarn / npm install mongoose co assert mocha`\r\n2) `$(npm bin)/mocha {filename}`\r\n\r\n```javascript\r\nconst mongoose = require('mongoose');\r\nconst co = require('co');\r\nconst assert = require('assert');\r\n\r\nmongoose.Promise = global.Promise;\r\n\r\n// Globals: place schemas here as a global to mimick the singleton pattern\r\nconst globals = {\r\n  baseSchema: new mongoose.Schema({\r\n    profile: {\r\n      name: String,\r\n      email: String\r\n    }\r\n  }, { timestamps: true }),\r\n\r\n  discriminatorSchema: new mongoose.Schema({\r\n    profile: {\r\n      address: { city: String, line1: String }\r\n    }\r\n  })\r\n};\r\n\r\n// Constants\r\nconst GITHUB_ISSUE = `overwrite-discriminators-bug`;\r\n\r\ndescribe('before each bug with discriminators', function() {\r\n  let Base;\r\n  let Discriminator;\r\n  let db;\r\n\r\n  function init() {\r\n    return co(function* () {\r\n      db = yield connectToDb();\r\n      const models = createModels(db);\r\n      Base = models.Base;\r\n      Discriminator = models.Discriminator;\r\n    });\r\n  }\r\n\r\n  describe('Block 1', function() {\r\n    before(function(done) {\r\n      co(function* () {\r\n        yield init();\r\n        done();\r\n      }).catch(done);\r\n    });\r\n\r\n    after(function(done) {\r\n      db.close();\r\n      done();\r\n    });\r\n\r\n    it('test 1', function(done) {\r\n      assert.ok(true);\r\n      done();\r\n    });\r\n\r\n    it('test 2', function(done) {\r\n      assert.ok(true);\r\n      done();\r\n    });\r\n  });\r\n\r\n  describe('Block 2', function() {\r\n    beforeEach(function(done) {\r\n      co(function* () {\r\n        yield init();\r\n        done();\r\n      }).catch(done);\r\n    });\r\n\r\n    after(function(done) {\r\n      db.close();\r\n      done();\r\n    });\r\n\r\n    it('test 3', function(done) {\r\n      assert.ok(true);\r\n      done();\r\n    });\r\n\r\n    it('test 4', function(done) {\r\n      assert.ok(true);\r\n      done();\r\n    });\r\n  });\r\n});\r\n\r\nfunction createModels(db) {\r\n\r\n  const Base = db.model('Base', globals.baseSchema);\r\n  const Discriminator = Base.discriminator('Discriminator', globals.discriminatorSchema);\r\n  return { Base, Discriminator };\r\n}\r\n\r\nfunction connectToDb() {\r\n  return co(function* () {\r\n    return mongoose.createConnection(`mongodb://localhost:27017/${GITHUB_ISSUE}`);\r\n  });\r\n}\r\n\r\n\r\n```\r\n\r\n**What is the expected behavior?**\r\nMongoose should create a copy of the schema so that if you try to recreate the discriminator model, it does not already have the discriminator key\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNode v6.9.2, mongodb v3.4.1, mongoose v4.8.2"},{"labels":["bug"],"text":"```\r\nvar mongoose = require('mongoose');\r\nmongoose.Promise = require('bluebird');\r\nvar Schema = mongoose.Schema;\r\n\r\nmongoose.connect('mongodb://localhost/test');\r\n\r\nvar ProductSchema = new Schema({\r\n  name: String\r\n});\r\n\r\nvar UserSchema = new Schema({\r\n  sell: [{\r\n    product: ProductSchema\r\n  }]\r\n});\r\n\r\nvar User = mongoose.model('User', UserSchema);\r\n\r\nreturn User.create({})\r\n.then(function(user) {\r\n  return User.update({\r\n    _id: user._id\r\n  }, {\r\n    sell: [{\r\n      product: {\r\n        name: 'Product 1'\r\n      }\r\n    }]\r\n  }, {\r\n    runValidators: true\r\n  });\r\n});\r\n```\r\n\r\nGives the error `TypeError: value.validate is not a function`. Update validation doesn't seem to like an array of objects with nested schema.\r\n\r\nmongoose version: 4.8.1\r\nmongodb version: 3.2.6"},{"labels":["bug"],"text":"Hi,\r\n\r\nI have a simple schema with a Buffer property, when creating a document I can set the property to `null` with no issues, but when issuing an update command setting the property to `null` I get an exception, is it not a valid operation?\r\n\r\nExample:\r\n```js\r\nvar mongoose = require('mongoose');\r\nvar conn = mongoose.createConnection('mongodb://127.0.0.1/test', {user: 'test', pass: 'test'});\r\n\r\nvar ItemSchema = new mongoose.Schema({\r\n    owner: { type: mongoose.Schema.Types.Buffer },\r\n    name: {type: String},\r\n}, { collection: 'items' });\r\n\r\nvar ItemModel = conn.model('Item', ItemSchema);\r\n\r\nvar item = new ItemModel({owner: null, name: 'item1'});\r\nitem.save().then(res => {\r\n    console.log('Saved with owner null -->', res)\r\n\r\n    // Update to some non-null value is OK\r\n    ItemModel.findOneAndUpdate({name: 'item1'}, {owner: new Buffer('Joe')}, {new: true}).then(res => {\r\n        console.log('Updated to Joe -->', res);\r\n\r\n        console.log('Updating back to null will throw');\r\n        ItemModel.findOneAndUpdate({name: 'item1'}, {owner: null}, {new: true}).then(r => console.log(r)).catch(e => console.log(e));\r\n    });\r\n});\r\n```\r\n\r\nOutput:\r\n```\r\nSaved with owner null --> { __v: 0,\r\n  owner: null,\r\n  name: 'item1',\r\n  _id: 5891b9116c280c1df8f7c58b }\r\nUpdated to Joe --> { _id: 5891b9116c280c1df8f7c58b,\r\n  owner:\r\n   Binary {\r\n     _bsontype: 'Binary',\r\n     sub_type: 0,\r\n     position: 3,\r\n     buffer: <Buffer 4a 6f 65> },\r\n  name: 'item1',\r\n  __v: 0 }\r\nUpdating back to null will throw\r\nTypeError: Cannot read property 'toObject' of null\r\n    at SchemaBuffer.castForQuery (C:\\temp\\mongo\\node_modules\\mongoose\\lib\\schema\\buffer.js:181:24)\r\n    at Query._castUpdateVal (C:\\temp\\mongo\\node_modules\\mongoose\\lib\\query.js:2881:17)\r\n    at Query._walkUpdatePath (C:\\temp\\mongo\\node_modules\\mongoose\\lib\\query.js:2825:25)\r\n    at Query._castUpdate (C:\\temp\\mongo\\node_modules\\mongoose\\lib\\query.js:2697:23)\r\n    at castDoc (C:\\temp\\mongo\\node_modules\\mongoose\\lib\\query.js:2904:18)\r\n    at Query._findAndModify (C:\\temp\\mongo\\node_modules\\mongoose\\lib\\query.js:1928:17)\r\n    at Query._findOneAndUpdate (C:\\temp\\mongo\\node_modules\\mongoose\\lib\\query.js:1784:8)\r\n    at C:\\temp\\mongo\\node_modules\\kareem\\index.js:244:8\r\n    at C:\\temp\\mongo\\node_modules\\kareem\\index.js:18:7\r\n    at _combinedTickCallback (internal/process/next_tick.js:67:7)\r\n    at process._tickCallback (internal/process/next_tick.js:98:9)\r\n```\r\n\r\nAm I doing something wrong?\r\nLooking at `SchemaBuffer.castForQuery@181`:\r\n`return this.cast(val).toObject({ transform: false, virtuals: false });`\r\nBut `SchemaBuffer.cast` explicitly returns `null` at line 129, so I guess it should be handled in `SchemaBuffer.castForQuery@181`, simple fix:\r\n```js\r\nvar casted = this.cast(val);\r\nreturn casted ? casted.toObject({ transform: false, virtuals: false }) : casted;\r\n```\r\n\r\nIdeas? Thx!\r\n\r\nVersions:\r\nmongodb@3.4.0\r\nmongoose@4.8.1\r\nnode@6.9.1\r\n"},{"labels":["bug"],"text":"I'm using ES6 classes to create a subclassed... class. However, when I try to setup the discriminator it throws an exception.\r\n\r\n**Repro**\r\n```JavaScript\r\nclass Shape extends Model { };\r\nclass Circle extends Shape { };\r\nmongoose.model(Shape, new Schema({ color: String }));\r\nShape.discriminator(Circle, new Schema({ radius: Number })); // <<< Throws here\r\n```\r\n\r\nThe relevant stack:\r\n```\r\n     Error: Virtual path \"__v\" conflicts with a real path in the schema\r\n      at Schema.virtual (node_modules\\mongoose\\lib\\schema.js:1483:11)\r\n      at Schema.<anonymous> (node_modules\\mongoose\\lib\\schema.js:1606:12)\r\n      at Array.forEach (native)\r\n      at Schema.loadClass (node_modules\\mongoose\\lib\\schema.js:1595:47)\r\n      at Schema.loadClass (node_modules\\mongoose\\lib\\schema.js:1613:16)\r\n      at Function.compile (node_modules\\mongoose\\lib\\model.js:3243:12)\r\n      at Mongoose.model (node_modules\\mongoose\\lib\\index.js:408:22)\r\n      at NativeConnection.Connection.model (node_modules\\mongoose\\lib\\connection.js:753:23)\r\n      at Function.discriminator (node_modules\\mongoose\\lib\\model.js:884:39)\r\n```\r\n\r\nOut of curiosity, I disabled versioning too, to see if it was related to that as the error message implies\r\n\r\n```JavaScript\r\nmongoose.model(Shape, new Schema({ color: String }, { versionKey: false }));\r\nShape.discriminator(Circle, new Schema({ radius: Number }, { versionKey: false }));\r\n```\r\n\r\nBut the exception remains:\r\n```\r\n     Error: Virtual path \"_id\" conflicts with a real path in the schema\r\n      at Schema.virtual (node_modules\\mongoose\\lib\\schema.js:1483:11)\r\n      at Schema.<anonymous> (node_modules\\mongoose\\lib\\schema.js:1606:12)\r\n      at Array.forEach (native)\r\n      at Schema.loadClass (node_modules\\mongoose\\lib\\schema.js:1595:47)\r\n      at Schema.loadClass (node_modules\\mongoose\\lib\\schema.js:1613:16)\r\n      at Function.compile (node_modules\\mongoose\\lib\\model.js:3243:12)\r\n      at Mongoose.model (node_modules\\mongoose\\lib\\index.js:408:22)\r\n      at NativeConnection.Connection.model (node_modules\\mongoose\\lib\\connection.js:753:23)\r\n      at Function.discriminator (node_modules\\mongoose\\lib\\model.js:884:39)\r\n```\r\n\r\n**Version tested**\r\nnode 6.7.0\r\nmongoose 4.7.7\r\nmongodb none (this test is purely disconnected)\r\n"},{"labels":["bug"],"text":"Mongoose 4.7.9\r\n\r\nJust started having this Error on code that has been working for months:\r\n\r\n```\r\nError: Can't use $exists with Array. at SchemaArray.castForQuery (/app/node_modules/mongoose/lib/schema/array.js:210:13)\r\n```\r\n\r\nCould it be related to #4933 ?"},{"labels":["bug"],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n\r\n**What is the current behavior?** \r\n\r\nPost Find hook propagates 'error' and 'docs' for the same set of parameters. (maybe for other hooks as well)\r\n\r\nExample: \r\n\r\n```javascript\r\n   \r\n   // Scenario #1\r\n   schema.pre('find', function (next) {\r\n        console.log('---------------pre');\r\n        return next(new Error(`error!!`));\r\n    });\r\n\r\n    schema.post('find', function (docs, next) {\r\n        console.log('---------------post', docs, next); // here docs is the \"Error\" that was passed on by the 'pre' middleware\r\n        return next(docs);\r\n    });\r\n\r\n   // Scenario #2\r\n   schema.pre('find', function (next) {\r\n        // Not passing any error.\r\n        console.log('---------------pre'); \r\n        return next();\r\n    });\r\n\r\n    schema.post('find', function (docs, next) {\r\n        console.log('---------------post', docs, next); // here docs is the actual result.\r\n        return next(docs);\r\n    });\r\n  \r\n   // This never gets called.\r\n   schema.post('find', function (err, docs, next) {\r\n         console.log('--------------', err);\r\n         next();\r\n   });\r\n\r\n\r\n```\r\n\r\n**What is the expected behavior?**\r\n\r\nNeeds to be consistent, the same param position, containing error and doc, for different scenario isn't right. It should probably be handled by the error handler.\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\n\r\nNode - v6.9.2\r\nMongoose - v4.7.3\r\n"},{"labels":["bug",null],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nbug\r\n\r\n**What is the current behavior?**\r\nPost-findOneAndUpdate middleware function defined with two arguments hangs when passRawResult=true. Apparently, it is passing a 3rd `next()` argument that it is expecting to be called. However, when I define the middleware function with 3 arguments, the middleware is skipped altogether (I'm guessing because it assumes this is 'error middleware'). I'm very confused about what is supposed to happen here, or how such middleware should be written for a plugin that is capable of handling both passRawResult=true and passRawResult=false scenarios...\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\nRunning \r\n`Model.findOneAndUpdate({ prop: 'xyz' }, { prop: 'abc' }, { upsert: true, passRawResult: true })`\r\nproduces the following behavior for each of the different middleware setups:\r\n\r\n```\r\n  // This is called, and is passed 2 arguments (the doc, and the raw result)\r\n  schema.post('findOneAndUpdate', function (doc) {\r\n    console.log(arguments)\r\n  })\r\n\r\n  // output:\r\n  //\r\n  // { '0': null,\r\n  //  '1': \r\n  //   { lastErrorObject: \r\n  //      { updatedExisting: false,\r\n  //        n: 1,\r\n  //     upserted: 5883edc039241549e8322aa0 },\r\n  //     value: null,\r\n  //     ok: 1,\r\n  //     _kareemIgnore: true } }\r\n```\r\n\r\n```\r\n  // This hangs, logging arguments shows that a 3rd hidden parameter (function) is passed\r\n  schema.post('findOneAndUpdate', function (doc, result) {\r\n    console.log(arguments)\r\n  })\r\n\r\n  // output:\r\n  //\r\n  // { '0': null,\r\n  //  '1': \r\n  //   { lastErrorObject: \r\n  //      { updatedExisting: false,\r\n  //        n: 1,\r\n  //     upserted: 5883edc039241549e8322aa0 },\r\n  //     value: null,\r\n  //     ok: 1,\r\n  //     _kareemIgnore: true },\r\n  //  '2': [Function]  }\r\n```\r\n\r\n```\r\n  // This is never called, presumably because it's assumed to be an error handler?\r\n  schema.post('findOneAndUpdate', function (doc, result, next) {\r\n    console.log(arguments)\r\n  })\r\n```\r\n\r\n```\r\n  // This is actually called, but next and _ are undefined\r\n  schema.post('findOneAndUpdate', function (doc, result, next, _) {\r\n    console.log(arguments)\r\n  })\r\n\r\n  // output:\r\n  //\r\n  // { '0': null,\r\n  //  '1': \r\n  //   { lastErrorObject: \r\n  //      { updatedExisting: false,\r\n  //        n: 1,\r\n  //     upserted: 5883edc039241549e8322aa0 },\r\n  //     value: null,\r\n  //     ok: 1,\r\n  //     _kareemIgnore: true } }\r\n```\r\n\r\n**What is the expected behavior?**\r\nI'd like to be able to access the raw result in my post middleware without causing it to hang. I'd also like to know what the appropriate signature is for a post middleware that might not know if the update operation set passRawResult to true or false\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNode 7.2.1, mongoose 4.7.7, mongodb 3.2"},{"labels":["bug",null],"text":"**Do you want to request a *feature* or report a *bug*?**\r\nBug\r\n**What is the current behavior?**\r\nWhen a MongoDB record was created with an _id as String instead of ObjectID, Mongoose fails to update the record but doesn't return an Error and instead returns a false record\r\n\r\n```javascript\r\nvar mongoose = require(\"mongoose\")\r\nmongoose.Promise = global.Promise\r\nmongoose.connect(\"mongodb://localhost/test\")\r\nvar db = mongoose.connection\r\ndb.on(\"error\", function(err){\r\n  console.log(\"MongoDB connection error:\")\r\n})\r\ndb.once(\"open\", function() {\r\n  console.log(\"Connection to MongoDB successful\")\r\n})\r\n\r\n// Create a user model to use for testing\r\nvar userSchema = new mongoose.Schema({\r\n  name: String,\r\n  email:{\r\n    type:String,\r\n    index:true,\r\n    unique:true,\r\n    required:true\r\n  }\r\n})\r\nvar user = mongoose.model(\"user\",userSchema)\r\n\r\n// Create a user that we want to save\r\nvar userToEnter = {\r\n  _id: \"5845368bcbd64060bc142bba\",\r\n  name:\"Foo\",\r\n  email:\"myemail@example\"\r\n}\r\n\r\n// If the user is entered into MongoDB directly (instead of via Mongoose)\r\n// the _id is not casted to ObjectID, but saved as a String\r\nuser.collection.insert(userToEnter)\r\n// => { \"_id\": \"5845368bcbd64060bc142bba\", \"name\": \"Foo\", \"email\": \"myemail@example\" }\r\n\r\n// Now try to update the record\r\nuser.findOne({ email:\"myemail@example\" }, function(err,record){\r\n  if (err){\r\n    console.log(err)\r\n  } else if (record) {\r\n    updateUser(record)\r\n  } else {\r\n    console.log(\"No user found\")\r\n  }\r\n})\r\n\r\nfunction updateUser(record){\r\n  record.name = \"Bar\"\r\n  record.save(function(err,newRecord,count){\r\n    if (err){\r\n      console.log(err)\r\n    } else {\r\n      userUpdated(newRecord,count)\r\n    }\r\n  })\r\n}\r\n\r\nfunction userUpdated(newRecord,count){\r\n  // The count is 0 and the returned object contains the saved changes.\r\n  // But the changes are not saved in MongoDB\r\n  console.log(\"Number of saved records: \"+count)\r\n  console.log(\"Record returned from Model.save: \"+JSON.stringify(newRecord))\r\n  console.log(\"Name: \"+newRecord.name)\r\n  user.findOne({ email:\"myemail@example\" }, function(err,record){\r\n    if (err){\r\n      console.log(err)\r\n    } else {\r\n      // MongoDB still contains the initial record\r\n      console.log(\"User after saving:\")\r\n      console.log(JSON.stringify(record))\r\n      console.log(\"Name: \"+record.name)\r\n    }\r\n  })\r\n}\r\n\r\n// Expected either an Error or:\r\n//    => Number of saved records: 1\r\n//    => Record returned from Model.save: { \"_id\": \"5845368bcbd64060bc142bba\", \"name\": \"Bar\", \"email\": \"myemail@example\" }\r\n//    => Name: Bar\r\n//    => User after saving:\r\n//    => { \"_id\": \"5845368bcbd64060bc142bba\", \"name\": \"Bar\", \"email\": \"myemail@example\" }\r\n//    => Name: Bar\r\n\r\n// Observed:\r\n//    => Number of saved records: 1\r\n//    => Record returned from Model.save: { \"_id\": \"5845368bcbd64060bc142bba\", \"name\": \"Bar\", \"email\": \"myemail@example\" }\r\n//    => Name: Bar\r\n//    => User after saving:\r\n//    => { \"_id\": \"5845368bcbd64060bc142bba\", \"name\": \"Foo\", \"email\": \"myemail@example\" }\r\n//    => Name: Foo\r\n```\r\n\r\n**What is the expected behavior?**\r\nMongoose should return an Error if the record can't be saved\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nNode v7.0.0\r\nMongoose Version: 4.7.7"},{"labels":["bug"],"text":"**Environment:**\r\n- Node.js 6.7.0\r\n- MongoDB 3.2.10\r\n- Mongoose 4.7.2\r\n\r\n**Steps to reproduce:**\r\n\r\n1. Execute the following test script:\r\n```js\r\nlet PaymentSchema = new db.Schema({\r\n  currency: {type: String, required: true, enum: ['USD'], default: 'USD'},\r\n  amount: {type: Number, required: true},\r\n});\r\n\r\nPaymentSchema.post('validate', function(error, doc, next) {\r\n  next(new Error('Invalid payment information'));\r\n});\r\n\r\nlet PaymentModel = db.model('Payment', PaymentSchema);\r\n\r\nlet payment = new PaymentModel({\r\n  currency: 'EUR',\r\n  amount: 10,\r\n});\r\n\r\npayment.validate()\r\n  .catch((error) => {\r\n    console.log(error.message);\r\n  });\r\n\r\nlet error = payment.validateSync();\r\nif (error) {\r\n  console.log(error.message);\r\n}\r\n```\r\n\r\n**Expected result:**\r\n- Post-validate error handler catches & converts all validation errors\r\n- Model validation methods `validate` and `validateSync` return converted error\r\n\r\n**Actual result:**\r\n- Post-validate error handler does NOT get called upon validation failure\r\n- Model validation methods return original error"},{"labels":["bug"],"text":"When using a custom `_id` attribute and indexing it as `unique` in the base schema, attempting to use discriminators fail.\r\n\r\nThe code (standalone script):\r\n\r\n```\r\nvar mongoose = require('mongoose');\r\nvar uuid     = require('uuid');\r\n\r\nmongoose.connect('mongodb://localhost:27017');\r\n\r\nvar options = {discriminatorKey: 'kind'};\r\n\r\nvar eventSchema = new mongoose.Schema({\r\n  _id: {\r\n    type: String,\r\n    default: uuid.v4,\r\n    unique: true,\r\n  },\r\n  time: Date\r\n}, options);\r\nvar Event = mongoose.model('Event', eventSchema);\r\n\r\n// ClickedLinkEvent is a special type of Event that has\r\n// a URL.\r\nvar ClickedLinkEvent = Event.discriminator('ClickedLink',\r\n  new mongoose.Schema({url: String}, options));\r\n```\r\n\r\nThe error\r\n```\r\n/mongoose-discriminator-bug/node_modules/mongoose/lib/utils.js:404\r\n      if (typeof to[key] === 'undefined') {\r\n                   ^\r\n\r\nTypeError: Cannot read property 'background' of null\r\n    at merge (/mongoose-discriminator-bug/node_modules/mongoose/lib/utils.js:404:20)\r\n    at merge (/mongoose-discriminator-bug/node_modules/mongoose/lib/utils.js:407:9)\r\n    at merge (/mongoose-discriminator-bug/node_modules/mongoose/lib/utils.js:407:9)\r\n    at Object.merge (/mongoose-discriminator-bug/node_modules/mongoose/lib/utils.js:407:9)\r\n    at merge (/mongoose-discriminator-bug/node_modules/mongoose/lib/model.js:814:11)\r\n    at Function.discriminator (/mongoose-discriminator-bug/node_modules/mongoose/lib/model.js:867:3)\r\n    at Object.<anonymous> (/mongoose-discriminator-bug/index.js:20:30)\r\n    at Module._compile (module.js:425:26)\r\n    at Object.Module._extensions..js (module.js:432:10)\r\n    at Module.load (module.js:356:32)\r\n    at Function.Module._load (module.js:311:12)\r\n    at Function.Module.runMain (module.js:457:10)\r\n    at startup (node.js:136:18)\r\n    at node.js:972:3\r\n```\r\n\r\nNode v5.0.0\r\nMongodb v3.2.6\r\nmongoose v4.7.6\r\n"},{"labels":["bug"],"text":"When I try to create a new record with the \"create\" Model method by supplying the _id as a String,\r\n```\r\nModel.create({\r\n      _id: \"5788683c1fa46a472a051543\"\r\n     name: \"abc\"\r\n});\r\n```\r\n it fails with the following error:\r\n`{\"errors\":{\"_id\":{\"message\":\"Cast to ObjectID failed for value \\\"5788683c1fa46a472a051543\\\" at path \\\"_id\\\"\",\"name\":\"CastError\",\"stringValue\":\"\\\"5788683c1fa46a472a051543\\\"\",\"kind\":\"ObjectID\",\"value\":\"5788683c1fa46a472a051543\",\"path\":\"_id\",\"reason\":{\"message\":\"Cast to ObjectId failed for value \\\"5788683c1fa46a472a051543\\\" at path \\\"_id\\\"\",\"name\":\"CastError\",\"stringValue\":\"\\\"5788683c1fa46a472a051543\\\"\",\"kind\":\"ObjectId\",\"value\":\"5788683c1fa46a472a051543\",\"path\":\"_id\"}}},\"message\":\"Model validation failed\",\"name\":\"ValidationError\"}`\r\n\r\nI suppose for Mongoose >= 4.7.3, it does not automatically convert string _id value to ObjectId _id value when we try to insert new records\r\n"},{"labels":["bug"],"text":"```\r\nconst mongoose = require('mongoose');\r\nmongoose.Promise = require('bluebird');\r\nconst { Schema } = mongoose;\r\n\r\nconst connect = () => {\r\n  const options = {\r\n    promiseLibrary: require('bluebird')\r\n  };\r\n  mongoose.connect('mongodb://localhost:27017/mongoose_test', options);\r\n};\r\nconnect();\r\n\r\nmongoose.connection.on('error', (err) => {\r\n  console.error(err);\r\n});\r\n\r\nconst UserSchema = new Schema({\r\n  location: {\r\n    type: { type: String, default: 'Point' },\r\n    coordinates: { type: Array, default: [0, 0] }\r\n  }\r\n});\r\nUserSchema.index({ location: '2dsphere' });\r\n\r\nconst User = mongoose.model('User', UserSchema);\r\n\r\nconst userId = '586d3620f6da431b4aec1a12';\r\n\r\nlet user = new User({\r\n  _id: userId\r\n})\r\n\r\nuser.save();\r\n\r\nfunction getUserLocation() {\r\n  return User.findById(userId)\r\n  .then((user) => {\r\n    return new Promise((resolve, reject) => {\r\n      if (user && user.location) {\r\n        resolve(user.location);\r\n      } else {\r\n        reject();\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\nfunction myAwesomeFunction(userLocation) {\r\n  return User.aggregate([{\r\n    $geoNear: {\r\n      near: userLocation,\r\n      distanceField: 'distance',\r\n      maxDistance: 1000,\r\n      spherical: true\r\n    }\r\n  }\r\n ]);\r\n}\r\n\r\ngetUserLocation()\r\n.then(myAwesomeFunction)\r\n.then(console.log)\r\n.catch(console.error);\r\n```\r\n\r\n```\r\nError: cyclic dependency detected\r\n    at serializeObject (/project/node_modules/bson/lib/bson/parser/serializer.js:296:33)\r\n    at serializeInto (/project/node_modules/bson/lib/bson/parser/serializer.js:776:17)\r\n    at serializeObject (/project/node_modules/bson/lib/bson/parser/serializer.js:308:18)\r\n    at serializeInto (/project/node_modules/bson/lib/bson/parser/serializer.js:776:17)\r\n    at serializeObject (/project/node_modules/bson/lib/bson/parser/serializer.js:308:18)\r\n    at serializeInto (/project/node_modules/bson/lib/bson/parser/serializer.js:776:17)\r\n    at serializeObject (/project/node_modules/bson/lib/bson/parser/serializer.js:308:18)\r\n    at serializeInto (/project/node_modules/bson/lib/bson/parser/serializer.js:776:17)\r\n    at serializeObject (/project/node_modules/bson/lib/bson/parser/serializer.js:308:18)\r\n    at serializeInto (/project/node_modules/bson/lib/bson/parser/serializer.js:776:17)\r\n    at serializeObject (/project/node_modules/bson/lib/bson/parser/serializer.js:308:18)\r\n    at serializeInto (/project/node_modules/bson/lib/bson/parser/serializer.js:618:17)\r\n    at serializeObject (/project/node_modules/bson/lib/bson/parser/serializer.js:308:18)\r\n    at serializeInto (/project/node_modules/bson/lib/bson/parser/serializer.js:776:17)\r\n    at BSON.serialize (/project/node_modules/bson/lib/bson/bson.js:58:27)\r\n    at Query.toBin (/project/node_modules/mongodb-core/lib/connection/commands.js:140:25)\r\n    at Pool.write (/project/node_modules/mongodb-core/lib/connection/pool.js:921:23)\r\n    at Server.command (/project/node_modules/mongodb-core/lib/topologies/server.js:515:15)\r\n    at Server.command (/project/node_modules/mongodb/lib/server.js:376:17)\r\n    at executeCommand (/project/node_modules/mongodb/lib/db.js:310:19)\r\n    at Db.command (/project/node_modules/mongodb/lib/db.js:334:44)\r\n    at Collection.aggregate (/project/node_modules/mongodb/lib/collection.js:2686:13)\r\n    at NativeCollection.(anonymous function) [as aggregate] (/project/node_modules/mongoose/lib/drivers/node-mongodb-native/collection.js:126:28)\r\n    at /project/node_modules/mongoose/lib/aggregate.js:576:10\r\n    at Aggregate.exec (/project/node_modules/mongoose/lib/aggregate.js:562:10)\r\n    at Aggregate.then (/project/node_modules/mongoose/lib/aggregate.js:606:15)\r\n```\r\n\r\nNode.js 6.9.2\r\nMongoDB 3.2.11\r\nMongoose 4.7.6"},{"labels":["bug"],"text":"<!-- *Before creating an issue please make sure you are using the latest version of mongoose -->\r\n\r\n**Do you want to request a *feature* or report a *bug*?**\r\nbug\r\n\r\n**If the current behavior is a bug, please provide the steps to reproduce.**\r\n<!-- If you can, provide a stadalone script / gist to reproduce your issue -->\r\n```js\r\nvar q = require(\"q\");\r\nvar mongoose = require(\"mongoose\");\r\nmongoose.set(\"debug\", true);\r\nmongoose.Promise = q.Promise;\r\n\r\nvar db1 = mongoose.createConnection();\r\ndb1.open(\"mongodb://localhost/issue-1234-1\");\r\n\r\nvar X = db1.model(\"X\", new mongoose.Schema({\r\n\ta: {\r\n\t\ttype: Number,\r\n\t\tmin: [1, \"a\"]\r\n\t},\r\n\tb: {\r\n\t\ttype: Number,\r\n\t\tmin: [1, \"b\"]\r\n\t}\r\n}));\r\n\r\n\r\nX.create({\r\n\ta: 0,\r\n\tb: 0\r\n})\r\n\t.catch(function (e1) {\r\n\t\tconsole.log(Object.keys(e1.errors));\r\n\t\treturn X.create({\r\n\t\t\ta: 10,\r\n\t\t\tb: 10\r\n\t\t})\r\n\t\t\t.then(function (x) {\r\n\t\t\t\tObject.assign(x, {a: 0, b: 0});\r\n\t\t\t\treturn x.save()\r\n\t\t\t\t\t.catch(function (e2) {\r\n\t\t\t\t\t\tconsole.log(Object.keys(e2.errors));\r\n\t\t\t\t\t});\r\n\t\t\t});\r\n\t})\r\n\t.then(function () {\r\n\t\treturn X.remove().then(function () {\r\n\t\t\tprocess.exit(0);\r\n\t\t});\r\n\t});\r\n```\r\n**What is the current behavior?**\r\nvalidation runs in different directions \r\n```\r\n[ 'b', 'a' ] // create runs from last to first\r\n[ 'a', 'b' ] // save\r\n```\r\n\r\n**What is the expected behavior?**\r\nvalidation should give same output for both functions, preferably as save works\r\n```\r\n[ 'a', 'b' ] // create\r\n[ 'a', 'b' ] // save\r\n```\r\n\r\n**Please mention your node.js, mongoose and MongoDB version.**\r\nmongoose 4.7.5\r\nâžœ node -v\r\nv7.0.0\r\nâžœ npm -v\r\n4.0.2\r\nâžœ mongo --version\r\nMongoDB shell version v3.4.0\r\n"},{"labels":["bug"],"text":"I need to change the value that is stored in updatedAt, is there a way?\r\nMy case I've a mobile that manipulate information and then send to server, when I tried to set the date that is older then actual on updatedAt, it store the `Date.now()`."},{"labels":["bug"],"text":"This might be related to #4073\r\n\r\n``` javascript\r\n    var entityDefinition = {\r\n      team: { type: mongoose.Schema.ObjectId, ref: 'Team', required: true },\r\n      teams: [{ type: Schema.ObjectId, ref: 'Team', required: true }],\r\n      updated: { type: Date, default: Date.now },\r\n      created: { type: Date, default: Date.now }\r\n    };\r\n\r\n    // define the schema for our entity model\r\n    var entitySchema = new mongoose.Schema(entityDefinition, { discriminatorKey: 'type' });\r\n    var Entity = mongoose.model('Entity', entitySchema);\r\n\r\n    var userDefinition = {\r\n      name: { type: String, required: true },\r\n    };\r\n\r\n    // define the schema for our user model\r\n    var userSchema = new mongoose.Schema(userDefinition, { discriminatorKey: 'type' });\r\n    var User = Entity.discriminator('User', userSchema);\r\n```\r\n\r\nAnd when I'm trying to select a User and populate it's teams array (from **Entity Schema**) it fails...\r\n\r\n``` javascript\r\n    User.findOne({ 'entityid': userid }, 'name team teams').populate('team teams').exec(function (err, user) {\r\n        console.log(user.name); // prints: \"danpe\"\r\n        console.log(user.team.name); // prints: \"General\"\r\n        console.log(user.teams); // prints: undefined (even though it is not empty when I'm inspecting the mongo model directly using Robomongo)\r\n        console.log(user.$__.populated.teams.value) // prints an array of ObjectIds, which is correct, but not populated into the main object..\r\n    }\r\n```\r\n\r\nIf I'm printing the `user` on debug I get the following:\r\n\r\n``` javascript\r\n    { '$__':\r\n       { strictMode: true,\r\n         selected: { team: 1, teams: 1, type: 1, name: 1 },\r\n         shardval: undefined,\r\n         saveError: undefined,\r\n         validationError: undefined,\r\n         adhocPaths: undefined,\r\n         removing: undefined,\r\n         inserting: undefined,\r\n         version: undefined,\r\n         getters: {},\r\n         _id: undefined,\r\n         populate: undefined,\r\n         populated: { teams: [Object], team: [Object] },\r\n         wasPopulated: false,\r\n         scope: undefined,\r\n         activePaths: { paths: [Object], states: [Object], stateNames: [Object] },\r\n         ownerDocument: undefined,\r\n         fullPath: undefined,\r\n         emitter: { domain: null, _events: {}, _eventsCount: 0, _maxListeners: 0 } }\r\n    ,\r\n      isNew: false,\r\n      errors: undefined,\r\n      _doc:\r\n       { profile: {},\r\n         teams: undefined,\r\n         type: 'User',\r\n         name: 'danpe',\r\n         team:\r\n          { '$__': [Object],\r\n            isNew: false,\r\n            errors: undefined,\r\n            _doc: [Object],\r\n            '$__original_save': [Function: val],\r\n            save: [Function: val],\r\n            _pres: [Object],\r\n            _posts: [Object],\r\n            '$__original_validate': [Function: val],\r\n            validate: [Function: val],\r\n            '$__original_remove': [Function: val],\r\n            remove: [Function: val] },\r\n         _id: { _bsontype: 'ObjectID', id: [Object] } },\r\n      '$__original_save': [Function: val],\r\n      save: [Function: val],\r\n      _pres:\r\n       { '$__original_save':\r\n          [ [Function: val],\r\n            [Function: val],\r\n            [Function: val],\r\n            [Function: val] ],\r\n         '$__original_validate': [ [Function: val] ],\r\n         '$__original_remove': [ [Function: val] ] },\r\n      _posts:\r\n       { '$__original_save': [],\r\n         '$__original_validate': [],\r\n         '$__original_remove': [] },\r\n      '$__original_validate': [Function: val],\r\n      validate: [Function: val],\r\n      '$__original_remove': [Function: val],\r\n      remove: [Function: val] }\r\n```\r\n\r\n_I'm using MongoDB 3.2 with mongoose 4.6.1_\r\n\r\nI think it's a bug in because the following is an unexpected behavior:\r\n\r\n```\r\nconsole.log(user.teams); // prints: undefined (even though it is not empty when I'm inspecting the mongo model directly using Robomongo)\r\nconsole.log(user.$__.populated.teams.value) // prints an array of ObjectIds, which is correct, but not populated into the main object..\r\n```\r\n"},{"labels":[null,"bug"],"text":"I have a Schema like following:\n\n```\nvar schema = new mongoose.Schema({\n    username: String,\n    email: {\n        type: String,\n        unique: true,\n        validate: [ isEmail, 'invalid email address' ]\n    },\n    token: {\n        type: String,\n        default: function () {\n            return crypto.randomBytes(16).toString('hex');\n        }\n    }\n});\n\nvar User = mongoose.model('User', schema);\n```\n\nand i call it like this:\n\n```\nvar Promise = require('bluebird');\nvar mongoose = require('mongoose');\nmongoose.Promise = Promise;\nvar options = { promiseLibrary: Promise };\nvar db = mongoose.connect(config.mongo, options);\n\nvar userObject = {username: name ,email: email};\nreturn User.create(userObject)\n        .then(function (user) {...\n```\n\nBut in model.js it never returns from\n\n```\n        // Hack to avoid getting a promise because of\n        // $__registerHooksFromSchema\n        if (toSave.$__original_save) {\n          toSave.$__original_save({__noPromise: true}, callbackWrapper);\n        }\n\nedit: to original_save is in hooks.js the hook function it also hangs if i do:\n\nvar user = new User({\n    username: from.name && from.name.trim() ? from.name : mail.subject,\n    email: from.address\n});\n\nreturn user.save()\n    .then(function (user) {\n```\n\nMy Setup:\n\"bluebird\": \"^3.3.5\",\n\"mongoose\": \"^4.4.12\",\nrequire('mongoose').connection.readyState is 1 right before create.\n"},{"labels":["bug"],"text":"The Problem\n\nI have been working on a scenario which has thrown up an idea which could be useful to myself and others.\n\nI added a `created` field to a schema, which has `{type: Date, default: Date.now}` and when I save a new document, this feature is awesome.\n\nThe issue arises because I have documents in the collection already which did not have the created field when I updated the schema. Now, whenever I do a  `Model.find` or `Model.findOne` the documents which do not have the `created` field, they receive a default of `Date.now` which is not only incorrect, but a vast misrepresentation of the state of the data within my collection.\n\nThe Solution\nWhat I would like to see can be represented by a specific case. Let's just look at the `find()` method for simplicity.\n\nFor reference, my Mongoose version number is 4.1.12\n\nWhat I would like to be able to do, is to specify the following Schema options: `{type: Date, default: Date.now, ignoreDefaultOnHydrate: true }`\n\nThis in combination with a new field `willBeNew` on the `Document(obj, fields, skipId, willBeNew)` constructor will allow the default to be determined whether it's inclusion is required during `$__buildDoc` by allowing `SchemaType.prototype.getDefault` access to both the `document.isNew` flag along with `this.options.ignoreDefaultOnHydrate`.\n\nI realise that this may be unnecessarily complicated for something which most people do not require, and maybe there is a better way for me to go about implementing this for myself, and if so, I would love to hear any suggestions, however, I found it strange, that there lies an inherent assumption when building a Document, that it will be new, when in the very next line of code, by calling `init()` (I am referring to the `query.completeMany()` ) the Document is marked `isNew = false`. This is the scenario I am talking about when I think we can pass a flag up to the Document constructor because we know that the document is going to be marked as not new immediately after this call. \n"},{"labels":["bug",null],"text":"Hi all,\n\nIs there a way to access the parameters being passed to a new instance of a model from a schema type's default function? Specifically:\n\n``` javascript\nvar crypto   = require('crypto');\nvar db       = require('../db').db; // <- ref to mongoose\nvar Schema   = db.Schema;\n\nvar schema = Schema({\n  email          : { type: String, index: true, required: true, unique: true },\n  precomputedhash: { type: String }\n});\n\nschema.path('precomputedhash').default(function(doc) {\n  console.log(doc); // -> undefined\n  var hmac = crypto.createHmac('sha256', 'fake secret');\n  var sig = hmac.update(doc.email /* <- what I'd like */).digest('hex');\n  return sig;\n});\n```\n\nI need to create a precomputed hash as soon as I instantiate. I know I can generate that hash as a default at the appropriate time but I need it to use the doc.email (ideal) or the objectid (not ideal but ok). Yes, a hook would do the trick but I do need this to be accessible after instantiation and before saving.\n\nFurther details: you may be asking yourself why... In this particular case, I need to generate a hash for a specific third-party service with which we are integrating. I need a predictable way to generate the hash because it is the way I can access user's data on that service. In this case, the hash is generated using a recipe the provider defined.\n\nIf I can't fund a solution, worse case scenario, I'll have to document that a record must be saved before being able to get that precomputedhash but I'd like to avoid that.\n\nThank you!\n"},{"labels":["bug"],"text":"Since 4.2.0 single embedded subdocs are allowed but inserting attributes within the subdoc that are not part of the related schema causes the attributes to be written to the database anyway.\nThe script:\n\n``` javascript\nvar mongoose = require('mongoose'),\n    Schema = mongoose.Schema,\n    mongoDsn = 'mongodb://localhost/mongooseSubDocs';\n\ndelete require.cache[require.resolve('mongoose')];\nmongoose.connect(mongoDsn);\n\nvar childSchema = new Schema({ name: 'string' }, {_id: false, versionKey: false, strict: true});\nchildSchema.pre('save', function(next) {\n  console.log(this);\n  next();\n});\n\nvar parentSchema = new Schema({\n  child: childSchema\n}, {versionKey: false, strict: true});\n\nvar Parent = mongoose.model('Parent', parentSchema);\n\nfunction saveParent() {\n    var parent = new Parent({ anything: 'parent', child: { name: 'Luke', anything: 'child' } })\n    parent.save(function(err) {\n        if (err) throw err;\n        mongoose.disconnect();\n    });\n};\n\nsaveParent();\n```\n\ncauses the following document to be saved \n\n``` json\n{\n    \"_id\" : ObjectId(\"565f6fbbced113b11ea6291a\"),\n    \"child\" : {\n        \"name\" : \"Luke\",\n        \"anything\" : \"child\"\n    }\n}\n```\n\nI'd expect `\"anything\" : \"child\"`to not be part of the child subdocument.\n\nmongoose: 4.2.8\nnode: v0.12.8\nmongodb: 3.0.6\n"},{"labels":["bug"],"text":"See https://github.com/Automattic/mongoose/issues/1638#issuecomment-151491447\n"},{"labels":["bug"],"text":"Getting this after upgrade to 4.1.11 I need this for mongodb 3.x\n"},{"labels":["bug"],"text":"This is an issue that has been discussed before and might be related to #2951 and #2988.\nBut I found it to be related to how the mongodb dependency was installed...\n\nIf mongodb is installed as a sibling dependency (ie mongob was installed first) to mongoose it will fail to get the ObjectId for a schema with **ref**.\nIf I choose to .populate I will get the sub document but otherwise I will get undefined.\nThe property is there though, but the value is set to undefined.\n\nThe important lines in the output below are\n\n```\ndoc= { name: 'test', _id: 5565efb54b470078cb0ae60d, __v: 0 }\ndoc.application= undefined\n```\n\nSomething about my environment\n- on windows x64, node v0.10.36\n- on ubuntu 15.04, node v0.10.38\n- mongodb 3.0.0 and 2.4.11\n\nThis is the test script I'v been using.\n\n``` javascript\nvar mongoose = require('mongoose');\nmongoose.set('debug', true);\nvar util = require('util');\n\nmongoose.connect('mongodb://localhost:27017/gh2951');\n\nvar ApplicationSchema = new mongoose.Schema({\n    name: String\n});\n\nvar UserSchema = new mongoose.Schema({\n    application: { type: mongoose.Schema.Types.ObjectId, ref: 'Application', required: true, index: true },\n    name: { type: String, required: true, index: true },\n  });\n\nvar Application = mongoose.model('Application', ApplicationSchema);\nvar User = mongoose.model('user', UserSchema);\n\nApplication.create({name: 'test'})\n.then(function (app) {\n    return User.create({ application: app, name: 'test' }) ;\n})\n.then(function (doc) {\n    return User.findOne({ _id: doc._id }).exec()  \n})  \n.then(function (doc) {\n    console.log('doc=', doc);\n    console.log('doc.application=', doc.application);\n    return User.findOne({ _id: doc._id }).populate('application').exec()\n})\n.then(function (doc) {\n    console.log('doc=', doc);\n    console.log('doc.application=', doc.application);\n    process.exit(0)\n})\n.end();\n```\n## mongodb as child\n\n``` json\n\"dependencies\": {\n    \"mongoose\": \"4.0.3\"\n  }\n```\n\nOutput:\nUnpopulated returns the ObjectId and populated returns the document, just as expected.\n\n```\nMongoose: applications.insert({ name: 'test', _id: ObjectId(\"5565f0d85e8ff1fcb6815dc5\"), __v: 0 })\nMongoose: users.ensureIndex({ application: 1 }) { background: true, safe: undefined }\nMongoose: users.insert({ application: ObjectId(\"5565f0d85e8ff1fcb6815dc5\"), name: 'test', _id: ObjectId(\"5565f0d85e8ff1fcb6815dc6\"), __v: 0 })\nMongoose: users.ensureIndex({ name: 1 }) { background: true, safe: undefined }\nMongoose: users.findOne({ _id: ObjectId(\"5565f0d85e8ff1fcb6815dc6\") }) { fields: undefined }\ndoc= { application: 5565f0d85e8ff1fcb6815dc5,\n  name: 'test',\n  _id: 5565f0d85e8ff1fcb6815dc6,\n  __v: 0 }\ndoc.application= 5565f0d85e8ff1fcb6815dc5\nMongoose: users.findOne({ _id: ObjectId(\"5565f0d85e8ff1fcb6815dc6\") }) { fields: undefined }\nMongoose: applications.find({ _id: { '$in': [ ObjectId(\"5565f0d85e8ff1fcb6815dc5\") ] } }) { fields: undefined }\ndoc= { application: { name: 'test', _id: 5565f0d85e8ff1fcb6815dc5, __v: 0 },\n  name: 'test',\n  _id: 5565f0d85e8ff1fcb6815dc6,\n  __v: 0 }\ndoc.application= { name: 'test', _id: 5565f0d85e8ff1fcb6815dc5, __v: 0 }\n```\n## mongodb as sibling\n\n``` json\n\"dependencies\": {\n    \"mongodb\": \"2.0.30\",\n    \"mongoose\": \"4.0.3\"\n  }\n```\n\nOutput:\nWithout .populate it returns undefined where an ObjectId was expected\n\n```\nMongoose: applications.insert({ name: 'test', _id: ObjectId(\"5565efb54b470078cb0ae60c\"), __v: 0 })\nMongoose: users.ensureIndex({ application: 1 }) { background: true, safe: undefined }\nMongoose: users.insert({ application: ObjectId(\"5565efb54b470078cb0ae60c\"), name: 'test', _id: ObjectId(\"5565efb54b470078cb0ae60d\"), __v: 0 })\nMongoose: users.ensureIndex({ name: 1 }) { background: true, safe: undefined }\nMongoose: users.findOne({ _id: ObjectId(\"5565efb54b470078cb0ae60d\") }) { fields: undefined }\ndoc= { name: 'test', _id: 5565efb54b470078cb0ae60d, __v: 0 }\ndoc.application= undefined\nMongoose: users.findOne({ _id: ObjectId(\"5565efb54b470078cb0ae60d\") }) { fields: undefined }\nMongoose: applications.find({ _id: { '$in': [ ObjectId(\"5565efb54b470078cb0ae60c\") ] } }) { fields: undefined }\ndoc= { application: { name: 'test', _id: 5565efb54b470078cb0ae60c, __v: 0 },\n  name: 'test',\n  _id: 5565efb54b470078cb0ae60d,\n  __v: 0 }\ndoc.application= { name: 'test', _id: 5565efb54b470078cb0ae60c, __v: 0 }\n```\n"},{"labels":["bug"],"text":"mongoose/lib/utils.js --> \n`var ReadPref = require('mongodb/lib/read_preference')` \nis producing an error \"node module not found\" when deployed to Heroku.  \n\n`Cannot find module 'mongodb/lib/read_preference`\n"},{"labels":["bug",null],"text":"Hi,\n\nI've been trying to trace this issue with node inspector for a full day, but have had no luck, so I'm posting the issue here.\n\nFirstly, the issue i'm encountering is that when the schema.options.toJSON.transform function gets called, the ret it is supplied with is a sub document of the populated document, not the full/parent document as expected. This only happens when I populate the post property of the schema. No other populated subdocument is supplied to the transform function like post is.\n\nHere is my schema:\n\n```\nvar notificationSchema = Schema({\n    type           : { type : String,   default : ''             },\n    owner          : { type : ObjectId, ref     : 'User'         },\n    user           : { type : ObjectId, ref     : 'User'         },\n    project        : { type : ObjectId, ref     : 'Project'      },\n    organisation   : { type : ObjectId, ref     : 'Organisation' },\n    field          : { type : ObjectId, ref     : 'Field'        },\n    thread         : { type : ObjectId, ref     : 'Thread'       },\n    post           : { type : ObjectId, ref     : 'Post'         },\n    timestamp      : { type : Date,     default : Date.now       },\n    read           : { type : Boolean,  default : false          }\n}, {\n    strict         : true\n});\n```\n\nHere is my notification lookup:\n\n```\napp.models.notification\n.find(data.query)\n.populate('user', 'name profile.firstname profile.lastname profile.picture profile.username')\n.populate('post', 'body')\n.populate('field', 'name stub logo.url picture')\n.populate('thread', 'title stub')\n.populate('project', 'name picture projectname')\n.populate('organisation', 'name stub logo.url picture')\n.exec(function(err, notifications) {\n    // by design of my test, only one notification is returned\n    console.log(notifications[0]);\n    res.json(notifications);\n});\n```\n\nHere is the stripped down transform function:\n\n```\nnotificationSchema.options.toJSON.transform = function (doc, ret, options) {\n    console.log(ret);\n}\n```\n\nHere is the output of `console.log(notifications[0])` from the model lookup:\n\n```\n{\n  _id: 553a21508dd23a3c27e8ceb4,\n  owner: 54bdd517ec1e7dc41022a05f,\n  user:\n   { _id: 5498e258a7fbbfcc12c3fa15,\n     accounts: { local: [Object] },\n     profile:\n      { username: 'jacksondelahunt',\n        firstname: 'Jackson',\n        lastname: 'Delahunt',\n        picture: '/uploads/8565e053-d1ef-40a4-97ca-5841b79a3d17.jpg',\n        socialLinks: {},\n        profileDetails: {},\n        banner: {} } },\n  post:\n   { _id: 5524ef2620e0a2047223bf38,\n     body: '<p>Here's my post</p>' },\n  thread:\n   { _id: 5524c45d2b6a6996231c66d9,\n     stub: 'space-station-telemetry-app',\n     banner: {},\n     title: 'Space Station Telemetry App' },\n  __v: 0,\n  read: true,\n  timestamp: Fri Apr 24 2015 20:56:16 GMT+1000 (AUS Eastern Standard Time),\n  type: 'new-project-mention'\n}\n```\n\nHere is the output of `console.log(ret)` in the transform function:\n\n```\n{\n  _id: 5524ef2620e0a2047223bf38,\n  body: <p>Here's my post</p>\n  id: '5524ef2620e0a2047223bf38'\n}\n```\n\nIf I comment out the post populate line in the model lookup so that the post is left unpopulated, the output of `console.log(ret)` is as follows, as expected:\n\n```\n{\n  _id: 553a21508dd23a3c27e8ceb4,\n  owner: 54bdd517ec1e7dc41022a05f,\n  user:\n   { _id: 5498e258a7fbbfcc12c3fa15,\n     profile:\n      { username: 'jacksondelahunt',\n        firstname: 'Jackson',\n        lastname: 'Delahunt',\n        picture: '/uploads/8565e053-d1ef-40a4-97ca-5841b79a3d17.jpg',\n        socialLinks: {},\n        profileDetails: {},\n        banner: {},\n        name: 'Jackson Delahunt' } },\n  post: 5524ef2620e0a2047223bf38,\n  thread:\n   { _id: 5524c45d2b6a6996231c66d9,\n     stub: 'space-station-telemetry-app',\n     title: 'Space Station Telemetry App',\n     id: '5524c45d2b6a6996231c66d9' },\n  __v: 0,\n  read: true,\n  timestamp: Fri Apr 24 2015 20:56:16 GMT+1000 (AUS Eastern Standard Time),\n  type: 'new-project-mention',\n  id: '553a21508dd23a3c27e8ceb4'\n}\n```\n\nHere is the post schema so you can see that there is no funny business going on there:\n\n```\nvar postSchema = Schema({\n    body      :  { type : String,   default : ''         },\n    parent    :  { type : ObjectId, ref     : 'Post'     },\n\n    thread    :  { type : ObjectId, ref     : 'Thread'   },\n    owner     :  { type : ObjectId, ref     : 'User'     },\n    accepted  :  { type : Boolean,  default : false      },\n    timestamp :  { type : Date,     default : Date.now   },\n    edited    :  { type : Date,     default : ''         },\n    votes     :  { type : Number,   default : 0          },\n    flagged   :  { type : Boolean,  default : false      },\n    deleted   :  { type : Boolean,  default : false      }\n}, {\n    strict    : true\n});\n```\n\nHow or why this is happening, I don't know, but I'm reporting it here as a bug as it reproducible and incorrect functionality. Sorry I can't provide you a plunker, but the system has a lot of dependencies to produce this data. Please let me know if there is anything else I can provide to make this clearer to trace.\n"},{"labels":["bug",null],"text":"I recently updated from 3.8.x to 4.0.1\nEverything went well, except that some connection events are fired just one time, or aren't fired at all. I'm using a connection pool of 5, and all the options defaulted (keepAlive, auto_reconnect, etc). I'm using Winston as my logger library, with console and file transport.\nThis is an actual test code:\n\n```\nmongoose.connection.on('connecting', function () {\n  logger.info('MongoDB: Trying: ' + dbURI); }); \nmongoose.connection.on('connected', function () {\n  logger.info('MongoDB: Successfully connected to: ' + dbURI); }); \nmongoose.connection.on('error',function (err) { \n  logger.error('MongoDB: ERROR connecting to: ' + dbURI + ' - ' + err); }); \nmongoose.connection.on('close',function (err) { \n  logger.error('MongoDB: Connection Closed'); }); \nmongoose.connection.on('reconnected', function () { \n  logger.warn('MongoDB: Database link was reconnected'); });\nmongoose.connection.on('disconnected', function () { \n  logger.error('MongoDB: The connection was ended on: ' + dbURI ); });\n// Connect to database\nmongoose.connect(dbURI, mongoOptions);\n```\n\nUpon start, the console shows:\n\n```\ninfo: MongoDB: Trying: mongodb://localhost/Alamo\ninfo: MongoDB: Successfully connected to: mongodb://localhost/Alamo\n```\n\nThat is \"connecting\" and \"connected\".\nNow, if I stop the MongoDB service, the console shows:\n\n```\nerror: MongoDB: The connection was ended on: mongodb://localhost/Alamo\nerror: MongoDB: Connection Closed\n```\n\nThat is \"disconnected\" and \"close\".\nIf i start the Mongo service back:\n\n```\ninfo: MongoDB: Successfully connected to: mongodb://localhost/Alamo\nwarn: MongoDB: Database link was reconnected\n```\n\nThat is \"connected\" and \"reconnected\".\nBut now, if i stop the Mongo service again, no message appears on the console. If I start the service one more time, I just get the \"reconnected\" event, and that's all. That is the only event i will see from this point on.\n\nIt's clear that the reconnection feature is working, but not having all events fired is cripping the log file, and an analysis of a possible problem will be harder.\n\nvkarpov15 pointed me in the chat that its probably related with:\nhttps://github.com/mongodb/node-mongodb-native/pull/1265\n\nMay be it's an issue related with the MongoDB 2.x driver.\n"},{"labels":["bug"],"text":"Environments:\n\n```\nNodeJS: v0.10.26\nMongoDB: 3.0.1\nMongoose: 4.0.1\n```\n\nIn the following code, I expects the output `{_id: ..., sku: ...}`, but `{_id: ...}`.\nHowever, when remove the `options: {lean: true}` from populate() or modify to `{options: {lean: false}}`, it is behavior of the expected.\n\n``` javascript\nvar mongoose = require('mongoose');\nmongoose.connect('mongodb://localhost/test');\nvar Sku = mongoose.model('Sku', {});\nvar Item = mongoose.model('Item', {\n  sku: {ref: 'Sku', type: mongoose.Schema.Types.ObjectId}\n});\n\n(new Sku()).save(function(err, sku) {\n  (new Item({sku: sku})).save(function() {\n    var stream = Item.find().populate({\n      path: 'sku',\n      options: {lean: true}\n    }).stream();\n    stream.on('data', function(data) {\n      console.log(data);\n    });\n    stream.on('end', function() {\n      process.exit(0);\n    });\n  });\n});\n```\n\nIs this behavior intended?\n"},{"labels":["bug"],"text":"My schema is similar to below, the db.x returns a mongoose-validator instance. I have tried the following in both 3.9.7 and master.\n\n```\nvar ApplicationCallbackSchema = db.defineSchema({\n    url: { type: String, required: true, validate: db.urlValidator('url') },\n    events: { type: [String] }\n} );\n\nvar ApplicationSchema = db.defineSchema({\n    name: { type: String, required: true, index: true, unique: true, validate: db.stringLengthValidator('name', 8, 32) },\n    transports: [Transport],\n    callbacks: [ApplicationCallbackSchema]\n```\n\n});\n\nThis call:\n\n```\n model.findOneAndUpdate({ _id: req.params.id }, req.body, { new: true, runValidators: true }...\n```\n\nResults in:\n\n```\nTypeError: Object #<Object> has no method 'validate'\n    at /Volumes/Workspace/qwasi/current/current/mojo-engine/node_modules/mongoose/lib/schema/documentarray.js:100:13\n    at /Volumes/Workspace/qwasi/current/current/mojo-engine/node_modules/mongoose/lib/schema/documentarray.js:106:9\n    at DocumentArray.SchemaType.doValidate (/Volumes/Workspace/qwasi/current/current/mojo-engine/node_modules/mongoose/lib/schematype.js:647:22)\n    at DocumentArray.doValidate (/Volumes/Workspace/qwasi/current/current/mojo-engine/node_modules/mongoose/lib/schema/documentarray.js:79:35)\n    at /Volumes/Workspace/qwasi/current/current/mojo-engine/node_modules/mongoose/lib/services/updateValidators.js:87:33\n    at /Volumes/Workspace/qwasi/current/current/mojo-engine/node_modules/async/lib/async.js:570:21\n    at /Volumes/Workspace/qwasi/current/current/mojo-engine/node_modules/async/lib/async.js:249:17\n    at /Volumes/Workspace/qwasi/current/current/mojo-engine/node_modules/async/lib/async.js:125:13\n    at Array.forEach (native)\n    at _each (/Volumes/Workspace/qwasi/current/current/mojo-engine/node_modules/async/lib/async.js:46:24)\n```\n\nAny assistance is much appreciated.\n"},{"labels":["bug"],"text":"Hello, we use this code:\nvar obj = {};\nobj ['nextID'] = 1;\n....findByIdAndUpdate (ID, { '$inc': obj }, {'new': true, 'upsert': true, 'select': obj}, callback);\n\nIt is work fine with 3.8.12 version, but in the version 3.8.23 we get this error \"MongoError: exception: You cannot currently mix including and excluding fields. Contact us if this is an issue.\". It think it is bug,,\n"},{"labels":["bug"],"text":"The docs ( http://mongoosejs.com/docs/api.html#query_Query-distinct ) say that the parameter order is: `Query#distinct([criteria], [field], [callback])`.\n\nAfter wasting 30 minutes with a very obscure error when using all 3 arguments, I found out that the parameter are actually reversed: `Query#distinct([field], [criteria], [callback])`. This works.\n"},{"labels":["bug"],"text":"Following the 3.8.22 update (possibly the bump of the mongodb driver), we started getting connection issues (see below). \n\n_I'm unsure if this is actually a Mongoose bug, or if it's from the MongoDB driver but figured it's best to report it here, since this is the module we're using directly._\n\nIt seems like the issues appear after in the following scenario: \n1. connect :+1: \n2. disconnect :+1: \n3. connect :bug: \n\n**Interim(?) solution**\nSpecifying an `authMechanism` in the connection options resolve the issue, even when using 3.8.22.\n\n**Possible issue**\nIt seems like the issue appears around line 700 in `/mongodb/lib/mongodb/db.js`, where there's inconsistency in the if-statements. If the provided `authMechanism` is set to `DEFAULT`, it will cause an error.\n\nAdding some logging shows that the `authMechanism` seems to be reused the next time `Db.prototype.authenticate()` is invoked, causing it to throw an error since it doesn't support an incoming value of `DEFAULT`.\n\n**Notes:**\n- We're using [a wrapping module](https://github.com/Springworks/node-mongoose-connection) to manage shared connections, but that hasn't changed for a long time. This module reuses existing connections to the same DB (across a top-level module and its submodules).\n- Stepping down to 3.8.21 resolved the problem\n\n**Error log**\n\n```\n{\n    \"timestamp\": \"2015-01-26T21:02:49.149Z\",\n    \"name\": \"\",\n    \"hostname\": \"\",\n    \"pid\": 42219,\n    \"level\": 40,\n    \"err\": {\n        \"name\": \"Error\",\n        \"message\": \"only GSSAPI, PLAIN, MONGODB-X509, SCRAM-SHA-1 or MONGODB-CR is supported by authMechanism\",\n        \"stack\": \"Error: only GSSAPI, PLAIN, MONGODB-X509, SCRAM-SHA-1 or MONGODB-CR is supported by authMechanism\\n    at Db.authenticate (./node_modules/mongoose-connection/node_modules/mongoose/node_modules/mongodb/lib/mongodb/db.js:690:23)\\n    at NativeConnection.Connection.onOpen (./node_modules/mongoose-connection/node_modules/mongoose/lib/connection.js:458:13)\\n    at ./node_modules/mongoose-connection/node_modules/mongoose/lib/connection.js:421:10\\n    at ./node_modules/mongoose-connection/node_modules/mongoose/lib/drivers/node-mongodb-native/connection.js:217:5\\n    at ./node_modules/mongoose-connection/node_modules/mongoose/node_modules/mongodb/lib/mongodb/db.js:294:11\\n    at process._tickDomainCallback (node.js:486:13)\"\n    },\n    \"msg\": \"only GSSAPI, PLAIN, MONGODB-X509, SCRAM-SHA-1 or MONGODB-CR is supported by authMechanism\",\n    \"v\": 0\n}\n```\n"},{"labels":["bug"],"text":"Hi all,\nI found a new bug on async validator of embedded doc : callback of save method is called before all subdoc are checked.\n\nThe best is an example : \n\n```\nvar mongoose=require('mongoose');\nvar schema = mongoose.Schema;\nvar db = mongoose.createConnection('mongodb://localhost/tests');\n\nvar v=function(value, cb){\n    var self=this;\n    console.log('IN VALID ' + value);\n    setTimeout(function(){\n    console.log('IN ASYNC VALID ' + value);\n    cb(false);\n    }, (value==='r'?1000:1500)); // First sub doc will be validate after 1s and second sub doc after 1.5s\n    return true;\n}\n\nvar s1 = new schema({\n    title:String,\n    validField:{\n    type:String,\n    validate:v\n    }\n});\nvar s2 = new schema({\n    title:  String,\n    s1:[s1]\n});\nvar s3 = new schema({\n    title:  String,\n    s2:[s2]\n});\n\nvar m3 = db.model('m3', s3);\nvar d = new m3({\n    title:'test',\n    s2:[\n    {\n        title:'test',\n        s1:[\n        {\n            validField:'r'\n        },\n        {\n            validField:'r2'\n        }\n        ]\n    }\n    ]\n});\nd.save(function(err,doc){\n    console.log(JSON.stringify(err, null, 2));\n    console.log(JSON.stringify(doc, null, 2));\n});\n```\n\nOn this example, normally output should be : \n\n```\nIN VALID r\nIN VALID r2\nIN ASYNC VALID r\nIN ASYNC VALID r2\n{\n  \"message\": \"Validation failed\",\n  \"name\": \"ValidationError\",\n  \"errors\": {\n    \"s2.0.s1.0.validField\": {\n      \"properties\": {\n        \"type\": \"user defined\",\n        \"message\": \"Validator failed for path `{PATH}` with value `{VALUE}`\",\n        \"path\": \"validField\",\n        \"value\": \"r\"\n      },\n      \"message\": \"Validator failed for path `validField` with value `r`\",\n      \"name\": \"ValidatorError\",\n      \"kind\": \"user defined\",\n      \"path\": \"validField\",\n      \"value\": \"r\"\n    },\n    \"s2.0.s1.1.validField\": {\n      \"properties\": {\n        \"type\": \"user defined\",\n        \"message\": \"Validator failed for path `{PATH}` with value `{VALUE}`\",\n        \"path\": \"validField\",\n        \"value\": \"r2\"\n      },\n      \"message\": \"Validator failed for path `validField` with value `r2`\",\n      \"name\": \"ValidatorError\",\n      \"kind\": \"user defined\",\n      \"path\": \"validField\",\n      \"value\": \"r2\"\n    }\n  },\n  \"key\": \"undefined.0.undefined.0.undefined\"\n}\nundefined\n```\n\nbut I have : \n\n```\nIN VALID r\nIN VALID r2\nIN ASYNC VALID r\n{\n  \"message\": \"Validation failed\",\n  \"name\": \"ValidationError\",\n  \"errors\": {\n    \"s2.0.s1.0.validField\": {\n      \"properties\": {\n        \"type\": \"user defined\",\n        \"message\": \"Validator failed for path `{PATH}` with value `{VALUE}`\",\n        \"path\": \"validField\",\n        \"value\": \"r\"\n      },\n      \"message\": \"Validator failed for path `validField` with value `r`\",\n      \"name\": \"ValidatorError\",\n      \"kind\": \"user defined\",\n      \"path\": \"validField\",\n      \"value\": \"r\"\n    }\n  },\n  \"key\": \"undefined.0.undefined.0.undefined\"\n}\nundefined\nIN ASYNC VALID r2\n```\n\nYou can see that the save method callback is called immedialy after first sub doc validation, it doesn't wait the second sub doc validation.\nThis issue happend only if we call cb(false) to invalid a doc, but if I do cb(true), save callback is called at the end (but of course doc is valid ;)) : \n\n```\nIN VALID r\nIN VALID r2\nIN ASYNC VALID r\nIN ASYNC VALID r2\nnull\n{\n  \"__v\": 0,\n  \"title\": \"test\",\n  \"_id\": \"54b3a5975a6dcea50ef9b915\",\n  \"s2\": [\n    {\n      \"title\": \"test\",\n      \"_id\": \"54b3a5975a6dcea50ef9b916\",\n      \"s1\": [\n        {\n          \"validField\": \"r\",\n          \"_id\": \"54b3a5975a6dcea50ef9b918\"\n        },\n        {\n          \"validField\": \"r2\",\n          \"_id\": \"54b3a5975a6dcea50ef9b917\"\n        }\n      ]\n    }\n  ]\n}\n```\n\nThanks\n"},{"labels":["bug"],"text":"Hi, i'm having an issue when trying to save a document.\nI have the following code:\n\n``` javascript\nexports.create = function(req, res) {\n    var mapScreen = new MapScreen(req.body);\n    console.log(req.user);\n    mapScreen.user = req.user;\n    console.log(mapScreen.user);\n\n    mapScreen.save(function(err) {\n        console.log(err);\n        if (err) {\n            return res.status(400).send({\n                message: errorHandler.getErrorMessage(err)\n            });\n        } else {\n            res.jsonp(mapScreen);\n        }\n    });\n};\n```\n\nI try sending the following data:\n\n```\n{\n    name: 'Map screen Name',\n    toponymName: 'Map screen Name',\n    user: { \n            _id: '54ae6d7e1f30e25e35556775'\n    },\n    geonameId: 1234,\n    location: {\n        center: {\n            coordinates: [22, 22]\n        }\n    }\n}\n```\n\nThis yields the following output:\n\n```\n{ _id: 54ae69d2c2241d7c338cfee0,\n  random: [ 0.9119633759837598, 0.8231905356515199 ],\n  name: 'Full',\n  surname: 'Name',\n  displayName: 'Full Name',\n  email: 'test1@test.com',\n  birthday: Thu Jan 08 2015 12:28:18 GMT+0100 (CET),\n  sex: 'M',\n  map: 54ae69d2c2241d7c338cfedf,\n  __v: 0,\n  __t: 'Person',\n  connections_count: 0,\n  data_filled: true,\n  active: true,\n  images: [],\n  covers: [],\n  roles: [ 'admin' ],\n  cover_url: '',\n  image_url: '',\n  interests: [],\n  occupations: [] }\n54ae69d2c2241d7c338cfee0\n{ [CastError: Cast to ObjectId failed for value \"[object Object]\" at path \"user\"]\n  message: 'Cast to ObjectId failed for value \"[object Object]\" at path \"user\"',\n  name: 'CastError',\n  type: 'ObjectId',\n  value: \n   { \n     _id: '54ae69d2c2241d7c338cfee0'\n   },\n  path: 'user' }\n```\n\nIf, however, i omit the user object in the request body, the code runs without issue, successfully saving the object.\n\nThis leads me to believe that manually setting the user via `mapScreen.user = req.user;` has no effect IF the field was set in the object constructor.\n\nI tried this with multiple versions including the stable and master version and the issue persists.\nIs this a bug?\n"},{"labels":["bug"],"text":"I have isolated a bug in `pre('save', ...)` middleware resolution, based on this issue: keystonejs/keystone#759\n\nThis works:\n\n``` javascript\nschema.pre('save', true, function(next, done) {\n    console.log('locking 1');\n    process.nextTick(function() {\n        console.log('releasing lock 1');\n        done();\n    });\n    next();\n});\n\nschema.pre('save', true, function(next, done) {\n    console.log('locking 2');\n    process.nextTick(function() {\n        console.log('releasing lock 2');\n        done();\n    });\n    next();\n});\n```\n\nThis also works:\n\n``` javascript\nschema.pre('save', true, function(next, done) {\n    console.log('locking 1');\n    process.nextTick(function() {\n        console.log('releasing lock 1');\n        done();\n    });\n    next();\n});\n\nschema.pre('save', function(done) {\n    console.log('locking 2');\n    console.log('releasing lock 2');\n    done();\n});\n```\n\nThis does not work:\n\n``` javascript\nschema.pre('save', true, function(next, done) {\n    console.log('locking 1');\n    process.nextTick(function() {\n        console.log('releasing lock 1');\n        done();\n    });\n    next();\n});\n\nschema.pre('save', function(done) {\n    console.log('locking 2');\n    process.nextTick(function() {\n        console.log('releasing lock 2');\n        done();\n    });\n});\n```\n\nThe order is important; if the **serial** middleware is included first in the bottom example, it works as expected.\n"},{"labels":["bug",null],"text":"I have a Schema defined as the following:\n\n``` javascript\nvar CarSchema = new Schema({\n    carplate: { type:String, index: true, required: true},\n    features: { optA: String, optB: String},\n    notes : String\n},{strict: \"throw\"});\n```\n\nand I reference this in another Schema, like in (Car is the model derived by the previous Schema):\n\n``` javascript\nvar ReservationSchema = new Schema({\n    car: {type: Schema.Types.ObjectId, ref: 'Car'},\n...\nnotes : String,\n...\n\n}, {strict: \"throw\"});\n```\n\nWell, when I run a query with a populate like the following\n\n``` javascript\nReservation.findOne({}).populate('car', '_id carplate').exec(function(err, results){...});\n```\n\nPopulation works but I'm always obtaining also the field named 'features', despite it's not selected in populate().\nFrom my further tests I'm observing it happens with all \"complex\" fields in Schemas.\n\nIs it a feature?\nThank you.\n"},{"labels":["bug"],"text":"Is there a way to remove a field/path from a schema object, once it has been added.\n\nI would like to create discriminators that have less fields then the baseSchema. Is this something i hack around as i don't see a function in the API docs?\n"},{"labels":["bug"],"text":"I'm trying to create the following schema:\n\n```\nvar ChildSchema = new Schema({\n    field: {\n        type: string,\n        sparse: true\n    }\n};\n\nvar ParentSchema = new Schema({\n    children1: [ChildSchema],\n    children2: [ChildSchema]\n};\n\nmongoose.model('Parent', ParentSchema);\n```\n\nIt seems like ensureIndex(field) is called for children1, but not for children2.\n"},{"labels":["bug"],"text":""},{"labels":["bug"],"text":"Is there IPv6 support for Mongoose? I couldn't find anything one way or the other on Google or in any of Mongoose's documentation, but from coding myself it doesn't seem like it. For example, when I run `mongod --bind_ip [IPv6-enabled host] --ipv6`, then run my application, `mongoose` can't connect to the host, but when I start the server without `--ipv6` then run my application, `mongoose` connects.\n\nIf there isn't support, is there a timeframe on when it will be added? This isn't urgent for my application, I'm just worried about the future as more networks become IPv6-only.\n"},{"labels":["bug",null],"text":"Sorting of populated documents within subdocuments results in the populated document being attached to the wrong subdocument.\n\nMongoose: `3.8.13`\nMongodb: `2.6.3`\n\nCheck out the differing `quantity` fields when sorting the populated `product` field ascending vs descending...\n\n```\n// Ascending sorting of populated product by \"name\"\n{\n  suborders: [\n    { _id: '...14cb', product: { name: 'Apple' }, quantity: 1 }  // Correct quantity\n    { _id: '...14ca', product: { name: 'Banana' }, quantity: 2 }  // Correct quantity\n  ]\n}\n\n// Descending sorting of populated product by \"name\"\n{\n  suborders: [\n    { _id: '...14cb', product: { name: 'Banana' }, quantity: 1 }  // INCORRECT quantity\n    { _id: '...14ca', product: { name: 'Apple' }, quantity: 2 }  // INCORRECT quantity\n  ]\n}\n```\n\nAscending sort:  1 apple, 2 bananas\nDescending sort:  2 apples, 1 banana\n\nApple should always be attached to the subdocument with _id ending in '14cb', but in the descending sort it's attached to the suborder with _id ending in '14ca'.\n\nFailing test code below...\n\n```\n// SETUP SCHEMA \n\nvar ProductSchema = new mongoose.Schema({ name: String });\nmongoose.model('Product', ProductSchema);\n\nvar SuborderSchema = new mongoose.Schema({\n  product: {\n    type: mongoose.Schema.Types.ObjectId,\n    ref: 'Product'\n  },\n  quantity: Number\n});\n\nvar OrderSchema = new mongoose.Schema({ \n  suborders: [SuborderSchema] \n});\nmongoose.model('Order', OrderSchema);\n\n\n//// FAILING TEST\n\nvar Order = mongoose.model('Order');\nvar Product = mongoose.model('Product');\n\n// Create 2 products\nProduct.create([\n  { name: 'Apple' }, \n  { name: 'Banana' }\n], function(err, apple, banana) {\n\n  // Create order with suborders\n  Order.create({\n    suborders: [\n      {\n        product: apple._id,\n        quantity: 1\n      }, {\n        product: banana._id,\n        quantity: 2\n      }\n    ]\n  }, function(err, order) {\n\n    // Populate with ascending sort \n    Order.findById(order._id)\n      .populate({\n        path: 'suborders.product',\n        options: { sort: 'name' } // ASCENDING SORT\n      }).exec(function(err, order) {\n        console.log('Ascending sort');\n        console.log(order.suborders);\n      }\n    );\n\n    // Populate with descending sort\n    Order.findById(order._id)\n      .populate({\n        path: 'suborders.product',\n        options: { sort: '-name' } // DESCENDING SORT\n      }).exec(function(err, order) {\n        console.log('Descending sort');\n        console.log(order.suborders);\n      }\n    );\n  });\n});\n```\n"},{"labels":["bug"],"text":"For instance, if I had a schema:\n\n```\n{\n    dates: [Date]\n}\n\n```\n\nThe following query will not return any results\n\n```\n{\n    dates: {\n        $elemMatch:{$gt: '2014-07-01T04:00:00.000Z'}\n    }\n}\n```\n\nInstead you must do this to get the right results:\n\n```\n{\n    dates: {\n        $elemMatch:{$gt: new Date('2014-07-01T04:00:00.000Z')}\n    }\n}\n```\n\nI have not tested this with other types, but it would seem the string is not being caste to the right type.\n\nEDIT: I should date string works as expected if it's just one level (ie without $elemMatch).\n"},{"labels":["bug"],"text":"Hi,\n\nSince version 3.8.9, operator equality comparison on ObjectId field doesn't match. \n\nUsing lodash to find _id in array of document also failed.\n\nexports.findAchievementModuleByChapterId = function(achievement,chapterId){\n        return _.find(achievement.modules, { 'currentChapter_id' : chapterId });\n    };\n\nERR1399756867174 Error: ERR0001 : tried to find module for user 52fceec51b01cb0200aeba38 on slide 532c6a3336fe9e9abbdf41db but module can't be found\n    at Promise.<anonymous> (/Users/lcalvy/Documents/Boulot/Sources/coorpacademy/core/lib/achievementHelper.js:39:37)\n    at Promise.<anonymous> (/Users/lcalvy/Documents/Boulot/Sources/coorpacademy/node_modules/mongoose/node_modules/mpromise/lib/promise.js:177:8)\n    at Promise.EventEmitter.emit (events.js:95:17)\n    at Promise.emit (/Users/lcalvy/Documents/Boulot/Sources/coorpacademy/node_modules/mongoose/node_modules/mpromise/lib/promise.js:84:38)\n    at Promise.fulfill (/Users/lcalvy/Documents/Boulot/Sources/coorpacademy/node_modules/mongoose/node_modules/mpromise/lib/promise.js:97:20)\n    at /Users/lcalvy/Documents/Boulot/Sources/coorpacademy/node_modules/mongoose/lib/query.js:1394:13\n    at model.Document.init (/Users/lcalvy/Documents/Boulot/Sources/coorpacademy/node_modules/mongoose/lib/document.js:250:11)\n    at completeOne (/Users/lcalvy/Documents/Boulot/Sources/coorpacademy/node_modules/mongoose/lib/query.js:1392:10)\n    at Object.cb (/Users/lcalvy/Documents/Boulot/Sources/coorpacademy/node_modules/mongoose/lib/query.js:1151:11)\n    at Object.<anonymous> (/Users/lcalvy/Documents/Boulot/Sources/coorpacademy/node_modules/mongoose/node_modules/mquery/lib/utils.js:137:16)\n"},{"labels":["bug"],"text":"Mongoose is throwing an exception when I invoke Model.create(1, function(err) {});\n\nI know \"1\" isn't a valid argument, however I believe it shouldn't throw an exception but invoke my callback with an error.\n\nSee below the error message:\n\n```\nTypeError: Cannot use 'in' operator to search for '_id' in 1\n    at model.Document.$__buildDoc (/src/node_modules/mongoose/lib/document.js:158:27)\n    at model.Document (/src/node_modules/mongoose/lib/document.js:57:20)\n    at model.Model (/src/node_modules/mongoose/lib/model.js:43:12)\n    at new model (/src/node_modules/mongoose/lib/model.js:2498:11)\n    at /src/node_modules/mongoose/lib/model.js:1516:15\n    at Array.forEach (native)\n    at Function.create (/src/node_modules/mongoose/lib/model.js:1515:8)\n    at Object.handle (/src/lib/services/create.js:13:11)\n    at next_layer (/src/node_modules/express/lib/router/route.js:103:13)\n    at Route.dispatch (/src/node_modules/express/lib/router/route.js:107:5)\n```\n"},{"labels":["bug"],"text":"We've been using mongoose 3.6.x for many months, and we've got one model that we set a `secondaryPreferred` read preference on.  We run a 3-member replica set, and it makes sense to offload queries for this one particular collection to our secondaries, to lessen the load on the primary.\n\nWe set it like this, basically speaking:\n\n``` js\nvar TheSchema = new mongoose.Schema({\n  someProp: String,\n  otherProp: Number\n}, {readPreference: 'secondaryPreferred'});\n```\n\nThis has been running fine for over three months - queries were being properly routed to the secondaries, and everything was great.\n\nAfter upgrading to mongoose 3.8.4, however, none of these queries work, and all of them return with this:\n\n```\nMongoError: not master and slaveOk=false\n    at Object.toError (/Users/avianflu/dev/blend-clean/node_modules/mongoose/node_modules/mongodb/lib/mongodb/utils.js:110:11)\n    at /Users/avianflu/dev/blend-clean/node_modules/mongoose/node_modules/mongodb/lib/mongodb/cursor.js:685:54\n    at Cursor.close (/Users/avianflu/dev/blend-clean/node_modules/mongoose/node_modules/mongodb/lib/mongodb/cursor.js:959:5)\n    at commandHandler (/Users/avianflu/dev/blend-clean/node_modules/mongoose/node_modules/mongodb/lib/mongodb/cursor.js:685:21)\n    at /Users/avianflu/dev/blend-clean/node_modules/mongoose/node_modules/mongodb/lib/mongodb/db.js:1806:9\n    at Server.Base._callHandler (/Users/avianflu/dev/blend-clean/node_modules/mongoose/node_modules/mongodb/lib/mongodb/connection/base.js:442:41)\n    at /Users/avianflu/dev/blend-clean/node_modules/mongoose/node_modules/mongodb/lib/mongodb/connection/server.js:485:18\n    at MongoReply.parseBody (/Users/avianflu/dev/blend-clean/node_modules/mongoose/node_modules/mongodb/lib/mongodb/responses/mongo_reply.js:68:5)\n    at null.<anonymous> (/Users/avianflu/dev/blend-clean/node_modules/mongoose/node_modules/mongodb/lib/mongodb/connection/server.js:443:20)\n    at EventEmitter.emit (events.js:95:17)\n```\n\nAny thoughts?  I've isolated this to the mongoose version upgrade.  Server configuration is not relevant.\n"},{"labels":["bug"],"text":"Mongoose version: 3.8.2. \n\nI was having a problem with updating a record to our database, and i've tracked the problem to trying to update a document with an empty array (0 element.)\n\nIn line 1966 of query.js the call to scheme.cast(val) where val is an empty array (array of length 0)\n\n```\nQuery.prototype._castUpdateVal = function _castUpdateVal (schema, val, op, \n...  \nif (schema.caster && op in castOps &&\n    (utils.isObject(val) || Array.isArray(val))) {\n    // Cast values for ops that add data to MongoDB.\n    // Ensures embedded documents get ObjectIds etc.\n    var tmp = schema.cast(val);\n\n    if (Array.isArray(val)) {\n      val = tmp;\n    } else {\n      val = tmp[0];\n    }\n  }\n...}\n```\n\nThe call falls through to the cast function of array.js (line: 124) and because the value argument is an array of length 0, the function tries to call doc.schema (line 128) which fails because no doc element is passed to the function \n\n```\nSchemaArray.prototype.cast = function (value, doc, init) {\n  if (Array.isArray(value)) {\n\n    if (!value.length) {\n      var indexes = doc.schema.indexedPaths();\n\n      for (var i = 0, l = indexes.length; i < l; ++i) {\n        var pathIndex = indexes[i][0][this.path];\n        if ('2dsphere' === pathIndex || '2d' === pathIndex) {\n          return;\n        }\n      }\n    }\n```\n"},{"labels":["bug"],"text":""},{"labels":["bug"],"text":"Hi,\ni've encountered a problem using enum validators for string types (from version 3.8, since version 3.6 everything was ok).\nWhen I use the enum validator the `GLOBAL` node object became polluted with an `errorMessage` property.\n\nVerisons:\nMongoose 3.8\nnode 0.10.18\nmongodb 2.0.0\n\nRunning the following code will raise the problem.\n\n``` javascript\nnew require( 'mongoose' ).Schema( {\n  name: {\n    type: String,\n    enum: [ 'HERP', 'DERP' ]\n  }\n} );\n\nconsole.log( 'errorMessage', errorMessage );\n// will log \"`{VALUE}` is not a valid enum value for path `{PATH}`.\"\n```\n"},{"labels":["bug"],"text":"Sub-docs are not saved if added into populated path.\n\n``` coffee\nmongoose = require \"mongoose\"\nSchema = mongoose.Schema\n\nCar = mongoose.model \"Car\", {\n  color: String\n  model: String\n}\n\nPerson = mongoose.model \"Person\", {\n  name: String\n  cars: [{type: Schema.Types.ObjectId, ref: \"Car\" }]\n}\n\nmongoose.connect \"mongodb://localhost/test\"\ndb = mongoose.connection\ndb.on \"open\", ->\n\n  joe  = new Person name: \"Joe\"\n\n  car1 = new Car { model: \"BMW\", color: \"red\" }\n  joe.cars.push car1\n  console.log \"1. cars = #{joe.cars.length}\"\n\n  joe.save -> car1.save ->\n    joe.populate \"cars\", ( err ) ->\n\n      car2 = new Car { model: \"BMW\", color: \"black\" }\n      joe.cars.push car2\n      console.log \"2. cars = #{joe.cars.length}\"\n\n      joe.save -> car2.save ->\n        joe.populate \"cars\", ( err ) ->\n          console.log \"3. cars = #{joe.cars.length}\"\n\n```\n\nOutput:\n\n```\n1. cars = 1\n2. cars = 2\n3. cars = 1\n```\n"},{"labels":["bug"],"text":"A `#populate( )` options are not retained in result query iff population is defined by query passed to `#merge( )` method as argument.\n\nThat is if `a` defines population then `a.merge( b )` will populate references, but if population defined by `b` query, paths will not be populated. \n\n``` coffee\nmongoose = require \"mongoose\"\nSchema = mongoose.Schema\n\nCar = mongoose.model \"Car\", {\n  color: String\n  model: String\n  owner: { type: Schema.Types.ObjectId, ref: \"Person\"}\n}\n\nPerson = mongoose.model \"Person\", {\n  name: String\n}\n\nmongoose.connect \"mongodb://localhost/test\"\ndb = mongoose.connection\ndb.on \"open\", ->\n\n  joe = new Person name: \"Joe\"\n  bmw = new Car model: \"BMW\", color: \"red\"\n  bmw.owner = joe\n\n  joe.save -> bmw.save ->\n\n    # Case selector\n    wantToPopulate = yes\n\n    if wantToPopulate\n      query = Car.findOne( ).populate( \"owner\", \"name\" )\n      query.merge Car.where( \"model\" ).equals( \"BMW\" )\n    else\n      query = Car.findOne( )\n      query.merge Car.where( \"model\" ).equals( \"BMW\" ).populate( \"owner\", \"name\" )\n\n    query.exec ( err, doc ) ->\n      console.dir doc.toJSON( )\n\n```\n"},{"labels":["bug"],"text":"It seems that dates are being incorrectly by toObject():\n\nhttps://github.com/sambs/mongoose/commit/47caf748916e9203d18239dc2ea8e92dbf734ab8\n\nThe problem seems to be in this line here:\n\nhttps://github.com/LearnBoost/mongoose/blob/master/lib/document.js#L1530\n\n... which treats Dates as objects and runs them through the minimize function.\n"},{"labels":["bug"],"text":"Not sure if this is intentional behavior, but I wanted to alert you all to it. I think it would make most sense to match MongoDB's errors.\n\nThe query is intentionally malformed.\n\n``` javascript\nvar Sample  = mongoose.model('Sample', { text : String, val : Number });\n\nvar sample = new Sample({ text : \"Hello\", val : 100 });\nsample.save(function(err) { if (err) console.log(err); });\n\nSample.find(45, function(err, results) {\n  console.log(err);      // should throw error (MongoDB does)\n  console.log(results);  // should be null. currently returns all\n});\n```\n"},{"labels":["bug"],"text":"Mongoose 3.6.19, node 0.10.13\n\nI was not yet able to reproduce this in a dedicated test case, but it happens inside my code base. I have multiple pre-save hooks, two of them need `place` to be populated. To keep both independent, they are both calling `doc.populate('place', function() {})`, but the second call causes `doc.place` to be `null`.\n\nI've documented my journey through the Mongoose code with screenshots, I hope they help.\n\n![screenshot from 2013-09-15 16 19 49](https://f.cloud.github.com/assets/679144/1145450/c4861060-1e14-11e3-9b94-a1d1f15d2fd7.png)\n![screenshot from 2013-09-15 16 29 56](https://f.cloud.github.com/assets/679144/1145449/c484516c-1e14-11e3-911a-19db35b0db1c.png)\n![screenshot from 2013-09-15 16 31 31](https://f.cloud.github.com/assets/679144/1145451/c4888e9e-1e14-11e3-93c4-e2a477c1f973.png)\n![screenshot from 2013-09-15 16 33 23](https://f.cloud.github.com/assets/679144/1145452/c48c3760-1e14-11e3-9db9-03054c9d1df0.png)\n\nThe very last screenshot shows the exact line where `place` suddenly becomes `null`. The two console outputs were made before and after the loop.\n\nUsing debug mode I can see that both calls send the exact same query to MongoDB, so that's not the issue.\n"},{"labels":["bug"],"text":"Following code throws `TypeError` exception (v3.6.19)\n\n``` coffee\nmongoose = require( \"mongoose\" )\nSchema   = mongoose.Schema\n\nSub = new Schema name: String, { _id: no }\nOut = new Schema subs: [ Sub ]\n\nOut = mongoose.model( \"Out\", Out )\n\ninst = new Out( )\ninst.subs.addToSet( name: \"some\" )\ninst.subs.addToSet( name: \"some\" ) #<-- here\n```\n"},{"labels":["bug"],"text":"Using Mongoose 3.6.19 and node 0.10.11.\n\nSorry if I've misunderstood the usage here.\n\nI have a schema:\n\n```\nvar Place = new mongoose.Schema({\n  geo: { type: [Number], index: '2dSphere' }\n});\nmongoose.Model('Place', Place);\n```\n\nWhen I try and use the `.near()` condition on the query, like this:\n\n```\nmongoose.Model('Place').find().where('geo').near({\n  center : { type : 'Point', coordinates: [-33.88,151.21] },\n  maxDistance : 100\n}).exec(function(err){ console.log(err); });\n```\n\nI get the following error:\n\n```\n{\n  \"message\": \"Cast to number failed for value \\\"[object Object]\\\" at path \\\"geo\\\"\",\n  \"name\": \"CastError\",\n  \"type\": \"number\",\n  \"value\": {\n    \"$geometry\": {\n      \"type\": \"Point\",\n      \"coordinates\": [\n        \"-33.88479\",\n        \"151.211875\"\n      ]\n    }\n  },\n  \"path\": \"geo\"\n}\n```\n\nI have tried several variations on the syntax, but nothing seems to work.\n\nBased on the docs linked to at http://docs.mongodb.org/manual/reference/operator/nearSphere/, this generates the same error:\n\n```\nmongoose.Model('Place').find().where('geo').nearSphere({'$geometry': { type: \"Point\", coordinates: near }}).maxDistance(100);\n```\n\nThe issue also seems to have been discussed on stack overflow:\nhttp://stackoverflow.com/questions/17605503/using-find-with-geospatial-coordinates-in-mongoose-nodejsmongodb\n\nHaving noticed several changes related to `near` in 3.7.x, I tried upgrading to the unstable branch but get the same results.\n\nAny help (working examples, bug confirmation, ?) would be great.\n\nFor what it's worth, `query.within` seems to be more fully featured and works as expected on my model.\n"},{"labels":["bug"],"text":"When using the mpath notation to update an array of subdocuments, it blows up.\nAttached is a nodeunit test case \n\n``` javascript\n\nvar mongoose = require('mongoose'),\n    Schema = mongoose.Schema ;\n\nvar CommentSchema = new Schema({\n    title:{type: String}, body: {type:String}\n});\n\n\nvar BlogPostSchema = new Schema({\n    title: String, body: String, comments: [CommentSchema]\n});\nvar BlogPost = mongoose.model('BlogPost', BlogPostSchema);\nvar Comment = mongoose.model('Comment', CommentSchema);\nvar connection = mongoose.connection;\nvar blog = new BlogPost({\n    title: 'Hello',\n    body: 'goodbye',\n    comments: [\n        {title: 'Comment 1', body: 'Body Comment 1'},\n        {title: 'Comment 2', body: 'Body Comment 2'}\n    ]\n});\n\nvar id;\nmodule.exports.setUp = function (done) {\n    connection.on('open', function () {\n        connection.db.dropDatabase(function () {\n            console.log('dropped database [' + connection.name + ']');\n            blog.save(function (err, obj) {\n                console.log('all done with saving user', obj);\n                id = obj._id;\n                done();\n            });\n        });\n    })\n    mongoose.connect('mongodb://localhost/deepexample', function () {\n        console.log('connected');\n\n    });\n}\nmodule.exports.tearDown = function (done) {\n    mongoose.disconnect(function () {\n        console.log('disconnecting');\n        done();\n\n    });\n}\n\nmodule.exports['findById and update using set'] = function (test) {\n    BlogPost.findOne({_id:id}, function (err, obj) {\n        if (err) {\n            console.log('err ' + id, err)\n            test.done(err);\n        }\n//If you switch these two lines it works.\n//       obj.comments[1].title = 'Nope';\n        obj.set('comments.1', {title: 'Nope'})\n        obj.save(function (err, obj) {\n            if (err) {\n                console.log('Error', err.message, err.stack);\n                test.ok(false);\n                return test.done();\n            }\n            console.log('got', obj);\n            test.equals(obj.comments[1].title, 'Nope');\n            test.done();\n\n        })\n    })\n\n}\n\n```\n\nStack Trace looks like\n\n```\nError Property 'id' of object { title: 'Comment 2',\n  body: 'Body Comment 2',\n  _id: 5227ee26e182586d15000003 } is not a function TypeError: Property 'id' of object { title: 'Comment 2',\n  body: 'Body Comment 2',\n  _id: 5227ee26e182586d15000003 } is not a function\n    at DocumentArray.cast (path/node_modules/mongoose/lib/schema/documentarray.js:137:36)\n    at DocumentArray.cast (path/node_modules/mongoose/lib/schema/documentarray.js:121:17)\n    at DocumentArray.SchemaType.applySetters (path/node_modules/mongoose/lib/schematype.js:477:17)\n    at path/node_modules/mongoose/lib/document.js:545:18\n    at model.Document.$__try (path/node_modules/mongoose/lib/document.js:758:8)\n    at model.Document.set (path/node_modules/mongoose/lib/document.js:544:24)\n    at Promise.<anonymous> (path/test/deepmongoose-test.js:60:13)\n    at Promise.<anonymous> (path/node_modules/mongoose/node_modules/mpromise/lib/promise.js:162:8)\n    at Promise.EventEmitter.emit (events.js:95:17)\n    at Promise.emit (path/node_modules/mongoose/node_modules/mpromise/lib/promise.js:79:38)\n    at Promise.fulfill (path/node_modules/mongoose/node_modules/mpromise/lib/promise.js:92:20)\n    at path/node_modules/mongoose/lib/query.js:1823:13\n    at model.Document.init (path/node_modules/mongoose/lib/document.js:251:11)\n    at completeOne (path/node_modules/mongoose/lib/query.js:1821:10)\n    at path/node_modules/mongoose/lib/query.js:1789:11\n    at path/node_modules/mongoose/lib/utils.js:414:16\n    at path/node_modules/mongoose/node_modules/mongodb/lib/mongodb/collection.js:953:5\n    at Cursor.nextObject (path/node_modules/mongoose/node_modules/mongodb/lib/mongodb/cursor.js:678:5)\n    at commandHandler (path/node_modules/mongoose/node_modules/mongodb/lib/mongodb/cursor.js:658:14)\n    at path/node_modules/mongoose/node_modules/mongodb/lib/mongodb/db.js:1670:9\n    at Server.Base._callHandler (path/node_modules/mongoose/node_modules/mongodb/lib/mongodb/connection/base.js:382:41)\n    at path/node_modules/mongoose/node_modules/mongodb/lib/mongodb/connection/server.js:472:18\n    at MongoReply.parseBody (path/node_modules/mongoose/node_modules/mongodb/lib/mongodb/responses/mongo_reply.js:68:5)\n    at null.<anonymous> (path/node_modules/mongoose/node_modules/mongodb/lib/mongodb/connection/server.js:430:20)\n    at EventEmitter.emit (events.js:95:17)\n    at null.<anonymous> (path/node_modules/mongoose/node_modules/mongodb/lib/mongodb/connection/connection_pool.js:191:13)\n    at EventEmitter.emit (events.js:98:17)\n    at Socket.<anonymous> (path/node_modules/mongoose/node_modules/mongodb/lib/mongodb/connection/connection.js:384:22)\n    at Socket.EventEmitter.emit (events.js:95:17)\n    at Socket.<anonymous> (_stream_readable.js:699:14)\n    at Socket.EventEmitter.emit (events.js:92:17)\n    at emitReadable_ (_stream_readable.js:382:10)\n    at emitReadable (_stream_readable.js:377:5)\n    at readableAddChunk (_stream_readable.js:142:7)\n    at Socket.Readable.push (_stream_readable.js:112:10)\n    at TCP.onread (net.js:511:21)\ndisconnecting\n\n\n\n```\n"},{"labels":["bug"],"text":"error:\n\n```\n{ [MongoError: exception: assertion src/mongo/db/../bson/bsonobjbuilder.h:92]\n  name: 'MongoError',\n  lastErrorObject: \n   { updatedExisting: true,\n     n: 1,\n     connectionId: 849,\n     err: null,\n     ok: 1 },\n  errmsg: 'exception: assertion src/mongo/db/../bson/bsonobjbuilder.h:92',\n  code: 0,\n  ok: 0 }\n```\n\nto reproduce:\n\n```\nvar SearchSchema = new Schema({\n  query: {\n    type: String\n  },\n  views:{\n    type: Number,\n    default: 0\n  }\n});\n\nSearch.findOneAndUpdate({\n    'query': \"some text\"\n  }, {\n    $inc: {\n      views: 1\n    }\n  }, {\n    upsert: true\n  }, cb);\n\n```\n\n```\n$ mongod --version\ndb version v2.4.6\nWed Sep  4 23:49:41.589 git version: b9925db5eac369d77a3a5f5d98a145eaaacd9673\n\nmongoose version: \"3.6.18\"\n```\n"},{"labels":["bug"],"text":"The reconnected event no longer works for replica sets.\n\nThe driver has a new \"reconnect\" event for single mongod connections\nbut we still need the proper driver events emitted to support this again.\n"},{"labels":["bug"],"text":"I have an application with users and groups. I declared users, groups and members ( a member is a reference to a user plus the role in the group) :\n\nvar UserSchema = new Schema({\n    _id: {type: String },\n    name: { type: String, default: '' },\n    email: { type: String, default: '' },\n    username: { type: String, default: ''},\n    hashed_password: { type: String, default: '' },\n    salt: { type: String, default: '' },\n})\n\nvar MemberSchema = new Schema({\n    user: { type: String, ref: 'User' },\n    role: { type: String, default: 'colaborator' },\n},{ _id : false });\n\nvar GroupSchema = new Schema({\n    _id : { type: String},\n    name: { type: String, default: '' },\n    description: { type: String, default: '' },\n    created_at: { type: Date, default: Date.now},\n    image: {type: String},\n    members : [MemberSchema]\n});\n\nWhen I try to populate the user from the group.members by using: \n\nGroupSchema.statics = {\n    getAll: function (callback) {\n        this.find(null, \"description name members -_id\")\n            .populate('members.user','username name -_id')\n            .exec(callback);\n    }\n};\n\nI end up with the full userSchema instead of just the username and name as expected:\n\n{\n        \"members\": [\n            {\n                \"user\": {\n                    \"salt\": \"a_salt\",\n                    \"hashed_password\": \"a_password\",\n                    \"username\": \"a_username2\",\n                    \"email\": \"a_mail@mail.com\",\n                    \"name\": \"a_name\"\n                },\n                \"role\": \"admin\"\n            },\n             {\n                \"user\": {\n                    \"salt\": \"a_salt2\",\n                    \"hashed_password\": \"a_password2\",\n                    \"username\": \"a_username2\",\n                    \"email\": \"a_mail2@mail.com\",\n                    \"name\": \"a_name2\"\n                },\n                \"role\": \"admin\"\n            }\n        ],\n        \"image\": \"an_image.jpg\",\n        \"description\": \"\",\n        \"name\": \"a_groupname\"\n    },\n\nNo _id but has all the other atributes. \nIf I select only the atributes i need:\n\nGroupSchema.statics = {\n    getAll: function (callback) {\n        this.find(null, \"description name members -_id\")\n            .populate('members.user','username name')\n            .exec(callback);\n    }\n};\n\nI end up with just those atributes and the _id:\n{\n        \"members\": [\n            {\n                \"user\": {\n                    \"_id\": \"an_id\",\n                    \"username\": \"a_username\",\n                    \"name\": \"a_name\"\n                },\n                \"role\": \"admin\"\n            },\n            {\n                \"user\": {\n                    \"_id\": \"an_id2\",\n                    \"username\": \"a_username2\",\n                    \"name\": \"a_username2\"\n                },\n                \"role\": \"collaborator\"\n            }\n        ],\n        \"image\": \"an_image.jpg\",\n        \"description\": \"\",\n        \"name\": \"a_groupname\"\n    }\n\nLooks like It doesn't allow to select fields and remove the id at the same time.\n\nThanks in advanced.\n"},{"labels":["bug"],"text":"Node version: 0.10.15\nMongoDB version: 2.4.5\nMongoose version: 3.6.16 / 3.7.2 (tried both)\n\nI have a problem whereby after using stream to read data from a collection, all subsequent errors are dropped silently. Here is a minimal example:\n\n``` javascript\n  var mongoose = require('mongoose');\n  var async = require('async');\n\n  var getDataFromDb, main, testFunc, wrapFunc;\n\n  getDataFromDb = function(callback) {\n    var Category, CategorySchema, d;\n    mongoose.connect(\"mongodb://somedburi\");\n    CategorySchema = new mongoose.Schema({\n      name: String\n    });\n    Category = mongoose.model('Category', CategorySchema);\n    d = Category.find().stream();\n    d.on('error', function(err) {\n      console.error(\"Error occurred while reading categories collection\");\n      return callback(err);\n    });\n    return d.on('close', function() {\n      console.log(\"Data read from collection successfully\");\n      return callback(null, {});\n    });\n  };\n\n  testFunc = function(callback) {\n    fsdlkjfsdfksdldfskl;\n    console.log('in testFunc()');\n    return callback();\n  };\n\n  wrapFunc = function(callback) {\n    return async.series([\n      function(cb) {\n        return getDataFromDb(function(err, data) {\n          if (err != null) {\n            return cb(err);\n          }\n          return cb();\n        });\n      }, function(cb) {\n        console.log('in second async');\n        return testFunc(cb);\n      }\n    ], function(err) {\n      if (err != null) {\n        return callback(err);\n      }\n      return callback(null, 'DONE');\n    });\n  };\n\n  main = function() {\n    return wrapFunc(function(err, userIndex) {\n      if (err != null) {\n        console.log(err);\n        return process.exit(1);\n      } else {\n        console.log(userIndex);\n        return process.exit(0);\n      }\n    });\n  };\n\n  if (require.main === module) {\n    main();\n  }\n```\n\nWhen calling with the first line in `testFunc` commented out (no error) then I get the following output as expected:\n\n```\n$ node testfile.js\nData read from collection successfully\nin second async\nin testFunc()\nDONE\n```\n\nHowever, when uncommenting the first line in `testFunc`, rather than an error getting raised, I get the following output:\n\n```\n$ node testfile.js\nData read from collection successfully\nin second async\n```\n\ni.e. the error is dropped silently. Finally, if I move the function call to be the first function in the `async.series` command, an error is raised as expected:\n\n```\n$ node testfile.js\nin second async\nReferenceError: fsdlkjfsdfksdldfskl is not defined\n```\n\nIt seems that any errors in code in the callback returning from a mongoose stream read is always silently dropped. I've tried the same code with a node filestream, and the error is properly raised, so this seems to be a mongoose specific issue.\n"},{"labels":["bug"],"text":"The current implementation of Model.remove() in https://github.com/LearnBoost/mongoose/blob/master/lib/model.js is broken.\n\nIt does not use the conditions parameter.\n\n``` javascript\nModel.remove = function remove (conditions, callback) {\n  if ('function' === typeof conditions) {\n    callback = conditions;\n    conditions = {};\n  }\n\n  // get the mongodb collection object\n  var mq = new Query({}, {}, this, this.collection);\n\n  return mq.remove(callback);\n};\n```\n\nTherefore when you have a User model and you call User.remove({_id:'uniqueId'}) it removes all documents from the collection.\n"},{"labels":["bug"],"text":""},{"labels":["bug"],"text":"When you remove an item from a subdocument in an array, the validations fail on save.  Actually it may be breaking more stuff than the validations, haven't looked too closely.\n\nTo reproduce: \na) create an document with an array of children\nb) modify document.children[1].value\nc) delete document.children[0]\nd) try to save\n\nbasically, it's trying to validate  `document.children[1].value` even though that value is now in position 0 in the array.\n\nHere's some code to reproduce the issue:\n\n``` js\nvar mongoose = require(\"mongoose\");\n\nvar ItemChildSchema = new mongoose.Schema({\n  name: { type: String, required: true, default: \"hello\" },\n});\n\nvar ItemParentSchema = new mongoose.Schema({\n  children: [ItemChildSchema]\n});\n\nmongoose.connect('mongodb://localhost/testvalidation');\n\nvar ItemParent =  mongoose.model('ItemParent', ItemParentSchema);\nvar ItemChild =  mongoose.model('ItemChild', ItemChildSchema);\nvar c1 = new ItemChild({ name: 'first child'});\nvar c2 = new ItemChild({ name: 'second child'});\n\nvar p = new ItemParent({\n  children: [c1, c2]\n})\n\np.save(function(err) {\n  if (err) throw err;\n\n  c2.name = 'updated 2'\n  p.children = [c2];\n\n  console.log('trying to modify', p.$__.activePaths.states.modify);\n  p.save(function(err) {\n    if (err) throw err;\n\n    console.log(\"saved\");\n  })\n\n});\n```\n\noutputs:\n\n```\ntestmongoose $ node test.js                                                                                                                                                                                                                            ~/src/testmongoose 18 â†µ\ntrying to modify { children: true }\n{ 'children.1.name': true, children: true }\n\n/Users/jandre/src/testmongoose/test.js:38\n    if (err) throw err;\n                   ^\nValidationError: Validator \"required\" failed for path name with value `undefined`\n    at model.Document.invalidate (/Users/jandre/src/testmongoose/node_modules/mongoose/lib/document.js:982:32)\n    at Document.validate.err (/Users/jandre/src/testmongoose/node_modules/mongoose/lib/document.js:951:16)\n    at validate (/Users/jandre/src/testmongoose/node_modules/mongoose/lib/schematype.js:561:7)\n    at SchemaType.doValidate (/Users/jandre/src/testmongoose/node_modules/mongoose/lib/schematype.js:577:9)\n    at Array.forEach (native)\n    at SchemaString.SchemaType.doValidate (/Users/jandre/src/testmongoose/node_modules/mongoose/lib/schematype.js:565:19)\n    at Document.validate.err (/Users/jandre/src/testmongoose/node_modules/mongoose/lib/document.js:949:9)\n    at process.startup.processNextTick.process._tickCallback (node.js:245:9)\n```\n"},{"labels":["bug"],"text":"I was working with CRUD API with Mongoose on back end and found an Issue in its Model constructor.\n\nThe issue appears when I'm passing populated object to it:\n\n``` coffee-script\ndoc = new MyModel populated_js_object\n```\n\nThe problem appears only when `populated_js_object` is a plain `js` object and only on scalar fields.\n\nSetting the desired field after my document was created works perfect.\n\nI created an example to illustrate my issue:\n\n``` coffee-script\n{Schema} = mongoose = require 'mongoose'\nObjectId = Schema.ObjectId\n\nElement = mongoose.model 'Element', new Schema\n  name    : String\n\nSome = mongoose.model 'Some', new Schema\n  object  : type: ObjectId, ref: 'Element'\n  array   : [type: ObjectId, ref: 'Element']\n\ntests = (docs) ->\n  oid_set: do ->\n    some = new Some\n    some.object = docs[0]._id\n    some.array = [docs[1]._id, docs[2]._id]\n    some\n  oid_ctor: do ->\n    data =\n      object: docs[0]._id\n      array: [docs[1]._id, docs[2]._id]\n    some = new Some data\n  obj_set: do ->\n    some = new Some\n    some.object = docs[0]\n    some.array = docs[1..2]\n    some\n  obj_ctor: do ->\n    # This is the buggy one\n    data =\n      object: docs[0]\n      array: docs[1..2]\n    some = new Some data\n\ndocs = for i in [1..3]\n  name = Math.random().toString(36).slice(2,12)\n  element = new Element {name}\n  element.toObject() # It works fine without toObject()\n\nconsole.log tests(docs)\n```\n\nHere I'm creating `Some` documents with four different ways. The result should be the same, but it's not:\n\n```\n{ oid_set: \n   { object: 51fb603e68c188c514000001,\n     _id: 51fb603e68c188c514000004,\n     array: [ 51fb603e68c188c514000002, 51fb603e68c188c514000003 ] },\n  oid_ctor: \n   { object: 51fb603e68c188c514000001,\n     _id: 51fb603e68c188c514000005,\n     array: [ 51fb603e68c188c514000002, 51fb603e68c188c514000003 ] },\n  obj_set:\n   { object: 51fb603e68c188c514000001,\n     _id: 51fb603e68c188c514000006,\n     array: [ 51fb603e68c188c514000002, 51fb603e68c188c514000003 ] },\n  obj_ctor: \n   { _id: 51fb603e68c188c514000007,\n     array: [ 51fb603e68c188c514000002, 51fb603e68c188c514000003 ] } }\n```\n\n`object` field is missing in the object, created in `obj_ctor` test.\n\nI also noticed that passing `mongoose.Model` instance instead of plain `js` object solves the problem, but constructor supposed to work the same for wrapped and unwrapped objects.\n"},{"labels":["bug"],"text":"- [ ] takes a long time to connect\n- [ ] query buffering after first attempt\n"},{"labels":["bug"],"text":"I met such kind of error when I try to update an element in an array of ObjectID using  $ positional operator.\n\nHere is my schema:\n\n``` js\nvar Schema = mongoose.Schema;\n\nvar playerSchema = new Schema({\n...\n  units: [\n    {\n      type: Schema.Types.ObjectId,\n      ref: 'Unit'\n    }\n  ],\n...\n});\n```\n\nAnd I try to update a unit in the array with a new one:\n\n``` js\nplayerSchema.methods.upgrade = function (unitId, stone, query, callback) {\n...\n        this.model('Player').update({_id: this._id, 'units': unitId}, {\n          $set: {'units.$': newUnit._id}\n        }, function removeOldUnit(err) {\n...\n          });\n};\n```\n\nThen I got an error shown in title: Cannot call method 'path' of undefined.\n\nAfter tracing the source code of mongoose, I guess I found the root cause in lib/model.js:\n\n``` js\nModel._getSchema = function _getSchema (path) {\n  var schema = this.schema\n    , pathschema = schema.path(path);\n\n  if (pathschema)\n    return pathschema;\n\n  // look for arrays\n  return (function search (parts, schema) {\n    var p = parts.length + 1\n      , foundschema\n      , trypath\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema) {\n\n        /////\n        //Note: I'm not sure what the 'caster' means but I think you guys use it to                          handle sub-doc or Mixed type later. But for my case, the ObjectId type doesn't need to go to this branch. I tried to return foundschema here directly and it worked fine for my case.\n        /////\n\n        if (foundschema.caster) {\n\n          // array of Mixed?\n          if (foundschema.caster instanceof Types.Mixed) {\n            return foundschema.caster;\n          }\n\n          // Now that we found the array, we need to check if there\n          // are remaining document paths to look up for casting.\n          // Also we need to handle array.$.path since schema.path\n          // doesn't work for that.\n          if (p !== parts.length) {\n            if ('$' === parts[p]) {\n              // comments.$.comments.$.title\n              return search(parts.slice(p+1), foundschema.schema);\n            } else {\n              // this is the last path of the selector\n              return search(parts.slice(p), foundschema.schema);\n            }\n          }\n        }\n        return foundschema;\n      }\n    }\n  })(path.split('.'), schema)\n}\n```\n"},{"labels":["bug"],"text":"Hi,\n\nwe was fighting with high rss consumption last days since we switched to node 0.10.12. We finally found out where the problem actually is. Its probably not directly a mongoose issue, but I think mongoose users might want to know about this and if we get a mongoose free reproducible code, then we can create an issue on node or v8 tracker.\n\nWe tracked down the issue you can reproduce with the code from gist to this particular part:\n\n```\nuser.virtual('currency').get(function() {\n\n    // This reference will bever be cleaned up by incremental gc\n    return this.location.country;\n});\n```\n## Behaviour\n\nWhen you start to send requests, memory usage gets higher and higher until OS limit is reached, gc is not able to cleanup in this specific case provided in the example.\n## Hotfix\n\nIf you use  gc_global option for v8 \"node --gc_global mongoose-test.js\" which will reenable periodical garbage collector, the issue will not be reproducible any more.\n## Since when\n\nhttps://github.com/joyent/node/commit/d607d856afc744b1e6bc42cdb9b67b6c4e7e4876\n\nThis commit is the point where the issue comes in play.\n\nIn my opinion incremental gc has a bug.\n\nThis commit is relased with node 0.9.4, the issue is not reproducible in all versions below and it is reproducible in all version higher.\n## How to reproduce\n1. Download 2 files from this gist https://gist.github.com/kof/5884355\n2. start mongod\n3. $ node mongoose-test.js\n4. $ for i in {1..500}; do curl http://localhost:8888/; done\n"},{"labels":["bug"],"text":"Mongoose `3.6.11`, node `0.10.5`\n## Test case\n\n``` js\nvar mongoose = require('mongoose');\nvar Schema = mongoose.Schema;\n\nmongoose.connect('mongodb://localhost/mongoose-bug')\n\nvar thingSchema = new Schema({\n    _id: String,\n    flag: {\n        type: Boolean,\n        \"default\": false\n    }\n});\n\nvar Thing = mongoose.model('Thing', thingSchema);\nvar key = 'some-id';\n\nThing.findOneAndUpdate({_id: key}, {$set: {flag: false}}, {upsert: true, \"new\": false}).exec(function(err, thing) {\n    console.dir(thing);\n});\n```\n## Actual output\n\n> First run:\n> { flag: false }\n> Second run:\n> { _id: 'some-id', flag: false }\n## Expected output\n\n> First run:\n> null\n> Second run:\n> { _id: 'some-id', flag: false }\n"},{"labels":["bug"],"text":"In my case every document Stream has a Stream.pictures containing an array of documents Picture.\n\nHere is what I get with using\n\n``` js\nStream.find({}).exec(err, docs) {\n  console.log(docs);\n});\n```\n\n``` js\n$ node test.js\n[ {\n    _id: 5196b332006b870000000008,\n    pictures:\n     [ 5196b33a006b870000000009,\n       5196b4b5006b87000000000a,\n       5196b4c8006b87000000000b,\n       5196b505006b87000000000d ],\n  },\n  { \n    _id: 51975c2716798c0000000001,\n    pictures:\n     [ 51975c3216798c0000000002,\n       51975c7c16798c0000000003,\n       51975ca016798c0000000004,\n       51975f51353d650000000001 ],\n  } ]\n```\n\nWhen I am using the new `populate()` in which I can pass an object such as:\n\n``` js\nStream\n  .find({})\n  .populate({\n      path: 'pictures',\n      options: { limit: 5}\n  })\n  .exec(function(err, docs) {\n    console.log(docs);\n  });\n```\n\nHowever I don't get 4 elements an 4 elements but I only get a total of 5 elements (and therefore this limit is a global limit), however, using populate I would expect to have a limit of 5 picture for each picture (so a local limit).\n\n``` js\n[ { \n    _id: 5196b332006b870000000008,\n    pictures:\n     [ { _id: 5196b33a006b870000000009 },\n       { _id: 5196b4b5006b87000000000a },\n       { _id: 5196b4c8006b87000000000b },\n       { _id: 5196b505006b87000000000d }]\n  },\n  { \n    _id: 51975c2716798c0000000001,\n    pictures:\n     [ { _id: 51975c3216798c0000000002 } ],\n} ]\n```\n\nIs there a way to do so, or is it a bug?\n"},{"labels":["bug"],"text":"Attached code should be enough self explaining.\n\nmongoose 3.6.11, mongodb: 2.2.2\n\n``` javascript\nschema = mongoose.Schema({\n    sub: [{name: String}]\n});\n\nModel = mongoose.model('Model', schema);\nModel.remove({}, function(err) {\n    var m = new Model();\n    m.sub.push({name: 'A'});\n    m.sub.push({name: 'B'});\n\n    m.save(function(err) {\n        Model.find({'sub.name': 'B'})\n        .select('sub.$')\n        .exec(function(err, items) {\n            console.dir(items[0]); // check if name is \"B\"\n            items[0].sub[0].name = 'C';\n            items[0].save(function(err) {\n                Model.find({}, function(err, items) {\n                    console.dir(items); // we have \"C\" and \"B\", should be \"A\" and \"C\"\n                });\n            });\n        });\n    });\n});\n```\n\nAm I doing something wrong? Thank you.\n"},{"labels":["bug"],"text":"I believe I've traced this down.  I had the same problem for nested schemas.  I have a schema like: \n\nvar Person = new Schema({\n  email          : {type: String, lowercase: true, trim: true}\n  , address        : {\n    street: {type: String}\n    , city: {type: String}\n    , state: {type: String}\n    , zip: {type: String}\n    , country: {type: String} }\n});\n\nI use \"init\" to take data from an http request and populate a model object, like this\n\nvar person = new Person();\nperson.init(req.body.user);\n\nreq.body.user looks  sort of like: \n\n{     email: 'asdf',\n       address: { street: 'x', city: '', state: '', zip: '', country: '' } } \n\nTurns out that the **proto** for req.body.user.address is null.  By by setting req.body.user.address to have a **proto** that is from Object, errors are gone.  I just used:\n\nreq.body.user.address = _.extend({}, req.body.user.address);\n\nNow saves work, no error about 'cannot read property 'name' of undefined.  I was previously getting the same error, here's a stack in case that is helpful:\n\nTypeError: Cannot read property 'name' of undefined\n        at init (/Users/evadnoob/Projects/mi/node_modules/mongoose/lib/document.js:270:61)\n        at model.Document.init (/Users/evadnoob/Projects/mi/node_modules/mongoose/lib/document.js:239:3)\n        at Promise.exports.save.async.waterfall.log.trace.user.toObject.virtuals (/Users/evadnoob/Projects/mi/lib/users.js:80:18)\n        at Promise.onResolve (/Users/evadnoob/Projects/mi/node_modules/mongoose/node_modules/mpromise/lib/promise.js:162:8)\n        at Promise.EventEmitter.emit (events.js:96:17)\n        at Promise.emit (/Users/evadnoob/Projects/mi/node_modules/mongoose/node_modules/mpromise/lib/promise.js:79:38)\n        at Promise.fulfill (/Users/evadnoob/Projects/mi/node_modules/mongoose/node_modules/mpromise/lib/promise.js:92:20)\n        at /Users/evadnoob/Projects/mi/node_modules/mongoose/lib/query.js:1822:13\n        at model.Document.init (/Users/evadnoob/Projects/mi/node_modules/mongoose/lib/document.js:243:11)\n        at completeOne (/Users/evadnoob/Projects/mi/node_modules/mongoose/lib/query.js:1820:10)\n"},{"labels":["bug"],"text":"I really don't understand this. Just updated to mongoose 3.6.10. This is the error, and below you can see the request the produces it, code etc.\n\n[05/14 02:15:11 GMT+0300] TypeError: Cannot read property 'name' of undefined\n[05/14 02:15:11 GMT+0300]     at model.Document.set (/opt/haibu/apps/oriben/hangies-crud/package/node_modules/mongoose/lib/document.js:435:49)\n[05/14 02:15:11 GMT+0300]     at model.Document (/opt/haibu/apps/oriben/hangies-crud/package/node_modules/mongoose/lib/document.js:61:10)\n[05/14 02:15:11 GMT+0300]     at model.Model (/opt/haibu/apps/oriben/hangies-crud/package/node_modules/mongoose/lib/model.js:38:12)\n[05/14 02:15:11 GMT+0300]     at new model (/opt/haibu/apps/oriben/hangies-crud/package/node_modules/mongoose/lib/model.js:2125:11)\n[05/14 02:15:11 GMT+0300]     at /opt/haibu/apps/oriben/hangies-crud/package/app.js:2345:12\n[05/14 02:15:11 GMT+0300]     at validatePost (/opt/haibu/apps/oriben/hangies-crud/package/app.js:212:3)\n[05/14 02:15:11 GMT+0300]     at /opt/haibu/apps/oriben/hangies-crud/package/app.js:2344:4\n[05/14 02:15:11 GMT+0300]     at Promise.authenticateWithToken (/opt/haibu/apps/oriben/hangies-crud/package/app.js:351:23)\n[05/14 02:15:11 GMT+0300]     at Promise.onResolve (/opt/haibu/apps/oriben/hangies-crud/package/node_modules/mongoose/node_modules/mpromise/lib/promise.js:162:8)\n[05/14 02:15:11 GMT+0300]     at Promise.EventEmitter.emit (events.js:96:17)\n\nthis is the request that causes the error:\n\n[05/14 02:15:11 GMT+0300] {\"ev\":\"serving\",\"path\":\"/posts\",\"method\":\"POST\",\"body\":{\"place\":{\"location\":[\"-122.031961\",\"37.330533\"],\"vicinity\":\"10600 North De Anza Boulevard\",\"pname\":\"The Sobrato Organization\",\"googid\":\"a74ee06a9a58de03b1a650c017db0cb6f5c694ea\",\"refer\":\"CoQBdgAAAP2O-Fw9mQyeF9_OjXHkxgPk1JHWcqTE8ol8nMLCfntjx35lcvArmxRhkvmjZbGRprcIRmXjYeMyQDJQq_ARRYOalFWoJimLlHKHbWFeKYk92N8C_YZBCDNS8tYyGHB4uH4CkgZaLt0Vx1AINPGnLXiESLEbLRIfyuq3tC41n2iYEhBO4qSb6LI77lPtzYgOWC05GhRYlrYLDzPnwCl7AdDXT-tIamwBkg\"},\"loc\":[\"-122.0312186\",\"37.33233141\"],\"orientation\":\"landscape\",\"body\":\" \"},\"query\":{},\"ip\":\"10.112.35.239\"}\n\nrelevant code from app.js: \n\n``` javascript\napp.post('/posts', function (req,res) {\n    res.contentType('application/json');\n    authenticateWithToken(req, res, function(err,user) {\n        if (err) {\n            console.log(JSON.stringify({\"ev\":\"error\",\"errorobj\":err.message}));\n        } else if (user) {\n            console.log(\"2\");\n            validatePost(req.body, user, 'create', function(ok, errs) {\n                post = new Post(req.body);\n                console.log(\"3\");\n```\n\nfrom document.js\n\n``` javascript\n        if (null != path[key]\n            && 'Object' == path[key].constructor.name\n            && 'virtual' != pathtype\n            && !(this.$__path(prefix + key) instanceof MixedSchema)) {\n```\n\ni'm exhausted from trying to solve it :( any help will be appreciated.\n"},{"labels":["bug"],"text":"```\n$ mongo --version\nMongoDB shell version: 2.4.3\n$ node -v\nv0.10.5\n```\n\nmongoose version is 3.6.9\n\nthe following code:\n\n```\nvar mongoose = require('mongoose');\n\nmongoose.connect('127.0.0.1/test');\n\nvar DocSchema = new mongoose.Schema({\n  _id: String,\n  foo: String\n});\n\nvar Doc = mongoose.model('docs', DocSchema);\n\nvar doc = new Doc({\n  _id: 'some_id',\n  foo: 'bar'\n});\n\ndoc.save(function(err) {\n  console.log(\"doc.save err:\", err);\n\n  Doc.findById('some_id', function(err, doc1) {\n    console.log(\"Doc.findById err:\", err);\n    console.log('doc:', doc1);\n\n    doc1.increment();\n    console.log('doc:', doc1);\n\n    doc1.save(function(err, doc) {\n      console.log(\"doc.save err:\", err);\n    });\n  });\n});\n```\n\ncauses an error, all output:\n\n```\n $ node example/increment.js \ndoc.save err: null\nDoc.findById err: null\ndoc: { _id: 'some_id', foo: 'bar', __v: 0 }\ndoc: { _id: 'some_id', foo: 'bar', __v: 0 }\ndoc.save err: { message: 'No matching document found.', name: 'VersionError' }\n```\n\nI incorrect use the _increment_ method, or something goes wrong?\n"},{"labels":["bug"],"text":"see https://github.com/LearnBoost/mongoose/issues/1442#issuecomment-17263317\n\n``` js\nvar Cat = mongoose.model('cats', new Schema({ name: String }));\nvar Litter = mongoose.model('litters', new Schema({name: String, cats: {}}));\n\nvar kitty = new Cat({ name: 'Zildjian' });\nkitty.save(function (err, meowness) {\n  if (err) console.log(\"error: \"+err);\n  console.log('meow');\n  var litter = new Litter({name:'Crazy', cats:[meowness]});\n  litter.save(function (err) {\n    console.log('double meow');\n    process.exit(0);\n  });\n});\n```\n\nWith mongoose 2.7.x up to 3.6.5, you'll get:\n\n``` js\n{\n  \"name\": \"Crazy\",\n  \"cats\": [\n    {\n      \"__v\": 0,\n      \"name\": \"Zildjian\",\n      \"_id\": ObjectId(\"518066eddf3dd10000000001\")\n    }\n  ],\n  \"_id\": ObjectId(\"518066eddf3dd10000000002\"),\n  \"__v\": 0\n}\n```\n\nWith mongoose >=3.6.6:\n\n``` js\n{\n  \"name\": \"Crazy\",\n  \"cats\": [\n    ObjectId(\"518063c876d7e70000000001\")\n  ],\n  \"_id\": ObjectId(\"518063c876d7e70000000002\"),\n  \"__v\": 0\n}\n```\n"},{"labels":["bug"],"text":"``` js\nvar util = require('util');\nvar mongoose = require('mongoose');\nvar Schema = mongoose.Schema;\n\n\nvar sampleSchema = new Schema({\n    title: {type: String, default: \"\"}\n    , desc: {type: String, default: \"\"}\n    , membernames: [String]\n});\n\nvar SampleModel = mongoose.model('Sample', sampleSchema);\n\n\n//connect to single instance\nmongoose.connect(\"mongodb://localhost/test\", {server: { auto_reconnect: true }}, function(err) {\n    if (err) console.log(\"something went wrong\");\n});\n\n\n//connection's working\nmongoose.connection.on('open', function () {\n\n    var a = new SampleModel({ title: \"sample title\", desc: \"sample desc\", membernames: [\"alfa\", \"beta\", \"gamma\"] });\n    a.save( function (err, s) {\n        if (err) {\n            console.log(\"something went wrong\");\n            console.log(util.inspect(err, false, null, false));\n        } else {\n\n            SampleModel.find( { membernames: { $regex: /a/, $options: \"i\" }}, null, null, function(err, f) {\n                if (err) {\n                    console.log(\"something went wrong\");\n                    console.log(util.inspect(err, false, null, false));\n                } else {\n                    console.log(f._id);\n                }\n            });\n        }\n    });\n});\n```\n"},{"labels":["bug"],"text":"[Gist](https://gist.github.com/thatmarvin/5423601)\n\nIf you run the gist above as is, you'll see that the setter never gets run upon `save()`.\n\nIf you change `TEST_VALUE` to something else, then the assertion passes.\n\nIs this expected behavior?\n"},{"labels":["bug"],"text":"relates to changes first made in 3.6.5 and a followup fix in 3.6.6\n\nhttps://groups.google.com/d/msg/mongoose-orm/uNNY42_E57Q/9-9KO8h7CSsJ\n\n``` js\n\nvar mongoose = require('mongoose');\nvar Schema = mongoose.Schema;\nvar assert = require('assert')\n\nconsole.log('\\n===========');\nconsole.log('    mongoose version: %s', mongoose.version);\nconsole.log('========\\n\\n');\n\nvar dbname = 'testing_morepopulationfallout-366';\nconsole.log('dbname: %s', dbname);\nmongoose.connect('localhost', dbname);\nmongoose.connection.on('error', function () {\n  console.error('connection error', arguments);\n});\n\n\nvar articleSchema = new Schema({\n    body:          {type: String, default: '', trim: true}, // Article body\n    mediaAttach:   {type: Schema.ObjectId, ref : 'Media', index:true},  // Attached media file\n    author:        {type: Schema.ObjectId, ref : 'User', required:true, index: true},   // userid who posted the article\n});\nvar Article = mongoose.model('Article', articleSchema);\n\nvar UserSchema = new Schema({\n    firstName:       {type: String, required:true, trim:true},\n    lastName:        {type: String, required:true, trim:true},\n    nickName:        {type: String, required:true, trim:true, index:{unique:true}},\n    Avatar:           {type: Schema.ObjectId, ref: 'Media', index: true},  // Avatar image\n    });\nvar User = mongoose.model('User', UserSchema);\n\nvar MediaSchema = new Schema({\n    filename:     {type : String, required: true, index: {unique:true}},\n    originalName: {type: String, default:''},\n    size:         {type: Number, default : 0},\n   });\nvar Media = mongoose.model('Media', MediaSchema);\n\n//\n\n\n\nmongoose.connection.on('open', function () {\n  var file1 = 'one';\n  var original1 = 'one-original';\n\n  Media.create({filename: file1, originalName: original1, size: 100}, function (err, media) {\n    if (err) return done(err);\n    console.log('created media', media);\n\n    var userFirst = 'aaron';\n    var userLast = 'heckmann';\n    var userNick = 'nick';\n\n    User.create({ firstName:userFirst, lastName:userLast, nickName: userNick, Avatar: media._id }, function (err, user) {\n      if (err) return done(err);\n      console.log('created user', user);\n\n      Article.create(\n          {body: 'body1', author: user._id}\n        , {body: 'body2', author: user._id, mediaAttach: media._id}\n        , {body: 'body3', author: user._id}, function (err, article1, article2, article3) {\n\n        if (err) return done(err);\n        console.log('created articles', article1, article2, article3);\n\n        mongoose.set('debug', true);\n\n        var query = Article.find()\n            .populate('author','firstName lastName nickName Avatar')\n            .populate('mediaAttach').exec(function (err, docs) {\n\n          if (err) return done(err);\n          console.log('found', docs);\n\n          var a1 = docs.filter(function(d){return 'body1' == d.body})[0];\n          var a2 = docs.filter(function(d){return 'body2' == d.body})[0];\n          var a3 = docs.filter(function(d){return 'body3' == d.body})[0];\n\n          // all have same author\n          assert.equal(a1.author.id, user.id);\n          assert.equal(a2.author.id, user.id);\n          assert.equal(a3.author.id, user.id);\n\n          try{\n            // fails\n            assert.equal(a2.mediaAttach.id, media.id);\n          }catch(err) { console.error(err);}\n\n          done();\n        })\n      })\n    })\n  });\n});\n\nfunction done (err) {\n  if (err) console.error(err.stack);\n  mongoose.connection.db.dropDatabase(function () {\n    mongoose.connection.close();\n  });\n}\n```\n"},{"labels":["bug"],"text":"see #1436 \n"},{"labels":["bug"],"text":"``` js\nvar CommentSchema = new Schema({\n creatorId : {\n           type : ObjectId,\n                ref : 'User',\n   },\n      body : {\n                type : String\n   },\n});\nvar Comment = db.model('Comment', CommentSchema);\n\n\n//User\nvar UserSchema = new Schema({\n       name : {\n                type : String\n   }\n});\n\nvar User = db.model('User', UserSchema);\n\n\nvar user = new User({ name: 'Jack'});\nuser.save( function( error, user){\n var comment = new Comment({\n             creatorId: user._id,\n            body: 'Comment to you'\n  });\n     comment.save( function(error, comment){\n         var comment2 = new Comment({\n                    creatorId: user._id,\n                    body: 'Comment to you'\n          });\n             comment2.save( function(error, comment2){\n\n                        Comment.find()\n                  .select( 'creatorId')\n                  .select('-_id')//The condition to reproduce\n                    .populate('creatorId')\n                  .exec( function( error, comments){\n                              console.log( comments[0].creatorId.name);//undefined\n                        });\n\n                });\n     });\n})\n```\n\nsee https://groups.google.com/d/msg/mongoose-orm/Hvz2sixp6q0/2pVZOY3b2pgJ\n"},{"labels":["bug"],"text":"When creating a tailable cursor from a collection with a 2dsphere index the initial query will return documents but documents later added will not be streamed.\n\nGist: https://gist.github.com/Jpro714/5392360\n\nMongoose 3.6.5\nMongoDb 2.6.1\nNode 0.10.4\n"},{"labels":["bug"],"text":"It appears that Mongoose does not support setting string paths into attributes of Types.Mixed:\n\n```\nassert = require('assert');\nmongoose = require('mongoose');\n\nschema = new mongoose.Schema({\n  mixed: {type: mongoose.Schema.Types.Mixed}\n})\nHasMixed = mongoose.model('HasMixed', schema);\n\nobj = new HasMixed({mixed: {name: 'Foo'}});\nobj.set('mixed.name', 'Bar');\nassert.equal(obj.mixed.name, 'Bar', 'Expect mixed.name to be \"Bar\"');\n```\n\nThe assertion fails in this test case. It's unintuitive because I can call obj.get('mixed.name') and will get the value of the nested property.\n\nI did some debugging and it appears that set simply bails out at https://github.com/LearnBoost/mongoose/blob/master/lib/document.js#L465-L466\n\nAlon\n\n(Groups discussion at https://groups.google.com/forum/?fromgroups=#!topic/mongoose-orm/0QxX6GKyZUY)\n"},{"labels":["bug"],"text":"relates to #1378\n"},{"labels":["bug"],"text":"Model#$__delta uses the newly added MongooseArray#$__getAtomics() (since commit [87b2a3330788ffee9a4cfa5ac23f9d028cd83946](https://github.com/LearnBoost/mongoose/commit/87b2a3330788ffee9a4cfa5ac23f9d028cd83946)).\n\nThis calls doc.toObject() in every element in the case of a MongooseDocumentArray, which causes a user-defined transform e.g.\n\n``` javascript\nschema.set('toObject', { transform: function(doc, ret, options) {\n  delete ret._id;\n} }))\n```\n\nto be called on the elements. The transformed elements are then saved in the database.\n\nCheckout [this gist](https://gist.github.com/mtsr/5300290) for a simple way to reproduce it.\n\nThe expected output is\n\n``` javascript\n{ seconds: [ { _id: 515c0d25863e8e503f000003 }, [length]: 1 ] }\n```\n\nthe actual output is\n\n``` javascript\n{ seconds: [ { _id: 515c0d25863e8e503f000003, bla: '123' }, [length]: 1 ] }\n```\n"},{"labels":["bug"],"text":"As can be seen in the minimal reproduction [here](https://gist.github.com/mtsr/5292570), when a schema and its subdoc both have transforms defined, the top-level transform is used for the subdoc as well.\n\nExpected output:\n\n``` javascript\n{ _id: 515aef8c2b98ec5125000001,\n  second: \n   [ { _id: 515aef8c2b98ec5125000002, secondToObject: true },\n     { _id: 515aef8c2b98ec5125000003, secondToObject: true } ],\n  firstToObject: true }\n```\n\nActual output:\n\n``` javascript\n{ _id: 515aef8c2b98ec5125000001,\n  second: \n   [ { _id: 515aef8c2b98ec5125000002, firstToObject: true },\n     { _id: 515aef8c2b98ec5125000003, firstToObject: true } ],\n  firstToObject: true }\n```\n\nIn the gist I also included a workaround, as all actual fixes to mongoose I tried broke a bunch of tests. In my opinion this problem is caused by Document.prototype.toObject actually changing the options object. If anything it should change a clone, but that breaks a bunch of tests right now.\n"},{"labels":["bug"],"text":"This snippet works in v3.5.9, but not in v3.6.x\n\n``` js\nvar mongoose = require('mongoose');\nvar assert = require('assert');\n\nmongoose.connect('mongodb://localhost/test');\n\nvar barSchema = new mongoose.Schema({ \n  value: Number\n});\n\nvar fooSchema = new mongoose.Schema({\n  value: Number,\n  bar: { type: \"ObjectId\", ref: \"Bar\" }\n});\n\nvar Foo = mongoose.model('Foo', fooSchema);\nvar Bar = mongoose.model('Bar', barSchema);\n\nBar.create({ value: 2 }, function(err, bar){\n  Foo.create({ value: 1, bar: bar._id }, function(err){\n    Foo.find({}).populate(\"bar\").stream()\n      .on('data', function(foo){\n        assert.equal(foo.bar.value, 2);\n      })\n      .on('end', function(){ \n        console.log(\"done\"); \n        mongoose.disconnect();\n      });\n  });\n});\n```\n"},{"labels":["bug"],"text":"We have the following (partial) schema within our application:\n\n```\nvar PreferenceSchema = new Schema ({\n    _id: {type: ObjectId, auto: true},\n    preference: { type: String, required: true },\n    value: { type: Schema.Types.Mixed }\n}, { versionKey: false });\n\nexports.BrandSchema = new Schema({\nsettings: {\n    preferences: [PreferenceSchema],\n}\n});\n```\n\nIn production, we are using mongoose v3.5.7.\n\nWhen we update this object, we pass in the following data: \n\n```\nvar newData = {\nsettings: { \n  preferences: \n   [ { preference: 'group_colors', value: true },\n     { preference: 'can_force_orders', value: false },\n     { preference: 'custom_csv', value: ' },\n     { preference: 'hide_from_buyers', value: false },\n     { preference: 'nozoom', value: false },\n     { preference: 'no_orders', value: false }\n  ]\n}\n}\n```\n\nWe do a findOne on the object we want to update, then \ndata.set('settings', newData.settings, {merge: true});\n\nThis generates the following updatestatement (correct):\n\n```\nbrands.update({\n    _id: ObjectId(\"500120d8ca1b9d7909000359\")\n}) {\n    '$set': {\n        settings: {\n            preferences: [{\n                preference: 'group_colors',\n                value: false,\n                _id: ObjectId(\"5155d625172cbc00a7000042\")\n            }, {\n                preference: 'can_force_orders',\n                value: false,\n                _id: ObjectId(\"5155d625172cbc00a7000040\")\n            }, {\n                preference: 'custom_csv',\n                value: false,\n                _id: ObjectId(\"5155d625172cbc00a700003f\")\n            }, {\n                preference: 'hide_from_buyers',\n                value: false,\n                _id: ObjectId(\"5155d625172cbc00a700003e\")\n            }, {\n                preference: 'nozoom',\n                value: false,\n                _id: ObjectId(\"5155d625172cbc00a700003d\")\n            }, {\n                preference: 'no_orders',\n                value: false,\n                _id: ObjectId(\"5155d625172cbc00a700003c\")\n            }]\n        }\n    }\n} {\n    safe: {\n        j: 1\n    }\n}\n```\n\nUpon upgrading to mongoose 3.6.0/3.6.1, the same call generates the following update statement (incorrect):\n\n```\nbrands.update({\n    _id: ObjectId(\"502e92c96e649c5d3c1c5995\")\n}) {\n    '$set': {\n        settings: {\n            preferences: [ObjectId(\"500120d8ca1b9d7909000359\"), ObjectId(\"5155d655481b1394a7000041\"), ObjectId(\"5155d655481b1394a7000040\"), ObjectId(\"5155d655481b1394a700003f\"), ObjectId(\"5155d655481b1394a700003e\"), ObjectId(\"5155d655481b1394a700003d\")],\n        }\n    }\n} {\n    safe: {\n        j: 1\n    }\n}\n```\n"},{"labels":["bug"],"text":"For example, I want to update a document without waiting for the callback:\n\n```\nuserSchema.methods.addAccount = function (account) {\n  this.update({$push: {accounts: account._id}}).exec();\n};\n```\n\nBut that will produce an error: \"TypeError: Cannot call method 'exec' of undefined\". I think the \"update\" method should be change to:\n\n```\nDocument.prototype.update = function update () {\n  var args = utils.args(arguments);\n  args.unshift({_id: this._id});\n  /**/ return /**/ this.constructor.update.apply(this.constructor, args);\n}\n```\n"},{"labels":["bug"],"text":"When using populate with findOneAndUpdate query it doesn't work\nhere is example https://gist.github.com/martynovs/5220509\nbut if update is empty (null or {}) then populate is working\n\nmongoose 3.6.0\n"},{"labels":["bug"],"text":"Please, could you explain this bug. You may run this code entirely.\n\nThis code saves one system in systems collection,  system has array of apps.\nThe we modify app's subdoc field \"memory\", save it.\n\nAfter save we get 2 apps, one of them is very strange and not modified first app. \n\n<pre>\nvar mongoose = require('mongoose')\n\nmongoose.connect('YOUR_DB')\n\nvar SystemSchema = new mongoose.Schema({\n    apps: [{\n        resources: {\n            memory: {\n                limit: 'number'\n            }\n\n        }\n    }]\n});\n\nSystemSchema.set('collection', 'systems')\n\nvar System = mongoose.model('System', SystemSchema)\n\nvar system = new System({\n    _id: '5140a09be5c703ac2c00000b',\n    apps: [\n        {\n            resources: {\n                memory: {\n                    limit: '1024'\n\n                }\n            }\n        }\n    ]\n})\n\nSystem.remove({}, function(){\n    system.save(function(err){\n        System.findById('5140a09be5c703ac2c00000b', function(err, system){\n\n            //system.apps.push({})\n            var app = system.apps[0]\n\n            app.resources.memory = {limit: 100}\n            system.save(function(){\n\n                System.findById('5140a09be5c703ac2c00000b', function(err, system){\n                    console.log('system.apps', system.apps)\n                })\n\n            })\n\n        })\n    })\n\n})\n</pre>\n\n\nThe output:\n\n<pre>\nsystem.apps [\n{ \n    resources: { memory: [ null ] } \n}\n{\n   _id: 514c3528480b17b458000002,\n  resources: { memory: { limit: 1024 } } \n}]\n</pre>\n\n\nMongoose 3.6.0, MongoDB 2.4RC\n"},{"labels":["bug"],"text":"Sub-document cannot call `ownerDocument( )` method after pushing it into owning doc.\n\n```\nsub = new SubModel();\nowner.subs.push(sub);\nsub.ownerDocument();\n```\n"},{"labels":["bug"],"text":"I've just updated mongoose from 3.5.x to 3.6.0rc1\n\nI had this schema defined:\n\n```\nCounterSchema = mongoose.Schema\n    model : String\n    next : Number\n```\n\nand now I get this error:\n\n```\nTypeError: Cannot read property 'scope' of undefined\n    at model.Object.defineProperty.get [as model] (foo/node_modules/mongoose/lib/document.js:1184:58)\n...\n```\n\nRenaming the field 'model' from Counter solves the issue.\n"},{"labels":["bug"],"text":"It could be good for performance if you add populate lean() to .populate() method itself. So if we use populate at now like the following:\n\n```\nModel.find({ type: 'paper' }).lean().populate('batch').exec(fn)\n```\n\nWe get documents with type 'paper' as just JavaScript objects but 'patch' as fully functional mongoose document. It could be cool if we could make something like the following:\n\n```\nModel.find({ type: 'paper' }).lean().populate('batch', {lean: true}).exec(fn)\n```\n\nNow all documents are just JavaScript object. What do you think about it?\n"},{"labels":["bug"],"text":"If I create an object \"property one\" with a field `data` that has a mixed schema type, leave it empty, fetch that property from the database, set the `data` field, save it, create a second property (\"property two\"), leave the data field empty, save it to the database, then look it up, the data field is now populated with the same data as the first property.\n\nMy guess is that it's related to the lack of minimize: false.\n\nhttps://gist.github.com/azylman/5139583\n"},{"labels":["bug"],"text":"Schema options for populated documents are ignored when calling toJSON. Instead options for the document which calls toJSON are used. See the following test fails for the detail.\n\nhttps://gist.github.com/nkzawa/5148103\n\nI found that the cause is utils.clone uses a same options value for each mongoose objects.\nThis behavior is not intuitive.\n"},{"labels":["bug"],"text":"Combining a `query.select(\"+field\")` to override the schema level `select: false` option breaks the `query.slice(\"field\", 2)`.\n\nThe following code proofs this bug (using mongoose v3.5.6):\n\n```\nvar mongoose = require(\"mongoose\");\nmongoose.connect(\"mongodb://localhost/test\");\n\nvar A = new mongoose.Schema({\n    one: { type: String },\n    many: { type: [String], select: false }\n});\n\nvar ModelA = mongoose.model(\"ModelA\", A);\n\nModelA.create({\n    one: \"single value\",\n    many: [\"1\", \"2\", \"3\", \"4\", \"5\"]\n}, function (err) {\n    var query = ModelA.find().select(\"+many\").where(\"many\").slice(2);\n    query.exec(function (err, doc) { console.dir(doc); });\n\n    // actual: [{ _id: 5135d63df4b7523b10000001, many: [ '1', '2', '3', '4', '5' ] }]\n    // expected: [{ one: 'single value', _id: 5135d63df4b7523b10000001, __v: 0, many: [ '1', '2' ] }]\n});\n```\n\nSeems like mixing `select(\"field\")` and `slice(\"field\", count)` statements, leads to unexpected results.\n"},{"labels":["bug"],"text":"Index creation fails with error `MongoError: cannot add index with a background operation in progress` for all but the first index if there are many indexes defined for a schema and the indexes take some time to create.\n\nRun https://github.com/hvrauhal/mongoosebug to reproduce.\n\nThis is related to issue #1059 \n"},{"labels":["bug"],"text":"Here is the piece of code that behaves in a very unexpected way:\n\n``` javascript\nvar schemaData = { anarray: [{ type: ObjectId, ref: 'amodel' }] };\nconsole.log(schemaData);   // \"{ anarray: [{ type: ObjectId, ref: 'amodel' }] }\"\n\nvar theSchema = new Schema(schemaData);\nconsole.log(schemaData);   // \"{ anarray: [{ ref: 'amodel' }] }\"\n```\n\nSo if I want to use the same schemaData object to create two different Schemas, the first creation will take place but since the schemaData object changed the second creation will fail with this error: \"TypeError: Undefined type at `ref`\n  Did you try nesting Schemas? You can only nest using refs or arrays.\"\n"},{"labels":["bug"],"text":"``` javascript\nModelActivity.find({user: userId})\n    .populate('user')\n    .exec(function(err, activity){\n        if(err){\n            throw err;\n        } else {\n            ModelActivity.populate(activity, {path: 'user.avatar'}, function(err, test){\n                console.log(test);\n            });\n        }\n    });\n```\n\nThis code was failing to detect that user.avatar was defined as 'photos' model in my schema (it works if it's in 1st level of populate), it was querying 'users' instead, so i had to specify it in populate options.\nI know this version is still WIP, but i didn't see it was reported...\n"},{"labels":["bug"],"text":""},{"labels":["bug"],"text":"I discovered something:\n\n```\nvar ParentSchema = new Schema({\n    children: { type: Schema.ObjectId, ref: 'Child'},\n});\n\nvar ChildSchema = new Schema({\n    name:String\n});\n```\n\n\"unshift\" a new 'Child'-ref on a populated Parent Object:\n\n```\nParent.find().populate('children').exec(function(err,res) {\n    res[0].children.unshift(child);\n    res[0].save();\n});\n```\n\non save, all old refs in children are replaced with populated objects:\n\n```\nMongoose: parents.update({ _id: ObjectId(\"51228b313456955044000005\"), __v: 1 }) { '$inc': { __v: 1 }, '$set': { children: [ ObjectId(\"51228b303456955044000004\"), { name: 'foo',  _id: ObjectId(\"51228b303456955044000004\"), __v: 0 } ] } } {} \n```\n\nseems like this only affects array manipulations other than \"push\". Push works fine as it uses $push instead of $set:\n\n```\nMongoose: parents.update({ _id: ObjectId(\"51228b313456955044000005\") }) { '$inc': { __v: 1 }, '$pushAll': { children: [ ObjectId(\"51228b303456955044000004\") ] } } {}\n```\n\nmongodb: 1.2.12\nmongoose: 3.5.5\nnode: 0.8.8\n"},{"labels":["bug",null],"text":"If I define a Schema with a `domain` property, and then attempt to save a model instance, it  fails with the following error:\n\n```\nevents.js:84\n        this.domain.enter();\n                    ^\nTypeError: Object github.com has no method 'enter'\n    at model.EventEmitter.emit (events.js:84:21)\n    at model.save (/Users/jaredhanson/Projects/website/node_modules/mongoose/lib/model.js:383:10)\n    at model.module.exports.hook.proto.(anonymous function)._done (/Users/jaredhanson/Projects/website/node_modules/mongoose/node_modules/hooks/hooks.js:59:24)\n    at module.exports.hook.proto.(anonymous function)._next (/Users/jaredhanson/Projects/website/node_modules/mongoose/node_modules/hooks/hooks.js:52:28)\n    at fnWrapper (/Users/jaredhanson/Projects/website/node_modules/mongoose/node_modules/hooks/hooks.js:159:8)\n    at model.module.exports (/Users/jaredhanson/Projects/node/mongoose-timestamps/lib/timestamps.js:22:5)\n    at module.exports.hook.proto.(anonymous function)._next (/Users/jaredhanson/Projects/website/node_modules/mongoose/node_modules/hooks/hooks.js:50:30)\n    at fnWrapper (/Users/jaredhanson/Projects/website/node_modules/mongoose/node_modules/hooks/hooks.js:159:8)\n    at complete (/Users/jaredhanson/Projects/website/node_modules/mongoose/lib/document.js:920:5)\n    at Document.validate.err (/Users/jaredhanson/Projects/website/node_modules/mongoose/lib/document.js:911:20)\n```\n\nIn this case, \"github.com\" is the value I assigned to the `domain` property with a schema that looks like:\n\n```\nvar AccountSchema = new Schema({\n    userId      : { type: Schema.ObjectId, required: true }\n  , domain      : String\n  , uid         : String\n  , username    : String\n  , displayName : String\n  , name: {\n      familyName : String\n    , givenName  : String\n    , middleName : String\n  }\n  , credentials : [ CredentialSchema ]\n});\n```\n\nNote, this is actually a conflict with Node core, which has a colliding `domain` property with anything that inherits from `EventEmitter`.  I have a running discussion with @isaacs about it here:\n\nhttps://github.com/joyent/node/issues/3922\n\nIt may help to get more input from Mongoose developers.\n"},{"labels":["bug",null],"text":"Hi,\n\nwhen retrieving a document using findOne while limiting the result of an array of sub documents via an $elemMatch projection, the wrong array element will get modified in the database when saving the document back.\n\nPlease see the following test case:\n\nhttps://gist.github.com/4711139\n\nWhich produced the following debug output:\n\n> Mongoose: docs.findOne({ someId: 1 }) { fields: { subDocs: { '$elemMatch': { someValue: 3 } } }, safe: undefined }  \n> Mongoose: docs.update({ _id: ObjectId(\"511054f985a8270000000002\") }) { '$set': { 'subDocs.0.someValue': 4 } } {} \n\nNotice up the update command sets 'subDocs.0.someValue' instead of 'subDocs.2.someValue'. I assume this is because an array with only a single element was returned due to the projection.\n\nWe have been relying on mongoose's ability to selectively update parts of large documents including many subdocuments depending on what data had been modified. Without the ability to use projection, the document retrieval kills our performance as node will spend a bulk of its time parsing the bson data. See also the following issue for a similar issue that we've encountered:\n\nhttps://github.com/LearnBoost/mongoose/issues/1303\n\nThanks!\n\nThis is using mongoose 3.5.4\n"},{"labels":["bug"],"text":"With an embedded doc array, the `select: false` option will be ignored if the embedded schema has its own paths with `select: false`.\n\nIn this example the doc `Foo` has two embedded doc arrays, both schemas identical except that the first, `a`, has a path with `select: false`.  In the result you should see that for a basic `findById`, the `a` path is still returned (with its own `name` path omitted, as per the `select: false` option).\n\nThis is with v3.5.5\n\n```\nvar mongoose = require(\"mongoose\");\nmongoose.connect(\"mongodb://localhost/test\");\n\nvar A = new mongoose.Schema({\n  name: {type: String, select: false}\n});\n\nvar B = new mongoose.Schema({\n  name: {type: String }\n});\n\nvar Schema = new mongoose.Schema({\n  a: {type: [A], select: false },\n  b: {type: [B], select: false }\n});\n\nvar Foo = mongoose.model(\"Foo\", Schema);\n\nFoo.create({\n  a: [{ name: 'bar' }],\n  b: [{ name: 'bar' }]\n}, function(err, foo) {\n  Foo.findById(foo._id, function(err, doc) {\n    console.log(doc); // { _id: \"...\", a: [{_id: \"...\" }] }\n  });\n});\n```\n"},{"labels":["bug"],"text":"Hello!\nWhen I'm trying to deselect '_id' field in populate (when it is array of refs), then I always get empty array.\n\n``` javascript\nnew mongoose.Schema(\n        {\n            geo: {type: [Number], index: '2d'}, \n            photos: [\n                { type: Schema.Types.ObjectId, ref: 'Photo' }\n            ]\n        },\n        {\n            strict: true\n        }\n    )\n```\n\n``` javascript\nSomeCollection.find({geo: { \"$within\": {\"$box\": box} }}).populate('photos', {_id: 0}).select('-_id photos').exec(function (err, docs) {\nconsole.dir(docs); // get here: [ { photos: [] }, { photos: [] }, { photos: [] } ]\n});\n```\n\nIf I don't deselect '_id', than all is ok: photos array for each doc is not empty\n"},{"labels":["bug"],"text":"Hi.\n\nSetting an object on a document where that object is null gives me a \n\n``` javascript\nMongo 10145 Error LEFT_SUBFIELD only supports object: \"ObjectName\".\n```\n\nNow i've enabled debug mode, and i can see that when mongoose does it's save() it doesn't tell mongo to set the whole object, but only the values inside the object. That explains the mongo error.\n\nI can resolve it by setting markModified on the whole object, but then i would need to do that for every object in my schema eg. in pre-save middleware.\n\nI've made a quick test to show it here:\nhttps://gist.github.com/4690893\n\nIf the schema looks like this \n\n``` javascript\nSchema({\n  meta: { amount: Number, enabled: Boolean, note: String }\n})\n```\n\nNot using markModified gives this mongo set:\n\n``` javascript\n{ '$set': { 'meta.amount': 1235, 'meta.enabled': true } }  // err if meta is null\n```\n\nUsing markModified gives this:\n\n``` javascript\n{ '$set': { meta: { note: null, amount: 1235, enabled: true } } }\n```\n\nI don't know if this is by design or it can somehow be solved.\nWhen i am trying isModified on the object it gives back true alright, so for now i just do \n\n``` javascript\nif(doc.isModified('objectName')\n  doc.markModified('objectName')\n```\n\nin pre-save middleware for every object in my schema.\n"},{"labels":["bug"],"text":"Heads up, CastError sets `error.type` which is apparently frowned upon in V8:\nhttp://code.google.com/p/v8/issues/detail?id=2397\n\nDoesn't cause immediate issues, but if I do something silly like\n\n```\nvar e = new CastError('a', 'b', 'c');\ndelete e.message;\ne.toString();\n```\n\nThings get ugly quick.  I get a cryptic `illegal access`.\n"},{"labels":["bug"],"text":"We're using the latest mongoose (3.5.5) in heroku, and we get variations on these stack traces, intermittently, whenever we use a replicaset. A single server is fine. Unfortunately, after an hour or so, every heroku process will have crashed or will be restarting.\n\nmongoose.connect(\"mongodb://UUUU:PPPP@XXXXX.member0.mongolayer.com:12345,XXXXX.member1.mongolayer.com:12345/app1234567?slaveOk=true\")\n\n2013-01-29 05:54:38+00:00 app web.102   - - Error: connection to [XXXXX.member0.mongolayer.com:12345] timed out\n    at Db.<anonymous> (/app/node_modules/mongoose/lib/drivers/node-mongodb-native/connection.js:75:17)\n    at Db.EventEmitter.emit (events.js:126:20)\n    at _emitAcrossAllDbInstances (/app/node_modules/mongoose/node_modules/mongodb/lib/mongodb/connection/server.js:626:20)\n    at Server.connect.connectionPool.on.server._serverState (/app/node_modules/mongoose/node_modules/mongodb/lib/mongodb/connection/server.js:514:7)\n    at EventEmitter.emit (events.js:126:20)\n    at _connect (/app/node_modules/mongoose/node_modules/mongodb/lib/mongodb/connection/connection_pool.js:128:15)\n    at EventEmitter.emit (events.js:99:17)\n    at Socket.timeoutHandler (/app/node_modules/mongoose/node_modules/mongodb/lib/mongodb/connection/connection.js:397:10)\n    at Socket.EventEmitter.emit (events.js:93:17)\n    at Socket._onTimeout (net.js:187:8) EXCEPT Context\n\n2013-01-29 06:11:06+00:00 app web.140   - - Error: no primary server found in set\n    at _connectHandler (/app/node_modules/mongoose/node_modules/mongodb/lib/mongodb/connection/repl_set.js:724:11)\n    at Server.connect.connectionPool.on.server._serverState (/app/node_modules/mongoose/node_modules/mongodb/lib/mongodb/connection/server.js:502:7)\n    at EventEmitter.emit (events.js:126:20)\n    at _connect (/app/node_modules/mongoose/node_modules/mongodb/lib/mongodb/connection/connection_pool.js:128:15)\n    at EventEmitter.emit (events.js:99:17) EXCEPT Context\n\nError: no primary server found in set\n   at _connectHandler (/app/node_modules/mongodb/lib/mongodb/connection/repl_set.js:813:11)\n   at Server.connect.connectionPool.on.server._serverState (/app/node_modules/mongodb/lib/mongodb/connection/server.js:541:7)\n"},{"labels":["bug"],"text":"Hi,\n\nI've been running into an issue where a change to one sub document gets dropped when also pulling another sub document depending on the order that these two changes are made. Please see the following minimal reproduction code:\n\nhttps://gist.github.com/4575777\n\nThe debug output for both order cases is as follows.\n\nCorrect case saving the following:\n\n```\nvar mySub = doc.subDocs[2];\ndoc.subDocs.pull(doc.subDocs[1]);\nmySub.someValue = 5;\n```\n\nresults in \n\n```\nMongoose: docs.update({ _id: ObjectId(\"50fb28517c9e6e9c8a000002\"), __v: 0 }) { '$inc': { __v: 1 }, '$set': { subDocs: [ { _id: ObjectId(\"50fb28517c9e6e9c8a000005\"), someValue: 1 }, { _id: ObjectId(\"50fb28517c9e6e9c8a000003\"), someValue: 5 } ] } } {} \n```\n\nIncorrect case saving the following:\n\n```\nvar mySub = doc.subDocs[2];\nmySub.someValue = 5;\ndoc.subDocs.pull(doc.subDocs[1]);\n```\n\nresults in\n\n```\nMongoose: docs.update({ _id: ObjectId(\"50fb2973817ac5b18a000002\"), __v: 0 }) { '$inc': { __v: 1 }, '$pull': { subDocs: { _id: { '$in': [ ObjectId(\"50fb2973817ac5b18a000004\") ] } } } } {}\n```\n\nI would greatly appreciate any help with this. Please let me know if I am overlooking something. Thanks!\n\nThis is using mongoose 3.5.4\n"},{"labels":["bug"],"text":"I have a pair of schemas that form a simple structure like this:\n\n```\nASchema = new Schema\n    key:        {type: String, required: true}\n    value:      {type: String, required: true}\n\nBSchema = new Schema\n    name:       {type: String, required: true}\n    contents:   {type: [ASchema]}\n```\n\nIf I have an instance of a B model, and I call .validate() on it, and there are some problems (say a contents.x.value is not present) then I get back a ValidationError.  So far, so good.\n\nWhen I call .toString() on the ValidationError, though, I end up overflowing the stack, because toString() ends up in an infinite loop.\n\nThe structure of my ValidationError is:\n\n```\n{ message: 'Validation failed',\n  name: 'ValidationError',\n  errors: \n   { 'b.44.value': \n      { message: 'Validator \"required\" failed for path value',\n        name: 'ValidatorError',\n        path: 'value',\n        type: 'required' },\n     b: [Circular] },\n  key: 'undefined.44.undefined' }\n```\n\nThe \"Circular\" here is the source of our problems.  It seems that params.error == params.error.errors.b.  toString() tries to recurse this structure, and ends up going forever.\n"},{"labels":["bug"],"text":"When executing a find query; Object fields in the mongoose Schema, which have arrays embedded, return an empty Object instead of being completely excluded.\n\nA detailed example is here: http://goo.gl/xJZkd\n\nI have a schema below\n\n``` javascript\nThisSchema = new Schema ({\n    name:   { type: String, index: { unique: true } },\n    _ref:       [\n                    { type: ObjectId, ref: 'Reference' }\n                ],\n    foo:   {\n                    start: {\n                        _ref:    { type: ObjectId, ref: 'Location' },\n                        name:   { type: String },\n                        loc:    { type: [Number], index: '2d' }\n                    },\n                    end: {\n                        _id:    { type: ObjectId, ref: 'Location' },\n                        name:   { type: String },\n                        loc:    { type: [Number], index: '2d' }\n                    }\n    foo2:    [ EmbeddedSchema ],\n    foo3:   {\n                    bar:  { type: [Number], min: 0, max: 100 }\n                }\n\n});\n```\n\nNow, calling\n\n``` javascript\nThisSchema.statics.find({'_id': x},'-foo -foo2 -foo3',cb)\n```\n\nreturns\n\n``` javascript\n{\n  \"result\": {\n    \"__v\": 0,\n    \"_id\": \"x\",\n    \"foo3\": {\n      \"bar\": []\n    },\n    \"foo\": {\n      \"end\": {\n        \"loc\": []\n      },\n      \"start\": {\n        \"loc\": []\n      }\n    },\n    \"_ref\": [\n      \"y\"\n    ]\n  }\n}\n```\n\nInstead of not returning foo as part of the result, it just returns its representation in the schema. Note that foo2 has been removed, it was just a simple array with no fields inside preset.\n\nThe result I expected was: \n\n``` javascript\n{\n  \"result\": {\n    \"__v\": 0,\n    \"_id\": \"x\",\n    \"_ref\": [\n      \"y\"\n    ]\n  }\n}\n```\n\nAs in the link provided above, there are workarounds, but the above issue makes Mongoose queries to be less consistent.\n"},{"labels":["bug"],"text":"The following example creates three documents and attempts to force the update of \"__v\" by altering the \"dummy\" array.   It works in the first case with a \"findOne/save\" construct, but doesn't work for the atomic \"update\" and \"findByIdAndUpdate\" functions.\n\nSince it is possible for find/save constructs to be interleaved with atomic updates, it seems that it the \"update\" functions should also increment  \"__v\".\n\nThis came up in the context of: http://stackoverflow.com/questions/14079693/mongoose-findbyidandupdate-or-update-and-increment-how-to-increment-v  An acceptable work around might be to allow \"__v\" to be incremented directly in an \"update\".\n\n```\n#! /usr/bin/node\n\nvar mongoose = require('mongoose');\nvar async = require('async');\nmongoose.connect('mongodb://localhost/test');\n\nvar db = mongoose.connection;\ndb.on('error', console.error.bind(console, 'connection error:'));\n\nvar kittySchema = mongoose.Schema({\n    name: String,\n    dummy: Array\n});\n\nvar Kitten = mongoose.model('Kitten', kittySchema);\n\nvar fluffy1 = new Kitten({ name: 'fluffy1', dummy: [1] }),\n    fluffy2 = new Kitten({ name: 'fluffy2', dummy: [1] }),\n    fluffy3 = new Kitten({ name: 'fluffy3', dummy: [1] }),\n\n    fluffy2Id = null,\n    fluffy3Id = null;\n\n\nasync.series([\n    function (openDone) {\n        db.once('open', function () {\n            openDone();\n        });\n    },\n    function (fluffy1SaveDone) {\n        fluffy1.save(function (err) {\n            if (err) {\n                console.log(err);\n            }\n            fluffy1SaveDone(err);\n        });\n    },\n\n    function (fluffy2SaveDone) {\n        fluffy2.save(function (err, kitty) {\n            if (err) {\n                console.log(err);\n            }\n            fluffy2Id = kitty._id;\n            fluffy2SaveDone(err);\n        });\n    },\n\n    function (fluffy3SaveDone) {\n        fluffy3.save(function (err, kitty) {\n            if (err) {\n                console.log(err);\n            }\n            fluffy3Id = kitty._id;\n            fluffy3SaveDone(err);\n        });\n    },\n\n    function (nonAtomicTestDone) {\n        Kitten.findOne({ name: /^fluffy1/ }, function (err, kitty) {\n            console.log(kitty);\n            kitty.dummy = [2];\n            kitty.save(function (err) {\n                nonAtomicTestDone(err);\n            });\n        });\n    },\n\n    function (updateTestDone) {\n        Kitten.update({_id: fluffy2Id}, {$set: {dummy: [2]}}, \n            function (err) {\n                updateTestDone(err);\n            }\n        );\n    },\n\n    function (findByIdTestDone) {\n        Kitten.findByIdAndUpdate(fluffy3Id, {$set: {dummy: [2]}},\n            function (err) {\n                findByIdTestDone(err);\n            }\n        );\n    }],\n\n    function (err) {\n        if (err) {\n            console.log(err);\n        }\n        process.exit(0);\n    }\n);\n```\n\nRESULT:\n\n```\n{ \"name\" : \"fluffy1\", \"_id\" : ObjectId(\"50e09e0be3013e2811000001\"), \"dummy\" : [ 2 ], \"__v\" : 1 }\n{ \"name\" : \"fluffy2\", \"_id\" : ObjectId(\"50e09e0be3013e2811000002\"), \"dummy\" : [ 2 ], \"__v\" : 0 }\n{ \"name\" : \"fluffy3\", \"_id\" : ObjectId(\"50e09e0be3013e2811000003\"), \"dummy\" : [ 2 ], \"__v\" : 0 }\n```\n"},{"labels":["bug"],"text":"Schema = new mongoose.Schema\n  stem: String\n  ext: String\n  types: Array\n  _scope:\n    type: mongoose.Schema.Types.ObjectId\n    ref: 'Scope'\n\nImage = mongoose.model 'Image', Schema\n\nimage = new Image()\nimage.save (err, image) ->\n  if err app.handleError err else console.log image\n\nResulting error:\n\napp/node_modules/mongoose/lib/document.js:1113                                                             \n\n, get: function ( ) { return this.get.call(this._scope || this, path); }  \n                      ^  \nRangeError: Maximum call stack size exceeded  \n"},{"labels":["bug"],"text":"I have an embedded doc that I want to monitor for changes\n\n```\nClientSchema = new Schema({\n  conversations: [ConversationSchema],\n})\n\nConversationSchema = new Schema({\n  messages: [MessageSchema],\n})\n\nConversationSchema.post('save', function(doc) {\n  console.log doc.collection.name\n})\n```\n\nBut it appears that when I save a new conversation, the doc passed to the middleware function is a client doc, not a conversation doc. I really want to track only the embedded conversations for changes, is there a way to do this with mongoose middleware as things currently stand?\n"},{"labels":["bug"],"text":"https://jira.mongodb.org/browse/SERVER-3192\nhttps://github.com/mongodb/mongo/commit/666397744ecbcfd1237ffe1dd454e1502ab3f60b\n"},{"labels":["bug"],"text":"I have a Schema sorta like this (abbreviated here):\n\n```\nvar Comment = module.exports = new Schema({\n  , teacher :   { type: Schema.ObjectId, index: true, ref: 'User'}\n\nvar StudentProfile = module.exports = new Schema({\n  , comments : [Comment]\n```\n\nHere's my code to add a new comment.  You can presume that std contains the result of a query like \n\n```\n       db.model('StudentProfile').findById(id).populate(\"comment\")\n```\n\nAnd now I execute this code:\n\n```\n        var comment = new Comment;\n        comment.teacher    = ~~~ some User object\n\n        std.comments.push(comment);\n\n        std.save(function (err) {...}\n\n        res.render('reporting/_comment', {\n            'comments' : std.comments,\n```\n\nAssume there is already one Comment and I'm pushing a second one.  \n\nHere's what std.comments look likes at the render call\n\n```\n   [ {teacher : {User object}},\n     {teacher : id of User object} }   <--- Newly pushed comment\n```\n\nWhat you can see here is that the pre-existing Comment from the query result is populated, but  the new one is not.  \n\nWith the advent of the populate feature  this kind of scenario is not going to be uncommon and it would be quite nice if the model objects the mongoose magic that turns comment.teacher back into an id was transparent.\n"}]